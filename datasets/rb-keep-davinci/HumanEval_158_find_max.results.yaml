name: HumanEval_158_find_max
language: ruby
results:
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpimxpq789\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpimxpq789.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005502105 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    181.75 tests/s, 363.50 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpo04fzyu1\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpo04fzyu1.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004936313 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.58 tests/s, 405.16 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpa64mfw78\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpa64mfw78.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005402207 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    185.11 tests/s, 370.22 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpubvx7hzp\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpubvx7hzp.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004865778 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    205.52 tests/s, 411.03 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3at76tlj\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp3at76tlj.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005018857 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    199.25 tests/s, 398.50 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpw1risbhr\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpw1risbhr.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004647409 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    215.17 tests/s, 430.35 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppybsgolk\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmppybsgolk.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004888982 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.54 tests/s, 409.08 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp0h1ws6j8\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp0h1ws6j8.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004894602 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.31 tests/s, 408.61 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjry5_g03\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpjry5_g03.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00495129 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    201.97 tests/s, 403.94 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqz7y0ffx\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpqz7y0ffx.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005523185 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    181.05 tests/s, 362.11 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_unique_chars = 0\n  words.each do |word|\n    unique_chars\
    \ = word.split(\"\").uniq.length\n    if unique_chars > max_unique_chars\n   \
    \   max_unique_chars = unique_chars\n      max_word = word\n    end\n  end\n \
    \ max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpff_ouexz\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpff_ouexz.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006356261 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    157.33 tests/s, 314.65 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp20lo7lk2\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp20lo7lk2.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00600477 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    166.53 tests/s, 333.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp_x8c08s\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpp_x8c08s.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005742789 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    174.13 tests/s, 348.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_mtynpwm\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_mtynpwm.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005323269 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    187.85 tests/s, 375.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpgxdpolu9\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpgxdpolu9.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005091273 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.41 tests/s, 392.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbtdhdiz0\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpbtdhdiz0.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005103226 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    195.95 tests/s, 391.91 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1khd3o_2\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp1khd3o_2.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006274698 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    159.37 tests/s, 318.74 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprif4t4j4\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmprif4t4j4.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005124496 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    195.14 tests/s, 390.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppkeuvpac\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmppkeuvpac.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005754881 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    173.77 tests/s, 347.53 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpupr0lbfe\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpupr0lbfe.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006364698 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    157.12 tests/s, 314.23 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp55jzfm1g\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp55jzfm1g.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005624354 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    177.80 tests/s, 355.60 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwl0tw9j5\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpwl0tw9j5.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006234723 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    160.39 tests/s, 320.78 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpd578cunc\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpd578cunc.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005847715 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    171.01 tests/s, 342.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_unique_chars = 0\n  words.each do |word|\n    unique_chars\
    \ = word.chars.uniq.count\n    if unique_chars > max_unique_chars\n      max_unique_chars\
    \ = unique_chars\n      max_word = word\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpv1grqv02\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpv1grqv02.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004775939 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    209.38 tests/s, 418.77 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp28ykc1cp\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp28ykc1cp.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005541199 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    180.47 tests/s, 360.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_3kvvupo\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_3kvvupo.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004790937 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    208.73 tests/s, 208.73 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpod_0u8oc\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpod_0u8oc.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005269789 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    189.76 tests/s, 379.52 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7046fcrd\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp7046fcrd.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005202371 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    192.22 tests/s, 384.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptvq_dpvc\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmptvq_dpvc.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00486082 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    205.73 tests/s, 411.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp0qibdhpm\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp0qibdhpm.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005028766 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.86 tests/s, 397.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpo7cakp8t\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpo7cakp8t.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00718003 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    139.28 tests/s, 278.55 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpg5mfqii3\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpg5mfqii3.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004907087 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.79 tests/s, 407.57 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbkx06cys\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpbkx06cys.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00517518 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    193.23 tests/s, 386.46 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max = words.max_by { |word| word.chars.uniq.size }\n  max\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpw7oaq5oj\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpw7oaq5oj.rb:17:in `test_find_max'\n\
    \     14:   def test_find_max\n     15:     candidate = method(:find_max)\n  \
    \   16:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 17:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     18:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     19:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     20:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004895094 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.29 tests/s, 408.57 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6zl3b9hk\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp6zl3b9hk.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004923027 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.13 tests/s, 406.25 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmplywfvnbt\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmplywfvnbt.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005493579 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    182.03 tests/s, 364.06 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpyqnmh6r8\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpyqnmh6r8.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004891678 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.43 tests/s, 408.86 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp502n4z8k\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp502n4z8k.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004952832 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    201.90 tests/s, 403.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbbum6iee\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpbbum6iee.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006959495 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    143.69 tests/s, 287.38 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpidjtgrr8\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpidjtgrr8.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004937423 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.53 tests/s, 405.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.split(\"\
    \").uniq.length\n    if count > max_count\n      max_count = count\n      max_word\
    \ = word\n    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_6tbijre\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_6tbijre.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004636899 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    215.66 tests/s, 431.32 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvkmplxca\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpvkmplxca.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005708043 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    175.19 tests/s, 350.38 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptp45j53v\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmptp45j53v.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.008332799 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    120.01 tests/s, 240.02 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxhljjekz\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpxhljjekz.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.007147509 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    139.91 tests/s, 279.82 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5hdaq7ao\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp5hdaq7ao.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.0055414 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    180.46 tests/s, 360.92 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_chars = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_chars\n      max_chars = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3eai03_b\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp3eai03_b.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006129886 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    163.14 tests/s, 326.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp5yatdxh\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpp5yatdxh.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005518426 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    181.21 tests/s, 362.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppy_u3lsj\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmppy_u3lsj.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005599057 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    178.60 tests/s, 357.20 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvq0t0q60\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpvq0t0q60.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00471775 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.97 tests/s, 423.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbh7nxgz6\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpbh7nxgz6.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005061907 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    197.55 tests/s, 395.11 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjxk6ojzq\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpjxk6ojzq.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004834339 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    206.85 tests/s, 413.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpo_fn0api\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpo_fn0api.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005197683 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    192.39 tests/s, 384.79 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptok51pht\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmptok51pht.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005317178 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    188.07 tests/s, 376.14 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpgl3x_c54\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpgl3x_c54.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004970956 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    201.17 tests/s, 402.34 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxrb5hj0s\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpxrb5hj0s.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005858426 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    170.69 tests/s, 341.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6gzsbipa\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp6gzsbipa.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005199827 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    192.31 tests/s, 384.63 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpih_0y2dx\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpih_0y2dx.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004902487 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.98 tests/s, 407.96 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if max_count\
    \ < word.split(\"\").uniq.count\n      max_count = word.split(\"\").uniq.count\n\
    \      max_word = word\n    end\n  end\n  max_word\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjlqz0nyw\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpjlqz0nyw.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004914362 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.49 tests/s, 406.97 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp683ap31t\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp683ap31t.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005212731 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    191.84 tests/s, 383.68 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # TODO: implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprkbgupnb\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmprkbgupnb.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004683746 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    213.50 tests/s, 213.50 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpt1e7y62s\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpt1e7y62s.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004976268 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    200.95 tests/s, 401.91 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpcp24_kfz\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpcp24_kfz.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004894824 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.30 tests/s, 408.59 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppqycl5b5\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmppqycl5b5.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005593868 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    178.77 tests/s, 357.53 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpj_0f7nhe\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpj_0f7nhe.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005151606 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    194.11 tests/s, 388.23 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfuaokcyo\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpfuaokcyo.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005087636 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.55 tests/s, 393.11 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_unique_chars = 0\n  words.each do |word|\n    unique_chars\
    \ = word.chars.uniq.count\n    if unique_chars > max_unique_chars\n      max_unique_chars\
    \ = unique_chars\n      max_word = word\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbqe63jg0\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpbqe63jg0.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005428648 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    184.21 tests/s, 368.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqgmrg8gg\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpqgmrg8gg.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004949918 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.02 tests/s, 404.05 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp9p3dtecm\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp9p3dtecm.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005150564 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    194.15 tests/s, 388.31 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4ul158ky\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp4ul158ky.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00510002 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.08 tests/s, 392.16 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpres_mobr\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpres_mobr.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005529898 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    180.84 tests/s, 361.67 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfidb1j2n\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpfidb1j2n.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006506263 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    153.70 tests/s, 307.40 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_unique_chars = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_unique_chars\n      max_word =\
    \ word\n      max_unique_chars = word.chars.uniq.count\n    end\n  end\n  max_word\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2fuzikmu\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp2fuzikmu.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.007763397 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    128.81 tests/s, 257.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7cuovo2_\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp7cuovo2_.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005062329 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    197.54 tests/s, 395.08 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpyyzcql74\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpyyzcql74.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004729563 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.44 tests/s, 422.87 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # TODO: your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpa7g68ohf\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpa7g68ohf.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.018755966 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    53.32 tests/s, 53.32 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpllqkhf7b\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpllqkhf7b.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004979874 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    200.81 tests/s, 401.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwnt5mw3r\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpwnt5mw3r.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005089961 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.47 tests/s, 392.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7o6mhxtk\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp7o6mhxtk.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004843497 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    206.46 tests/s, 412.92 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2tp4se8n\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp2tp4se8n.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005216308 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    191.71 tests/s, 383.41 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpf8n8kwz0\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpf8n8kwz0.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004686903 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    213.36 tests/s, 426.72 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max = 0\n  max_word = \"\"\n  words.each do |word|\n    if word.chars.uniq.length\
    \ > max\n      max = word.chars.uniq.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpuqxuzopg\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpuqxuzopg.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004915813 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.43 tests/s, 406.85 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4wew6szn\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp4wew6szn.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005049665 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.03 tests/s, 396.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpn0i79lsu\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpn0i79lsu.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005130506 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    194.91 tests/s, 389.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3zaxwhgu\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp3zaxwhgu.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005221728 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    191.51 tests/s, 383.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjjfzmac0\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpjjfzmac0.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004808161 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.98 tests/s, 415.96 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpn8qphhrh\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpn8qphhrh.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004931552 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.78 tests/s, 405.55 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_1z7h982\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_1z7h982.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00482943 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.06 tests/s, 414.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2ssexl2c\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp2ssexl2c.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004736146 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.14 tests/s, 422.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp9og50khs\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp9og50khs.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004617493 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    216.57 tests/s, 433.14 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpcg5lze98\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpcg5lze98.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005398782 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    185.23 tests/s, 370.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max = words.max_by { |word| word.chars.uniq.count }\n  max\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6ymnzkj8\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp6ymnzkj8.rb:17:in `test_find_max'\n\
    \     14:   def test_find_max\n     15:     candidate = method(:find_max)\n  \
    \   16:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 17:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     18:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     19:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     20:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005002597 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    199.90 tests/s, 399.79 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpv6vdlixm\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpv6vdlixm.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004992798 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    200.29 tests/s, 400.58 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpa9m53dzh\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpa9m53dzh.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005226558 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    191.33 tests/s, 382.66 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpn7ojaptm\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpn7ojaptm.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005498898 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    181.85 tests/s, 363.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpt7tf73hf\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpt7tf73hf.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005587607 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    178.97 tests/s, 357.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_n9gf9jw\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_n9gf9jw.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004817898 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.56 tests/s, 207.56 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmplt7m8oih\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmplt7m8oih.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004946832 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.15 tests/s, 404.30 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7md_5c6t\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp7md_5c6t.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004641427 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    215.45 tests/s, 215.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpusozuwcn\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpusozuwcn.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004699616 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    212.78 tests/s, 425.57 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp9f5pm5e_\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp9f5pm5e_.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005347656 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    187.00 tests/s, 374.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpnwx8mneo\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpnwx8mneo.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005829311 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    171.55 tests/s, 343.09 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7a9ids_k\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp7a9ids_k.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005305978 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    188.47 tests/s, 376.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp88zhn96o\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp88zhn96o.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004955046 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    201.81 tests/s, 403.63 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprs9tr4hb\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmprs9tr4hb.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004813411 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.75 tests/s, 415.51 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_chars = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_chars\n      max_chars = word.chars.uniq.count\n\
    \      max_word = word\n    end\n  end\n  max_word\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpco_tm10p\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpco_tm10p.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004815003 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.68 tests/s, 415.37 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp__13sawp\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp__13sawp.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004930761 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.81 tests/s, 202.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_pjqwsuk\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_pjqwsuk.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004898682 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.14 tests/s, 204.14 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpcp2j6qxe\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpcp2j6qxe.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00505785 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    197.71 tests/s, 395.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4yazmxkh\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp4yazmxkh.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.007059725 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    141.65 tests/s, 283.30 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3j84qe7w\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp3j84qe7w.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005165562 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    193.59 tests/s, 387.18 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp0kbe5ad\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpp0kbe5ad.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005377651 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    185.95 tests/s, 371.91 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmppx5ae81w\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmppx5ae81w.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005616751 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    178.04 tests/s, 356.08 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.length\
    \ > max_count\n      max_count = word.chars.uniq.length\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfzvbiti_\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpfzvbiti_.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005416795 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    184.61 tests/s, 369.22 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max = words.max_by { |word| word.chars.uniq.size }\n  max\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzo1n5j18\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpzo1n5j18.rb:17:in `test_find_max'\n\
    \     14:   def test_find_max\n     15:     candidate = method(:find_max)\n  \
    \   16:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 17:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     18:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     19:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     20:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005537271 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    180.59 tests/s, 361.19 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp14og4uc\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpp14og4uc.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004908169 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.74 tests/s, 407.48 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpcp76xzvq\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpcp76xzvq.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004828097 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.12 tests/s, 414.24 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmprxsuf5fz\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmprxsuf5fz.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005651496 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    176.94 tests/s, 353.89 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpsmgmq1_1\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpsmgmq1_1.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.007192454 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    139.03 tests/s, 278.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpg1k37j84\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpg1k37j84.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00548865 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    182.19 tests/s, 364.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxeemd1jd\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpxeemd1jd.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.009997819 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    100.02 tests/s, 200.04 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpeei0ozyf\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpeei0ozyf.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.008658391 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    115.49 tests/s, 230.99 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbs0vl__d\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpbs0vl__d.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005094419 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.29 tests/s, 392.59 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4eeyqm3b\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp4eeyqm3b.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00472788 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.51 tests/s, 423.02 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5o0tk2u1\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp5o0tk2u1.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005506554 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    181.60 tests/s, 363.20 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp72sa6idb\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp72sa6idb.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004877781 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    205.01 tests/s, 410.02 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6rwritf9\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp6rwritf9.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005498209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    181.88 tests/s, 363.75 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmplwkeng08\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmplwkeng08.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004778645 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    209.26 tests/s, 418.53 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzi9is_wr\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpzi9is_wr.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004835963 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    206.78 tests/s, 413.57 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp9lbuo3tg\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp9lbuo3tg.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005306949 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    188.43 tests/s, 376.86 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpmu9tdjeq\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpmu9tdjeq.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004849248 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    206.22 tests/s, 412.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpw2b4zfuc\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpw2b4zfuc.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004955128 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    201.81 tests/s, 403.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpx9wirl49\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpx9wirl49.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005279697 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    189.40 tests/s, 378.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_dyo0e47\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_dyo0e47.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005011684 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    199.53 tests/s, 399.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5j2nfmp6\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp5j2nfmp6.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005024376 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    199.03 tests/s, 398.06 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpcb7fajyy\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpcb7fajyy.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004878923 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.96 tests/s, 409.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvuxkwogc\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpvuxkwogc.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004745433 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    210.73 tests/s, 421.46 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpe6jw2px1\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpe6jw2px1.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00520629 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    192.08 tests/s, 384.15 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxglw23pm\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpxglw23pm.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004876468 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    205.07 tests/s, 410.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpb1mdlxrm\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpb1mdlxrm.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005076936 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.97 tests/s, 393.94 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp8tx43f9h\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp8tx43f9h.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005804154 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    172.29 tests/s, 344.58 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvkupgzvy\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpvkupgzvy.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005869918 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    170.36 tests/s, 340.72 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpv761oawg\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpv761oawg.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005474323 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    182.67 tests/s, 365.34 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_chars = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_chars\n      max_chars = word.chars.uniq.count\n\
    \      max_word = word\n    end\n  end\n  max_word\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpchaazb6y\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpchaazb6y.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004963332 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    201.48 tests/s, 402.96 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_len = 0\n  words.each do |word|\n    if word.length\
    \ > max_len\n      max_len = word.length\n      max_word = word\n    end\n  end\n\
    \  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpunq759ez\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpunq759ez.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005200338 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    192.30 tests/s, 384.59 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppdsh7hiy\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmppdsh7hiy.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005144233 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    194.39 tests/s, 388.78 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpnorihi64\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpnorihi64.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00515358 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    194.04 tests/s, 388.08 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptyze5lp0\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmptyze5lp0.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00717995 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    139.28 tests/s, 278.55 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpkuspn210\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpkuspn210.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005142459 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    194.46 tests/s, 388.92 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfl_aagrn\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpfl_aagrn.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005104247 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    195.92 tests/s, 391.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp0rgvsi_c\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp0rgvsi_c.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005405304 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    185.00 tests/s, 370.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpd0qryvb0\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpd0qryvb0.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004600229 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    217.38 tests/s, 217.38 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp8m33jp3j\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp8m33jp3j.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005117633 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    195.40 tests/s, 390.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5o30bv8v\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp5o30bv8v.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004960698 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    201.58 tests/s, 403.17 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4r4_yx_5\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp4r4_yx_5.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00497854 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    200.86 tests/s, 401.72 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7b6ue0fy\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp7b6ue0fy.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005041279 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.36 tests/s, 396.72 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp075v0wyd\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp075v0wyd.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00503601 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.57 tests/s, 397.14 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6tf5r58h\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp6tf5r58h.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005001865 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    199.93 tests/s, 399.85 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpnihujbm1\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpnihujbm1.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005292381 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    188.95 tests/s, 377.90 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # TODO: implement\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1wfm2dsy\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp1wfm2dsy.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004923828 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.09 tests/s, 203.09 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpdbhcflf_\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpdbhcflf_.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005282222 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    189.31 tests/s, 378.63 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2ar9_pu9\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp2ar9_pu9.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004698875 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    212.82 tests/s, 425.63 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpje0n8_z8\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpje0n8_z8.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.007378924 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    135.52 tests/s, 271.04 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_chars = 0\n  words.each do |word|\n    if word.chars.uniq.length\
    \ > max_chars\n      max_chars = word.chars.uniq.length\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpy43o2fr8\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpy43o2fr8.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005315013 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    188.15 tests/s, 376.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbrkjzl3_\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpbrkjzl3_.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004830442 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.02 tests/s, 414.04 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpdgiv3ure\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpdgiv3ure.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005080333 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.84 tests/s, 393.67 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfvfro46x\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpfvfro46x.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005918348 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    168.97 tests/s, 337.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max = words.max_by { |word| word.chars.uniq.count }\n  max\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpdkv4miro\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpdkv4miro.rb:17:in `test_find_max'\n\
    \     14:   def test_find_max\n     15:     candidate = method(:find_max)\n  \
    \   16:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 17:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     18:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     19:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     20:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004793122 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    208.63 tests/s, 417.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3ikcrviy\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp3ikcrviy.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.008353057 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    119.72 tests/s, 239.43 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1zpu65q4\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp1zpu65q4.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005115849 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    195.47 tests/s, 390.94 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp84v_h9_y\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp84v_h9_y.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006862944 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    145.71 tests/s, 291.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1wmtcmgb\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp1wmtcmgb.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005625207 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    177.77 tests/s, 355.54 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmphwguo9wk\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmphwguo9wk.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004849619 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    206.20 tests/s, 412.40 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = words[0]\n  max_count = words[0].chars.uniq.count\n  words.each\
    \ do |word|\n    if word.chars.uniq.count > max_count\n      max_word = word\n\
    \      max_count = word.chars.uniq.count\n    end\n  end\n  max_word\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
    \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
    name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
    , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpscma3ecv\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpscma3ecv.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004637209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    215.65 tests/s, 431.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqcjpnuw7\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpqcjpnuw7.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00461616 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    216.63 tests/s, 433.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfn4ef_z7\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpfn4ef_z7.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005773385 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    173.21 tests/s, 346.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp740pn10\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpp740pn10.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004756553 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    210.24 tests/s, 210.24 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp71007vvb\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp71007vvb.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00470139 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    212.70 tests/s, 425.41 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # TODO: implement\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5zefrhjf\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp5zefrhjf.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004913919 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.50 tests/s, 203.50 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_jrdiwzh\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp_jrdiwzh.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005203494 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    192.18 tests/s, 384.36 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzp78jvpp\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpzp78jvpp.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005036721 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.54 tests/s, 397.08 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpo00d68yh\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpo00d68yh.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004907497 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    203.77 tests/s, 407.54 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3n3x1fdt\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp3n3x1fdt.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004756765 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    210.23 tests/s, 420.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpyrza6enn\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpyrza6enn.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004893331 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.36 tests/s, 408.72 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvrsjaiss\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpvrsjaiss.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004988861 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    200.45 tests/s, 400.89 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpiuswhxif\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpiuswhxif.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005487879 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    182.22 tests/s, 364.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5t_3c_o0\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp5t_3c_o0.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005037112 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.53 tests/s, 397.05 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxc44eexv\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpxc44eexv.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.00882865 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    113.27 tests/s, 226.54 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.size }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpz1c391e1\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpz1c391e1.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.005047531 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.12 tests/s, 396.23 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  words.max_by { |word| word.chars.uniq.count }\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpj9v8mvo9\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpj9v8mvo9.rb:16:in `test_find_max'\n\
    \     13:   def test_find_max\n     14:     candidate = method(:find_max)\n  \
    \   15:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 16:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     17:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     18:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     19:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004706511 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    212.47 tests/s, 424.94 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfz3r1siz\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpfz3r1siz.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004729203 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.45 tests/s, 422.90 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp7m0choq\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpp7m0choq.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004718242 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.94 tests/s, 423.89 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.chars.uniq.count\n\
    \    if count > max_count\n      max_count = count\n      max_word = word\n  \
    \  end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpeyrjst9w\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpeyrjst9w.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004731196 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.36 tests/s, 422.73 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # TODO: implement\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7fxa2vro\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp7fxa2vro.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004690009 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    213.22 tests/s, 213.22 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp420hwiwz\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp420hwiwz.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004831785 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    206.96 tests/s, 206.96 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  # TODO: implement\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp0kemsvqw\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp0kemsvqw.rb:15:in `test_find_max'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_find_max\n\
    \     14:     candidate = method(:find_max)\n  => 15:     assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n     16:     assert_equal(\"\
    enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n     17:     assert_equal(\"\
    aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n     18:     assert_equal(\"\
    abc\", candidate.call([\"abc\", \"cba\"]))\n<\"string\"> expected but was\n<nil>\n\
    \ndiff:\n? \"string\"\n? n    l  \n===============================================================================\n\
    \nFinished in 0.004711438 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    212.25 tests/s, 212.25 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvupn9hr2\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpvupn9hr2.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004926233 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.99 tests/s, 405.99 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    count = word.split(\"\
    \").uniq.count\n    if count > max_count\n      max_count = count\n      max_word\
    \ = word\n    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n\
    \    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n\
    \    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n\
    \    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n\
    \    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"\
    footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"\
    rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\"\
    , \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\"\
    , \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n\
    \    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwt0opp95\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpwt0opp95.rb:25:in `test_find_max'\n\
    \     22:   def test_find_max\n     23:     candidate = method(:find_max)\n  \
    \   24:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 25:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     26:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     27:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     28:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004566957 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    218.96 tests/s, 437.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max = words.max_by { |word| word.chars.uniq.count }\n  max\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate\
    \ = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\",\
    \ \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\",\
    \ \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
    ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\"\
    , \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6qjqhesx\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp6qjqhesx.rb:17:in `test_find_max'\n\
    \     14:   def test_find_max\n     15:     candidate = method(:find_max)\n  \
    \   16:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 17:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     18:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     19:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     20:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.006564323 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    152.34 tests/s, 304.68 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.length\
    \ > max_count\n      max_count = word.length\n      max_word = word\n    end\n\
    \  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5t0f6lyu\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmp5t0f6lyu.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004335431 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    230.66 tests/s, 461.32 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Write a function that accepts a list of strings.\n# The list contains\
    \ different words. Return the word with maximum number\n# of unique characters.\
    \ If multiple strings have maximum number of unique\n# characters, return the\
    \ one which comes first in lexicographical order.\n# find_max([\"name\", \"of\"\
    , \"string\"]) == \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"\
    enam\"\n# find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n\
    \  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n    if word.chars.uniq.count\
    \ > max_count\n      max_count = word.chars.uniq.count\n      max_word = word\n\
    \    end\n  end\n  max_word\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\"\
    , candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\",\
    \ candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\"\
    , candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"\
    abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"\
    this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"\
    we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
    this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"\
    b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"\
    ]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpv89vecrq\nStarted\nF\n===============================================================================\n\
    Failure: test_find_max(TestHumanEval)\n/tmp/tmpv89vecrq.rb:24:in `test_find_max'\n\
    \     21:   def test_find_max\n     22:     candidate = method(:find_max)\n  \
    \   23:     assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"\
    ]))\n  => 24:     assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"\
    game\"]))\n     25:     assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"]))\n     26:     assert_equal(\"abc\", candidate.call([\"abc\"\
    , \"cba\"]))\n     27:     assert_equal(\"footbott\", candidate.call([\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"]))\n<\"enam\"> expected but was\n<\"\
    name\">\n\ndiff:\n? ename\n===============================================================================\n\
    \nFinished in 0.004375948 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    228.52 tests/s, 457.04 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
