name: HumanEval_12_longest
language: ruby
prompt: "# Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return None in case the input\
  \ list is empty.\n# >>> longest([])\n# >>> longest(['a', 'b', 'c'])\n# 'a'\n# >>>\
  \ longest(['a', 'bb', 'ccc'])\n# 'ccc'\ndef longest(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n\
  \    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n \
  \   assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n\
  \  end\nend\n"
completions: ["  if strings.length == 0\n    return nil\n  end\n  longest = strings[0]\n\
    \  strings.each do |string|\n    if string.length > longest.length\n      longest\
    \ = string\n    end\n  end\n  return longest\nend", "  return nil if strings.empty?\n\
    \  longest = strings[0]\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend", "  if strings.empty?\n    return nil\n\
    \  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  return nil if strings.empty?\n  longest = strings[0]\n\
    \  strings.each do |string|\n    longest = string if string.length > longest.length\n\
    \  end\n  longest\nend", "  return nil if strings.empty?\n  longest = strings[0]\n\
    \  strings.each do |string|\n    longest = string if string.length > longest.length\n\
    \  end\n  longest\nend", "  # your code here\nend", "  return nil if strings.empty?\n\
    \  longest = strings[0]\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend", "  strings.max_by(&:length)\nend",
  "  # TODO: implement me\nend", "  return nil if strings.empty?\n  longest = strings[0]\n\
    \  strings.each do |string|\n    longest = string if string.length > longest.length\n\
    \  end\n  longest\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.max_by(&:length)\nend", "  return\
    \ nil if strings.empty?\n  strings.max_by { |string| string.length }\nend", " \
    \ if strings.empty?\n    return nil\n  end\n  longest_string = strings[0]\n  strings.each\
    \ do |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |str| str.length }\nend", "  strings.max_by(&:length)\nend",
  "  if strings.empty?\n    return nil\n  end\n  longest_string = strings[0]\n  strings.each\
    \ do |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |string| string.length }\nend", "  # TODO: implement me!\n\
    end", "  return nil if strings.empty?\n  strings.max_by { |string| string.length\
    \ }\nend", "  strings.max_by(&:length)\nend", "  if strings.empty?\n    return\
    \ nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if\
    \ string.length > longest_string.length\n      longest_string = string\n    end\n\
    \  end\n  return longest_string\nend", "  return nil if strings.empty?\n  strings.max_by\
    \ { |str| str.length }\nend", "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\n\
    end", "  if strings.empty?\n    return nil\n  else\n    strings.max_by(&:length)\n\
    \  end\nend", "  strings.max_by { |string| string.length }\nend", "  if strings.empty?\n\
    \    nil\n  else\n    strings.max_by { |string| string.length }\n  end\nend",
  "  if strings.empty?\n    return nil\n  end\n  longest_string = strings[0]\n  strings.each\
    \ do |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  if strings.empty?\n    return\
    \ nil\n  else\n    longest_string = strings[0]\n    strings.each do |string|\n\
    \      if string.length > longest_string.length\n        longest_string = string\n\
    \      end\n    end\n    return longest_string\n  end\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  strings.max_by(&:length)\n\
    end", "  longest = strings.max_by { |string| string.length }\n  longest.nil? ?\
    \ nil : longest\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.max_by(&:length)\nend", "  longest\
    \ = nil\n  strings.each do |string|\n    if longest.nil? || string.length > longest.length\n\
    \      longest = string\n    end\n  end\n  longest\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  # TODO: implement me\nend", "  return\
    \ nil if strings.empty?\n  strings.max_by { |string| string.length }\nend", " \
    \ if strings.length == 0\n    return nil\n  end\n  longest_string = strings[0]\n\
    \  strings.each do |string|\n    if string.length > longest_string.length\n  \
    \    longest_string = string\n    end\n  end\n  return longest_string\nend", " \
    \ if strings.empty?\n    return nil\n  end\n  longest_string = strings[0]\n  strings.each\
    \ do |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |str| str.length }\nend", "  if strings.empty?\n    return\
    \ nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if\
    \ string.length > longest_string.length\n      longest_string = string\n    end\n\
    \  end\n  return longest_string\nend", "  if strings.empty?\n    return nil\n\
    \  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  return nil if strings.empty?\n  strings.max_by { |str|\
    \ str.length }\nend", "  return nil if strings.empty?\n  strings.max_by { |str|\
    \ str.length }\nend", "  strings.max_by { |string| string.length }\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend", " \
    \ if strings.empty?\n    return nil\n  end\n  longest_string = strings[0]\n  strings.each\
    \ do |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  strings.max_by { |x| x.length\
    \ }\nend", "  return nil if strings.empty?\n  strings.max_by { |string| string.length\
    \ }\nend", "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend",
  "  # TODO: implement me\nend", "  return nil if strings.empty?\n  strings.max_by\
    \ { |string| string.length }\nend", "  # TODO: implement me\nend", "  longest\
    \ = nil\n  strings.each do |string|\n    if longest.nil? || string.length > longest.length\n\
    \      longest = string\n    end\n  end\n  longest\nend", "  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.sort_by { |str| str.length }.last\n\
    end", "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend", " \
    \ return nil if strings.empty?\n  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\n\
    end", "  longest = strings.max_by { |string| string.length }\n  if longest ==\
    \ nil\n    return nil\n  else\n    return longest\n  end\nend", "  return nil\
    \ if strings.empty?\n  strings.max_by(&:length)\nend", "  strings.max_by { |str|\
    \ str.length }\nend", "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by { |string| string.length }\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |str| str.length }\nend", "  return nil if strings.empty?\n\
    \  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  # TODO: implement me\nend", "  return\
    \ nil if strings.empty?\n  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by { |str| str.length }\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by { |str| str.length }\nend", "  if strings.empty?\n   \
    \ return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.max_by { |str| str.length }\n\
    end", "  if strings.empty?\n    return nil\n  else\n    strings.max_by(&:length)\n\
    \  end\nend", "  strings.max_by(&:length)\nend", "  if strings.empty?\n    return\
    \ nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if\
    \ string.length > longest_string.length\n      longest_string = string\n    end\n\
    \  end\n  return longest_string\nend", "  longest = strings.sort_by { |s| s.length\
    \ }.last\n  longest.nil? ? nil : longest\nend", "  strings.max_by { |str| str.length\
    \ }\nend", "  strings.max_by { |str| str.length }\nend", "  return nil if strings.empty?\n\
    \  strings.max_by(&:length)\nend", "  if strings.empty?\n    return nil\n  end\n\
    \  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  strings.max_by(&:length)\nend", "  if strings.length\
    \ == 0\n    return nil\n  end\n  longest_string = strings[0]\n  strings.each do\
    \ |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  longest = strings.max_by { |string|\
    \ string.length }\n  return longest\nend", "  strings.max_by(&:length)\nend",
  "  return nil if strings.empty?\n  strings.max_by { |string| string.length }\nend",
  "  strings.max_by { |str| str.length }\nend", "  if strings.empty?\n    return nil\n\
    \  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  if strings.empty?\n    return nil\n  end\n  longest_string\
    \ = strings[0]\n  strings.each do |string|\n    if string.length > longest_string.length\n\
    \      longest_string = string\n    end\n  end\n  return longest_string\nend",
  "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend", "  return\
    \ nil if strings.empty?\n  strings.max_by(&:length)\nend", "  longest = strings.max_by\
    \ { |string| string.length }\n  if longest.nil?\n    return nil\n  else\n    return\
    \ longest\n  end\nend", "  return nil if strings.empty?\n  strings.max_by { |string|\
    \ string.length }\nend", "  return nil if strings.empty?\n  longest = strings[0]\n\
    \  strings.each do |string|\n    longest = string if string.length > longest.length\n\
    \  end\n  longest\nend", "  if strings.length == 0\n    return nil\n  end\n  longest\
    \ = strings[0]\n  strings.each do |string|\n    if string.length > longest.length\n\
    \      longest = string\n    end\n  end\n  return longest\nend", "  if strings.empty?\n\
    \    return nil\n  else\n    longest_string = strings[0]\n    strings.each do\
    \ |string|\n      if string.length > longest_string.length\n        longest_string\
    \ = string\n      end\n    end\n    return longest_string\n  end\nend", "  return\
    \ nil if strings.empty?\n  strings.max_by { |str| str.length }\nend", "  return\
    \ nil if strings.empty?\n  strings.max_by(&:length)\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.max_by { |string| string.length\
    \ }\nend", "  strings.max_by(&:length)\nend", "  if strings.empty?\n    return\
    \ nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if\
    \ string.length > longest_string.length\n      longest_string = string\n    end\n\
    \  end\n  return longest_string\nend", "  if strings.empty?\n    return nil\n\
    \  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n\
    \  longest = strings[0]\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend", "  strings.max_by(&:length)\nend",
  "  return nil if strings.empty?\n  strings.max_by { |string| string.length }\nend",
  "  if strings.empty?\n    return nil\n  end\n  longest_string = strings[0]\n  strings.each\
    \ do |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  return nil if strings.empty?\n\
    \  strings.max_by(&:length)\nend", "  if strings.empty?\n    return nil\n  else\n\
    \    longest_string = strings[0]\n    strings.each do |string|\n      if string.length\
    \ > longest_string.length\n        longest_string = string\n      end\n    end\n\
    \    return longest_string\n  end\nend", "  if strings.empty?\n    return nil\n\
    \  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  if strings.empty?\n    return nil\n  end\n  longest_string\
    \ = strings[0]\n  strings.each do |string|\n    if string.length > longest_string.length\n\
    \      longest_string = string\n    end\n  end\n  return longest_string\nend",
  "  return nil if strings.empty?\n  strings.max_by { |str| str.length }\nend", " \
    \ strings.max_by { |x| x.length }\nend", "  if strings.empty?\n    return nil\n\
    \  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n\
    \  strings.max_by(&:length)\nend", "  if strings.empty?\n    return nil\n  end\n\
    \  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  strings.max_by { |str| str.length }\nend", "  strings.max_by\
    \ { |string| string.length }\nend", "  return nil if strings.empty?\n  longest\
    \ = strings[0]\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend", "  if strings.empty?\n    return nil\n\
    \  else\n    longest_string = strings[0]\n    strings.each do |string|\n     \
    \ if string.length > longest_string.length\n        longest_string = string\n\
    \      end\n    end\n    return longest_string\n  end\nend", "  longest = nil\n\
    \  strings.each do |string|\n    if longest.nil? || string.length > longest.length\n\
    \      longest = string\n    end\n  end\n  longest\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  strings.max_by(&:length)\n\
    end", "  longest = strings.first\n  strings.each do |string|\n    if string.length\
    \ > longest.length\n      longest = string\n    end\n  end\n  longest\nend", " \
    \ return nil if strings.empty?\n  strings.max_by { |string| string.length }\n\
    end", "  if strings.empty?\n    return nil\n  end\n  longest_string = strings[0]\n\
    \  strings.each do |string|\n    if string.length > longest_string.length\n  \
    \    longest_string = string\n    end\n  end\n  return longest_string\nend", " \
    \ if strings.empty?\n    return nil\n  else\n    longest_string = strings[0]\n\
    \    strings.each do |string|\n      if string.length > longest_string.length\n\
    \        longest_string = string\n      end\n    end\n    return longest_string\n\
    \  end\nend", "  return nil if strings.empty?\n  longest = strings[0]\n  strings.each\
    \ do |string|\n    longest = string if string.length > longest.length\n  end\n\
    \  longest\nend", "  return nil if strings.empty?\n  strings.max_by { |string|\
    \ string.length }\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.max_by\
    \ { |string| string.length }\nend", "  # TODO\nend", "  strings.max_by { |string|\
    \ string.length }\nend", "  return nil if strings.empty?\n  strings.max_by { |string|\
    \ string.length }\nend", "  longest = strings.max_by { |str| str.length }\n  longest\n\
    end", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.max_by\
    \ { |str| str.length }\nend", "  if strings.empty?\n    return nil\n  end\n  longest_string\
    \ = strings[0]\n  strings.each do |string|\n    if string.length > longest_string.length\n\
    \      longest_string = string\n    end\n  end\n  return longest_string\nend",
  "  strings.max_by(&:length)\nend", "  if strings.empty?\n    return nil\n  end\n\
    \  longest_string = strings[0]\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  return\
    \ longest_string\nend", "  return nil if strings.empty?\n  strings.max_by { |string|\
    \ string.length }\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.max_by { |str| str.length }\n\
    end", "  longest = strings.max_by { |string| string.length }\n  longest.nil? ?\
    \ nil : longest\nend", "  if strings.empty?\n    return nil\n  end\n  longest_string\
    \ = strings[0]\n  strings.each do |string|\n    if string.length > longest_string.length\n\
    \      longest_string = string\n    end\n  end\n  return longest_string\nend",
  "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend", "  return\
    \ nil if strings.empty?\n  strings.max_by(&:length)\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  strings.max_by(&:length)\n\
    end", "  if strings.length == 0\n    return nil\n  end\n  longest_string = strings[0]\n\
    \  strings.each do |string|\n    if string.length > longest_string.length\n  \
    \    longest_string = string\n    end\n  end\n  return longest_string\nend", " \
    \ strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  if strings.length == 0\n    return nil\n  else\n    strings.max_by {\
    \ |x| x.length }\n  end\nend", "  if strings.empty?\n    return nil\n  else\n\
    \    longest_string = strings[0]\n    strings.each do |string|\n      if string.length\
    \ > longest_string.length\n        longest_string = string\n      end\n    end\n\
    \    return longest_string\n  end\nend", "  strings.max_by { |str| str.length\
    \ }\nend", "  return nil if strings.empty?\n  strings.max_by { |s| s.length }\n\
    end", "  longest = nil\n  strings.each do |string|\n    if longest.nil? || string.length\
    \ > longest.length\n      longest = string\n    end\n  end\n  longest\nend", " \
    \ strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  longest = nil\n  strings.each do |string|\n    if longest.nil? || string.length\
    \ > longest.length\n      longest = string\n    end\n  end\n  longest\nend", " \
    \ strings.max_by(&:length)\nend", "  # your code here\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  max_length = 0\n  result =\
    \ nil\n  strings.each do |string|\n    if string.length > max_length\n      max_length\
    \ = string.length\n      result = string\n    end\n  end\n  result\nend", "  longest\
    \ = strings.max_by { |string| string.length }\n  longest\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |string| string.length }\nend", "  strings.max_by(&:length)\n\
    end", "  longest = nil\n  strings.each do |string|\n    if longest.nil? || string.length\
    \ > longest.length\n      longest = string\n    end\n  end\n  longest\nend", " \
    \ strings.max_by { |string| string.length }\nend", "  if strings.empty?\n    return\
    \ nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n    if\
    \ string.length > longest_string.length\n      longest_string = string\n    end\n\
    \  end\n  return longest_string\nend", "  strings.max_by(&:length)\nend", "  if\
    \ strings.empty?\n    return nil\n  else\n    longest_string = strings[0]\n  \
    \  strings.each do |string|\n      if string.length > longest_string.length\n\
    \        longest_string = string\n      end\n    end\n    return longest_string\n\
    \  end\nend", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n\
    \  longest = strings[0]\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
