name: HumanEval_115_max_fill
language: rust
prompt: "/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n/// bucket_capacity\
  \ : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output: 5\n/// Example 3:\n\
  /// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity : 5\n/// Output:\
  \ 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length\
  \ <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// *\
  \ 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n   \
  \ assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
  \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1,\
  \ 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
completions: ["    let mut max = 0;\n    for row in grid {\n        let mut sum =\
    \ 0;\n        for &cell in &row {\n            sum += cell;\n            if sum\
    \ > capacity {\n                sum = capacity;\n            }\n        }\n  \
    \      max = max.max(sum);\n    }\n    max", "    let mut result = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        let mut height = 0;\n  \
    \      for &cell in &row {\n            if cell == 1 {\n                height\
    \ += 1;\n            } else {\n                height = 0;\n            }\n  \
    \          max_height = max(max_height, height);\n        }\n    }\n    for row\
    \ in grid {\n        let mut height = 0;\n        for &cell in &row {\n      \
    \      if cell == 1 {\n                height += 1;\n            } else {\n  \
    \              height = 0;\n            }\n            let fill = min(height,\
    \ max_height);\n            result += fill;\n            max_height = max(0, max_height\
    \ - capacity);\n        }\n    }\n    result", "    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                fill += 1;\n            } else {\n\
    \                if fill > max_fill {\n                    max_fill = fill;\n\
    \                }\n                fill = 0;\n            }\n        }\n    \
    \    if fill > max_fill {\n            max_fill = fill;\n        }\n    }\n  \
    \  (max_fill + capacity - 1) / capacity", "    let mut grid = grid;\n    let mut\
    \ count = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n    for row\
    \ in &grid {\n        for col in row {\n            if *col > max_col {\n    \
    \            max_col = *col;\n            }\n        }\n        if row.iter().sum::<isize>()\
    \ > max_row {\n            max_row = row.iter().sum::<isize>();\n        }\n \
    \   }\n    for _ in 0..max_row {\n        for row in &mut grid {\n           \
    \ for col in row {\n                if *col > 0 {\n                    *col -=\
    \ 1;\n                    count += 1;\n                }\n            }\n    \
    \    }\n    }\n    for _ in 0..max_col {\n        for row in &mut grid {\n   \
    \         for col in row {\n                if *col > 0 {\n                  \
    \  *col -= 1;\n                    count += 1;\n                }\n          \
    \  }\n        }\n    }\n    count", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ if well == 1 {\n                fill += 1;\n            } else {\n         \
    \       if fill > max_fill {\n                    max_fill = fill;\n         \
    \       }\n                fill = 0;\n            }\n        }\n        if fill\
    \ > max_fill {\n            max_fill = fill;\n        }\n    }\n    max_fill /\
    \ capacity + max_fill % capacity", "    let mut count = 0;\n    let mut max =\
    \ 0;\n    for row in grid {\n        for &well in &row {\n            if well\
    \ == 1 {\n                max += 1;\n            }\n        }\n    }\n    let\
    \ mut filled = 0;\n    while filled < max {\n        for row in grid {\n     \
    \       for &well in &row {\n                if well == 1 {\n                \
    \    filled += 1;\n                    if filled == max {\n                  \
    \      break;\n                    }\n                }\n            }\n     \
    \       if filled == max {\n                break;\n            }\n          \
    \  count += 1;\n        }\n    }\n    count", "    let mut grid = grid;\n    let\
    \ mut count = 0;\n    let mut max_fill = 0;\n    let mut max_fill_index = 0;\n\
    \    let mut max_fill_row = 0;\n    let mut max_fill_col = 0;\n    let mut max_fill_row_index\
    \ = 0;\n    let mut max_fill_col_index = 0;\n    let mut max_fill_row_count =\
    \ 0;\n    let mut max_fill_col_count = 0;\n    let mut max_fill_row_count_index\
    \ = 0;\n    let mut max_fill_col_count_index = 0;\n    let mut max_fill_row_count_max\
    \ = 0;\n    let mut max_fill_col_count_max = 0;\n    let mut max_fill_row_count_max_index\
    \ = 0;\n    let mut max_fill_col_count_max_index = 0;\n    let mut max_fill_row_count_max_index_index\
    \ = 0;\n    let mut max_fill_col_count_max_index_index = 0;\n    let mut max_fill_row_count_max_index_index_index\
    \ = 0;\n    let mut max_fill_col_count_max_index_index_index = 0;\n    let mut\
    \ max_fill_row_count_max_index_index_index_index = 0;\n    let mut max_fill_col_count_max_index_index_index_index\
    \ = 0;\n    let mut max_fill_row_count_max_index_index_index_index_index = 0;\n\
    \    let mut max_fill_col_count_max_index_index_index_index_index = 0;\n    let\
    \ mut max_fill_row_count_max_index_index_index_index_index_index = 0;\n    let\
    \ mut max_fill_col_count_max_index_index_index_index_index_index = 0;\n    let\
    \ mut max_fill_row_count_max_index_index_index_index_index_index_index = 0;\n\
    \    let mut max_fill_col_count_max_index_index_index_index_index_", "    let\
    \ mut max_fill = 0;\n    let mut fill = 0;\n    for row in grid {\n        for\
    \ &well in &row {\n            if well == 1 {\n                fill += 1;\n  \
    \          } else {\n                max_fill = max_fill.max(fill);\n        \
    \        fill = 0;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \        fill = 0;\n    }\n    (max_fill + capacity - 1) / capacity", "    let\
    \ mut grid = grid;\n    let mut count = 0;\n    let n = grid.len();\n    let m\
    \ = grid[0].len();\n    for i in 0..n {\n        for j in 0..m {\n           \
    \ if grid[i][j] == 1 {\n                count += 1;\n                let mut k\
    \ = i;\n                while k < n && grid[k][j] == 1 {\n                   \
    \ grid[k][j] = 0;\n                    k += 1;\n                }\n          \
    \      if k == n {\n                    break;\n                }\n          \
    \      let mut l = j;\n                while l < m && grid[k][l] == 1 {\n    \
    \                grid[k][l] = 0;\n                    l += 1;\n              \
    \  }\n                if l == m {\n                    break;\n              \
    \  }\n            }\n        }\n    }\n    count", "    let mut max_fill = 0;\n\
    \    let mut fill = 0;\n    for row in grid {\n        for &well in &row {\n \
    \           fill += well;\n            if fill > capacity {\n                max_fill\
    \ += fill - capacity;\n                fill = capacity;\n            }\n     \
    \   }\n        fill = 0;\n    }\n    max_fill", "    let mut max_fill = 0;\n \
    \   let mut total_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for &cell in &row {\n            if cell == 1 {\n                fill\
    \ += 1;\n            }\n        }\n        total_fill += fill;\n        max_fill\
    \ = max_fill.max(fill);\n    }\n    let mut buckets = 0;\n    while max_fill >\
    \ 0 {\n        buckets += 1;\n        max_fill -= capacity;\n    }\n    buckets\
    \ + total_fill", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = 0;\n            }\n        }\n        if fill > 0 {\n            max_fill\
    \ += 1;\n        }\n    }\n    max_fill", "    let mut max = 0;\n    for row in\
    \ grid {\n        let mut sum = 0;\n        for &cell in &row {\n            sum\
    \ += cell;\n            if sum > capacity {\n                sum = capacity;\n\
    \            }\n        }\n        max = max.max(sum);\n    }\n    max", "   \
    \ let mut max = 0;\n    for row in grid {\n        let mut cur = 0;\n        for\
    \ &c in &row {\n            cur += c;\n            if cur > capacity {\n     \
    \           cur = capacity;\n            }\n        }\n        max = max.max(cur);\n\
    \    }\n    max", "    let mut result = 0;\n    let mut max_height = 0;\n    for\
    \ row in grid {\n        let mut height = 0;\n        for &well in &row {\n  \
    \          if well == 1 {\n                height += 1;\n            } else {\n\
    \                max_height = max(max_height, height);\n                height\
    \ = 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \        result += max_height;\n        if max_height > capacity {\n         \
    \   result += max_height - capacity;\n            max_height = capacity;\n   \
    \     }\n    }\n    result", "    let mut grid = grid;\n    let mut count = 0;\n\
    \    let mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut\
    \ height = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1\
    \ {\n                height += 1;\n            } else {\n                height\
    \ = 0;\n            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in &row {\n            if well == 1 {\n       \
    \         fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill %\
    \ capacity != 0) as isize", "    let mut max_fill = 0;\n    for row in grid {\n\
    \        let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                fill += 1;\n            } else {\n\
    \                fill = 0;\n            }\n            if fill > max_fill {\n\
    \                max_fill = fill;\n            }\n        }\n    }\n    max_fill\
    \ / capacity + max_fill % capacity", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ if well == 1 {\n                fill += 1;\n            } else {\n         \
    \       if fill > max_fill {\n                    max_fill = fill;\n         \
    \       }\n                fill = 0;\n            }\n        }\n        if fill\
    \ > max_fill {\n            max_fill = fill;\n        }\n    }\n    max_fill /\
    \ capacity + if max_fill % capacity == 0 { 0 } else { 1 }", "    let mut grid\
    \ = grid;\n    let mut count = 0;\n    let mut max_row = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut sum = 0;\n        for cell in row.iter_mut() {\n        \
    \    sum += *cell;\n            *cell = 0;\n        }\n        if sum > max_row\
    \ {\n            max_row = sum;\n        }\n    }\n    for _ in 0..max_row {\n\
    \        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell < capacity {\n                    *cell += 1;\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in &row {\n            if well == 1 {\n       \
    \         fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + max_fill %\
    \ capacity", "    let mut grid = grid;\n    let mut count = 0;\n    let mut max\
    \ = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n\
    \            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n     \
    \   for cell in row.iter() {\n            max = max.max(*cell);\n        }\n \
    \   }\n    count + max - 1", "    let mut max_fill = 0;\n    let mut fill = 0;\n\
    \    for row in grid {\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += 1;\n      \
    \  fill = 0;\n    }\n    max_fill", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ fill += well;\n            if fill > capacity {\n                fill = capacity;\n\
    \            }\n        }\n        max_fill = max_fill.max(fill);\n    }\n   \
    \ max_fill", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in &row {\n            fill += well;\n        \
    \    if fill > capacity {\n                fill = capacity;\n            }\n \
    \       }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill", "   \
    \ let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n  \
    \      for &well in &row {\n            fill += well;\n            if fill > capacity\
    \ {\n                max_fill += 1;\n                fill = well;\n          \
    \  }\n        }\n        max_fill += fill;\n    }\n    max_fill", "    let mut\
    \ max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n        for\
    \ &well in &row {\n            fill += well;\n            if fill > capacity {\n\
    \                max_fill += 1;\n                fill = well;\n            }\n\
    \        }\n        max_fill += fill;\n    }\n    max_fill", "    let mut grid\
    \ = grid;\n    let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut()\
    \ {\n        for cell in row.iter_mut() {\n            if *cell > 0 {\n      \
    \          *cell = 1;\n                count += 1;\n            }\n        }\n\
    \    }\n    for row in grid.iter() {\n        for cell in row.iter() {\n     \
    \       max = max.max(*cell);\n        }\n    }\n    count + (max - 1) * capacity",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for &well in &row {\n            fill += well;\n            if fill ==\
    \ capacity {\n                max_fill += 1;\n                fill = 0;\n    \
    \        }\n        }\n        if fill > 0 {\n            max_fill += 1;\n   \
    \     }\n    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            } else {\n                if\
    \ fill > max_fill {\n                    max_fill = fill;\n                }\n\
    \                fill = 0;\n            }\n        }\n        if fill > max_fill\
    \ {\n            max_fill = fill;\n        }\n    }\n    (max_fill + capacity\
    \ - 1) / capacity", "    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in &grid {\n        let mut row_max = 0;\n\
    \        for &cell in row {\n            if cell > row_max {\n               \
    \ row_max = cell;\n            }\n        }\n        if row_max > max_height {\n\
    \            max_height = row_max;\n        }\n    }\n    for _ in 0..max_height\
    \ {\n        for row in &mut grid {\n            for cell in row {\n         \
    \       if *cell > 0 {\n                    *cell -= 1;\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n  \
    \      for &well in &row {\n            fill += well;\n            if fill > capacity\
    \ {\n                fill = capacity;\n            }\n        }\n        max_fill\
    \ = max_fill.max(fill);\n    }\n    max_fill", "    let mut count = 0;\n    let\
    \ mut max_row = vec![0; grid[0].len()];\n    for row in grid {\n        for (i,\
    \ &v) in row.iter().enumerate() {\n            if v == 1 {\n                max_row[i]\
    \ += 1;\n            }\n        }\n    }\n    for &v in max_row.iter() {\n   \
    \     let mut c = v;\n        while c > 0 {\n            count += 1;\n       \
    \     c -= capacity;\n        }\n    }\n    count", "    let mut result = 0;\n\
    \    let mut max_row = 0;\n    for row in grid {\n        let mut sum = 0;\n \
    \       for &cell in &row {\n            sum += cell;\n        }\n        max_row\
    \ = max(max_row, sum);\n    }\n    for row in grid {\n        let mut sum = 0;\n\
    \        for &cell in &row {\n            sum += cell;\n        }\n        result\
    \ += max_row - sum;\n    }\n    result / capacity", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = well;\n            }\n        }\n   \
    \     max_fill += fill;\n    }\n    max_fill", "    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut() {\n\
    \        for cell in row.iter_mut() {\n            if *cell > 0 {\n          \
    \      *cell = capacity;\n                count += 1;\n            }\n       \
    \     max = max.max(*cell);\n        }\n    }\n    if max == 0 {\n        return\
    \ 0;\n    }\n    let mut i = 0;\n    while i < grid.len() {\n        let mut j\
    \ = 0;\n        while j < grid[i].len() {\n            if grid[i][j] > 0 {\n \
    \               let mut k = i + 1;\n                while k < grid.len() && grid[k][j]\
    \ > 0 {\n                    grid[k][j] -= 1;\n                    k += 1;\n \
    \               }\n                count += 1;\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    count", "    let mut grid = grid;\n\
    \    let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut row_max = 0;\n        for cell in row.iter_mut() {\n    \
    \        if *cell == 1 {\n                row_max += 1;\n            }\n     \
    \   }\n        if row_max > max_height {\n            max_height = row_max;\n\
    \        }\n    }\n    for _ in 0..max_height {\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell == 1 {\n\
    \                    *cell = 0;\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count", "    let mut max_fill =\
    \ 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in &row\
    \ {\n            if well == 1 {\n                fill += 1;\n            } else\
    \ {\n                fill = 0;\n            }\n            max_fill = max_fill.max(fill);\n\
    \        }\n    }\n    max_fill / capacity + max_fill % capacity", "    let mut\
    \ grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n    for row\
    \ in grid.iter_mut() {\n        let mut height = 0;\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                height += 1;\n            }\
    \ else {\n                height = 0;\n            }\n            *cell = height;\n\
    \            max_height = max(max_height, height);\n        }\n    }\n    for\
    \ height in 1..=max_height {\n        for row in grid.iter_mut() {\n         \
    \   for cell in row.iter_mut() {\n                if *cell >= height {\n     \
    \               *cell -= height;\n                    count += 1;\n          \
    \      }\n            }\n        }\n    }\n    count", "    let mut max = 0;\n\
    \    for row in grid {\n        let mut sum = 0;\n        for &x in &row {\n \
    \           sum += x;\n            if sum > capacity {\n                sum =\
    \ capacity;\n            }\n        }\n        max = max.max(sum);\n    }\n  \
    \  max", "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill\
    \ = 0;\n        for &well in &row {\n            fill += well;\n            if\
    \ fill > capacity {\n                max_fill += 1;\n                fill = well;\n\
    \            }\n        }\n        max_fill += fill;\n    }\n    max_fill", " \
    \   let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for &well in &row {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max_fill.max(fill);\n    }\n    max_fill", "    let mut max_fill\
    \ = 0;\n    let mut fill = 0;\n    for row in grid {\n        for &well in &row\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n        fill = 0;\n    }\n    max_fill", "    let mut\
    \ max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n        for\
    \ &well in &row {\n            fill += well;\n            if fill == capacity\
    \ {\n                max_fill += 1;\n                fill = 0;\n            }\n\
    \        }\n        if fill > 0 {\n            max_fill += 1;\n        }\n   \
    \ }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = 0;\n            }\n        }\n        if fill > 0 {\n          \
    \  max_fill += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid {\n   \
    \     let mut fill = 0;\n        for &well in &row {\n            if well == 1\
    \ {\n                fill += 1;\n            } else {\n                if fill\
    \ > max_fill {\n                    max_fill = fill;\n                }\n    \
    \            fill = 0;\n            }\n        }\n        if fill > max_fill {\n\
    \            max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize", "    let mut max = 0;\n    for row in grid {\n \
    \       let mut count = 0;\n        for &cell in &row {\n            if cell ==\
    \ 1 {\n                count += 1;\n            }\n        }\n        max = max.max(count);\n\
    \    }\n    max / capacity + (max % capacity != 0) as isize", "    let mut grid\
    \ = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n    for row in\
    \ grid.iter_mut() {\n        for cell in row.iter_mut() {\n            if *cell\
    \ == 1 {\n                *cell = capacity;\n                max_height = capacity;\n\
    \            }\n        }\n    }\n    while max_height > 0 {\n        let mut\
    \ next_max_height = 0;\n        for row in grid.iter_mut() {\n            for\
    \ cell in row.iter_mut() {\n                if *cell == max_height {\n       \
    \             *cell -= 1;\n                    next_max_height = max(next_max_height,\
    \ *cell);\n                    count += 1;\n                }\n            }\n\
    \        }\n        max_height = next_max_height;\n    }\n    count", "    let\
    \ mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n      \
    \  for &well in &row {\n            if well == 1 {\n                fill += 1;\n\
    \            } else {\n                fill = 0;\n            }\n            max_fill\
    \ = max_fill.max(fill);\n        }\n    }\n    max_fill / capacity + max_fill\
    \ % capacity", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n   \
    \             fill += 1;\n            } else {\n                max_fill = max_fill.max(fill);\n\
    \                fill = 0;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill / capacity + (max_fill % capacity != 0) as isize", "    let\
    \ mut grid = grid;\n    let mut count = 0;\n    let mut max = 0;\n    for row\
    \ in grid.iter_mut() {\n        for cell in row.iter_mut() {\n            if *cell\
    \ > 0 {\n                *cell = 1;\n                count += 1;\n           \
    \ }\n        }\n    }\n    for row in grid.iter() {\n        for cell in row.iter()\
    \ {\n            max = max.max(*cell);\n        }\n    }\n    if max > capacity\
    \ {\n        return -1;\n    }\n    let mut result = 0;\n    while count > 0 {\n\
    \        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell > 0 {\n                    *cell -= 1;\n       \
    \             count -= 1;\n                }\n            }\n        }\n     \
    \   result += 1;\n    }\n    result", "    let mut count = 0;\n    let mut max_fill\
    \ = 0;\n    for row in grid {\n        for &cell in &row {\n            if cell\
    \ == 1 {\n                max_fill += 1;\n            }\n        }\n    }\n  \
    \  let mut fill = 0;\n    let mut row_idx = 0;\n    while fill < max_fill {\n\
    \        let row = &grid[row_idx];\n        let mut col_idx = 0;\n        while\
    \ col_idx < row.len() {\n            if row[col_idx] == 1 {\n                fill\
    \ += 1;\n                count += 1;\n                col_idx += capacity as usize;\n\
    \            } else {\n                col_idx += 1;\n            }\n        }\n\
    \        row_idx += 1;\n    }\n    count", "    let mut max = 0;\n    for row\
    \ in grid {\n        let mut sum = 0;\n        for &cell in &row {\n         \
    \   sum += cell;\n            if sum > capacity {\n                sum = capacity;\n\
    \            }\n        }\n        max = max.max(sum);\n    }\n    max", "   \
    \ let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n  \
    \      for &well in &row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            } else {\n                if fill > max_fill {\n           \
    \         max_fill = fill;\n                }\n                fill = 0;\n   \
    \         }\n        }\n        if fill > max_fill {\n            max_fill = fill;\n\
    \        }\n    }\n    max_fill / capacity + (max_fill % capacity != 0) as isize",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for &well in &row {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max_fill.max(fill);\n    }\n    max_fill", "    let mut grid\
    \ = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n    for row in\
    \ grid.iter_mut() {\n        let mut row_max = 0;\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                row_max += 1;\n            }\n\
    \        }\n        max_height = max(max_height, row_max);\n    }\n    for _ in\
    \ 0..max_height {\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell == 1 {\n                    *cell\
    \ = 0;\n                    count += 1;\n                }\n            }\n  \
    \      }\n    }\n    count", "    let mut max_fill = 0;\n    for row in grid {\n\
    \        let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for &well in &row {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max_fill.max(fill);\n    }\n    max_fill", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                fill += 1;\n           \
    \ } else {\n                fill = 0;\n            }\n            if fill > max_fill\
    \ {\n                max_fill = fill;\n            }\n        }\n    }\n    max_fill\
    \ / capacity + if max_fill % capacity == 0 { 0 } else { 1 }", "    let mut max\
    \ = 0;\n    for row in grid {\n        let mut sum = 0;\n        for &cell in\
    \ &row {\n            sum += cell;\n            if sum > capacity {\n        \
    \        sum = capacity;\n            }\n        }\n        max = max.max(sum);\n\
    \    }\n    max", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += fill;\n    }\n\
    \    max_fill", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                fill = capacity;\n            }\n\
    \        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill", "  \
    \  let mut grid = grid;\n    let mut count = 0;\n    let mut max_fill = 0;\n \
    \   let mut max_fill_index = 0;\n    for row in grid.iter_mut() {\n        let\
    \ mut fill = 0;\n        for (i, &cell) in row.iter().enumerate() {\n        \
    \    if cell == 1 {\n                fill += 1;\n            }\n            if\
    \ fill > max_fill {\n                max_fill = fill;\n                max_fill_index\
    \ = i;\n            }\n        }\n        if fill > 0 {\n            count +=\
    \ 1;\n            for i in 0..=max_fill_index {\n                row[i] = 0;\n\
    \            }\n        }\n        max_fill = 0;\n        max_fill_index = 0;\n\
    \    }\n    count", "    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            } else {\n                fill\
    \ = 0;\n            }\n            if fill > max_fill {\n                max_fill\
    \ = fill;\n            }\n        }\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize", "    let mut max_fill = 0;\n    let mut fill = 0;\n\
    \    for row in grid {\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += 1;\n      \
    \  fill = 0;\n    }\n    max_fill", "    let mut grid = grid;\n    let mut count\
    \ = 0;\n    let mut max = 0;\n    let mut max_index = 0;\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] > max {\n\
    \                max = grid[i][j];\n                max_index = j;\n         \
    \   }\n        }\n        if max > 0 {\n            count += 1;\n            for\
    \ j in 0..grid[i].len() {\n                grid[i][j] = grid[i][j].saturating_sub(capacity);\n\
    \            }\n            grid[i][max_index] = 0;\n            max = 0;\n  \
    \      }\n    }\n    count", "    let mut max_fill = 0;\n    for row in grid {\n\
    \        let mut fill = 0;\n        for &x in &row {\n            if x == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    if max_fill > capacity {\n        max_fill\
    \ - capacity\n    } else {\n        0\n    }", "    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut row = 0;\n    let mut col = 0;\n    let mut\
    \ max_row = grid.len();\n    let mut max_col = grid[0].len();\n    while row <\
    \ max_row {\n        while col < max_col {\n            if grid[row][col] == 1\
    \ {\n                count += 1;\n                let mut row_ = row;\n      \
    \          while row_ < max_row && grid[row_][col] == 1 {\n                  \
    \  grid[row_][col] = 0;\n                    row_ += 1;\n                }\n \
    \               let mut col_ = col;\n                while col_ < max_col && grid[row][col_]\
    \ == 1 {\n                    grid[row][col_] = 0;\n                    col_ +=\
    \ 1;\n                }\n            }\n            col += 1;\n        }\n   \
    \     col = 0;\n        row += 1;\n    }\n    count", "    let mut result = 0;\n\
    \    let mut max_height = 0;\n    for row in grid {\n        let mut height =\
    \ 0;\n        for &well in &row {\n            if well == 1 {\n              \
    \  height += 1;\n            } else {\n                max_height = max(max_height,\
    \ height);\n                height = 0;\n            }\n        }\n        max_height\
    \ = max(max_height, height);\n        if max_height > capacity {\n           \
    \ result += max_height - capacity;\n            max_height = capacity;\n     \
    \   }\n    }\n    result", "    let mut max_fill = 0;\n    for row in grid {\n\
    \        let mut fill = 0;\n        for &well in &row {\n            if well ==\
    \ 1 {\n                fill += 1;\n            } else {\n                fill\
    \ = 0;\n            }\n            if fill > max_fill {\n                max_fill\
    \ = fill;\n            }\n        }\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize", "    let mut result = 0;\n    let mut row_max =\
    \ vec![0; grid.len()];\n    for row in grid {\n        let mut max = 0;\n    \
    \    for &cell in &row {\n            max = std::cmp::max(max, cell);\n      \
    \  }\n        row_max.push(max);\n    }\n    for &max in &row_max {\n        result\
    \ += max / capacity;\n        if max % capacity != 0 {\n            result +=\
    \ 1;\n        }\n    }\n    result", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ fill += well;\n            if fill > capacity {\n                max_fill +=\
    \ 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += fill;\n    }\n    max_fill", "    let mut max = 0;\n    for row in grid {\n\
    \        let mut sum = 0;\n        for &cell in &row {\n            sum += cell;\n\
    \            if sum > capacity {\n                sum = capacity;\n          \
    \  }\n        }\n        max = max.max(sum);\n    }\n    max", "    let mut count\
    \ = 0;\n    let mut max_fill = 0;\n    for row in grid {\n        for &well in\
    \ &row {\n            if well == 1 {\n                max_fill += 1;\n       \
    \     }\n        }\n    }\n    let mut fill = 0;\n    while fill < max_fill {\n\
    \        for row in grid {\n            for &well in &row {\n                if\
    \ well == 1 {\n                    fill += 1;\n                    if fill ==\
    \ max_fill {\n                        return count;\n                    }\n \
    \               }\n            }\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut grid = grid;\n    let mut count = 0;\n    let mut max\
    \ = 0;\n    for row in grid.iter_mut() {\n        let mut row_max = 0;\n     \
    \   for cell in row.iter_mut() {\n            if *cell > 0 {\n               \
    \ *cell -= 1;\n                row_max += 1;\n                count += 1;\n  \
    \          }\n        }\n        max = max.max(row_max);\n    }\n    count + (max\
    \ + capacity - 1) / capacity", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            } else {\n                max_fill\
    \ = max_fill.max(fill);\n                fill = 0;\n            }\n        }\n\
    \        max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + if max_fill\
    \ % capacity == 0 { 0 } else { 1 }", "    let mut grid = grid;\n    let mut count\
    \ = 0;\n    let mut max_fill = 0;\n    let mut max_fill_index = 0;\n    for i\
    \ in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                count += 1;\n            }\n        }\n        if count\
    \ > max_fill {\n            max_fill = count;\n            max_fill_index = i;\n\
    \        }\n        count = 0;\n    }\n    for i in 0..grid.len() {\n        for\
    \ j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                count\
    \ += 1;\n            }\n        }\n        if count == max_fill {\n          \
    \  for j in 0..grid[i].len() {\n                if grid[i][j] == 1 {\n       \
    \             grid[i][j] = 0;\n                }\n            }\n        }\n \
    \       count = 0;\n    }\n    let mut count = 0;\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n \
    \               count += 1;\n            }\n        }\n    }\n    count", "  \
    \  let mut max_fill = 0;\n    let mut fill = 0;\n    for row in grid {\n     \
    \   for &well in &row {\n            fill += well;\n            if fill > capacity\
    \ {\n                max_fill += 1;\n                fill = well;\n          \
    \  }\n        }\n        max_fill += 1;\n        fill = 0;\n    }\n    max_fill",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for &well in &row {\n            if well == 1 {\n                fill\
    \ += 1;\n            } else {\n                if fill > max_fill {\n        \
    \            max_fill = fill;\n                }\n                fill = 0;\n\
    \            }\n        }\n        if fill > max_fill {\n            max_fill\
    \ = fill;\n        }\n    }\n    max_fill / capacity + (max_fill % capacity >\
    \ 0) as isize", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            fill += well;\n    \
    \        if fill == capacity {\n                max_fill += 1;\n             \
    \   fill = 0;\n            }\n        }\n        if fill > 0 {\n            max_fill\
    \ += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in &row {\n    \
    \        fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += fill;\n    }\n    max_fill", "    let mut count = 0;\n    let mut max_fill\
    \ = 0;\n    for row in grid {\n        for &well in &row {\n            if well\
    \ == 1 {\n                max_fill += 1;\n            }\n        }\n    }\n  \
    \  let mut fill = 0;\n    for row in grid {\n        for &well in &row {\n   \
    \         if well == 1 {\n                fill += 1;\n            }\n        \
    \    if fill == max_fill {\n                count += 1;\n                fill\
    \ = 0;\n            }\n        }\n        if fill > 0 {\n            count +=\
    \ 1;\n            fill = 0;\n        }\n    }\n    count", "    let mut max =\
    \ 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max = max.max(fill);\n\
    \    }\n    max", "    let mut result = 0;\n    let mut max_row = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in &row {\n     \
    \       sum += cell;\n        }\n        max_row = max(max_row, sum);\n    }\n\
    \    for row in grid {\n        let mut sum = 0;\n        for &cell in &row {\n\
    \            sum += cell;\n        }\n        result += max_row - sum;\n    }\n\
    \    result", "    let n = grid.len();\n    let m = grid[0].len();\n    let mut\
    \ result = 0;\n    let mut max_row = vec![0; m];\n    for i in 0..n {\n      \
    \  for j in 0..m {\n            max_row[j] = max(max_row[j], grid[i][j]);\n  \
    \      }\n    }\n    for i in 0..n {\n        for j in 0..m {\n            result\
    \ += max_row[j] - grid[i][j];\n        }\n    }\n    result / capacity + if result\
    \ % capacity == 0 { 0 } else { 1 }", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ fill += well;\n            if fill > capacity {\n                max_fill +=\
    \ 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += fill;\n    }\n    max_fill", "    let mut result = 0;\n    let mut row_max\
    \ = vec![0; grid.len()];\n    for row in grid {\n        let mut max = 0;\n  \
    \      for &cell in &row {\n            max = max.max(cell);\n        }\n    \
    \    row_max.push(max);\n    }\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for col in 0..grid[0].len() {\n        let mut max = 0;\n        for row\
    \ in &grid {\n            max = max.max(row[col]);\n        }\n        col_max.push(max);\n\
    \    }\n    for row in 0..grid.len() {\n        for col in 0..grid[0].len() {\n\
    \            let max = row_max[row].min(col_max[col]);\n            result +=\
    \ max - grid[row][col];\n        }\n    }\n    result", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            fill += well;\n            if fill > capacity {\n      \
    \          fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill", "    let mut grid = grid;\n    let mut count = 0;\n   \
    \ let mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut res = 0;\n    let mut max_height = 0;\n    for row in\
    \ grid {\n        let mut height = 0;\n        for &well in &row {\n         \
    \   if well == 1 {\n                height += 1;\n            } else {\n     \
    \           max_height = max(max_height, height);\n                height = 0;\n\
    \            }\n        }\n        max_height = max(max_height, height);\n   \
    \ }\n    for row in grid {\n        let mut height = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                height += 1;\n         \
    \   } else {\n                res += max(0, max_height - height);\n          \
    \      height = 0;\n            }\n        }\n        res += max(0, max_height\
    \ - height);\n    }\n    res", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            } else {\n                if\
    \ fill > max_fill {\n                    max_fill = fill;\n                }\n\
    \                fill = 0;\n            }\n        }\n        if fill > max_fill\
    \ {\n            max_fill = fill;\n        }\n    }\n    max_fill / capacity +\
    \ (max_fill % capacity != 0) as isize", "    let mut result = 0;\n    let mut\
    \ max_row = vec![0; grid[0].len()];\n    for row in grid {\n        for (i, &x)\
    \ in row.iter().enumerate() {\n            if x == 1 {\n                max_row[i]\
    \ += 1;\n            }\n        }\n    }\n    for &x in max_row.iter() {\n   \
    \     result += (x + capacity - 1) / capacity;\n    }\n    result", "    let mut\
    \ max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n        for\
    \ &well in &row {\n            fill += well;\n            if fill > capacity {\n\
    \                max_fill += 1;\n                fill = well;\n            }\n\
    \        }\n        max_fill += fill;\n    }\n    max_fill", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            fill += well;\n            if fill > capacity {\n      \
    \          max_fill += 1;\n                fill = well;\n            }\n     \
    \   }\n        max_fill += fill;\n    }\n    max_fill", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                fill += 1;\n           \
    \ } else {\n                max_fill = max_fill.max(fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max_fill.max(fill);\n   \
    \ }\n    max_fill / capacity + max_fill % capacity", "    let mut grid = grid;\n\
    \    let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut()\
    \ {\n        for cell in row.iter_mut() {\n            if *cell > 0 {\n      \
    \          *cell = capacity;\n                count += 1;\n            }\n   \
    \         max = max.max(*cell);\n        }\n    }\n    if max == 0 {\n       \
    \ return 0;\n    }\n    let mut i = 0;\n    while i < grid.len() {\n        let\
    \ mut j = 0;\n        while j < grid[i].len() {\n            if grid[i][j] ==\
    \ max {\n                grid[i][j] = 0;\n                let mut k = i + 1;\n\
    \                while k < grid.len() {\n                    if grid[k][j] > 0\
    \ {\n                        grid[k][j] -= 1;\n                    }\n       \
    \             k += 1;\n                }\n                count += 1;\n      \
    \      }\n            j += 1;\n        }\n        i += 1;\n    }\n    count",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut row = 0;\n    let\
    \ mut col = 0;\n    while row < grid.len() {\n        while col < grid[row].len()\
    \ {\n            if grid[row][col] == 1 {\n                let mut water = capacity;\n\
    \                while water > 0 && row < grid.len() {\n                    if\
    \ grid[row][col] == 1 {\n                        grid[row][col] = 0;\n       \
    \                 water -= 1;\n                    }\n                    row\
    \ += 1;\n                }\n                count += 1;\n                row -=\
    \ 1;\n            }\n            col += 1;\n        }\n        col = 0;\n    \
    \    row += 1;\n    }\n    count", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ if well == 1 {\n                fill += 1;\n            } else {\n         \
    \       fill = 0;\n            }\n            max_fill = max_fill.max(fill);\n\
    \        }\n    }\n    max_fill / capacity + (max_fill % capacity != 0) as isize",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for &well in &row {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max_fill.max(fill);\n    }\n    max_fill", "    let mut result\
    \ = 0;\n    let mut max_height = 0;\n    for row in grid {\n        let mut height\
    \ = 0;\n        for &cell in &row {\n            if cell == 1 {\n            \
    \    height += 1;\n            } else {\n                max_height = max(max_height,\
    \ height);\n                height = 0;\n            }\n        }\n        max_height\
    \ = max(max_height, height);\n        result += max_height;\n        if max_height\
    \ > capacity {\n            result += max_height - capacity;\n            max_height\
    \ = capacity;\n        }\n    }\n    result", "    let mut max_fill = 0;\n   \
    \ for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                fill += 1;\n            } else {\n\
    \                fill = 0;\n            }\n            if fill > max_fill {\n\
    \                max_fill = fill;\n            }\n        }\n    }\n    (max_fill\
    \ - 1) / capacity + 1", "    let mut max_fill = 0;\n    let mut max_fill_count\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ row.iter() {\n            fill += well;\n            if fill > capacity {\n\
    \                max_fill_count += 1;\n                fill = capacity;\n    \
    \        }\n        }\n        max_fill = max(max_fill, fill);\n    }\n    max_fill_count\
    \ + max_fill", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n   \
    \             fill += 1;\n            } else {\n                fill = 0;\n  \
    \          }\n            max_fill = max_fill.max(fill);\n        }\n    }\n \
    \   max_fill / capacity + max_fill % capacity", "    let mut max_fill = 0;\n \
    \   for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid {\n   \
    \     let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = well;\n            }\n        }\n   \
    \     max_fill += fill;\n    }\n    max_fill", "    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                fill += 1;\n            } else {\n\
    \                max_fill = max_fill.max(fill);\n                fill = 0;\n \
    \           }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\
    \ / capacity + (max_fill % capacity != 0) as isize", "    let mut water = 0;\n\
    \    let mut max_height = 0;\n    for row in grid {\n        for &cell in &row\
    \ {\n            water += cell;\n            max_height = max(max_height, cell);\n\
    \        }\n    }\n    let mut low = 0;\n    let mut high = max_height;\n    while\
    \ low < high {\n        let mid = low + (high - low) / 2;\n        let mut count\
    \ = 0;\n        for row in grid {\n            for &cell in &row {\n         \
    \       count += max(0, cell - mid);\n            }\n        }\n        if count\
    \ > capacity {\n            low = mid + 1;\n        } else {\n            high\
    \ = mid;\n        }\n    }\n    water - low * capacity", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                fill += 1;\n           \
    \ } else {\n                fill = 0;\n            }\n            max_fill = max_fill.max(fill);\n\
    \        }\n    }\n    max_fill / capacity + max_fill % capacity", "    let mut\
    \ max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n        for\
    \ &well in &row {\n            fill += well;\n            if fill > capacity {\n\
    \                fill = capacity;\n            }\n        }\n        max_fill\
    \ = max_fill.max(fill);\n    }\n    max_fill", "    let mut max = 0;\n    for\
    \ row in grid {\n        let mut curr = 0;\n        for &cell in &row {\n    \
    \        if cell == 1 {\n                curr += 1;\n            } else {\n  \
    \              max = max.max(curr);\n                curr = 0;\n            }\n\
    \        }\n        max = max.max(curr);\n    }\n    max / capacity + (max % capacity\
    \ != 0) as isize", "    let mut max_fill = 0;\n    for row in grid {\n       \
    \ let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = 0;\n            }\n        }\n      \
    \  if fill > 0 {\n            max_fill += 1;\n        }\n    }\n    max_fill",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_fill = 0;\n \
    \   for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                *cell = capacity;\n                count\
    \ += 1;\n            }\n        }\n    }\n    while count > 0 {\n        count\
    \ = 0;\n        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell > 0 {\n                    *cell -= 1;\n       \
    \             count += 1;\n                }\n            }\n        }\n     \
    \   max_fill += 1;\n    }\n    max_fill", "    let mut result = 0;\n    let mut\
    \ min_height = 0;\n    for row in grid {\n        let mut height = 0;\n      \
    \  for &cell in &row {\n            height += cell;\n        }\n        let fill\
    \ = min(height, capacity);\n        result += fill - min_height;\n        min_height\
    \ = fill;\n    }\n    result", "    let mut count = 0;\n    let mut max_row =\
    \ 0;\n    for row in grid {\n        let mut row_max = 0;\n        for &col in\
    \ &row {\n            if col > row_max {\n                row_max = col;\n   \
    \         }\n        }\n        if row_max > max_row {\n            max_row =\
    \ row_max;\n        }\n    }\n    for _ in 0..max_row {\n        for row in &grid\
    \ {\n            for &col in row {\n                if col > 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n        for\
    \ row in &mut grid {\n            for col in row {\n                if *col >\
    \ 0 {\n                    *col -= 1;\n                }\n            }\n    \
    \    }\n    }\n    count", "    let mut grid = grid;\n    let mut count = 0;\n\
    \    let mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    while count > 0 {\n        let mut\
    \ new_count = 0;\n        for row in grid.iter_mut() {\n            for cell in\
    \ row.iter_mut() {\n                if *cell > 0 {\n                    *cell\
    \ = 0;\n                    count -= 1;\n                } else if *cell == -1\
    \ {\n                    *cell = 1;\n                    new_count += 1;\n   \
    \             }\n            }\n        }\n        count += new_count;\n     \
    \   max += 1;\n        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell == 1 {\n                    if capacity > 0 {\n\
    \                        *cell = -1;\n                        capacity -= 1;\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n            }\n        }\n    }\n    max", "    let\
    \ mut max_fill = 0;\n    let mut total_fill = 0;\n    for row in grid {\n    \
    \    let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        total_fill += fill;\n \
    \   }\n    max_fill + (total_fill + capacity - 1) / capacity", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            fill += well;\n            if fill > capacity {\n      \
    \          fill = capacity;\n            }\n        }\n        max_fill = std::cmp::max(max_fill,\
    \ fill);\n    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            fill\
    \ += well;\n            if fill > capacity {\n                max_fill += 1;\n\
    \                fill = well;\n            }\n        }\n        max_fill += fill;\n\
    \    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid {\n   \
    \     let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n\
    \    for row in grid.iter_mut() {\n        let mut height = 0;\n        for cell\
    \ in row.iter_mut() {\n            if *cell == 1 {\n                height +=\
    \ 1;\n            } else {\n                height = 0;\n            }\n     \
    \       *cell = height;\n            max_height = max(max_height, height);\n \
    \       }\n    }\n    for height in 1..=max_height {\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell >= height\
    \ {\n                    *cell -= height;\n                    count += 1;\n \
    \               }\n            }\n        }\n    }\n    count", "    let mut result\
    \ = 0;\n    let mut max_row = vec![0; grid[0].len()];\n    for row in grid {\n\
    \        for (i, &v) in row.iter().enumerate() {\n            if v == 1 {\n  \
    \              max_row[i] += 1;\n            }\n        }\n    }\n    for &v in\
    \ max_row.iter() {\n        result += (v + capacity - 1) / capacity;\n    }\n\
    \    result", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in &row {\n            fill += well;\n        \
    \    if fill > capacity {\n                fill = capacity;\n            }\n \
    \       }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill", "   \
    \ let mut grid = grid;\n    let mut count = 0;\n    let mut max = 0;\n    for\
    \ row in grid.iter_mut() {\n        let mut sum = 0;\n        for cell in row.iter_mut()\
    \ {\n            sum += *cell;\n            *cell = 0;\n        }\n        if\
    \ sum > max {\n            max = sum;\n        }\n    }\n    for _ in 0..max {\n\
    \        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell < capacity {\n                    *cell += 1;\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut result = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        if v == 1 {\n                max_row[i] += 1;\n            }\n      \
    \  }\n    }\n    for &v in max_row.iter() {\n        result += v / capacity;\n\
    \        if v % capacity != 0 {\n            result += 1;\n        }\n    }\n\
    \    result", "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_height\
    \ = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n\
    \            if *cell == 1 {\n                *cell = capacity;\n            \
    \    max_height = capacity;\n            }\n        }\n    }\n    for row in grid.iter_mut()\
    \ {\n        for cell in row.iter_mut() {\n            if *cell > 0 {\n      \
    \          *cell -= 1;\n                count += 1;\n            }\n        }\n\
    \    }\n    count + max_height", "    let mut result = 0;\n    let mut max_height\
    \ = 0;\n    for row in grid {\n        let mut height = 0;\n        for &well\
    \ in &row {\n            if well == 1 {\n                height += 1;\n      \
    \      } else {\n                max_height = max(max_height, height);\n     \
    \           height = 0;\n            }\n        }\n        max_height = max(max_height,\
    \ height);\n        result += max_height;\n        max_height = max_height.saturating_sub(capacity);\n\
    \    }\n    result", "    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut row_max\
    \ = 0;\n        for col in row.iter_mut() {\n            if *col == 1 {\n    \
    \            row_max += 1;\n            }\n        }\n        max_height = max(max_height,\
    \ row_max);\n    }\n    for _ in 0..max_height {\n        let mut row_max = 0;\n\
    \        for row in grid.iter_mut() {\n            let mut col_max = 0;\n    \
    \        for col in row.iter_mut() {\n                if *col == 1 {\n       \
    \             col_max += 1;\n                }\n            }\n            row_max\
    \ = max(row_max, col_max);\n        }\n        for row in grid.iter_mut() {\n\
    \            for col in row.iter_mut() {\n                if *col == 1 {\n   \
    \                 *col = 0;\n                }\n            }\n        }\n   \
    \     for row in grid.iter_mut() {\n            for col in row.iter_mut() {\n\
    \                if *col == 0 {\n                    *col = 1;\n             \
    \   }\n            }\n        }\n        count += 1;\n    }\n    count", "   \
    \ let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n  \
    \      for &well in &row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            } else {\n                if fill > max_fill {\n           \
    \         max_fill = fill;\n                }\n                fill = 0;\n   \
    \         }\n        }\n        if fill > max_fill {\n            max_fill = fill;\n\
    \        }\n    }\n    max_fill / capacity + if max_fill % capacity == 0 { 0 }\
    \ else { 1 }", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                fill = capacity;\n            }\n\
    \        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill", "  \
    \  let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for &well in &row {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max_fill.max(fill);\n    }\n    max_fill", "    let mut count\
    \ = 0;\n    let mut max_fill = 0;\n    for row in grid {\n        for &well in\
    \ &row {\n            if well == 1 {\n                max_fill += 1;\n       \
    \     }\n        }\n    }\n    let mut fill = 0;\n    for row in grid {\n    \
    \    for &well in &row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            }\n            if fill == max_fill {\n                count\
    \ += 1;\n                fill = 0;\n            }\n        }\n        if fill\
    \ > 0 {\n            count += 1;\n            fill = 0;\n        }\n    }\n  \
    \  count", "    let mut count = 0;\n    let mut max_height = 0;\n    for row in\
    \ grid {\n        let mut height = 0;\n        for &well in &row {\n         \
    \   if well == 1 {\n                height += 1;\n            } else {\n     \
    \           height = 0;\n            }\n            max_height = max(max_height,\
    \ height);\n        }\n        count += max_height;\n        max_height = max(0,\
    \ max_height - capacity);\n    }\n    count", "    let mut max_fill = 0;\n   \
    \ for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill", "    let mut max_fill = 0;\n    let mut fill = 0;\n   \
    \ for row in grid {\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += 1;\n      \
    \  fill = 0;\n    }\n    max_fill", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ fill += well;\n            if fill > capacity {\n                fill = capacity;\n\
    \            }\n        }\n        max_fill = max_fill.max(fill);\n    }\n   \
    \ max_fill", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in &row {\n            fill += well;\n        \
    \    if fill == capacity {\n                max_fill += 1;\n                fill\
    \ = 0;\n            }\n        }\n        if fill > 0 {\n            max_fill\
    \ += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in &row {\n    \
    \        if well == 1 {\n                fill += 1;\n            } else {\n  \
    \              max_fill = max_fill.max(fill);\n                fill = 0;\n   \
    \         }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\
    \ / capacity + max_fill % capacity", "    let mut result = 0;\n    let mut well_max\
    \ = vec![0; grid[0].len()];\n    for row in grid {\n        for (i, &well) in\
    \ row.iter().enumerate() {\n            if well == 1 {\n                well_max[i]\
    \ += 1;\n            }\n        }\n    }\n    for &max in well_max.iter() {\n\
    \        result += (max + capacity - 1) / capacity;\n    }\n    result", "   \
    \ let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n  \
    \      for &well in &row {\n            fill += well;\n            if fill > capacity\
    \ {\n                fill = capacity;\n            }\n        }\n        max_fill\
    \ = max_fill.max(fill);\n    }\n    max_fill", "    let mut result = 0;\n    let\
    \ mut max_row = vec![0; grid[0].len()];\n    for row in grid {\n        for (i,\
    \ &v) in row.iter().enumerate() {\n            if v == 1 {\n                max_row[i]\
    \ += 1;\n            }\n        }\n    }\n    for &v in max_row.iter() {\n   \
    \     result += (v + capacity - 1) / capacity;\n    }\n    result", "    let mut\
    \ result = 0;\n    let mut max_height = 0;\n    for row in grid {\n        let\
    \ mut height = 0;\n        for &cell in &row {\n            if cell == 1 {\n \
    \               height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            max_height = max(max_height, height);\n        }\n\
    \        result += max_height;\n        max_height = max(0, max_height - capacity);\n\
    \    }\n    result", "    let mut max_fill = 0;\n    for row in grid {\n     \
    \   let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                fill += 1;\n            } else {\n\
    \                fill = 0;\n            }\n            if fill > max_fill {\n\
    \                max_fill = fill;\n            }\n        }\n    }\n    max_fill\
    \ / capacity + max_fill % capacity", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ if well == 1 {\n                fill += 1;\n            } else {\n         \
    \       if fill > max_fill {\n                    max_fill = fill;\n         \
    \       }\n                fill = 0;\n            }\n        }\n        if fill\
    \ > max_fill {\n            max_fill = fill;\n        }\n    }\n    (max_fill\
    \ + capacity - 1) / capacity", "    let mut max_fill = 0;\n    let mut max_fill_count\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &cell in\
    \ &row {\n            if cell == 1 {\n                fill += 1;\n           \
    \ } else {\n                if fill > max_fill {\n                    max_fill\
    \ = fill;\n                    max_fill_count = 1;\n                } else if\
    \ fill == max_fill {\n                    max_fill_count += 1;\n             \
    \   }\n                fill = 0;\n            }\n        }\n        if fill >\
    \ max_fill {\n            max_fill = fill;\n            max_fill_count = 1;\n\
    \        } else if fill == max_fill {\n            max_fill_count += 1;\n    \
    \    }\n    }\n    max_fill_count * capacity + max_fill - capacity", "    let\
    \ n = grid.len();\n    let m = grid[0].len();\n    let mut max_fill = 0;\n   \
    \ for i in 0..n {\n        let mut fill = 0;\n        for j in 0..m {\n      \
    \      if grid[i][j] == 1 {\n                fill += 1;\n            }\n     \
    \   }\n        max_fill = max_fill.max(fill);\n    }\n    let mut count = 0;\n\
    \    for i in 0..n {\n        let mut fill = 0;\n        for j in 0..m {\n   \
    \         if grid[i][j] == 1 {\n                fill += 1;\n            }\n  \
    \          if fill == max_fill {\n                count += 1;\n              \
    \  fill = 0;\n            }\n        }\n        if fill > 0 {\n            count\
    \ += 1;\n        }\n    }\n    count", "    let mut grid = grid;\n    let mut\
    \ count = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n    for row\
    \ in &grid {\n        for col in row {\n            if *col > max_col {\n    \
    \            max_col = *col;\n            }\n        }\n        if row.iter().sum::<isize>()\
    \ > max_row {\n            max_row = row.iter().sum::<isize>();\n        }\n \
    \   }\n    for i in 0..max_row {\n        for j in 0..max_col {\n            for\
    \ row in &mut grid {\n                if row[j] > 0 {\n                    row[j]\
    \ -= 1;\n                    count += 1;\n                }\n            }\n \
    \       }\n    }\n    count", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            } else {\n                if\
    \ fill > max_fill {\n                    max_fill = fill;\n                }\n\
    \                fill = 0;\n            }\n        }\n        if fill > max_fill\
    \ {\n            max_fill = fill;\n        }\n    }\n    max_fill / capacity +\
    \ (max_fill % capacity != 0) as isize", "    let mut max_fill = 0;\n    for row\
    \ in grid {\n        let mut fill = 0;\n        for &well in &row {\n        \
    \    if well == 1 {\n                fill += 1;\n            } else {\n      \
    \          if fill > max_fill {\n                    max_fill = fill;\n      \
    \          }\n                fill = 0;\n            }\n        }\n        if\
    \ fill > max_fill {\n            max_fill = fill;\n        }\n    }\n    max_fill\
    \ / capacity + max_fill % capacity", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ if well == 1 {\n                fill += 1;\n            } else {\n         \
    \       max_fill = max_fill.max(fill);\n                fill = 0;\n          \
    \  }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill /\
    \ capacity + if max_fill % capacity > 0 { 1 } else { 0 }", "    let mut grid =\
    \ grid;\n    let mut count = 0;\n    while !grid.iter().all(|row| row.iter().all(|&x|\
    \ x == 0)) {\n        for row in grid.iter_mut() {\n            for x in row.iter_mut()\
    \ {\n                if *x > 0 {\n                    *x -= capacity;\n      \
    \              if *x < 0 {\n                        *x = 0;\n                \
    \    }\n                }\n            }\n        }\n        count += 1;\n   \
    \ }\n    count", "    let mut grid = grid;\n    let mut count = 0;\n    let mut\
    \ max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n     \
    \   for cell in row.iter() {\n            max = max.max(*cell);\n        }\n \
    \   }\n    let mut min = count;\n    for i in 1..=max {\n        let mut c = 0;\n\
    \        for row in grid.iter() {\n            for cell in row.iter() {\n    \
    \            if *cell > 0 {\n                    c += 1;\n                }\n\
    \                if *cell > i {\n                    c += 1;\n               \
    \ }\n            }\n        }\n        min = min.min(c);\n    }\n    min", " \
    \   let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for &well in &row {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max_fill.max(fill);\n    }\n    max_fill", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                fill += 1;\n           \
    \ } else {\n                max_fill = max_fill.max(fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max_fill.max(fill);\n   \
    \ }\n    max_fill / capacity + (max_fill % capacity != 0) as isize", "    let\
    \ mut grid = grid;\n    let mut count = 0;\n    let n = grid.len();\n    let m\
    \ = grid[0].len();\n    for i in 0..n {\n        for j in 0..m {\n           \
    \ if grid[i][j] == 1 {\n                grid[i][j] = 0;\n                count\
    \ += 1;\n                let mut stack = vec![(i, j)];\n                while\
    \ let Some((i, j)) = stack.pop() {\n                    if i > 0 && grid[i - 1][j]\
    \ == 1 {\n                        grid[i - 1][j] = 0;\n                      \
    \  stack.push((i - 1, j));\n                    }\n                    if i <\
    \ n - 1 && grid[i + 1][j] == 1 {\n                        grid[i + 1][j] = 0;\n\
    \                        stack.push((i + 1, j));\n                    }\n    \
    \                if j > 0 && grid[i][j - 1] == 1 {\n                        grid[i][j\
    \ - 1] = 0;\n                        stack.push((i, j - 1));\n               \
    \     }\n                    if j < m - 1 && grid[i][j + 1] == 1 {\n         \
    \               grid[i][j + 1] = 0;\n                        stack.push((i, j\
    \ + 1));\n                    }\n                }\n            }\n        }\n\
    \    }\n    count * capacity", "    let mut max = 0;\n    for row in grid {\n\
    \        let mut sum = 0;\n        for &val in row.iter() {\n            sum +=\
    \ val;\n            if sum > capacity {\n                max += 1;\n         \
    \       sum = val;\n            }\n        }\n        max += sum;\n    }\n   \
    \ max", "    let mut max_fill = 0;\n    let mut fill = 0;\n    for row in grid\
    \ {\n        for &well in &row {\n            fill += well;\n            if fill\
    \ > capacity {\n                max_fill += fill - capacity;\n               \
    \ fill = capacity;\n            }\n        }\n        fill = 0;\n    }\n    max_fill",
  "    let mut max_fill = 0;\n    let mut fill = 0;\n    for row in grid {\n     \
    \   for &well in &row {\n            fill += well;\n            if fill > capacity\
    \ {\n                max_fill += 1;\n                fill = well;\n          \
    \  }\n        }\n        max_fill += 1;\n        fill = 0;\n    }\n    max_fill",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n\
    \    let mut max_height_index = 0;\n    for (i, row) in grid.iter().enumerate()\
    \ {\n        let height = row.iter().sum();\n        if height > max_height {\n\
    \            max_height = height;\n            max_height_index = i;\n       \
    \ }\n    }\n    let mut max_height = max_height;\n    while max_height > 0 {\n\
    \        let mut i = max_height_index;\n        while i < grid.len() && grid[i][0]\
    \ > 0 {\n            let mut j = 0;\n            while j < grid[i].len() && grid[i][j]\
    \ > 0 {\n                grid[i][j] -= 1;\n                j += 1;\n         \
    \   }\n            i += 1;\n        }\n        count += 1;\n        max_height\
    \ -= capacity;\n    }\n    count", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ fill += well;\n            if fill > capacity {\n                max_fill +=\
    \ 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += fill;\n    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            } else {\n                fill\
    \ = 0;\n            }\n            if fill > max_fill {\n                max_fill\
    \ = fill;\n            }\n        }\n    }\n    if max_fill == 0 {\n        return\
    \ 0;\n    }\n    let mut count = 0;\n    for row in grid {\n        let mut fill\
    \ = 0;\n        for &well in &row {\n            if well == 1 {\n            \
    \    fill += 1;\n            } else {\n                fill = 0;\n           \
    \ }\n            if fill == max_fill {\n                count += 1;\n        \
    \        fill = 0;\n            }\n        }\n    }\n    count", "    let mut\
    \ grid = grid;\n    let mut count = 0;\n    for row in grid.iter_mut() {\n   \
    \     for cell in row.iter_mut() {\n            if *cell > 0 {\n             \
    \   *cell -= capacity;\n                count += 1;\n            }\n        }\n\
    \    }\n    count", "    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill", "    let mut grid = grid;\n\
    \    let mut result = 0;\n    let mut row = 0;\n    while row < grid.len() {\n\
    \        let mut col = 0;\n        while col < grid[row].len() {\n           \
    \ if grid[row][col] == 1 {\n                let mut fill = capacity;\n       \
    \         while fill > 0 {\n                    if row == 0 {\n              \
    \          grid[row][col] = 0;\n                        fill -= 1;\n         \
    \           } else if grid[row - 1][col] == 1 {\n                        grid[row\
    \ - 1][col] = 0;\n                        fill -= 1;\n                    } else\
    \ {\n                        break;\n                    }\n                }\n\
    \                result += 1;\n            }\n            col += 1;\n        }\n\
    \        row += 1;\n    }\n    result", "    let mut max_fill = 0;\n    let mut\
    \ max_fill_count = 0;\n    for row in grid {\n        let mut fill = 0;\n    \
    \    for &cell in &row {\n            fill += cell;\n            if fill > capacity\
    \ {\n                max_fill = capacity;\n                max_fill_count += 1;\n\
    \                fill = 0;\n            }\n        }\n        if fill > max_fill\
    \ {\n            max_fill = fill;\n            max_fill_count += 1;\n        }\n\
    \    }\n    max_fill_count", "    let mut max_fill = 0;\n    let mut max_fill_row\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                fill += 1;\n           \
    \ }\n        }\n        if fill > max_fill {\n            max_fill = fill;\n \
    \           max_fill_row = 1;\n        } else if fill == max_fill {\n        \
    \    max_fill_row += 1;\n        }\n    }\n    let mut fill = 0;\n    for row\
    \ in grid {\n        for &well in &row {\n            if well == 1 {\n       \
    \         fill += 1;\n            }\n        }\n        if fill == max_fill {\n\
    \            max_fill_row -= 1;\n        }\n        if max_fill_row == 0 {\n \
    \           break;\n        }\n    }\n    if max_fill == 0 {\n        return 0;\n\
    \    }\n    let mut fill = 0;\n    let mut count = 0;\n    for row in grid {\n\
    \        for &well in &row {\n            if well == 1 {\n                fill\
    \ += 1;\n            }\n        }\n        if fill == max_fill {\n           \
    \ count += 1;\n        }\n        if fill > max_fill {\n            count += 1;\n\
    \            fill = 0;\n        }\n    }\n    count * capacity - max_fill", " \
    \   let mut max_fill = 0;\n    let mut max_fill_row = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in &row {\n            fill\
    \ += well;\n        }\n        if fill > max_fill {\n            max_fill = fill;\n\
    \            max_fill_row = 1;\n        } else if fill == max_fill {\n       \
    \     max_fill_row += 1;\n        }\n    }\n    max_fill * max_fill_row", "  \
    \  let mut grid = grid;\n    let mut result = 0;\n    let mut row = 0;\n    let\
    \ mut col = 0;\n    while row < grid.len() {\n        if grid[row][col] == 1 {\n\
    \            grid[row][col] = 0;\n            result += 1;\n        }\n      \
    \  if col == grid[row].len() - 1 {\n            row += 1;\n            col = 0;\n\
    \        } else {\n            col += 1;\n        }\n    }\n    result", "   \
    \ let mut fill = 0;\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  for &well in &row {\n            fill += well;\n            if fill > capacity\
    \ {\n                max_fill += fill - capacity;\n                fill = capacity;\n\
    \            }\n        }\n        fill = 0;\n    }\n    max_fill", "    let mut\
    \ grid = grid;\n    let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut()\
    \ {\n        max = 0;\n        for cell in row.iter_mut() {\n            if *cell\
    \ == 1 {\n                *cell = 0;\n                count += 1;\n          \
    \  }\n            max = max.max(*cell);\n        }\n        count += max;\n  \
    \  }\n    count", "    let mut max_fill = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in &row {\n            fill += well;\n    \
    \        if fill == capacity {\n                max_fill += 1;\n             \
    \   fill = 0;\n            }\n        }\n        if fill > 0 {\n            max_fill\
    \ += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in &row {\n    \
    \        if well == 1 {\n                fill += 1;\n            } else {\n  \
    \              max_fill = max_fill.max(fill);\n                fill = 0;\n   \
    \         }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\
    \ / capacity + (max_fill % capacity != 0) as isize", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill", "    let mut grid = grid;\n    let mut count = 0;\n   \
    \ let mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = capacity;\n         \
    \       count += 1;\n            }\n            max = max.max(*cell);\n      \
    \  }\n    }\n    if max == 0 {\n        return 0;\n    }\n    let mut total =\
    \ 0;\n    while total < count {\n        total = 0;\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell > 0 {\n\
    \                    *cell -= 1;\n                    total += 1;\n          \
    \      }\n            }\n        }\n    }\n    count", "    let mut grid = grid;\n\
    \    let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut height = 0;\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                height += 1;\n            } else {\n\
    \                height = 0;\n            }\n            *cell = height;\n   \
    \         max_height = max(max_height, height);\n        }\n    }\n    for height\
    \ in 1..=max_height {\n        for row in grid.iter_mut() {\n            let mut\
    \ filled = 0;\n            for cell in row.iter_mut() {\n                if *cell\
    \ >= height {\n                    filled += 1;\n                } else {\n  \
    \                  filled = 0;\n                }\n                if filled ==\
    \ capacity {\n                    count += 1;\n                    filled = 0;\n\
    \                }\n            }\n        }\n    }\n    count", "    let mut\
    \ max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n        for\
    \ &well in &row {\n            if well == 1 {\n                fill += 1;\n  \
    \          } else {\n                fill = 0;\n            }\n            if\
    \ fill > max_fill {\n                max_fill = fill;\n            }\n       \
    \ }\n    }\n    max_fill / capacity + (max_fill % capacity != 0) as isize", " \
    \   let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for &well in &row {\n            if well == 1 {\n                fill\
    \ += 1;\n            } else {\n                fill = 0;\n            }\n    \
    \        if fill > max_fill {\n                max_fill = fill;\n            }\n\
    \        }\n    }\n    max_fill / capacity + max_fill % capacity", "    let mut\
    \ grid = grid;\n    let mut count = 0;\n    let mut i = 0;\n    while i < grid.len()\
    \ {\n        let mut j = 0;\n        while j < grid[i].len() {\n            if\
    \ grid[i][j] == 1 {\n                count += 1;\n                let mut k =\
    \ 0;\n                while k < grid.len() {\n                    let mut l =\
    \ 0;\n                    while l < grid[k].len() {\n                        if\
    \ grid[k][l] == 1 {\n                            grid[k][l] = 0;\n           \
    \                 if capacity == 1 {\n                                break;\n\
    \                            }\n                            capacity -= 1;\n \
    \                       }\n                        l += 1;\n                 \
    \   }\n                    k += 1;\n                }\n            }\n       \
    \     j += 1;\n        }\n        i += 1;\n    }\n    count", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                fill += 1;\n           \
    \ } else {\n                if fill > max_fill {\n                    max_fill\
    \ = fill;\n                }\n                fill = 0;\n            }\n     \
    \   }\n        if fill > max_fill {\n            max_fill = fill;\n        }\n\
    \    }\n    (max_fill + capacity - 1) / capacity", "    let mut result = 0;\n\
    \    let mut wells = grid;\n    let mut max_height = 0;\n    for well in wells.iter()\
    \ {\n        let height = well.iter().sum();\n        if height > max_height {\n\
    \            max_height = height;\n        }\n    }\n    for height in 0..max_height\
    \ {\n        for well in wells.iter_mut() {\n            for unit in well.iter_mut()\
    \ {\n                if *unit > 0 {\n                    *unit -= 1;\n       \
    \             result += 1;\n                }\n            }\n        }\n    }\n\
    \    result", "    let mut result = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        max_row[i] = max_row[i].max(v);\n        }\n    }\n    for row in grid\
    \ {\n        for (i, &v) in row.iter().enumerate() {\n            if v > 0 {\n\
    \                let fill = max_row[i].min(capacity);\n                max_row[i]\
    \ -= fill;\n                result += fill;\n            }\n        }\n    }\n\
    \    result", "    let mut result = 0;\n    let mut max_height = 0;\n    for row\
    \ in grid {\n        let mut height = 0;\n        for &cell in &row {\n      \
    \      if cell == 1 {\n                height += 1;\n            } else {\n  \
    \              max_height = max(max_height, height);\n                height =\
    \ 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \        result += max_height;\n        max_height = max_height.saturating_sub(capacity);\n\
    \    }\n    result", "    let mut max_fill = 0;\n    for row in grid {\n     \
    \   let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill", "    let mut max_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                fill += 1;\n            } else {\n\
    \                max_fill = max_fill.max(fill);\n                fill = 0;\n \
    \           }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\
    \ / capacity + max_fill % capacity", "    let mut max_fill = 0;\n    for row in\
    \ grid {\n        let mut fill = 0;\n        for &well in &row {\n           \
    \ if well == 1 {\n                fill += 1;\n            } else {\n         \
    \       max_fill = max_fill.max(fill);\n                fill = 0;\n          \
    \  }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill /\
    \ capacity + if max_fill % capacity == 0 { 0 } else { 1 }", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            fill += well;\n            if fill > capacity {\n      \
    \          fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid {\n   \
    \     let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill",
  "    let mut max_fill = 0;\n    let mut fill = 0;\n    for row in grid {\n     \
    \   for &well in &row {\n            fill += well;\n            if fill > capacity\
    \ {\n                max_fill += 1;\n                fill = well;\n          \
    \  }\n        }\n        max_fill += 1;\n        fill = 0;\n    }\n    max_fill",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max = 0;\n    for\
    \ row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n           \
    \ if *cell > 0 {\n                *cell = 1;\n                count += 1;\n  \
    \          }\n        }\n    }\n    for row in grid.iter() {\n        for cell\
    \ in row.iter() {\n            max = max.max(*cell);\n        }\n    }\n    if\
    \ max == 0 {\n        return 0;\n    }\n    let mut sum = 0;\n    for row in grid.iter()\
    \ {\n        for cell in row.iter() {\n            sum += cell;\n        }\n \
    \   }\n    let mut result = 0;\n    let mut i = 0;\n    while sum > 0 {\n    \
    \    let mut j = 0;\n        while j < grid.len() {\n            if grid[j][i]\
    \ > 0 {\n                sum -= 1;\n                grid[j][i] -= 1;\n       \
    \     }\n            j += 1;\n        }\n        result += 1;\n        i += 1;\n\
    \    }\n    result", "    let mut max_fill = 0;\n    for row in grid {\n     \
    \   let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    (max_fill + capacity - 1) / capacity", " \
    \   let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for &well in &row {\n            if well == 1 {\n                fill\
    \ += 1;\n            } else {\n                max_fill = max_fill.max(fill);\n\
    \                fill = 0;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill / capacity + max_fill % capacity", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ &row {\n            if well == 1 {\n                fill += 1;\n           \
    \ } else {\n                max_fill = max_fill.max(fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max_fill.max(fill);\n   \
    \ }\n    max_fill / capacity + (max_fill % capacity != 0) as isize", "    let\
    \ mut grid = grid;\n    let mut count = 0;\n    let mut max = 0;\n    for row\
    \ in grid.iter_mut() {\n        for cell in row.iter_mut() {\n            if *cell\
    \ > 0 {\n                *cell = 1;\n                count += 1;\n           \
    \ }\n        }\n    }\n    if count == 0 {\n        return 0;\n    }\n    for\
    \ row in grid.iter() {\n        for cell in row.iter() {\n            if *cell\
    \ > 0 {\n                max = max.max(*cell);\n            }\n        }\n   \
    \ }\n    let mut result = 0;\n    while max > 0 {\n        let mut count = 0;\n\
    \        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell == max {\n                    *cell = 0;\n     \
    \               count += 1;\n                }\n            }\n        }\n   \
    \     result += count / capacity;\n        if count % capacity > 0 {\n       \
    \     result += 1;\n        }\n        max -= 1;\n    }\n    result", "    let\
    \ mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n      \
    \  for &well in &row {\n            fill += well;\n            if fill == capacity\
    \ {\n                max_fill += 1;\n                fill = 0;\n            }\n\
    \        }\n        if fill > 0 {\n            max_fill += 1;\n        }\n   \
    \ }\n    max_fill"]
stop_tokens:
- "\n}"
