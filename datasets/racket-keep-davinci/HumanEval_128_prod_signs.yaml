name: HumanEval_128_prod_signs
language: racket
prompt: "#lang racket\n\n;; You are given an array arr of integers and you need to\
  \ return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
  ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
  \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>> prod_signs([0,\
  \ 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
  \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
  \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n   \
  \ (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 2 4\
  \ 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal?\
  \ (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0))\
  \ 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n       (let ([magnitudes\
    \ (map abs arr)])\n         (let ([sign-prod (apply * signs)])\n           (let\
    \ ([mag-sum (apply + magnitudes)])\n             (* sign-prod mag-sum)))))]))\n",
  "  (cond [(empty? arr) (error \"Empty array\")]\n        [else\n         (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n           (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1\
    \ 1))) arr)])\n       (apply * (map abs arr))\n       (apply * signs))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map\
    \ abs arr))))]))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n\
    \       (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n\
    \      'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0)\
    \ 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (cond\n    [(empty? arr) (error \"empty arr\")]\n    [(every?\
    \ zero? arr) 0]\n    [else\n     (apply * (map sign arr))\n     (* (apply * (map\
    \ sign arr))\n        (apply + (map abs arr)))]))\n", "  (if (null? arr)\n   \
    \   #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * signs)\n        (apply + (map abs arr)))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x)\n                          (if (zero? x)\n                             \
    \ 0\n                              (if (positive? x)\n                       \
    \           1\n                                  -1)))\n                     \
    \   arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", " \
    \ (if (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs\
    \ arr))))))\n", "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum\
    \ 0] [prod 1])\n        (if (null? arr)\n            (* sum prod)\n          \
    \  (let ([x (car arr)])\n              (loop (cdr arr) (+ sum (abs x)) (* prod\
    \ (if (zero? x) 0 (if (> x 0) 1 -1)))))))))\n", "  (if (null? arr)\n      #f\n\
    \      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1)))\
    \ arr)]\n             [magnitudes (map abs arr)])\n        (apply * signs)\n \
    \       (apply + magnitudes))))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n\
    \     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \       (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n\
    \      'None\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (negative? x)\
    \ -1 1))) arr))\n      (apply + (map abs arr))))\n", "  (if (null? arr)\n    \
    \  #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n        (apply *\
    \ signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n      #f\n \
    \     (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))))\n",
  "  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply + (map abs arr)))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if\
    \ (positive? x) 1 -1)) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      'None\n      (let* ([magnitudes (map abs arr)]\n     \
    \        [signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n \
    \            [magnitude-sum (apply + magnitudes)]\n             [sign-prod (apply\
    \ * signs)])\n        (* magnitude-sum sign-prod))))\n", "  (if (null? arr)\n\
    \      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n        (if (null?\
    \ arr)\n            (* sum prod)\n            (let ([x (car arr)])\n         \
    \     (cond\n                [(positive? x) (loop (cdr arr) (+ sum x) prod)]\n\
    \                [(negative? x) (loop (cdr arr) (+ sum (- x)) (* prod -1))]\n\
    \                [else (loop (cdr arr) sum prod)]))))))\n", "  (if (empty? arr)\n\
    \      'None\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x)\
    \ 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (if (null? arr)\n    \
    \  'None\n      (let ([signs (map (lambda (x)\n                          (if (=\
    \ x 0)\n                              0\n                              (if (>\
    \ x 0)\n                                  1\n                                \
    \  -1)))\n                        arr)])\n        (let ([magnitudes (map abs arr)])\n\
    \          (let ([sign-prod (apply * signs)])\n            (let ([mag-sum (apply\
    \ + magnitudes)])\n              (* sign-prod mag-sum)))))))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [else\n     (let* ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n            [magnitudes (map abs arr)])\n  \
    \     (apply * signs)\n       (apply + magnitudes))]))\n", "  (cond [(empty? arr)\
    \ 'None]\n        [else\n         (apply *\n                (map (lambda (x)\n\
    \                       (cond [(zero? x) 0]\n                             [(positive?\
    \ x) 1]\n                             [else -1]))\n                     arr))]))\n",
  "  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (= x 0) 0 (if\
    \ (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (if (null? arr)\n\
    \      #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)]\n             [prod (apply * signs)]\n             [mags (map abs\
    \ arr)])\n        (apply + (map * mags signs)))))\n", "  (if (null? arr)\n   \
    \   'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * signs)\n        (apply + (map abs arr)))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n      (let ([signs\
    \ (map (lambda (x)\n                          (if (zero? x)\n                \
    \              0\n                              (if (negative? x)\n          \
    \                        -1\n                                  1)))\n        \
    \                arr)])\n        (let ([magnitudes (map abs arr)])\n         \
    \ (apply * (map * signs magnitudes))))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ((signs (map (lambda (x)\n                          (if (zero? x)\n\
    \                              0\n                              (if (positive?\
    \ x)\n                                  1\n                                  -1)))\n\
    \                        arr)))\n        (* (apply * signs)\n           (apply\
    \ + (map abs arr))))))\n", "  (cond\n    [(empty? arr) (error \"empty arr\")]\n\
    \    [(empty? (rest arr)) (abs (first arr))]\n    [else\n     (* (signum (first\
    \ arr))\n        (abs (first arr))\n        (prod_signs (rest arr)))]))\n", " \
    \ (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply + (map\
    \ abs arr)))))\n", "  (cond [(empty? arr) 'None]\n        [else\n         (apply\
    \ *\n                (map (lambda (x)\n                       (cond [(zero? x)\
    \ 0]\n                             [(negative? x) -1]\n                      \
    \       [else 1]))\n                     arr))]))\n", "  (if (null? arr)\n   \
    \   'None\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\
    \ [(empty? arr) 'None]\n        [else\n         (let ([magnitudes (map abs arr)])\n\
    \           (apply * (map signum arr))\n           (apply + magnitudes))]))\n",
  "  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (= x 0) 0 (if\
    \ (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (if (null? arr)\n\
    \      #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1\
    \ 1))) arr)]\n             [magnitudes (map abs arr)])\n        (apply * signs)\n\
    \        (apply + magnitudes))))\n", "  (cond [(empty? arr) 'None]\n        [else\n\
    \         (let ([signs (map abs arr)])\n           (apply * (map signum arr))\n\
    \           (apply + signs))]))\n", "  (if (null? arr)\n      'None\n      (let*\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n       \
    \      [magnitudes (map abs arr)])\n        (apply * signs)\n        (apply +\
    \ magnitudes))))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0)\
    \ 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (if (null? arr)\n    \
    \  'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr)))\n        (* (apply * signs) (apply + (map abs arr))))))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (if (null? arr)\n      'None\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply\
    \ * signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n \
    \     (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr))\n    \
    \  (apply + (map abs arr))))\n", "  (if (null? arr)\n      #f\n      (let ((signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      #f\n\
    \      (let loop ([arr arr] [sum 0] [prod 1])\n        (if (null? arr)\n     \
    \       (* sum prod)\n            (let ([x (car arr)])\n              (if (= x\
    \ 0)\n                  (* sum prod)\n                  (loop (cdr arr) (+ sum\
    \ (abs x)) (* prod (if (> x 0) 1 -1)))))))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null?\
    \ arr)\n      'None\n      (apply * (map sign arr))\n      (apply + (map abs arr))))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs\
    \ arr))))))\n", "  (if (empty? arr)\n      'None\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n",
  "  (cond [(empty? arr) (error \"empty array\")]\n        [else\n         (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n", "  (if (empty? arr)\n      'None\n\
    \      (apply * (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr))\n \
    \     (apply + (map abs arr))))\n", "  (cond\n    [(empty? arr) (error \"Empty\
    \ array\")]\n    [(empty? (cdr arr)) (car arr)]\n    [else\n     (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n", "  (cond\n    [(empty? arr) 'None]\n\
    \    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n", "  (cond\
    \ [(empty? arr) 'None]\n        [else (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr))]))\n", "  (if (null? arr)\n      'None\n      (let\
    \ loop ([arr arr] [sum 0] [prod 1])\n        (if (null? arr)\n            (* sum\
    \ prod)\n            (loop (cdr arr) (+ sum (abs (car arr))) (* prod (signum (car\
    \ arr))))))))\n", "  (if (null? arr)\n      'None\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs\
    \ arr))))\n", "  (cond\n    [(empty? arr) (error \"Empty array\")]\n    [(empty?\
    \ (rest arr)) (abs (first arr))]\n    [else\n     (* (abs (first arr))\n     \
    \   (prod_signs (rest arr)))]))\n", "  (if (null? arr)\n      'None\n      (let\
    \ ([signs (map (lambda (x)\n                          (if (zero? x)\n        \
    \                      0\n                              (if (positive? x)\n  \
    \                                1\n                                  -1)))\n\
    \                        arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes\
    \ (map abs arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n",
  "  (cond\n    [(empty? arr) (error \"empty arr\")]\n    [(empty? (rest arr)) (abs\
    \ (first arr))]\n    [else\n     (* (abs (first arr))\n        (prod_signs (rest\
    \ arr)))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x)\n                          (if (zero? x)\n                             \
    \ 0\n                              (if (negative? x)\n                       \
    \           -1\n                                  1)))\n                     \
    \   arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", " \
    \ (if (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      'None\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs\
    \ arr))))\n", "  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda\
    \ (x)\n                           (if (zero? x)\n                            \
    \   0\n                               (if (negative? x)\n                    \
    \               -1\n                                   1)))\n                \
    \         arr)]\n             [magnitudes (map abs arr)])\n        (apply * signs)\n\
    \        (apply + magnitudes))))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n      \
    \  (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (empty? arr)\n\
    \      (error \"Empty array\")\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      'None\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs\
    \ arr))))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n     (let*\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n       \
    \     [prod (apply * signs)]\n            [mags (map abs arr)])\n       (apply\
    \ + (map * mags signs)))]))\n", "  (cond\n    [(empty? arr) (error \"empty array\"\
    )]\n    [(= (length arr) 1) (abs (first arr))]\n    [else\n     (let ([signs (map\
    \ (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n", "  (if (null? arr)\n      'None\n      (let\
    \ ([signs (map (lambda (x)\n                          (if (zero? x)\n        \
    \                      0\n                              (if (positive? x)\n  \
    \                                1\n                                  -1)))\n\
    \                        arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes (map\
    \ abs arr)])\n        (apply * (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      'None\n      (apply * (map (lambda (x)\n             \
    \         (if (zero? x)\n                          0\n                       \
    \   (if (positive? x)\n                              1\n                     \
    \         -1)))\n                    arr))))\n", "  (if (null? arr)\n      'None\n\
    \      (apply * (map (lambda (x)\n                      (if (zero? x)\n      \
    \                    0\n                          (if (positive? x)\n        \
    \                      1\n                              -1)))\n              \
    \      arr))))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n", " \
    \ (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x)\n        \
    \                  (if (zero? x)\n                              0\n          \
    \                    (if (negative? x)\n                                  -1\n\
    \                                  1)))\n                        arr)])\n    \
    \    (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n    [(empty?\
    \ arr) (error \"Empty array\")]\n    [(every? zero? arr) 0]\n    [else\n     (apply\
    \ * (map sign arr))\n     (* (apply * (map sign arr))\n        (apply + (map abs\
    \ arr)))]))\n", "  (if (empty? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x) (cond [(> x 0) 1] [(< x 0) -1] [else 0])) arr)])\n        (* (apply * signs)\
    \ (apply + (map abs arr))))))\n", "  (cond [(empty? arr) 'None]\n        [else\
    \ (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))]))\n",
  "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n\
    \        (if (null? arr)\n            (* sum prod)\n            (loop (cdr arr)\
    \ (+ sum (abs (car arr))) (* prod (signum (car arr))))))))\n", "  (if (empty?\
    \ arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n        (*\
    \ (apply * signs) (apply + magnitudes)))))\n", "  (cond [(empty? arr) #f]\n  \
    \      [else\n         (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n\
    \        (if (null? arr)\n            (* sum prod)\n            (let ([n (car\
    \ arr)])\n              (cond [(> n 0) (loop (cdr arr) (+ sum n) prod)]\n    \
    \                [(= n 0) (loop (cdr arr) sum 0)]\n                    [(< n 0)\
    \ (loop (cdr arr) (+ sum (- n)) (* prod -1))]))))))\n", "  (if (null? arr)\n \
    \     'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n", " \
    \ (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr)))\n        (apply * (map abs arr))\n      \
    \  (apply * signs))))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n     (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \ (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n   \
    \   'None\n      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n",
  "  (if (null? arr)\n      (error \"empty array\")\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n", "  (if (empty? arr)\n      'None\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (if (empty? arr)\n     \
    \ 'None\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n\
    \      (apply + (map abs arr))))\n", "  (if (null? arr)\n      'None\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \  (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (empty? arr)\n\
    \      (error \"empty array\")\n      (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr))))\n", "  (if (null? arr)\n      'None\n  \
    \    (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n\
    \             [magnitudes (map abs arr)])\n        (apply * signs)\n        (apply\
    \ + magnitudes))))\n", "  (if (null? arr)\n      (void)\n      (let* ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes\
    \ (map abs arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (< x 0) -1 1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      #f\n      (let loop ([arr arr] [acc\
    \ 0])\n        (if (null? arr)\n            acc\n            (loop (cdr arr) (+\
    \ (* (abs (car arr)) (signum (car arr))) acc))))))\n", "  (if (null? arr)\n  \
    \    'None\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)))\n        (* (apply * signs) (apply + (map abs arr))))))\n", " \
    \ (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n", "  (if (null? arr)\n      'None\n      (apply\
    \ * (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\n      (apply\
    \ + (map abs arr))))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply *\
    \ signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n   \
    \   (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n", "  (if\
    \ (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n     (let* ([signs\
    \ (map (lambda (x)\n                          (cond\n                        \
    \    [(zero? x) 0]\n                            [(negative? x) -1]\n         \
    \                   [else 1]))\n                        arr)]\n            [sign-prod\
    \ (apply * signs)]\n            [magnitudes (map abs arr)])\n       (apply + (map\
    \ * magnitudes signs)))]))\n", "  (cond [(empty? arr) 'None]\n        [else (apply\
    \ * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))]))\n", "  (if (null?\
    \ arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply + (map\
    \ abs arr)))))\n", "  (if (null? arr)\n      (void)\n      (let* ([magnitudes\
    \ (map abs arr)]\n             [signs (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr)]\n             [magnitude-sum (apply + magnitudes)]\n      \
    \       [sign-prod (apply * signs)])\n        (* magnitude-sum sign-prod))))\n",
  "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n                [magnitudes (map\
    \ abs arr)])\n           (apply * signs)\n           (apply + magnitudes))]))\n",
  "  (if (null? arr)\n      #f\n      (let loop ([arr arr] [sum 0] [prod 1])\n   \
    \     (if (null? arr)\n            (* sum prod)\n            (let ([x (car arr)])\n\
    \              (loop (cdr arr) (+ sum (abs x)) (* prod (if (zero? x) 1 (if (positive?\
    \ x) 1 -1)))))))))\n", "  (if (empty? arr)\n      'None\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map\
    \ abs arr))))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply *\
    \ signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n   \
    \   (apply * (map sign arr))\n      (apply + (map abs arr))))\n", "  (if (empty?\
    \ arr)\n      'None\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (cond [(empty? arr)\
    \ 'None]\n        [else\n         (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs\
    \ (map sign arr)]\n                [magnitudes (map abs arr)]\n              \
    \  [prod (apply * signs)]\n                [sum (apply + magnitudes)])\n     \
    \      (* prod sum))]))\n", "  (if (null? arr)\n      'None\n      (apply * (map\
    \ (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs\
    \ arr))))\n", "  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs arr))))\n",
  "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (positive? x) 1 -1))) arr)]\n                [magnitudes\
    \ (map abs arr)])\n           (* (apply * signs) (apply + magnitudes)))]))\n",
  "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n\
    \      'None\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x)\
    \ 1 -1))) arr))))\n", "  (if (null? arr)\n      'None\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs\
    \ arr))))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n", "  (cond\n    [(empty? arr) (error\
    \ \"Empty array\")]\n    [(empty? (rest arr)) (abs (first arr))]\n    [else\n\
    \     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1)))\
    \ arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null?\
    \ arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n        (apply\
    \ * signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n      'none\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n", "  (if (empty? arr)\n      (error \"empty arr\")\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ([prod (apply * (map (lambda (x) (if (zero? x) 0\
    \ (if (> x 0) 1 -1))) arr))])\n        (apply + (map (lambda (x) (abs x)) arr))\n\
    \        (* prod (apply + (map (lambda (x) (abs x)) arr))))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (< x 0) -1 1))) arr)]\n             [magnitudes (map abs arr)])\n \
    \       (apply * signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([sums (apply + (map abs arr))]\n            [prods (apply\
    \ * (map signum arr))])\n        (* sums prods))))\n", "  (cond [(empty? arr)\
    \ 'None]\n        [else\n         (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum\
    \ 0] [prod 1])\n        (if (null? arr)\n            (* sum prod)\n          \
    \  (loop (cdr arr) (+ sum (abs (car arr))) (* prod (signum (car arr))))))))\n",
  "  (cond [(empty? arr) #f]\n        [else\n         (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map\
    \ abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      'None\n\
    \      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n\
    \             [sign-prod (apply * signs)]\n             [magnitudes (map abs arr)])\n\
    \        (apply + (map * magnitudes signs)))))\n", "  (cond [(empty? arr) 'None]\n\
    \        [else (apply * (map (lambda (x) (cond [(positive? x) 1]\n           \
    \                                   [(negative? x) -1]\n                     \
    \                         [else 0]))\n                            arr))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n",
  "  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n             [prod (apply * signs)]\n      \
    \       [magnitudes (map abs arr)])\n        (apply + (map * magnitudes signs)))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map abs arr)])\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      'None\n      (let ([sum (apply + (map\
    \ abs arr))]\n            [prod (apply * (map sign arr))])\n        (* sum prod))))\n",
  "  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n \
    \       (apply * signs)\n        (apply + magnitudes))))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (positive? x) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n\
    \        (cond [(null? arr) (* sum prod)]\n              [(zero? (car arr)) (loop\
    \ (cdr arr) sum prod)]\n              [(negative? (car arr)) (loop (cdr arr) (+\
    \ sum (abs (car arr))) (* prod -1))]\n              [else (loop (cdr arr) (+ sum\
    \ (abs (car arr))) prod)]))))\n", "  (if (null? arr)\n      'None\n      (let*\
    \ ([magnitudes (map abs arr)]\n             [signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitude-sum (apply + magnitudes)]\n\
    \             [sign-prod (apply * signs)])\n        (* magnitude-sum sign-prod))))\n",
  "  (cond [(empty? arr) #f]\n        [else (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (negative? x) -1 1))) arr))]))\n", "  (if (null? arr)\n      'None\n \
    \     (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr))\n    \
    \  (apply + (map abs arr))))\n", "  (if (null? arr)\n      #f\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * signs)\n        (apply + (map abs arr)))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([sums (map abs arr)])\n        (apply * (map\
    \ (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\n        (apply\
    \ + sums))))\n", "  (if (null? arr)\n      'None\n      (let ((signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply\
    \ * signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n \
    \     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let loop ([arr arr] [prod 1] [sum 0])\n        (if\
    \ (null? arr)\n            (* prod sum)\n            (let ([x (car arr)])\n  \
    \            (cond\n                [(> x 0) (loop (cdr arr) (* prod 1) (+ sum\
    \ x))]\n                [(< x 0) (loop (cdr arr) (* prod -1) (+ sum (- x)))]\n\
    \                [else (loop (cdr arr) prod sum)]))))))\n", "  (if (null? arr)\n\
    \      'None\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x)\
    \ 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (cond\n    [(empty? arr)\
    \ 'None]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)))\n        (* (apply * signs) (apply + (map abs\
    \ arr))))))\n", "  (if (null? arr)\n      'None\n      (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs arr))))\n",
  "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n\
    \        (if (null? arr)\n            (* sum prod)\n            (let* ([x (car\
    \ arr)]\n                   [sign (if (zero? x) 0 (if (positive? x) 1 -1))])\n\
    \              (loop (cdr arr) (+ sum (abs x)) (* prod sign)))))))\n", "  (if\
    \ (null? arr)\n      'none\n      (apply * (map (lambda (x) (if (zero? x) 0 (if\
    \ (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map sign arr)])\n\
    \       (apply * (map abs arr))\n       (apply * signs))]))\n", "  (if (empty?\
    \ arr)\n      'None\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr))))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map\
    \ abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      'None\n\
    \      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n", " \
    \ (if (null? arr)\n      'None\n      (let loop ([arr arr] [acc 0])\n        (if\
    \ (null? arr)\n            acc\n            (loop (cdr arr) (+ (* (abs (car arr))\
    \ (signum (car arr))) acc))))))\n", "  (if (null? arr)\n      'None\n      (let\
    \ loop ([arr arr] [sum 0] [prod 1])\n        (cond [(null? arr) (* sum prod)]\n\
    \              [(zero? (car arr)) (loop (cdr arr) sum prod)]\n              [(negative?\
    \ (car arr)) (loop (cdr arr) (+ sum (abs (car arr))) (* prod -1))]\n         \
    \     [else (loop (cdr arr) (+ sum (abs (car arr))) prod)]))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n        (apply\
    \ * signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n\
    \      'None\n      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (define (sign x)\n    (cond\n      [(> x 0) 1]\n      [(<\
    \ x 0) -1]\n      [else 0]))\n  (define (magnitude x)\n    (abs x))\n  (define\
    \ (prod-signs-helper arr)\n    (if (null? arr)\n        1\n        (* (sign (car\
    \ arr)) (prod-signs-helper (cdr arr)))))\n  (define (magnitude-sum arr)\n    (if\
    \ (null? arr)\n        0\n        (+ (magnitude (car arr)) (magnitude-sum (cdr\
    \ arr)))))\n  (if (null? arr)\n      'None\n      (* (prod-signs-helper arr) (magnitude-sum\
    \ arr))))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n     (define signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n     (define magnitudes\
    \ (map abs arr))\n     (apply * signs)\n     (* (apply * signs) (apply + magnitudes))]))\n",
  "  (cond\n    [(empty? arr) (error \"empty array\")]\n    [(empty? (rest arr)) (if\
    \ (zero? (first arr)) 0 (first arr))]\n    [else\n     (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr)]\n            [prod (apply\
    \ * signs)]\n            [magnitudes (map abs arr)])\n       (apply + (map * magnitudes\
    \ signs)))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (if (null? arr)\n      #f\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (if (null? arr)\n \
    \     'None\n      (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1)))\
    \ arr))\n      (apply + (map abs arr))))\n", "  (if (null? arr)\n      #f\n  \
    \    (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else\n         (apply *\n                (map (lambda\
    \ (x)\n                       (cond [(zero? x) 0]\n                          \
    \   [(negative? x) -1]\n                             [else 1]))\n            \
    \         arr))]))\n", "  (if (empty? arr)\n      'None\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs\
    \ arr))))\n", "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum\
    \ 0] [prod 1])\n        (if (null? arr)\n            (* sum prod)\n          \
    \  (let ([x (car arr)])\n              (cond\n                [(> x 0) (loop (cdr\
    \ arr) (+ sum x) prod)]\n                [(< x 0) (loop (cdr arr) sum (* prod\
    \ -1))]\n                [else (loop (cdr arr) sum prod)]))))))\n", "  (cond\n\
    \    [(empty? arr) (error \"empty arr\")]\n    [(= 1 (length arr)) (abs (first\
    \ arr))]\n    [else\n     (* (abs (first arr))\n        (prod_signs (rest arr)))]))\n",
  "  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n \
    \       (* (apply * signs) (apply + magnitudes)))))\n", "  (if (null? arr)\n \
    \     'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (apply *\n\
    \            (map (lambda (x) (cond [(> x 0) 1] [(< x 0) -1] [else 0]))\n    \
    \             arr))]))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n     (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \ (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n   \
    \   #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
