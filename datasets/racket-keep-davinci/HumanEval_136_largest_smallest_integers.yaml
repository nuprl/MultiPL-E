name: HumanEval_136_largest_smallest_integers
language: racket
prompt: "#lang racket\n\n;; Create a function that returns a tuple (a, b), where 'a'\
  \ is\n;; the largest of negative integers, and 'b' is the smallest\n;; of positive\
  \ integers in a list.\n;; If there is no negative or positive integers, return them\
  \ as None.\n;; Examples:\n;; largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
  \ 1)\n;; largest_smallest_integers([]) == (None, None)\n;; largest_smallest_integers([0])\
  \ == (None, None)\n(define (largest_smallest_integers lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (define (is-positive? n)\n    (> n 0))\n  (define (is-negative? n)\n\
    \    (< n 0))\n  (define (is-zero? n)\n    (= n 0))\n  (define (is-integer? n)\n\
    \    (integer? n))\n  (define (is-none? n)\n    (eq? n 'None))\n  (define (is-not-none?\
    \ n)\n    (not (is-none? n)))\n  (define (is-none-or-integer? n)\n    (or (is-none?\
    \ n) (is-integer? n)))\n  (define (is-none-or-positive? n)\n    (or (is-none?\
    \ n) (is-positive? n)))\n  (define (is-none-or-negative? n)\n    (or (is-none?\
    \ n) (is-negative? n)))\n  (define (is-none-or-zero? n)\n    (or (is-none? n)\
    \ (is-zero? n)))\n  (define (is-none-or-not-zero? n)\n    (or (is-none? n) (not\
    \ (is-zero? n))))\n  (define (is-none-or-not-positive? n)\n    (or (is-none? n)\
    \ (not (is-positive? n))))\n  (define (is-none-or-not-negative? n)\n    (or (is-none?\
    \ n) (not (is-negative? n))))\n  (define (is-none-or-not-integer? n)\n    (or\
    \ (is-none? n) (not (is-integer? n))))\n  (define (is-not-none-and-integer? n)\n\
    \    (and (is-not-none? n) (is-integer? n)))\n  (define (is-not-none-and-positive?\
    \ n)\n    (and (is-not-none? n) (is-positive? n)))\n  (define (is-not-none-and-negative?\
    \ n)\n    (and (is-not-none? n) (is-negative? n)))\n  (define (is-not", "  (define\
    \ (is-positive? n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n \
    \ (define (largest-negative lst)\n    (cond\n      [(empty? lst) 'None]\n    \
    \  [(is-negative? (first lst)) (max (first lst) (largest-negative (rest lst)))]\n\
    \      [else (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond\n      [(empty? lst) 'None]\n      [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (largest-negative lst)\n    (cond\
    \ [(empty? lst) #f]\n          [(is-negative? (first lst)) (max (first lst) (largest-negative\
    \ (rest lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (define (largest-smallest-integers-helper lst)\n    (cond\
    \ [(empty? lst) (cons #f #f)]\n          [(and (is-positive? (first lst)) (is-negative?\
    \ (first lst))) (cons (first lst) (first lst))]\n          [(is-positive? (first\
    \ lst)) (cons (largest-negative lst) (first lst))]\n          [(is-negative? (first\
    \ lst)) (cons (first lst) (smallest-positive lst))]\n          [else (largest-smallest-integers-helper\
    \ (rest lst))]))\n  (largest-smallest-integers-helper lst))\n", "  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (is-positive? n)\n    (and (number?\
    \ n) (> n 0)))\n  (define (is-zero? n)\n    (and (number? n) (= n 0)))\n  (define\
    \ (is-integer? n)\n    (and (number? n) (integer? n)))\n  (define (is-non-zero-integer?\
    \ n)\n    (and (is-integer? n) (not (is-zero? n))))\n  (define (is-non-zero-integer-list?\
    \ lst)\n    (and (list? lst) (every is-non-zero-integer? lst)))\n  (define (max-negative\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-negative? (first lst)) (max\
    \ (first lst) (max-negative (rest lst)))]\n          [else (max-negative (rest\
    \ lst))]))\n  (define (min-positive lst)\n    (cond [(empty? lst) #f]\n      \
    \    [(is-positive? (first lst)) (min (first lst) (min-positive (rest lst)))]\n\
    \          [else (min-positive (rest lst))]))\n  (cond [(is-non-zero-integer-list?\
    \ lst) (values (max-negative lst) (min-positive lst))]\n        [else (values\
    \ #f #f)]))\n", "  (cond\n    [(empty? lst) (values 'None 'None)]\n    [(not (number?\
    \ (car lst))) (largest_smallest_integers (cdr lst))]\n    [(negative? (car lst))\
    \ (values (car lst) (cadr lst))]\n    [else (values (cadr lst) (car lst))]))\n",
  "  (define (is-negative? n) (< n 0))\n  (define (is-positive? n) (> n 0))\n  (define\
    \ (is-zero? n) (= n 0))\n  (define (is-integer? n)\n    (and (integer? n)\n  \
    \       (not (is-zero? n))))\n  (define (is-negative-integer? n)\n    (and (is-integer?\
    \ n)\n         (is-negative? n)))\n  (define (is-positive-integer? n)\n    (and\
    \ (is-integer? n)\n         (is-positive? n)))\n  (define (largest-negative-integer\
    \ lst)\n    (cond [(null? lst) 'None]\n          [(is-negative-integer? (car lst))\n\
    \           (max (car lst) (largest-negative-integer (cdr lst)))]\n          [else\
    \ (largest-negative-integer (cdr lst))]))\n  (define (smallest-positive-integer\
    \ lst)\n    (cond [(null? lst) 'None]\n          [(is-positive-integer? (car lst))\n\
    \           (min (car lst) (smallest-positive-integer (cdr lst)))]\n         \
    \ [else (smallest-positive-integer (cdr lst))]))\n  (cons (largest-negative-integer\
    \ lst)\n        (smallest-positive-integer lst)))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(and (negative? (first lst))\
    \ (not (positive? (first lst))))\n       (max (first lst) (largest_negative (rest\
    \ lst)))]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(and (positive? (first lst))\
    \ (not (negative? (first lst))))\n       (min (first lst) (smallest_positive (rest\
    \ lst)))]\n      [else (smallest_positive (rest lst))]))\n  (cons (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (let ([negs (filter (lambda (x) (and (integer?\
    \ x) (< x 0))) lst)]\n        [pos (filter (lambda (x) (and (integer? x) (> x\
    \ 0))) lst)])\n    (cond [(empty? negs) (cons #f (min pos))]\n          [(empty?\
    \ pos) (cons (max negs) #f)]\n          [else (cons (max negs) (min pos))])))\n",
  "  (define (is-positive? n)\n    (and (integer? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (integer? n) (< n 0)))\n  (define (is-zero? n)\n    (and (integer?\
    \ n) (= n 0)))\n  (define (is-integer? n)\n    (integer? n))\n  (define (is-none?\
    \ n)\n    (not (is-integer? n)))\n  (define (is-not-none? n)\n    (not (is-none?\
    \ n)))\n  (define (largest-negative lst)\n    (cond [(empty? lst) (error \"No\
    \ negative numbers in list\")]\n          [(is-not-none? (car lst)) (car lst)]\n\
    \          [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) (error \"No positive numbers in list\")]\n   \
    \       [(is-not-none? (car lst)) (car lst)]\n          [else (smallest-positive\
    \ (cdr lst))]))\n  (define (largest-negative-or-none lst)\n    (cond [(empty?\
    \ lst) 'None]\n          [(is-negative? (car lst)) (largest-negative lst)]\n \
    \         [else (largest-negative-or-none (cdr lst))]))\n  (define (smallest-positive-or-none\
    \ lst)\n    (cond [(empty? lst) 'None]\n          [(is-positive? (car lst)) (smallest-positive\
    \ lst)]\n          [else (smallest-positive-or-none (cdr lst))]))\n  (define (largest-smallest-integers-helper\
    \ lst)\n    (cond [(empty? lst) (list 'None 'None)]\n          [(is-zero? (car\
    \ lst)) (largest-smallest-integers-helper (cdr lst))]\n          [(is-negative?\
    \ (car lst)) (list (largest-negative-or-none lst) (smallest-positive-or-none lst))]\n\
    \         ", "  (define (largest-negative lst)\n    (cond\n      [(empty? lst)\
    \ 'None]\n      [(< (first lst) 0) (max (first lst) (largest-negative (rest lst)))]\n\
    \      [else (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond\n      [(empty? lst) 'None]\n      [(> (first lst) 0) (min (first lst)\
    \ (smallest-positive (rest lst)))]\n      [else (smallest-positive (rest lst))]))\n\
    \  (cons (largest-negative lst) (smallest-positive lst)))\n", "  (define (is-negative?\
    \ x)\n    (and (number? x) (< x 0)))\n  (define (is-positive? x)\n    (and (number?\
    \ x) (> x 0)))\n  (define (largest-negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(is-negative? (first lst)) (max (first lst) (largest-negative (rest\
    \ lst)))]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-positive? (first lst))\
    \ (min (first lst) (smallest-positive (rest lst)))]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (let ([negs (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda\
    \ (x) (> x 0)) lst)])\n    (if (empty? negs)\n        (cons #f (if (empty? pos)\
    \ #f (min pos)))\n        (cons (max negs) (if (empty? pos) #f (min pos))))))\n",
  "  (let ([neg-lst (filter (lambda (x) (< x 0)) lst)]\n        [pos-lst (filter (lambda\
    \ (x) (> x 0)) lst)])\n    (if (empty? neg-lst)\n        (cons #f (if (empty?\
    \ pos-lst) #f (min pos-lst)))\n        (cons (max neg-lst) (if (empty? pos-lst)\
    \ #f (min pos-lst))))))\n", "  (define (largest_negative lst)\n    (cond\n   \
    \   [(empty? lst) #f]\n      [(< (first lst) 0) (max (first lst) (largest_negative\
    \ (rest lst)))]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(> (first lst) 0) (min (first\
    \ lst) (smallest_positive (rest lst)))]\n      [else (smallest_positive (rest\
    \ lst))]))\n  (define (largest_smallest_integers_helper lst)\n    (cond\n    \
    \  [(empty? lst) (values #f #f)]\n      [(< (first lst) 0) (values (max (first\
    \ lst) (largest_negative (rest lst))) (smallest_positive (rest lst)))]\n     \
    \ [(> (first lst) 0) (values (largest_negative (rest lst)) (min (first lst) (smallest_positive\
    \ (rest lst))))]\n      [else (largest_smallest_integers_helper (rest lst))]))\n\
    \  (largest_smallest_integers_helper lst))\n", "  (let ([negs (filter (\u03BB\
    \ (x) (negative? x)) lst)]\n        [pos (filter (\u03BB (x) (positive? x)) lst)])\n\
    \    (if (empty? negs)\n        (cons #f (min pos))\n        (cons (max negs)\
    \ (if (empty? pos) #f (min pos))))))\n", "  (let ([negs (filter (lambda (x) (<\
    \ x 0)) lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n    (if (empty?\
    \ negs)\n        (cons #f (if (empty? pos) #f (apply min pos)))\n        (cons\
    \ (apply max negs) (if (empty? pos) #f (apply min pos))))))\n", "  (let ([neg\
    \ (filter (lambda (x) (negative? x)) lst)]\n        [pos (filter (lambda (x) (positive?\
    \ x)) lst)])\n    (if (empty? neg)\n        (cons 'None (if (empty? pos) 'None\
    \ (min pos)))\n        (cons (max neg) (if (empty? pos) 'None (min pos))))))\n",
  "  (define (largest-negative lst)\n    (cond [(empty? lst) 'None]\n          [(and\
    \ (negative? (first lst))\n                (or (not (negative? (second lst)))\n\
    \                    (and (negative? (second lst))\n                         (<\
    \ (first lst) (second lst)))))\n           (first lst)]\n          [else (largest-negative\
    \ (rest lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) 'None]\n\
    \          [(and (positive? (first lst))\n                (or (not (positive?\
    \ (second lst)))\n                    (and (positive? (second lst))\n        \
    \                 (> (first lst) (second lst)))))\n           (first lst)]\n \
    \         [else (smallest-positive (rest lst))]))\n  (list (largest-negative lst)\
    \ (smallest-positive lst)))\n", "  (cond\n    [(empty? lst) (values 'None 'None)]\n\
    \    [(not (number? (car lst))) (largest_smallest_integers (cdr lst))]\n    [(and\
    \ (positive? (car lst)) (positive? (cadr lst)))\n     (let ([a (car lst)]\n  \
    \         [b (cadr lst)])\n       (if (< a b)\n           (largest_smallest_integers\
    \ (cons b (cddr lst)))\n           (largest_smallest_integers (cons a (cddr lst)))))]\n\
    \    [(and (negative? (car lst)) (negative? (cadr lst)))\n     (let ([a (car lst)]\n\
    \           [b (cadr lst)])\n       (if (> a b)\n           (largest_smallest_integers\
    \ (cons b (cddr lst)))\n           (largest_smallest_integers (cons a (cddr lst)))))]\n\
    \    [(and (positive? (car lst)) (negative? (cadr lst)))\n     (let ([a (car lst)]\n\
    \           [b (cadr lst)])\n       (if (< a (- b))\n           (largest_smallest_integers\
    \ (cons (- b) (cddr lst)))\n           (largest_smallest_integers (cons a (cddr\
    \ lst)))))]\n    [(and (negative? (car lst)) (positive? (cadr lst)))\n     (let\
    \ ([a (car lst)]\n           [b (cadr lst)])\n       (if (> (- a) b)\n       \
    \    (largest_smallest_integers (cons b (cddr lst)))\n           (largest_smallest_integers\
    \ (cons (- a) (cddr lst)))))]\n    [(and (positive? (car lst)) (not (number? (cadr\
    \ lst))))\n     (let ([a (car lst)])\n       (largest_smallest_integers (cons\
    \ a (cddr lst))))]\n    [(and (negative? (car lst)) (not (number? (cadr lst))))\n\
    \     (let ([a (car lst)])", "  (let* ((negatives (filter (lambda (x) (< x 0))\
    \ lst))\n         (positives (filter (lambda (x) (> x 0)) lst))\n         (largest-negative\
    \ (if (empty? negatives)\n                               'None\n             \
    \                  (apply max negatives)))\n         (smallest-positive (if (empty?\
    \ positives)\n                                'None\n                        \
    \        (apply min positives))))\n    (list largest-negative smallest-positive)))\n",
  "  (cond\n    [(empty? lst) (values 'None 'None)]\n    [(andmap positive? lst) (values\
    \ 'None (min lst))]\n    [(andmap negative? lst) (values (max lst) 'None)]\n \
    \   [else (values (max (filter negative? lst)) (min (filter positive? lst)))]))\n\
    </code>\n", "  (define (is-positive? n)\n    (and (integer? n) (> n 0)))\n  (define\
    \ (is-negative? n)\n    (and (integer? n) (< n 0)))\n  (define (get-largest-negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-negative? (first lst))\
    \ (max (first lst) (get-largest-negative (rest lst)))]\n      [else (get-largest-negative\
    \ (rest lst))]))\n  (define (get-smallest-positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(is-positive? (first lst)) (min (first lst) (get-smallest-positive\
    \ (rest lst)))]\n      [else (get-smallest-positive (rest lst))]))\n  (values\
    \ (get-largest-negative lst) (get-smallest-positive lst)))\n", "  (cond\n    [(empty?\
    \ lst) (cons 'None 'None)]\n    [(empty? (filter number? lst)) (cons 'None 'None)]\n\
    \    [else (cons (apply max (filter number? lst))\n                (apply min\
    \ (filter number? lst)))]))\n", "  (let ([negs (filter (lambda (x) (< x 0)) lst)]\n\
    \        [pos (filter (lambda (x) (> x 0)) lst)])\n    (if (empty? negs)\n   \
    \     (cons #f (if (empty? pos) #f (min pos)))\n        (cons (max negs) (if (empty?\
    \ pos) #f (min pos))))))\n", "  (let ([negs (filter (lambda (x) (negative? x))\
    \ lst)]\n        [pos (filter (lambda (x) (positive? x)) lst)])\n    (if (empty?\
    \ negs)\n        (cons #f (if (empty? pos) #f (min pos)))\n        (cons (max\
    \ negs) (if (empty? pos) #f (min pos))))))\n", "  (define (largest-neg lst)\n\
    \    (cond\n      [(empty? lst) 'None]\n      [(< (first lst) 0) (max (first lst)\
    \ (largest-neg (rest lst)))]\n      [else (largest-neg (rest lst))]))\n  (define\
    \ (smallest-pos lst)\n    (cond\n      [(empty? lst) 'None]\n      [(> (first\
    \ lst) 0) (min (first lst) (smallest-pos (rest lst)))]\n      [else (smallest-pos\
    \ (rest lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (define\
    \ (is-positive? n)\n    (and (number? n)\n         (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (number? n)\n         (< n 0)))\n  (define (is-zero? n)\n    (and\
    \ (number? n)\n         (= n 0)))\n  (define (is-integer? n)\n    (and (number?\
    \ n)\n         (integer? n)))\n  (define (is-non-zero-integer? n)\n    (and (is-integer?\
    \ n)\n         (not (is-zero? n))))\n  (define (largest-negative-integer lst)\n\
    \    (cond [(empty? lst) #f]\n          [(is-non-zero-integer? (first lst))\n\
    \           (if (is-negative? (first lst))\n               (max (first lst) (largest-negative-integer\
    \ (rest lst)))\n               (largest-negative-integer (rest lst)))]\n     \
    \     [else (largest-negative-integer (rest lst))]))\n  (define (smallest-positive-integer\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-non-zero-integer? (first lst))\n\
    \           (if (is-positive? (first lst))\n               (min (first lst) (smallest-positive-integer\
    \ (rest lst)))\n               (smallest-positive-integer (rest lst)))]\n    \
    \      [else (smallest-positive-integer (rest lst))]))\n  (define (largest-negative-integer-or-none\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-non-zero-integer? (first lst))\n\
    \           (if (is-negative? (first lst))\n               (max (first lst) (largest-negative-integer-or-none\
    \ (rest lst)))\n               (largest-negative-integer-or-none (rest lst)))]\n\
    \          [else (largest-negative-integer-or-none (rest lst))]))\n  (define (smallest-positive-integer-or-none\
    \ lst)\n    (cond [(empty? lst) #", "  (define (largest-neg lst)\n    (cond\n\
    \      [(empty? lst) 'None]\n      [(negative? (first lst)) (max (first lst) (largest-neg\
    \ (rest lst)))]\n      [else (largest-neg (rest lst))]))\n  (define (smallest-pos\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(positive? (first lst))\
    \ (min (first lst) (smallest-pos (rest lst)))]\n      [else (smallest-pos (rest\
    \ lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (let ([negs\
    \ (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda (x) (> x 0))\
    \ lst)])\n    (if (empty? negs)\n        (cons 'None (if (empty? pos) 'None (min\
    \ pos)))\n        (cons (max negs) (if (empty? pos) 'None (min pos))))))\n", " \
    \ (define (largest-negative lst)\n    (cond\n      [(empty? lst) (error \"no negative\
    \ integers\")]\n      [(< (first lst) 0) (max (first lst) (largest-negative (rest\
    \ lst)))]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) (error \"no positive integers\")]\n   \
    \   [(> (first lst) 0) (min (first lst) (smallest-positive (rest lst)))]\n   \
    \   [else (smallest-positive (rest lst))]))\n  (define (largest-negative-or-none\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(< (first lst) 0) (max (first\
    \ lst) (largest-negative-or-none (rest lst)))]\n      [else (largest-negative-or-none\
    \ (rest lst))]))\n  (define (smallest-positive-or-none lst)\n    (cond\n     \
    \ [(empty? lst) 'None]\n      [(> (first lst) 0) (min (first lst) (smallest-positive-or-none\
    \ (rest lst)))]\n      [else (smallest-positive-or-none (rest lst))]))\n  (cond\n\
    \    [(empty? lst) (values 'None 'None)]\n    [(< (first lst) 0) (values (largest-negative\
    \ lst) (smallest-positive-or-none (rest lst)))]\n    [(> (first lst) 0) (values\
    \ (largest-negative-or-none (rest lst)) (smallest-positive lst))]\n    [else (values\
    \ 'None 'None)]))\n", "  (define (is-negative? n)\n    (and (number? n) (< n 0)))\n\
    \  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-zero?\
    \ n)\n    (and (number? n) (= n 0)))\n  (define (is-not-zero? n)\n    (and (number?\
    \ n) (not (= n 0))))\n  (define (is-not-zero-or-positive? n)\n    (and (number?\
    \ n) (not (or (= n 0) (> n 0)))))\n  (define (is-not-zero-or-negative? n)\n  \
    \  (and (number? n) (not (or (= n 0) (< n 0)))))\n  (define (largest-negative\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-not-zero-or-positive? (first\
    \ lst))\n           (max (first lst) (largest-negative (rest lst)))]\n       \
    \   [else (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond [(empty? lst) #f]\n          [(is-not-zero-or-negative? (first lst))\n\
    \           (min (first lst) (smallest-positive (rest lst)))]\n          [else\
    \ (smallest-positive (rest lst))]))\n  (define (largest-negative-or-none lst)\n\
    \    (cond [(empty? lst) #f]\n          [(is-not-zero-or-positive? (first lst))\n\
    \           (max (first lst) (largest-negative-or-none (rest lst)))]\n       \
    \   [else #f]))\n  (define (smallest-positive-or-none lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(is-not-zero-or-negative? (first lst))\n           (min\
    \ (first lst) (smallest-positive-or-none (rest lst)))]\n          [else #f]))\n\
    \  (define (largest-negative-or-none-or-none lst)\n    (cond", "  (define (helper\
    \ lst largest smallest)\n    (cond [(empty? lst) (values largest smallest)]\n\
    \          [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n           (helper (rest lst) largest (first lst))]\n    \
    \      [(and (negative? (first lst)) (or (not (negative? largest)) (> (first lst)\
    \ largest)))\n           (helper (rest lst) (first lst) smallest)]\n         \
    \ [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n", " \
    \ (cond\n    [(empty? lst) (values 'None 'None)]\n    [(andmap number? lst) (values\
    \ 'None 'None)]\n    [else (values (apply max (filter negative? lst))\n      \
    \            (apply min (filter positive? lst)))]))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(null? lst) 'None]\n      [(and (number? (car lst))\
    \ (< (car lst) 0)) (max (car lst) (largest_negative (cdr lst)))]\n      [else\
    \ (largest_negative (cdr lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(null? lst) 'None]\n      [(and (number? (car lst)) (> (car lst) 0)) (min\
    \ (car lst) (smallest_positive (cdr lst)))]\n      [else (smallest_positive (cdr\
    \ lst))]))\n  (cons (largest_negative lst) (smallest_positive lst)))\n", "  (define\
    \ (is-positive? n)\n    (and (integer? n) (> n 0)))\n  (define (is-negative? n)\n\
    \    (and (integer? n) (< n 0)))\n  (define (largest-negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(is-negative? (first lst)) (max (first lst) (largest-negative\
    \ (rest lst)))]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-positive? (first lst))\
    \ (min (first lst) (smallest-positive (rest lst)))]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (let ([neg-lst (filter (lambda (x) (< x 0)) lst)]\n        [pos-lst (filter (lambda\
    \ (x) (> x 0)) lst)])\n    (if (empty? neg-lst)\n        (cons #f (if (empty?\
    \ pos-lst) #f (min pos-lst)))\n        (cons (max neg-lst) (if (empty? pos-lst)\
    \ #f (min pos-lst))))))\n", "  (define (largest_negative lst)\n    (cond\n   \
    \   [(empty? lst) 'None]\n      [(and (negative? (first lst)) (not (negative?\
    \ (second lst)))) (first lst)]\n      [else (largest_negative (rest lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(empty? lst) 'None]\n  \
    \    [(and (positive? (first lst)) (not (positive? (second lst)))) (first lst)]\n\
    \      [else (smallest_positive (rest lst))]))\n  (cons (largest_negative lst)\
    \ (cons (smallest_positive lst) '())))\n", "  (define (is-positive? n)\n    (and\
    \ (number? n)\n         (> n 0)))\n  (define (is-negative? n)\n    (and (number?\
    \ n)\n         (< n 0)))\n  (define (get-largest-negative lst)\n    (cond\n  \
    \    [(empty? lst) #f]\n      [(is-negative? (first lst))\n       (max (first\
    \ lst) (get-largest-negative (rest lst)))]\n      [else (get-largest-negative\
    \ (rest lst))]))\n  (define (get-smallest-positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(is-positive? (first lst))\n       (min (first lst) (get-smallest-positive\
    \ (rest lst)))]\n      [else (get-smallest-positive (rest lst))]))\n  (cons (get-largest-negative\
    \ lst)\n        (get-smallest-positive lst)))\n", "  (let* ([negs (filter (lambda\
    \ (x) (negative? x)) lst)]\n         [pos (filter (lambda (x) (positive? x)) lst)])\n\
    \    (if (empty? negs)\n        (cons #f (if (empty? pos) #f (min pos)))\n   \
    \     (cons (max negs) (if (empty? pos) #f (min pos))))))\n", "  (define (helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (values largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n      [(and\
    \ (negative? (first lst)) (or (not (negative? largest)) (> (first lst) largest)))\n\
    \       (helper (rest lst) (first lst) smallest)]\n      [else (helper (rest lst)\
    \ largest smallest)]))\n  (helper lst #f #f))\n", "  (define (helper lst)\n  \
    \  (cond\n      [(empty? lst) (values '() '())]\n      [(positive? (car lst))\
    \ (values (list (car lst)) (cdr lst))]\n      [(negative? (car lst)) (values (list)\
    \ (cdr lst))]\n      [else (values (list) (cdr lst))]))\n  (define (helper2 lst)\n\
    \    (cond\n      [(empty? lst) (values '() '())]\n      [(positive? (car lst))\
    \ (values (list) (cdr lst))]\n      [(negative? (car lst)) (values (list (car\
    \ lst)) (cdr lst))]\n      [else (values (list) (cdr lst))]))\n  (define (helper3\
    \ lst)\n    (cond\n      [(empty? lst) (values '() '())]\n      [(positive? (car\
    \ lst)) (values (list) (cdr lst))]\n      [(negative? (car lst)) (values (list)\
    \ (cdr lst))]\n      [else (values (list (car lst)) (cdr lst))]))\n  (define (helper4\
    \ lst)\n    (cond\n      [(empty? lst) (values '() '())]\n      [(positive? (car\
    \ lst)) (values (list) (cdr lst))]\n      [(negative? (car lst)) (values (list)\
    \ (cdr lst))]\n      [else (values (list) (cdr lst))]))\n  (define (helper5 lst)\n\
    \    (cond\n      [(empty? lst) (values '() '())]\n      [(positive? (car lst))\
    \ (values (list) (cdr lst))]\n      [(negative? (car lst)) (values (list) (cdr\
    \ lst))]\n      [else (values (list) (cdr lst))]))\n  (define (helper6 lst)\n\
    \    (cond\n      [(empty? lst) (values '() '())]\n      [(positive? (car lst))\
    \ (values (list) (", "  (define (helper lst)\n    (cond [(empty? lst) (values\
    \ #f #f)]\n          [(and (positive? (first lst)) (negative? (first lst))) (values\
    \ #f #f)]\n          [(negative? (first lst)) (values (first lst) #f)]\n     \
    \     [(positive? (first lst)) (values #f (first lst))]\n          [else (values\
    \ #f #f)]))\n  (define (helper2 lst)\n    (cond [(empty? lst) (values #f #f)]\n\
    \          [(and (positive? (first lst)) (negative? (first lst))) (values #f #f)]\n\
    \          [(negative? (first lst)) (values (first lst) #f)]\n          [(positive?\
    \ (first lst)) (values #f (first lst))]\n          [else (values #f #f)]))\n \
    \ (define (helper3 lst)\n    (cond [(empty? lst) (values #f #f)]\n          [(and\
    \ (positive? (first lst)) (negative? (first lst))) (values #f #f)]\n         \
    \ [(negative? (first lst)) (values (first lst) #f)]\n          [(positive? (first\
    \ lst)) (values #f (first lst))]\n          [else (values #f #f)]))\n  (define\
    \ (helper4 lst)\n    (cond [(empty? lst) (values #f #f)]\n          [(and (positive?\
    \ (first lst)) (negative? (first lst))) (values #f #f)]\n          [(negative?\
    \ (first lst)) (values (first lst) #f)]\n          [(positive? (first lst)) (values\
    \ #f (first lst))]\n          [else (values #f #f)]))\n  (define (helper5 lst)\n\
    \    (cond [(empty? lst) (values #f #f)]\n          [(and (positive? (first lst))\
    \ (negative? (first lst))) (values #f #f)]\n          [(negative? (first lst))\
    \ (values (first lst) #f)]\n          [(positive? (first lst))", "  (define (largest-negative\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(and (negative? (first lst))\
    \ (not (empty? (rest lst))))\n       (if (negative? (first (rest lst)))\n    \
    \       (largest-negative (rest lst))\n           (first lst))]\n      [(negative?\
    \ (first lst)) (first lst)]\n      [else 'None]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(and (positive? (first lst))\
    \ (not (empty? (rest lst))))\n       (if (positive? (first (rest lst)))\n    \
    \       (smallest-positive (rest lst))\n           (first lst))]\n      [(positive?\
    \ (first lst)) (first lst)]\n      [else 'None]))\n  (cons (largest-negative lst)\
    \ (smallest-positive lst)))\n", "  (cond\n    [(empty? lst) (cons 'None 'None)]\n\
    \    [(not (number? (car lst))) (largest_smallest_integers (cdr lst))]\n    [(and\
    \ (number? (car lst)) (positive? (car lst)))\n     (cons (car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n    [(and (number? (car lst)) (negative? (car lst)))\n     (cons\
    \ (car lst) (largest_smallest_integers (cdr lst)))]))\n", "  (let* ([negatives\
    \ (filter (lambda (x) (< x 0)) lst)]\n         [positives (filter (lambda (x)\
    \ (> x 0)) lst)])\n    (if (empty? negatives)\n        (cons #f (if (empty? positives)\
    \ #f (min positives)))\n        (cons (max negatives) (if (empty? positives) #f\
    \ (min positives))))))\n", "  (let ([negs (filter (lambda (x) (and (number? x)\
    \ (< x 0))) lst)]\n        [pos (filter (lambda (x) (and (number? x) (> x 0)))\
    \ lst)])\n    (if (empty? negs)\n        (if (empty? pos)\n            (values\
    \ #f #f)\n            (values #f (apply min pos)))\n        (if (empty? pos)\n\
    \            (values (apply max negs) #f)\n            (values (apply max negs)\
    \ (apply min pos))))))\n", "  (define (largest-negative lst)\n    (cond [(null?\
    \ lst) #f]\n          [(and (negative? (car lst))\n                (or (not (negative?\
    \ (cadr lst)))\n                    (negative? (car lst))\n                  \
    \  (and (negative? (cadr lst))\n                         (> (car lst) (cadr lst)))))\n\
    \           (car lst)]\n          [else (largest-negative (cdr lst))]))\n  (define\
    \ (smallest-positive lst)\n    (cond [(null? lst) #f]\n          [(and (positive?\
    \ (car lst))\n                (or (not (positive? (cadr lst)))\n             \
    \       (positive? (car lst))\n                    (and (positive? (cadr lst))\n\
    \                         (< (car lst) (cadr lst)))))\n           (car lst)]\n\
    \          [else (smallest-positive (cdr lst))]))\n  (define (none? x)\n    (or\
    \ (eq? x #f) (eq? x '())))\n  (cond [(none? (largest-negative lst)) (cons '()\
    \ (smallest-positive lst))]\n        [(none? (smallest-positive lst)) (cons (largest-negative\
    \ lst) '())]\n        [else (cons (largest-negative lst) (smallest-positive lst))]))\n",
  "  (define (is-positive? x)\n    (and (number? x) (> x 0)))\n  (define (is-negative?\
    \ x)\n    (and (number? x) (< x 0)))\n  (define (is-zero? x)\n    (and (number?\
    \ x) (= x 0)))\n  (define (is-integer? x)\n    (and (number? x) (integer? x)))\n\
    \  (define (is-non-zero-integer? x)\n    (and (is-integer? x) (not (is-zero? x))))\n\
    \  (define (is-non-zero-positive-integer? x)\n    (and (is-non-zero-integer? x)\
    \ (is-positive? x)))\n  (define (is-non-zero-negative-integer? x)\n    (and (is-non-zero-integer?\
    \ x) (is-negative? x)))\n  (define (largest-negative-integer lst)\n    (cond [(empty?\
    \ lst) 'None]\n          [(is-non-zero-negative-integer? (first lst))\n      \
    \     (max (first lst) (largest-negative-integer (rest lst)))]\n          [else\
    \ (largest-negative-integer (rest lst))]))\n  (define (smallest-positive-integer\
    \ lst)\n    (cond [(empty? lst) 'None]\n          [(is-non-zero-positive-integer?\
    \ (first lst))\n           (min (first lst) (smallest-positive-integer (rest lst)))]\n\
    \          [else (smallest-positive-integer (rest lst))]))\n  (cons (largest-negative-integer\
    \ lst) (smallest-positive-integer lst)))\n", "  (cond [(empty? lst) (values 'None\
    \ 'None)]\n        [(andmap positive? lst) (values 'None (apply min lst))]\n \
    \       [(andmap negative? lst) (values (apply max lst) 'None)]\n        [else\
    \ (values (apply max (filter negative? lst))\n                     (apply min\
    \ (filter positive? lst)))]))\n", "  (define (is-positive? n)\n    (and (number?\
    \ n) (> n 0)))\n  (define (is-negative? n)\n    (and (number? n) (< n 0)))\n \
    \ (define (is-zero? n)\n    (and (number? n) (= n 0)))\n  (define (is-integer?\
    \ n)\n    (and (number? n) (integer? n)))\n  (define (is-zero-or-integer? n)\n\
    \    (or (is-zero? n) (is-integer? n)))\n  (define (is-positive-integer? n)\n\
    \    (and (is-integer? n) (is-positive? n)))\n  (define (is-negative-integer?\
    \ n)\n    (and (is-integer? n) (is-negative? n)))\n  (define (is-zero-or-positive-integer?\
    \ n)\n    (or (is-zero? n) (is-positive-integer? n)))\n  (define (is-zero-or-negative-integer?\
    \ n)\n    (or (is-zero? n) (is-negative-integer? n)))\n  (define (is-zero-or-positive-or-negative-integer?\
    \ n)\n    (or (is-zero? n) (is-positive-integer? n) (is-negative-integer? n)))\n\
    \  (define (largest-negative-integer lst)\n    (if (null? lst)\n        'None\n\
    \        (if (is-negative-integer? (car lst))\n            (if (null? (cdr lst))\n\
    \                (car lst)\n                (if (> (car lst) (largest-negative-integer\
    \ (cdr lst)))\n                    (car lst)\n                    (largest-negative-integer\
    \ (cdr lst))))\n            (largest-negative-integer (cdr lst)))))\n  (define\
    \ (smallest-positive-integer lst)\n    (if (null? lst)\n        'None\n      \
    \  (if (is-positive-integer? (car lst))\n            (if (null? (cdr lst))\n \
    \               (car lst)\n                (if (< (car lst) (", "  (let ([negs\
    \ (filter (lambda (x) (negative? x)) lst)]\n        [pos (filter (lambda (x) (positive?\
    \ x)) lst)])\n    (if (empty? negs)\n        (cons 'None (if (empty? pos) 'None\
    \ (min pos)))\n        (cons (max negs) (if (empty? pos) 'None (min pos))))))\n",
  "  (define (is-positive? n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n\
    \ 0))\n  (define (find-largest-negative lst)\n    (cond\n      [(empty? lst) #f]\n\
    \      [(is-negative? (first lst)) (max (first lst) (find-largest-negative (rest\
    \ lst)))]\n      [else (find-largest-negative (rest lst))]))\n  (define (find-smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-positive? (first lst))\
    \ (min (first lst) (find-smallest-positive (rest lst)))]\n      [else (find-smallest-positive\
    \ (rest lst))]))\n  (define (replace-false-with-none n)\n    (cond\n      [(false?\
    \ n) 'None]\n      [else n]))\n  (values (replace-false-with-none (find-largest-negative\
    \ lst))\n          (replace-false-with-none (find-smallest-positive lst))))\n",
  "  (let* ([negs (filter (lambda (x) (< x 0)) lst)]\n         [pos (filter (lambda\
    \ (x) (> x 0)) lst)])\n    (if (empty? negs)\n        (cons #f (if (empty? pos)\
    \ #f (min pos)))\n        (cons (max negs) (if (empty? pos) #f (min pos))))))\n",
  "  (define (largest_smallest_integers_iter lst largest smallest)\n    (cond [(empty?\
    \ lst) (values largest smallest)]\n          [(and (positive? (first lst)) (or\
    \ (not (positive? smallest)) (< (first lst) smallest)))\n           (largest_smallest_integers_iter\
    \ (rest lst) largest (first lst))]\n          [(and (negative? (first lst)) (or\
    \ (not (negative? largest)) (> (first lst) largest)))\n           (largest_smallest_integers_iter\
    \ (rest lst) (first lst) smallest)]\n          [else (largest_smallest_integers_iter\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n",
  "  (define (largest-negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and\
    \ (negative? (first lst)) (not (negative? (second lst)))) (first lst)]\n     \
    \ [else (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst)) (not\
    \ (positive? (second lst)))) (first lst)]\n      [else (smallest-positive (rest\
    \ lst))]))\n  (define (largest-negative-smallest-positive lst)\n    (cond\n  \
    \    [(empty? lst) (list #f #f)]\n      [(and (negative? (first lst)) (not (negative?\
    \ (second lst)))) (list (first lst) (smallest-positive lst))]\n      [(and (positive?\
    \ (first lst)) (not (positive? (second lst)))) (list (largest-negative lst) (first\
    \ lst))]\n      [else (largest-negative-smallest-positive (rest lst))]))\n  (largest-negative-smallest-positive\
    \ lst))\n", "  (define (is-positive? n)\n    (and (integer? n)\n         (> n\
    \ 0)))\n  (define (is-negative? n)\n    (and (integer? n)\n         (< n 0)))\n\
    \  (define (find-largest-negative lst)\n    (cond [(null? lst) #f]\n         \
    \ [(is-negative? (car lst)) (max (car lst) (find-largest-negative (cdr lst)))]\n\
    \          [else (find-largest-negative (cdr lst))]))\n  (define (find-smallest-positive\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-positive? (car lst)) (min (car\
    \ lst) (find-smallest-positive (cdr lst)))]\n          [else (find-smallest-positive\
    \ (cdr lst))]))\n  (cons (find-largest-negative lst)\n        (find-smallest-positive\
    \ lst)))\n", "  (let ([negs (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter\
    \ (lambda (x) (> x 0)) lst)])\n    (if (empty? negs)\n        (cons #f (if (empty?\
    \ pos) #f (min pos)))\n        (cons (max negs) (if (empty? pos) #f (min pos))))))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(empty? lst) (values\
    \ largest smallest)]\n      [(and (positive? (first lst)) (or (not (positive?\
    \ smallest)) (&lt; (first lst) smallest)))\n       (helper (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (&gt; (first lst) largest)))\n       (helper (rest lst) (first lst) smallest)]\n\
    \      [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(empty? lst) (values\
    \ largest smallest)]\n      [(and (positive? (first lst)) (not (positive? smallest)))\n\
    \       (helper (rest lst) largest (first lst))]\n      [(and (negative? (first\
    \ lst)) (not (negative? largest)))\n       (helper (rest lst) (first lst) smallest)]\n\
    \      [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n",
  "  (cond\n    [(empty? lst) (values 'None 'None)]\n    [(not (list? lst)) (error\
    \ 'largest_smallest_integers \"not a list\")]\n    [(and (not (empty? (filter\
    \ negative? lst)))\n          (not (empty? (filter positive? lst))))\n     (values\
    \ (apply max (filter negative? lst))\n             (apply min (filter positive?\
    \ lst)))]\n    [(not (empty? (filter negative? lst)))\n     (values (apply max\
    \ (filter negative? lst)) 'None)]\n    [(not (empty? (filter positive? lst)))\n\
    \     (values 'None (apply min (filter positive? lst)))]\n    [else (values 'None\
    \ 'None)]))\n", "  (define (get-largest-negative lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(negative? (first lst)) (max (first lst) (get-largest-negative\
    \ (rest lst)))]\n      [else (get-largest-negative (rest lst))]))\n  (define (get-smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(positive? (first lst)) (min\
    \ (first lst) (get-smallest-positive (rest lst)))]\n      [else (get-smallest-positive\
    \ (rest lst))]))\n  (define (get-largest-negative-or-none lst)\n    (cond\n  \
    \    [(get-largest-negative lst) (get-largest-negative lst)]\n      [else #f]))\n\
    \  (define (get-smallest-positive-or-none lst)\n    (cond\n      [(get-smallest-positive\
    \ lst) (get-smallest-positive lst)]\n      [else #f]))\n  (list (get-largest-negative-or-none\
    \ lst) (get-smallest-positive-or-none lst)))\n", "  (define (is-positive? n)\n\
    \    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (is-zero? n)\n\
    \    (= n 0))\n  (define (is-integer? n)\n    (integer? n))\n  (define (is-not-integer?\
    \ n)\n    (not (is-integer? n)))\n  (define (is-not-zero? n)\n    (not (is-zero?\
    \ n)))\n  (define (is-not-positive? n)\n    (not (is-positive? n)))\n  (define\
    \ (is-not-negative? n)\n    (not (is-negative? n)))\n  (define (is-not-zero-or-positive?\
    \ n)\n    (and (is-not-zero? n) (is-not-positive? n)))\n  (define (is-not-zero-or-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-negative? n)))\n  (define (is-not-zero-or-integer?\
    \ n)\n    (and (is-not-zero? n) (is-not-integer? n)))\n  (define (is-not-zero-or-not-integer?\
    \ n)\n    (and (is-not-zero? n) (is-not-integer? n)))\n  (define (is-not-zero-or-not-positive?\
    \ n)\n    (and (is-not-zero? n) (is-not-positive? n)))\n  (define (is-not-zero-or-not-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-negative? n)))\n  (define (is-not-zero-or-not-integer-or-not-positive?\
    \ n)\n    (and (is-not-zero? n) (is-not-integer? n) (is-not-positive? n)))\n \
    \ (define (is-not-zero-or-not-integer-or-not-negative? n)\n    (and (is-not-zero?\
    \ n) (is-not-integer? n) (is-not", "  (cond\n    [(empty? lst) (values 'None 'None)]\n\
    \    [(and (positive? (first lst)) (negative? (first lst))) (values 'None (first\
    \ lst))]\n    [(and (negative? (first lst)) (positive? (first lst))) (values (first\
    \ lst) 'None)]\n    [(positive? (first lst)) (values 'None (first lst))]\n   \
    \ [(negative? (first lst)) (values (first lst) 'None)]\n    [else (values 'None\
    \ 'None)]))\n", "  (define (helper lst largest smallest)\n    (cond [(null? lst)\
    \ (cons largest smallest)]\n          [(and (positive? (car lst)) (or (not (positive?\
    \ smallest)) (< (car lst) smallest)))\n           (helper (cdr lst) largest (car\
    \ lst))]\n          [(and (negative? (car lst)) (or (not (negative? largest))\
    \ (> (car lst) largest)))\n           (helper (cdr lst) (car lst) smallest)]\n\
    \          [else (helper (cdr lst) largest smallest)]))\n  (helper lst #f #f))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(empty? lst) (values\
    \ largest smallest)]\n      [(and (negative? (first lst)) (or (not (number? largest))\
    \ (< (first lst) largest)))\n       (helper (rest lst) (first lst) smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (number? smallest)) (> (first lst)\
    \ smallest)))\n       (helper (rest lst) largest (first lst))]\n      [else (helper\
    \ (rest lst) largest smallest)]))\n  (helper lst #f #f))\n", "  (let ([negs (filter\
    \ (lambda (x) (and (integer? x) (negative? x))) lst)]\n        [pos (filter (lambda\
    \ (x) (and (integer? x) (positive? x))) lst)])\n    (if (empty? negs)\n      \
    \  (cons 'None (if (empty? pos) 'None (min pos)))\n        (cons (max negs) (if\
    \ (empty? pos) 'None (min pos))))))\n", "  (define (is-positive? n)\n    (and\
    \ (number? n) (> n 0)))\n  (define (is-negative? n)\n    (and (number? n) (< n\
    \ 0)))\n  (define (is-zero? n)\n    (and (number? n) (= n 0)))\n  (define (is-integer?\
    \ n)\n    (and (number? n) (integer? n)))\n  (define (is-not-integer? n)\n   \
    \ (not (is-integer? n)))\n  (define (is-not-zero? n)\n    (not (is-zero? n)))\n\
    \  (define (is-not-positive? n)\n    (not (is-positive? n)))\n  (define (is-not-negative?\
    \ n)\n    (not (is-negative? n)))\n  (define (is-not-zero-or-positive? n)\n  \
    \  (and (is-not-zero? n) (is-not-positive? n)))\n  (define (is-not-zero-or-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-negative? n)))\n  (define (is-not-zero-or-integer?\
    \ n)\n    (and (is-not-zero? n) (is-not-integer? n)))\n  (define (is-not-zero-or-not-integer?\
    \ n)\n    (and (is-not-zero? n) (is-not-integer? n)))\n  (define (is-not-zero-or-not-positive?\
    \ n)\n    (and (is-not-zero? n) (is-not-positive? n)))\n  (define (is-not-zero-or-not-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-negative? n)))\n  (define (is-not-zero-or-not-positive-or-not-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-positive? n) (is-not-negative? n)))\n\
    \  (define (is-not-zero-or-not-positive-or-not-integer?", "  (let ([negs (filter\
    \ (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n\
    \    (if (empty? negs)\n        (cons #f (if (empty? pos) #f (min pos)))\n   \
    \     (cons (max negs) (if (empty? pos) #f (min pos))))))\n", "  (define (is-positive?\
    \ n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (is-zero?\
    \ n)\n    (= n 0))\n  (define (is-integer? n)\n    (integer? n))\n  (define (is-not-integer?\
    \ n)\n    (not (is-integer? n)))\n  (define (is-not-zero? n)\n    (not (is-zero?\
    \ n)))\n  (define (is-not-positive? n)\n    (not (is-positive? n)))\n  (define\
    \ (is-not-negative? n)\n    (not (is-negative? n)))\n  (define (is-not-zero-or-positive?\
    \ n)\n    (and (is-not-zero? n) (is-not-positive? n)))\n  (define (is-not-zero-or-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-negative? n)))\n  (define (is-not-zero-or-integer?\
    \ n)\n    (and (is-not-zero? n) (is-not-integer? n)))\n  (define (is-not-zero-or-not-integer?\
    \ n)\n    (and (is-not-zero? n) (is-not-integer? n)))\n  (define (is-not-zero-or-not-positive?\
    \ n)\n    (and (is-not-zero? n) (is-not-positive? n)))\n  (define (is-not-zero-or-not-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-negative? n)))\n  (define (is-not-zero-or-not-positive-or-not-negative?\
    \ n)\n    (and (is-not-zero? n) (is-not-positive? n) (is-not-negative? n)))\n\
    \  (define (is-not-zero-or-not-positive-or-not-integer? n)\n    (and (is-not-zero?\
    \ n) (is-not-positive? n) (is-not", "  (let ([negatives (filter (lambda (x) (<\
    \ x 0)) lst)]\n        [positives (filter (lambda (x) (> x 0)) lst)])\n    (if\
    \ (empty? negatives)\n        (cons #f (if (empty? positives) #f (min positives)))\n\
    \        (cons (max negatives) (if (empty? positives) #f (min positives))))))\n",
  "  (define (is-positive? n)\n    (and (number? n)\n         (positive? n)))\n  (define\
    \ (is-negative? n)\n    (and (number? n)\n         (negative? n)))\n  (define\
    \ (get-largest-negative lst)\n    (cond [(empty? lst) #f]\n          [(is-negative?\
    \ (first lst))\n           (max (first lst) (get-largest-negative (rest lst)))]\n\
    \          [else (get-largest-negative (rest lst))]))\n  (define (get-smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst))\n \
    \          (min (first lst) (get-smallest-positive (rest lst)))]\n          [else\
    \ (get-smallest-positive (rest lst))]))\n  (define (get-largest-negative-or-none\
    \ lst)\n    (cond [(not (get-largest-negative lst)) 'None]\n          [else (get-largest-negative\
    \ lst)]))\n  (define (get-smallest-positive-or-none lst)\n    (cond [(not (get-smallest-positive\
    \ lst)) 'None]\n          [else (get-smallest-positive lst)]))\n  (cons (get-largest-negative-or-none\
    \ lst)\n        (get-smallest-positive-or-none lst)))\n", "  (let ([neg-lst (filter\
    \ (lambda (x) (< x 0)) lst)]\n        [pos-lst (filter (lambda (x) (> x 0)) lst)])\n\
    \    (if (empty? neg-lst)\n        (cons 'None (cons (min pos-lst) '()))\n   \
    \     (cons (max neg-lst) (cons (if (empty? pos-lst) 'None (min pos-lst)) '())))))\n",
  "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (is-zero? n)\n    (and (number?\
    \ n) (= n 0)))\n  (define (is-integer? n)\n    (and (number? n) (integer? n)))\n\
    \  (define (is-not-integer? n)\n    (not (is-integer? n)))\n  (define (is-not-zero?\
    \ n)\n    (not (is-zero? n)))\n  (define (is-not-positive? n)\n    (not (is-positive?\
    \ n)))\n  (define (is-not-negative? n)\n    (not (is-negative? n)))\n  (define\
    \ (is-not-zero-or-positive? n)\n    (not (or (is-zero? n) (is-positive? n))))\n\
    \  (define (is-not-zero-or-negative? n)\n    (not (or (is-zero? n) (is-negative?\
    \ n))))\n  (define (is-not-zero-or-integer? n)\n    (not (or (is-zero? n) (is-integer?\
    \ n))))\n  (define (is-not-positive-or-integer? n)\n    (not (or (is-positive?\
    \ n) (is-integer? n))))\n  (define (is-not-negative-or-integer? n)\n    (not (or\
    \ (is-negative? n) (is-integer? n))))\n  (define (is-not-positive-or-negative?\
    \ n)\n    (not (or (is-positive? n) (is-negative? n))))\n  (define (is-not-positive-or-negative-or-integer?\
    \ n)\n    (not (or (is-positive? n) (is-negative? n) (is-integer? n))))\n  (define\
    \ (is-not-zero-or-positive-or-integer? n)\n    (not (or (is-zero? n) (is-positive?\
    \ n) (is-integer? n))))\n", "  (define (largest-negative lst)\n    (cond\n   \
    \   [(null? lst) 'None]\n      [(and (negative? (car lst)) (not (null? (cdr lst))))\n\
    \       (if (negative? (car (cdr lst)))\n           (largest-negative (cdr lst))\n\
    \           (car lst))]\n      [(negative? (car lst)) (car lst)]\n      [else\
    \ (largest-negative (cdr lst))]))\n  (define (smallest-positive lst)\n    (cond\n\
    \      [(null? lst) 'None]\n      [(and (positive? (car lst)) (not (null? (cdr\
    \ lst))))\n       (if (positive? (car (cdr lst)))\n           (smallest-positive\
    \ (cdr lst))\n           (car lst))]\n      [(positive? (car lst)) (car lst)]\n\
    \      [else (smallest-positive (cdr lst))]))\n  (list (largest-negative lst)\
    \ (smallest-positive lst)))\n", "  (define (largest-negative lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(< (first lst) 0) (max (first lst) (largest-negative (rest\
    \ lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(> (first lst) 0) (min (first\
    \ lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive (rest\
    \ lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n", "  (define\
    \ (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative? n)\n\
    \    (and (number? n) (< n 0)))\n  (define (largest-negative lst)\n    (apply\
    \ max (filter is-negative? lst)))\n  (define (smallest-positive lst)\n    (apply\
    \ min (filter is-positive? lst)))\n  (values (largest-negative lst) (smallest-positive\
    \ lst)))\n", "  (define (helper lst largest smallest)\n    (cond\n      [(empty?\
    \ lst) (values largest smallest)]\n      [(and (positive? (first lst)) (or (not\
    \ (positive? smallest)) (< (first lst) smallest)))\n       (helper (rest lst)\
    \ largest (first lst))]\n      [(and (negative? (first lst)) (or (not (negative?\
    \ largest)) (> (first lst) largest)))\n       (helper (rest lst) (first lst) smallest)]\n\
    \      [else (helper (rest lst) largest smallest)]))\n  (define (positive? n)\n\
    \    (and (number? n) (> n 0)))\n  (define (negative? n)\n    (and (number? n)\
    \ (< n 0)))\n  (helper lst #f #f))\n", "  (let ([neg-lst (filter (\u03BB (n) (<\
    \ n 0)) lst)]\n        [pos-lst (filter (\u03BB (n) (> n 0)) lst)])\n    (if (empty?\
    \ neg-lst)\n        (cons 'None (if (empty? pos-lst) 'None (min pos-lst)))\n \
    \       (cons (max neg-lst) (if (empty? pos-lst) 'None (min pos-lst))))))\n",
  "  (define (is-positive? n)\n    (and (integer? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (integer? n) (< n 0)))\n  (define (find-largest-negative lst)\n\
    \    (cond [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car lst)\
    \ (find-largest-negative (cdr lst)))]\n          [else (find-largest-negative\
    \ (cdr lst))]))\n  (define (find-smallest-positive lst)\n    (cond [(null? lst)\
    \ #f]\n          [(is-positive? (car lst)) (min (car lst) (find-smallest-positive\
    \ (cdr lst)))]\n          [else (find-smallest-positive (cdr lst))]))\n  (define\
    \ (none? n)\n    (not n))\n  (define (convert-none n)\n    (if (none? n)\n   \
    \     'None\n        n))\n  (cons (convert-none (find-largest-negative lst))\n\
    \        (convert-none (find-smallest-positive lst))))\n", "  (let ([negs (filter\
    \ (lambda (x) (negative? x)) lst)]\n        [pos (filter (lambda (x) (positive?\
    \ x)) lst)])\n    (if (empty? negs)\n        (cons #f (if (empty? pos) #f (min\
    \ pos)))\n        (cons (max negs) (if (empty? pos) #f (min pos))))))\n", "  (define\
    \ (is-negative n)\n    (and (number? n) (< n 0)))\n  (define (is-positive n)\n\
    \    (and (number? n) (> n 0)))\n  (define (max-negative lst)\n    (cond\n   \
    \   [(empty? lst) #f]\n      [(is-negative (first lst)) (max (first lst) (max-negative\
    \ (rest lst)))]\n      [else (max-negative (rest lst))]))\n  (define (min-positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-positive (first lst)) (min\
    \ (first lst) (min-positive (rest lst)))]\n      [else (min-positive (rest lst))]))\n\
    \  (define (none? n)\n    (not (number? n)))\n  (values (if (none? (max-negative\
    \ lst)) #f (max-negative lst))\n          (if (none? (min-positive lst)) #f (min-positive\
    \ lst))))\n", "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define\
    \ (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define (get-largest-negative\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car\
    \ lst) (get-largest-negative (cdr lst)))]\n          [else (get-largest-negative\
    \ (cdr lst))]))\n  (define (get-smallest-positive lst)\n    (cond [(null? lst)\
    \ #f]\n          [(is-positive? (car lst)) (min (car lst) (get-smallest-positive\
    \ (cdr lst)))]\n          [else (get-smallest-positive (cdr lst))]))\n  (define\
    \ largest-negative (get-largest-negative lst))\n  (define smallest-positive (get-smallest-positive\
    \ lst))\n  (cond [(and (not largest-negative) (not smallest-positive)) (values\
    \ #f #f)]\n        [(not largest-negative) (values #f smallest-positive)]\n  \
    \      [(not smallest-positive) (values largest-negative #f)]\n        [else (values\
    \ largest-negative smallest-positive)]))\n", "  (define (is-positive? n)\n   \
    \ (and (integer? n) (> n 0)))\n  (define (is-negative? n)\n    (and (integer?\
    \ n) (< n 0)))\n  (define (max-negatives lst)\n    (apply max (filter is-negative?\
    \ lst)))\n  (define (min-positives lst)\n    (apply min (filter is-positive? lst)))\n\
    \  (define (none? n)\n    (not (and (integer? n) (> n 0))))\n  (define (none-or-n\
    \ n)\n    (if (none? n) 'None n))\n  (values (none-or-n (max-negatives lst))\n\
    \          (none-or-n (min-positives lst))))\n", "  (cond\n    [(empty? lst) (values\
    \ 'None 'None)]\n    [(andmap number? lst) (values 'None 'None)]\n    [else (values\
    \ (apply max (filter negative? lst))\n                  (apply min (filter positive?\
    \ lst)))]))\n", "  (define (is-positive? n)\n    (and (integer? n) (> n 0)))\n\
    \  (define (is-negative? n)\n    (and (integer? n) (< n 0)))\n  (define (is-zero?\
    \ n)\n    (and (integer? n) (= n 0)))\n  (define (is-integer? n)\n    (and (integer?\
    \ n) (not (is-zero? n))))\n  (define (largest-negative lst)\n    (cond\n     \
    \ [(null? lst) #f]\n      [(is-negative? (car lst)) (max (car lst) (largest-negative\
    \ (cdr lst)))]\n      [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(is-positive? (car lst)) (min\
    \ (car lst) (smallest-positive (cdr lst)))]\n      [else (smallest-positive (cdr\
    \ lst))]))\n  (define (largest-smallest-integers-helper lst)\n    (cond\n    \
    \  [(null? lst) (cons #f #f)]\n      [(is-integer? (car lst)) (cons (largest-negative\
    \ lst) (smallest-positive lst))]\n      [else (largest-smallest-integers-helper\
    \ (cdr lst))]))\n  (largest-smallest-integers-helper lst))\n", "  (let ([negatives\
    \ (filter (lambda (x) (< x 0)) lst)]\n        [positives (filter (lambda (x) (>\
    \ x 0)) lst)])\n    (cond\n      [(empty? negatives) (cons 'None (cons (min positives)\
    \ '()))]\n      [(empty? positives) (cons (max negatives) (cons 'None '()))]\n\
    \      [else (cons (max negatives) (cons (min positives) '()))])))\n", "  (let\
    \ ([negatives (filter (\u03BB (x) (and (number? x) (< x 0))) lst)]\n        [positives\
    \ (filter (\u03BB (x) (and (number? x) (> x 0))) lst)])\n    (cond [(empty? negatives)\
    \ (cons #f (min positives))]\n          [(empty? positives) (cons (max negatives)\
    \ #f)]\n          [else (cons (max negatives) (min positives))])))\n", "  (cond\n\
    \    [(empty? lst) (values 'None 'None)]\n    [(andmap (lambda (x) (zero? x))\
    \ lst) (values 'None 'None)]\n    [else (values (apply max (filter negative? lst))\n\
    \                  (apply min (filter positive? lst)))]))\n", "  (let ([negs (filter\
    \ (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n\
    \    (if (empty? negs)\n        (cons #f (first pos))\n        (cons (apply max\
    \ negs) (first pos)))))\n", "  (define (largest-neg lst)\n    (cond [(empty? lst)\
    \ 'None]\n          [(and (negative? (first lst)) (not (negative? (second lst))))\
    \ (first lst)]\n          [else (largest-neg (rest lst))]))\n  (define (smallest-pos\
    \ lst)\n    (cond [(empty? lst) 'None]\n          [(and (positive? (first lst))\
    \ (not (positive? (second lst)))) (first lst)]\n          [else (smallest-pos\
    \ (rest lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (define\
    \ (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative? n)\n\
    \    (and (number? n) (< n 0)))\n  (define (filter-positive lst)\n    (filter\
    \ is-positive? lst))\n  (define (filter-negative lst)\n    (filter is-negative?\
    \ lst))\n  (define (min-positive lst)\n    (if (null? lst)\n        #f\n     \
    \   (apply min (filter-positive lst))))\n  (define (max-negative lst)\n    (if\
    \ (null? lst)\n        #f\n        (apply max (filter-negative lst))))\n  (values\
    \ (max-negative lst) (min-positive lst)))\n", "  (define (is-positive? n)\n  \
    \  (and (number? n)\n         (> n 0)))\n  (define (is-negative? n)\n    (and\
    \ (number? n)\n         (< n 0)))\n  (define (get-max-neg lst)\n    (cond\n  \
    \    [(null? lst) #f]\n      [(is-negative? (car lst)) (max (car lst) (get-max-neg\
    \ (cdr lst)))]\n      [else (get-max-neg (cdr lst))]))\n  (define (get-min-pos\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(is-positive? (car lst)) (min\
    \ (car lst) (get-min-pos (cdr lst)))]\n      [else (get-min-pos (cdr lst))]))\n\
    \  (define (get-max-neg-or-none lst)\n    (cond\n      [(null? lst) #f]\n    \
    \  [(is-negative? (car lst)) (max (car lst) (get-max-neg-or-none (cdr lst)))]\n\
    \      [else (get-max-neg-or-none (cdr lst))]))\n  (define (get-min-pos-or-none\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(is-positive? (car lst)) (min\
    \ (car lst) (get-min-pos-or-none (cdr lst)))]\n      [else (get-min-pos-or-none\
    \ (cdr lst))]))\n  (define (get-max-neg-or-none lst)\n    (cond\n      [(null?\
    \ lst) #f]\n      [(is-negative? (car lst)) (max (car lst) (get-max-neg-or-none\
    \ (cdr lst)))]\n      [else (get-max-neg-or-none (cdr lst))]))\n  (define (get-min-pos-or-none\
    \ lst)\n    (cond\n      [(null? lst) #f]\n     ", "  (define (is-positive? n)\n\
    \    (and (number? n)\n         (> n 0)))\n  (define (is-negative? n)\n    (and\
    \ (number? n)\n         (< n 0)))\n  (define (get-largest-negative lst)\n    (cond\
    \ [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car lst) (get-largest-negative\
    \ (cdr lst)))]\n          [else (get-largest-negative (cdr lst))]))\n  (define\
    \ (get-smallest-positive lst)\n    (cond [(null? lst) #f]\n          [(is-positive?\
    \ (car lst)) (min (car lst) (get-smallest-positive (cdr lst)))]\n          [else\
    \ (get-smallest-positive (cdr lst))]))\n  (define (get-largest-negative-or-none\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car\
    \ lst) (get-largest-negative-or-none (cdr lst)))]\n          [else #f]))\n  (define\
    \ (get-smallest-positive-or-none lst)\n    (cond [(null? lst) #f]\n          [(is-positive?\
    \ (car lst)) (min (car lst) (get-smallest-positive-or-none (cdr lst)))]\n    \
    \      [else #f]))\n  (define (get-largest-negative-or-none-or-none lst)\n   \
    \ (cond [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car lst) (get-largest-negative-or-none-or-none\
    \ (cdr lst)))]\n          [else #f]))\n  (define (get-smallest-positive-or-none-or-none\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-positive? (car lst)) (min (car\
    \ lst) (get-smallest-positive-or-none-or-none (cdr l", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) (error \"No negative integers\")]\n   \
    \   [(negative? (first lst)) (max (first lst) (largest_negative (rest lst)))]\n\
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) (error \"No positive integers\")]\n      [(positive?\
    \ (first lst)) (min (first lst) (smallest_positive (rest lst)))]\n      [else\
    \ (smallest_positive (rest lst))]))\n  (define (largest_smallest_integers_helper\
    \ lst)\n    (cond\n      [(empty? lst) (values None None)]\n      [(negative?\
    \ (first lst)) (values (largest_negative lst) (smallest_positive lst))]\n    \
    \  [(positive? (first lst)) (values (largest_negative lst) (smallest_positive\
    \ lst))]\n      [else (largest_smallest_integers_helper (rest lst))]))\n  (largest_smallest_integers_helper\
    \ lst))\n", "  (define (is-positive? n)\n    (> n 0))\n  (define (is-negative?\
    \ n)\n    (< n 0))\n  (define (get-positive-numbers lst)\n    (filter is-positive?\
    \ lst))\n  (define (get-negative-numbers lst)\n    (filter is-negative? lst))\n\
    \  (define (get-largest-negative-number lst)\n    (if (empty? lst)\n        'None\n\
    \        (apply max lst)))\n  (define (get-smallest-positive-number lst)\n   \
    \ (if (empty? lst)\n        'None\n        (apply min lst)))\n  (values (get-largest-negative-number\
    \ (get-negative-numbers lst))\n          (get-smallest-positive-number (get-positive-numbers\
    \ lst))))\n", "  (define (largest-neg lst)\n    (cond [(empty? lst) 'None]\n \
    \         [(and (negative? (first lst))\n                (or (null? (rest lst))\n\
    \                    (negative? (first (rest lst)))))\n           (first lst)]\n\
    \          [else (largest-neg (rest lst))]))\n  (define (smallest-pos lst)\n \
    \   (cond [(empty? lst) 'None]\n          [(and (positive? (first lst))\n    \
    \            (or (null? (rest lst))\n                    (positive? (first (rest\
    \ lst)))))\n           (first lst)]\n          [else (smallest-pos (rest lst))]))\n\
    \  (values (largest-neg lst) (smallest-pos lst)))\n", "  (define (largest-negative\
    \ lst)\n    (cond [(empty? lst) 'None]\n          [(negative? (first lst)) (max\
    \ (first lst) (largest-negative (rest lst)))]\n          [else (largest-negative\
    \ (rest lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) 'None]\n\
    \          [(positive? (first lst)) (min (first lst) (smallest-positive (rest\
    \ lst)))]\n          [else (smallest-positive (rest lst))]))\n  (cons (largest-negative\
    \ lst) (smallest-positive lst)))\n", "  (let ([negs (filter (lambda (x) (< x 0))\
    \ lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n    (cond\n      [(empty?\
    \ negs) (cons #f (min pos))]\n      [(empty? pos) (cons (max negs) #f)]\n    \
    \  [else (cons (max negs) (min pos))])))\n", "  (define (largest-negative lst)\n\
    \    (cond\n      [(empty? lst) 'None]\n      [(and (negative? (first lst))\n\
    \            (or (empty? (rest lst))\n                (positive? (first (rest\
    \ lst)))))\n       (first lst)]\n      [else (largest-negative (rest lst))]))\n\
    \  (define (smallest-positive lst)\n    (cond\n      [(empty? lst) 'None]\n  \
    \    [(and (positive? (first lst))\n            (or (empty? (rest lst))\n    \
    \            (negative? (first (rest lst)))))\n       (first lst)]\n      [else\
    \ (smallest-positive (rest lst))]))\n  (tuple (largest-negative lst) (smallest-positive\
    \ lst)))\n", "  (define (largest_smallest_integers_helper lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (values largest smallest)]\n      [(and (positive?\
    \ (first lst)) (not smallest))\n       (largest_smallest_integers_helper (rest\
    \ lst) largest (first lst))]\n      [(and (negative? (first lst)) (not largest))\n\
    \       (largest_smallest_integers_helper (rest lst) (first lst) smallest)]\n\
    \      [(and (positive? (first lst)) (< (first lst) smallest))\n       (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (> (first\
    \ lst) largest))\n       (largest_smallest_integers_helper (rest lst) (first lst)\
    \ smallest)]\n      [else (largest_smallest_integers_helper (rest lst) largest\
    \ smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n", "  (define\
    \ (helper lst largest smallest)\n    (cond [(empty? lst) (values largest smallest)]\n\
    \          [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n           (helper (rest lst) largest (first lst))]\n    \
    \      [(and (negative? (first lst)) (or (not (negative? largest)) (> (first lst)\
    \ largest)))\n           (helper (rest lst) (first lst) smallest)]\n         \
    \ [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n", " \
    \ (define (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define (is-positive?\
    \ n)\n    (and (number? n) (> n 0)))\n  (define (get-largest-negative lst)\n \
    \   (cond [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car lst)\
    \ (get-largest-negative (cdr lst)))]\n          [else (get-largest-negative (cdr\
    \ lst))]))\n  (define (get-smallest-positive lst)\n    (cond [(null? lst) #f]\n\
    \          [(is-positive? (car lst)) (min (car lst) (get-smallest-positive (cdr\
    \ lst)))]\n          [else (get-smallest-positive (cdr lst))]))\n  (define (get-largest-negative-or-none\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car\
    \ lst) (get-largest-negative-or-none (cdr lst)))]\n          [else (get-largest-negative-or-none\
    \ (cdr lst))]))\n  (define (get-smallest-positive-or-none lst)\n    (cond [(null?\
    \ lst) #f]\n          [(is-positive? (car lst)) (min (car lst) (get-smallest-positive-or-none\
    \ (cdr lst)))]\n          [else (get-smallest-positive-or-none (cdr lst))]))\n\
    \  (define (get-largest-negative-or-none lst)\n    (cond [(null? lst) #f]\n  \
    \        [(is-negative? (car lst)) (max (car lst) (get-largest-negative-or-none\
    \ (cdr lst)))]\n          [else (get-largest-negative-or-none (cdr lst))]))\n\
    \  (define (get-smallest-positive-or-none lst)\n    (cond [(null? lst) #f]\n \
    \         [(is-positive? (car lst", "  (cond\n    [(empty? lst) (values 'None\
    \ 'None)]\n    [(andmap positive? lst) (values 'None (min lst))]\n    [(andmap\
    \ negative? lst) (values (max lst) 'None)]\n    [else (values (max (filter negative?\
    \ lst)) (min (filter positive? lst)))]))\n", "  (define (largest-neg lst)\n  \
    \  (cond [(empty? lst) 'None]\n          [(negative? (first lst)) (max (first\
    \ lst) (largest-neg (rest lst)))]\n          [else (largest-neg (rest lst))]))\n\
    \  (define (smallest-pos lst)\n    (cond [(empty? lst) 'None]\n          [(positive?\
    \ (first lst)) (min (first lst) (smallest-pos (rest lst)))]\n          [else (smallest-pos\
    \ (rest lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (cond\n\
    \    [(empty? lst) (cons 'None 'None)]\n    [(not (number? (car lst))) (largest_smallest_integers\
    \ (cdr lst))]\n    [(and (number? (car lst)) (negative? (car lst)))\n     (cons\
    \ (car lst) (largest_smallest_integers (cdr lst)))]\n    [(and (number? (car lst))\
    \ (positive? (car lst)))\n     (cons 'None (car lst))]\n    [else (cons 'None\
    \ 'None)]))\n", "  (define (is-positive? n)\n    (> n 0))\n  (define (is-negative?\
    \ n)\n    (< n 0))\n  (define (is-zero? n)\n    (= n 0))\n  (define (is-integer?\
    \ n)\n    (integer? n))\n  (define (is-none? n)\n    (equal? n 'None))\n  (define\
    \ (is-not-none? n)\n    (not (is-none? n)))\n  (define (is-none-or-integer? n)\n\
    \    (or (is-none? n) (is-integer? n)))\n  (define (is-none-or-positive? n)\n\
    \    (or (is-none? n) (is-positive? n)))\n  (define (is-none-or-negative? n)\n\
    \    (or (is-none? n) (is-negative? n)))\n  (define (is-none-or-zero? n)\n   \
    \ (or (is-none? n) (is-zero? n)))\n  (define (is-none-or-not-none? n)\n    (or\
    \ (is-none? n) (is-not-none? n)))\n  (define (is-none-or-none-or-integer? n)\n\
    \    (or (is-none? n) (is-none-or-integer? n)))\n  (define (is-none-or-none-or-positive?\
    \ n)\n    (or (is-none? n) (is-none-or-positive? n)))\n  (define (is-none-or-none-or-negative?\
    \ n)\n    (or (is-none? n) (is-none-or-negative? n)))\n  (define (is-none-or-none-or-zero?\
    \ n)\n    (or (is-none? n) (is-none-or-zero? n)))\n  (define (is-none-or-none-or-not-none?\
    \ n)\n    (or (is-none? n) (is-none-or-not-none? n)))\n  (define (is-none-or-none-or-none-or-integer?",
  "  (define (loop lst largest smallest)\n    (cond [(empty? lst) (values largest\
    \ smallest)]\n          [(and (positive? (first lst)) (not (positive? smallest)))\n\
    \           (loop (rest lst) largest (first lst))]\n          [(and (negative?\
    \ (first lst)) (not (negative? largest)))\n           (loop (rest lst) (first\
    \ lst) smallest)]\n          [else (loop (rest lst) largest smallest)]))\n  (loop\
    \ lst #f #f))\n", "  (define (largest-neg lst)\n    (cond\n      [(null? lst)\
    \ #f]\n      [(and (number? (car lst)) (< (car lst) 0)) (max (car lst) (largest-neg\
    \ (cdr lst)))]\n      [else (largest-neg (cdr lst))]))\n  (define (smallest-pos\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (number? (car lst)) (>\
    \ (car lst) 0)) (min (car lst) (smallest-pos (cdr lst)))]\n      [else (smallest-pos\
    \ (cdr lst))]))\n  (cond\n    [(null? lst) (values #f #f)]\n    [(and (number?\
    \ (car lst)) (= (car lst) 0)) (values #f #f)]\n    [else (values (largest-neg\
    \ lst) (smallest-pos lst))]))\n", "  (let ([negatives (filter (lambda (x) (negative?\
    \ x)) lst)]\n        [positives (filter (lambda (x) (positive? x)) lst)])\n  \
    \  (if (empty? negatives)\n        (cons #f (if (empty? positives) #f (min positives)))\n\
    \        (cons (max negatives) (if (empty? positives) #f (min positives))))))\n",
  "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (largest-negative lst)\n    (cond\
    \ [(empty? lst) #f]\n          [(is-negative? (first lst)) (max (first lst) (largest-negative\
    \ (rest lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (define (none? n)\n    (not (number? n)))\n  (define (none-or-value\
    \ n)\n    (if (none? n) 'None n))\n  (values (none-or-value (largest-negative\
    \ lst))\n          (none-or-value (smallest-positive lst))))\n", "  (define (is-positive?\
    \ n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (positive-integers\
    \ lst)\n    (filter is-positive? lst))\n  (define (negative-integers lst)\n  \
    \  (filter is-negative? lst))\n  (define (largest-negative-integer lst)\n    (if\
    \ (null? lst)\n        'None\n        (apply max lst)))\n  (define (smallest-positive-integer\
    \ lst)\n    (if (null? lst)\n        'None\n        (apply min lst)))\n  (values\
    \ (largest-negative-integer (negative-integers lst))\n          (smallest-positive-integer\
    \ (positive-integers lst))))\n", "  (define (is-positive? n)\n    (and (integer?\
    \ n) (> n 0)))\n  (define (is-negative? n)\n    (and (integer? n) (< n 0)))\n\
    \  (define (max-negatives lst)\n    (cond [(empty? lst) #f]\n          [(is-negative?\
    \ (first lst)) (max (first lst) (max-negatives (rest lst)))]\n          [else\
    \ (max-negatives (rest lst))]))\n  (define (min-positives lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(is-positive? (first lst)) (min (first lst) (min-positives\
    \ (rest lst)))]\n          [else (min-positives (rest lst))]))\n  (cons (max-negatives\
    \ lst) (min-positives lst)))\n", "  (define (helper lst largest smallest)\n  \
    \  (cond [(empty? lst) (values largest smallest)]\n          [(and (positive?\
    \ (first lst)) (or (not (positive? smallest)) (&lt; (first lst) smallest)))\n\
    \           (helper (rest lst) largest (first lst))]\n          [(and (negative?\
    \ (first lst)) (or (not (negative? largest)) (&gt; (first lst) largest)))\n  \
    \         (helper (rest lst) (first lst) smallest)]\n          [else (helper (rest\
    \ lst) largest smallest)]))\n  (helper lst #f #f))\n", "  (define (is-positive?\
    \ n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (is-zero?\
    \ n)\n    (= n 0))\n  (define (is-integer? n)\n    (and (integer? n)\n       \
    \  (not (is-zero? n))))\n  (define (is-positive-integer? n)\n    (and (is-integer?\
    \ n)\n         (is-positive? n)))\n  (define (is-negative-integer? n)\n    (and\
    \ (is-integer? n)\n         (is-negative? n)))\n  (define (largest-negative-integer\
    \ lst)\n    (if (null? lst)\n        'None\n        (if (is-negative-integer?\
    \ (car lst))\n            (max (car lst) (largest-negative-integer (cdr lst)))\n\
    \            (largest-negative-integer (cdr lst)))))\n  (define (smallest-positive-integer\
    \ lst)\n    (if (null? lst)\n        'None\n        (if (is-positive-integer?\
    \ (car lst))\n            (min (car lst) (smallest-positive-integer (cdr lst)))\n\
    \            (smallest-positive-integer (cdr lst)))))\n  (cons (largest-negative-integer\
    \ lst)\n        (smallest-positive-integer lst)))\n", "  (define (is-positive?\
    \ n)\n    (and (integer? n) (> n 0)))\n  (define (is-negative? n)\n    (and (integer?\
    \ n) (< n 0)))\n  (define (is-zero? n)\n    (and (integer? n) (= n 0)))\n  (define\
    \ (is-integer? n)\n    (integer? n))\n  (define (is-not-integer? n)\n    (not\
    \ (is-integer? n)))\n  (define (is-not-zero? n)\n    (not (is-zero? n)))\n  (define\
    \ (is-not-positive? n)\n    (not (is-positive? n)))\n  (define (is-not-negative?\
    \ n)\n    (not (is-negative? n)))\n  (define (is-not-zero-or-positive? n)\n  \
    \  (not (or (is-zero? n) (is-positive? n))))\n  (define (is-not-zero-or-negative?\
    \ n)\n    (not (or (is-zero? n) (is-negative? n))))\n  (define (is-not-zero-or-integer?\
    \ n)\n    (not (or (is-zero? n) (is-integer? n))))\n  (define (is-not-positive-or-integer?\
    \ n)\n    (not (or (is-positive? n) (is-integer? n))))\n  (define (is-not-negative-or-integer?\
    \ n)\n    (not (or (is-negative? n) (is-integer? n))))\n  (define (is-not-positive-or-negative?\
    \ n)\n    (not (or (is-positive? n) (is-negative? n))))\n  (define (is-not-positive-or-negative-or-integer?\
    \ n)\n    (not (or (is-positive? n) (is-negative? n) (is-integer? n))))\n  (define\
    \ (is-not-zero-or-positive-or-integer? n)\n    (not (or (is-zero? n) (is-positive?\
    \ n) (is-integer? n))))\n  (define (is-not", "  (define (is-positive? n)\n   \
    \ (and (number? n) (> n 0)))\n  (define (is-negative? n)\n    (and (number? n)\
    \ (< n 0)))\n  (define (largest-negative lst)\n    (cond\n      [(null? lst) #f]\n\
    \      [(is-negative? (car lst)) (max (car lst) (largest-negative (cdr lst)))]\n\
    \      [else (largest-negative (cdr lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond\n      [(null? lst) #f]\n      [(is-positive? (car lst)) (min (car\
    \ lst) (smallest-positive (cdr lst)))]\n      [else (smallest-positive (cdr lst))]))\n\
    \  (cons (largest-negative lst) (smallest-positive lst)))\n", "  (define (is-positive?\
    \ n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (is-zero?\
    \ n)\n    (= n 0))\n  (define (is-integer? n)\n    (and (integer? n)\n       \
    \  (not (is-zero? n))))\n  (define (is-positive-integer? n)\n    (and (is-integer?\
    \ n)\n         (is-positive? n)))\n  (define (is-negative-integer? n)\n    (and\
    \ (is-integer? n)\n         (is-negative? n)))\n  (define (find-largest-negative-integer\
    \ lst)\n    (cond\n      [(empty? lst) (error \"no negative integers in list\"\
    )]\n      [(is-negative-integer? (first lst))\n       (max (first lst) (find-largest-negative-integer\
    \ (rest lst)))]\n      [else (find-largest-negative-integer (rest lst))]))\n \
    \ (define (find-smallest-positive-integer lst)\n    (cond\n      [(empty? lst)\
    \ (error \"no positive integers in list\")]\n      [(is-positive-integer? (first\
    \ lst))\n       (min (first lst) (find-smallest-positive-integer (rest lst)))]\n\
    \      [else (find-smallest-positive-integer (rest lst))]))\n  (define (find-largest-negative-integer-or-none\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(is-negative-integer? (first\
    \ lst))\n       (max (first lst) (find-largest-negative-integer-or-none (rest\
    \ lst)))]\n      [else (find-largest-negative-integer-or-none (rest lst))]))\n\
    \  (define (find-smallest-positive-integer-or-none lst)\n    (cond\n      [(empty?\
    \ lst) 'None]\n      [(is-positive-integer? (first lst))\n       (min (first lst)\
    \ (find-smallest-positive-integer-or-none (rest lst)))]", "  (define (largest-neg\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(and (number? (first lst))\
    \ (< (first lst) 0))\n       (max (first lst) (largest-neg (rest lst)))]\n   \
    \   [else (largest-neg (rest lst))]))\n  (define (smallest-pos lst)\n    (cond\n\
    \      [(empty? lst) 'None]\n      [(and (number? (first lst)) (> (first lst)\
    \ 0))\n       (min (first lst) (smallest-pos (rest lst)))]\n      [else (smallest-pos\
    \ (rest lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (define\
    \ (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define (is-positive? n)\n\
    \    (and (number? n) (> n 0)))\n  (define (is-zero? n)\n    (and (number? n)\
    \ (= n 0)))\n  (define (is-zero-or-positive? n)\n    (or (is-zero? n) (is-positive?\
    \ n)))\n  (define (is-zero-or-negative? n)\n    (or (is-zero? n) (is-negative?\
    \ n)))\n  (define (largest-negative lst)\n    (cond [(empty? lst) #f]\n      \
    \    [(is-negative? (first lst)) (max (first lst) (largest-negative (rest lst)))]\n\
    \          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (define (largest-negative-or-zero lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(is-zero-or-negative? (first lst)) (max (first lst) (largest-negative-or-zero\
    \ (rest lst)))]\n          [else (largest-negative-or-zero (rest lst))]))\n  (define\
    \ (smallest-positive-or-zero lst)\n    (cond [(empty? lst) #f]\n          [(is-zero-or-positive?\
    \ (first lst)) (min (first lst) (smallest-positive-or-zero (rest lst)))]\n   \
    \       [else (smallest-positive-or-zero (rest lst))]))\n  (cond [(empty? lst)\
    \ (cons #f #f)]\n        [(and (is-zero-or-negative? (first lst)) (is-zero-or-positive?\
    \ (first lst))) (cons #f #f)]\n        [(is-zero-or", "  (define (largest-neg\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(< (first lst) 0) (max (first\
    \ lst) (largest-neg (rest lst)))]\n      [else (largest-neg (rest lst))]))\n \
    \ (define (smallest-pos lst)\n    (cond\n      [(empty? lst) 'None]\n      [(>\
    \ (first lst) 0) (min (first lst) (smallest-pos (rest lst)))]\n      [else (smallest-pos\
    \ (rest lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (define\
    \ (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define (is-positive? n)\n\
    \    (and (number? n) (> n 0)))\n  (define (largest-negative lst)\n    (cond [(null?\
    \ lst) #f]\n          [(is-negative? (car lst)) (max (car lst) (largest-negative\
    \ (cdr lst)))]\n          [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-positive? (car lst)) (min (car\
    \ lst) (smallest-positive (cdr lst)))]\n          [else (smallest-positive (cdr\
    \ lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n", "  (define\
    \ (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative? n)\n\
    \    (and (number? n) (< n 0)))\n  (define (filter-positive lst)\n    (filter\
    \ is-positive? lst))\n  (define (filter-negative lst)\n    (filter is-negative?\
    \ lst))\n  (define (min-positive lst)\n    (if (null? lst)\n        #f\n     \
    \   (apply min (filter-positive lst))))\n  (define (max-negative lst)\n    (if\
    \ (null? lst)\n        #f\n        (apply max (filter-negative lst))))\n  (cons\
    \ (max-negative lst) (min-positive lst)))\n", "  (define (is-positive? n)\n  \
    \  (and (integer? n)\n         (> n 0)))\n  (define (is-negative? n)\n    (and\
    \ (integer? n)\n         (< n 0)))\n  (define (positive-integers lst)\n    (filter\
    \ is-positive? lst))\n  (define (negative-integers lst)\n    (filter is-negative?\
    \ lst))\n  (define (largest-negative-integer lst)\n    (if (empty? lst)\n    \
    \    #f\n        (max (first lst)\n             (largest-negative-integer (rest\
    \ lst)))))\n  (define (smallest-positive-integer lst)\n    (if (empty? lst)\n\
    \        #f\n        (min (first lst)\n             (smallest-positive-integer\
    \ (rest lst)))))\n  (values (largest-negative-integer (negative-integers lst))\n\
    \          (smallest-positive-integer (positive-integers lst))))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(null? lst) 'None]\n      [(and (negative?\
    \ (car lst)) (not (null? (cdr lst))))\n       (if (negative? (car (cdr lst)))\n\
    \           (largest_negative (cdr lst))\n           (car lst))]\n      [(negative?\
    \ (car lst)) (car lst)]\n      [else (largest_negative (cdr lst))]))\n  (define\
    \ (smallest_positive lst)\n    (cond\n      [(null? lst) 'None]\n      [(and (positive?\
    \ (car lst)) (not (null? (cdr lst))))\n       (if (positive? (car (cdr lst)))\n\
    \           (smallest_positive (cdr lst))\n           (car lst))]\n      [(positive?\
    \ (car lst)) (car lst)]\n      [else (smallest_positive (cdr lst))]))\n  (cons\
    \ (largest_negative lst) (smallest_positive lst)))\n", "  (define (is-positive?\
    \ n)\n    (and (number? n) (> n 0)))\n  (define (is-negative? n)\n    (and (number?\
    \ n) (< n 0)))\n  (define (largest-negative lst)\n    (cond [(empty? lst) #f]\n\
    \          [(is-negative? (first lst)) (max (first lst) (largest-negative (rest\
    \ lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (define (largest-negative-or-none lst)\n    (cond [(largest-negative\
    \ lst) (largest-negative lst)]\n          [else 'None]))\n  (define (smallest-positive-or-none\
    \ lst)\n    (cond [(smallest-positive lst) (smallest-positive lst)]\n        \
    \  [else 'None]))\n  (list (largest-negative-or-none lst) (smallest-positive-or-none\
    \ lst)))\n", "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define\
    \ (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define (filter-positive\
    \ lst)\n    (filter is-positive? lst))\n  (define (filter-negative lst)\n    (filter\
    \ is-negative? lst))\n  (define (min-positive lst)\n    (if (null? lst)\n    \
    \    #f\n        (apply min (filter-positive lst))))\n  (define (max-negative\
    \ lst)\n    (if (null? lst)\n        #f\n        (apply max (filter-negative lst))))\n\
    \  (values (max-negative lst) (min-positive lst)))\n", "  (let ([negs (filter\
    \ (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n\
    \    (if (empty? negs)\n        (cons #f (if (empty? pos) #f (min pos)))\n   \
    \     (cons (max negs) (if (empty? pos) #f (min pos))))))\n", "  (define (helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (values largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (&lt; (first\
    \ lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n      [(and\
    \ (negative? (first lst)) (or (not (negative? largest)) (&gt; (first lst) largest)))\n\
    \       (helper (rest lst) (first lst) smallest)]\n      [else (helper (rest lst)\
    \ largest smallest)]))\n  (helper lst #f #f))\n", "  (let* ([negs (filter (lambda\
    \ (x) (negative? x)) lst)]\n         [pos (filter (lambda (x) (positive? x)) lst)])\n\
    \    (if (or (empty? negs) (empty? pos))\n        (values (if (empty? negs) #f\
    \ (max negs))\n                (if (empty? pos) #f (min pos)))\n        (values\
    \ (max negs) (min pos)))))\n", "  (define (is-positive? n)\n    (and (integer?\
    \ n) (> n 0)))\n  (define (is-negative? n)\n    (and (integer? n) (< n 0)))\n\
    \  (define (find-largest-negative lst)\n    (cond [(empty? lst) #f]\n        \
    \  [(is-negative? (first lst))\n           (max (first lst) (find-largest-negative\
    \ (rest lst)))]\n          [else (find-largest-negative (rest lst))]))\n  (define\
    \ (find-smallest-positive lst)\n    (cond [(empty? lst) #f]\n          [(is-positive?\
    \ (first lst))\n           (min (first lst) (find-smallest-positive (rest lst)))]\n\
    \          [else (find-smallest-positive (rest lst))]))\n  (define (none? n)\n\
    \    (not (number? n)))\n  (define (largest-negative lst)\n    (cond [(none? (find-largest-negative\
    \ lst)) #f]\n          [else (find-largest-negative lst)]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(none? (find-smallest-positive lst)) #f]\n          [else (find-smallest-positive\
    \ lst)]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n", "  (define\
    \ (is-positive? n)\n    (and (integer? n)\n         (positive? n)))\n  (define\
    \ (is-negative? n)\n    (and (integer? n)\n         (negative? n)))\n  (define\
    \ (largest-negative lst)\n    (cond [(empty? lst) #f]\n          [(is-negative?\
    \ (first lst))\n           (max (first lst) (largest-negative (rest lst)))]\n\
    \          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst))\n \
    \          (min (first lst) (smallest-positive (rest lst)))]\n          [else\
    \ (smallest-positive (rest lst))]))\n  (define (largest-negative-or-none lst)\n\
    \    (cond [(largest-negative lst) (largest-negative lst)]\n          [else 'None]))\n\
    \  (define (smallest-positive-or-none lst)\n    (cond [(smallest-positive lst)\
    \ (smallest-positive lst)]\n          [else 'None]))\n  (cons (largest-negative-or-none\
    \ lst)\n        (smallest-positive-or-none lst)))\n", "  (define (is-positive?\
    \ n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (is-zero?\
    \ n)\n    (= n 0))\n  (define (is-integer? n)\n    (and (integer? n)\n       \
    \  (not (is-zero? n))))\n  (define (get-largest-negative lst)\n    (cond\n   \
    \   [(null? lst) #f]\n      [(is-negative? (car lst)) (max (car lst) (get-largest-negative\
    \ (cdr lst)))]\n      [else (get-largest-negative (cdr lst))]))\n  (define (get-smallest-positive\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(is-positive? (car lst)) (min\
    \ (car lst) (get-smallest-positive (cdr lst)))]\n      [else (get-smallest-positive\
    \ (cdr lst))]))\n  (define (get-largest-negative-or-none lst)\n    (cond\n   \
    \   [(null? lst) #f]\n      [(is-integer? (car lst)) (get-largest-negative lst)]\n\
    \      [else (get-largest-negative-or-none (cdr lst))]))\n  (define (get-smallest-positive-or-none\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(is-integer? (car lst)) (get-smallest-positive\
    \ lst)]\n      [else (get-smallest-positive-or-none (cdr lst))]))\n  (define (get-largest-negative-or-none-or-none\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(is-integer? (car lst)) (get-largest-negative-or-none\
    \ lst)]\n      [else (get-largest-negative-or-none-or-none (cdr lst))]))\n  (define\
    \ (get-smallest-positive-or-none-or-none lst)\n    (cond\n      [(null?", "  (define\
    \ (is-positive? n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n \
    \ (define (is-zero? n)\n    (= n 0))\n  (define (is-integer? n)\n    (and (integer?\
    \ n)\n         (not (is-zero? n))))\n  (define (is-positive-integer? n)\n    (and\
    \ (is-integer? n)\n         (is-positive? n)))\n  (define (is-negative-integer?\
    \ n)\n    (and (is-integer? n)\n         (is-negative? n)))\n  (define (largest-negative-integer\
    \ lst)\n    (cond [(empty? lst)\n           'None]\n          [(is-negative-integer?\
    \ (first lst))\n           (max (first lst)\n                (largest-negative-integer\
    \ (rest lst)))]\n          [else\n           (largest-negative-integer (rest lst))]))\n\
    \  (define (smallest-positive-integer lst)\n    (cond [(empty? lst)\n        \
    \   'None]\n          [(is-positive-integer? (first lst))\n           (min (first\
    \ lst)\n                (smallest-positive-integer (rest lst)))]\n          [else\n\
    \           (smallest-positive-integer (rest lst))]))\n  (cons (largest-negative-integer\
    \ lst)\n        (smallest-positive-integer lst)))\n", "  (define (helper lst largest\
    \ smallest)\n    (cond\n      [(empty? lst) (cons largest smallest)]\n      [(and\
    \ (not (negative? (first lst))) (not (positive? (first lst))))\n       (helper\
    \ (rest lst) largest smallest)]\n      [(and (negative? (first lst)) (not (positive?\
    \ (first lst))))\n       (helper (rest lst) (first lst) smallest)]\n      [(and\
    \ (positive? (first lst)) (not (negative? (first lst))))\n       (helper (rest\
    \ lst) largest (first lst))]\n      [(and (positive? (first lst)) (negative? (first\
    \ lst)))\n       (helper (rest lst) (first lst) (first lst))]))\n  (helper lst\
    \ 'None 'None))\n", "  (define (helper lst largest smallest)\n    (cond [(empty?\
    \ lst) (values largest smallest)]\n          [(and (positive? (first lst)) (or\
    \ (not (positive? smallest)) (< (first lst) smallest)))\n           (helper (rest\
    \ lst) largest (first lst))]\n          [(and (negative? (first lst)) (or (not\
    \ (negative? largest)) (> (first lst) largest)))\n           (helper (rest lst)\
    \ (first lst) smallest)]\n          [else (helper (rest lst) largest smallest)]))\n\
    \  (helper lst #f #f))\n", "  (define (is-positive? n)\n    (and (integer? n)\
    \ (> n 0)))\n  (define (is-negative? n)\n    (and (integer? n) (< n 0)))\n  (define\
    \ (get-largest-negative lst)\n    (if (null? lst)\n        #f\n        (if (is-negative?\
    \ (car lst))\n            (max (car lst) (get-largest-negative (cdr lst)))\n \
    \           (get-largest-negative (cdr lst)))))\n  (define (get-smallest-positive\
    \ lst)\n    (if (null? lst)\n        #f\n        (if (is-positive? (car lst))\n\
    \            (min (car lst) (get-smallest-positive (cdr lst)))\n            (get-smallest-positive\
    \ (cdr lst)))))\n  (define (none? n)\n    (not n))\n  (define (get-largest-negative-or-none\
    \ lst)\n    (if (none? (get-largest-negative lst))\n        #f\n        (get-largest-negative\
    \ lst)))\n  (define (get-smallest-positive-or-none lst)\n    (if (none? (get-smallest-positive\
    \ lst))\n        #f\n        (get-smallest-positive lst)))\n  (cons (get-largest-negative-or-none\
    \ lst) (get-smallest-positive-or-none lst)))\n", "  (define (is-positive? n)\n\
    \    (and (number? n) (> n 0)))\n  (define (is-negative? n)\n    (and (number?\
    \ n) (< n 0)))\n  (define (get-largest-negative lst)\n    (cond [(empty? lst)\
    \ #f]\n          [(is-negative? (first lst)) (max (first lst) (get-largest-negative\
    \ (rest lst)))]\n          [else (get-largest-negative (rest lst))]))\n  (define\
    \ (get-smallest-positive lst)\n    (cond [(empty? lst) #f]\n          [(is-positive?\
    \ (first lst)) (min (first lst) (get-smallest-positive (rest lst)))]\n       \
    \   [else (get-smallest-positive (rest lst))]))\n  (define (get-largest-negative-or-none\
    \ lst)\n    (cond [(get-largest-negative lst) (get-largest-negative lst)]\n  \
    \        [else 'None]))\n  (define (get-smallest-positive-or-none lst)\n    (cond\
    \ [(get-smallest-positive lst) (get-smallest-positive lst)]\n          [else 'None]))\n\
    \  (cons (get-largest-negative-or-none lst) (get-smallest-positive-or-none lst)))\n",
  "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (positive-integers lst)\n    (filter\
    \ is-positive? lst))\n  (define (negative-integers lst)\n    (filter is-negative?\
    \ lst))\n  (define (largest-negative lst)\n    (apply max (negative-integers lst)))\n\
    \  (define (smallest-positive lst)\n    (apply min (positive-integers lst)))\n\
    \  (cond\n    [(empty? lst) (values 'None 'None)]\n    [(empty? (positive-integers\
    \ lst)) (values (largest-negative lst) 'None)]\n    [(empty? (negative-integers\
    \ lst)) (values 'None (smallest-positive lst))]\n    [else (values (largest-negative\
    \ lst) (smallest-positive lst))]))\n", "  (let ([negs (filter (lambda (x) (< x\
    \ 0)) lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n    (if (empty?\
    \ negs)\n        (cons 'None (if (empty? pos) 'None (min pos)))\n        (cons\
    \ (max negs) (if (empty? pos) 'None (min pos))))))\n", "  (define (helper lst)\n\
    \    (cond\n      [(empty? lst) (values '() '())]\n      [(and (positive? (first\
    \ lst)) (negative? (first lst)))\n       (values (cons (first lst) '()) (cons\
    \ (first lst) '()))]\n      [(positive? (first lst))\n       (let-values ([(negatives\
    \ positives) (helper (rest lst))])\n         (values negatives (cons (first lst)\
    \ positives)))]\n      [(negative? (first lst))\n       (let-values ([(negatives\
    \ positives) (helper (rest lst))])\n         (values (cons (first lst) negatives)\
    \ positives))]\n      [else (helper (rest lst))]))\n  (let-values ([(negatives\
    \ positives) (helper lst)])\n    (values (if (empty? negatives) 'None (apply max\
    \ negatives))\n            (if (empty? positives) 'None (apply min positives)))))\n",
  "  (define (helper lst max min)\n    (cond\n      [(empty? lst) (values max min)]\n\
    \      [(negative? (first lst)) (helper (rest lst) (max (first lst) max) min)]\n\
    \      [(positive? (first lst)) (helper (rest lst) max (min (first lst) min))]\n\
    \      [else (helper (rest lst) max min)]))\n  (helper lst (values -inf.0 inf.0)))\n",
  "  (let ([neg-lst (filter (lambda (x) (&lt; x 0)) lst)]\n        [pos-lst (filter\
    \ (lambda (x) (&gt; x 0)) lst)])\n    (if (empty? neg-lst)\n        (cons 'None\
    \ (if (empty? pos-lst) 'None (min pos-lst)))\n        (cons (max neg-lst) (if\
    \ (empty? pos-lst) 'None (min pos-lst))))))\n", "  (define (is-negative? n)\n\
    \    (and (number? n) (< n 0)))\n  (define (is-positive? n)\n    (and (number?\
    \ n) (> n 0)))\n  (define (largest-negative lst)\n    (cond [(empty? lst) #f]\n\
    \          [(is-negative? (first lst)) (max (first lst) (largest-negative (rest\
    \ lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (let* ([negative-numbers (filter (lambda (x) (< x 0)) lst)]\n         [positive-numbers\
    \ (filter (lambda (x) (> x 0)) lst)])\n    (cond\n      [(empty? negative-numbers)\
    \ (cons 'None (min positive-numbers))]\n      [(empty? positive-numbers) (cons\
    \ (max negative-numbers) 'None)]\n      [else (cons (max negative-numbers) (min\
    \ positive-numbers))])))\n", "  (define (is-positive? n)\n    (and (number? n)\
    \ (> n 0)))\n  (define (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define\
    \ (largest-negative lst)\n    (if (null? lst)\n        #f\n        (if (is-negative?\
    \ (car lst))\n            (max (car lst) (largest-negative (cdr lst)))\n     \
    \       (largest-negative (cdr lst)))))\n  (define (smallest-positive lst)\n \
    \   (if (null? lst)\n        #f\n        (if (is-positive? (car lst))\n      \
    \      (min (car lst) (smallest-positive (cdr lst)))\n            (smallest-positive\
    \ (cdr lst)))))\n  (define (largest-negative-or-none lst)\n    (if (largest-negative\
    \ lst)\n        (largest-negative lst)\n        'None))\n  (define (smallest-positive-or-none\
    \ lst)\n    (if (smallest-positive lst)\n        (smallest-positive lst)\n   \
    \     'None))\n  (cons (largest-negative-or-none lst) (smallest-positive-or-none\
    \ lst)))\n", "  (define (is-positive? n)\n    (> n 0))\n  (define (is-negative?\
    \ n)\n    (< n 0))\n  (define (largest-negative lst)\n    (cond\n      [(null?\
    \ lst) 'None]\n      [(is-negative? (car lst)) (max (car lst) (largest-negative\
    \ (cdr lst)))]\n      [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(null? lst) 'None]\n      [(is-positive? (car lst))\
    \ (min (car lst) (smallest-positive (cdr lst)))]\n      [else (smallest-positive\
    \ (cdr lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (define (helper lst)\n    (cond\n      [(null? lst) (values #f #f)]\n      [(and\
    \ (positive? (car lst)) (not (positive? (cadr lst)))) (values #f (car lst))]\n\
    \      [(and (negative? (car lst)) (not (negative? (cadr lst)))) (values (car\
    \ lst) #f)]\n      [else (apply values (helper (cdr lst)))]))\n  (apply values\
    \ (helper lst)))\n", "  (define (helper lst largest smallest)\n    (cond\n   \
    \   [(empty? lst) (cons largest smallest)]\n      [(and (positive? (first lst))\
    \ (or (negative? largest) (< (first lst) largest)))\n       (helper (rest lst)\
    \ (first lst) smallest)]\n      [(and (negative? (first lst)) (or (positive? smallest)\
    \ (> (first lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n\
    \      [else (helper (rest lst) largest smallest)]))\n  (helper lst (positive?\
    \ (first lst)) (negative? (first lst))))\n", "  (let* ([negs (filter (lambda (x)\
    \ (and (integer? x) (< x 0))) lst)]\n         [pos (filter (lambda (x) (and (integer?\
    \ x) (> x 0))) lst)])\n    (if (empty? negs)\n        (cons #f (if (empty? pos)\
    \ #f (min pos)))\n        (cons (max negs) (if (empty? pos) #f (min pos))))))\n",
  "  (define (is-positive? n)\n    (and (not (zero? n)) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (not (zero? n)) (< n 0)))\n  (define (largest-negative lst)\n \
    \   (cond [(empty? lst) #f]\n          [(is-negative? (first lst)) (max (first\
    \ lst) (largest-negative (rest lst)))]\n          [else (largest-negative (rest\
    \ lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) #f]\n \
    \         [(is-positive? (first lst)) (min (first lst) (smallest-positive (rest\
    \ lst)))]\n          [else (smallest-positive (rest lst))]))\n  (define (largest-negative-or-none\
    \ lst)\n    (cond [(largest-negative lst) (largest-negative lst)]\n          [else\
    \ #f]))\n  (define (smallest-positive-or-none lst)\n    (cond [(smallest-positive\
    \ lst) (smallest-positive lst)]\n          [else #f]))\n  (values (largest-negative-or-none\
    \ lst) (smallest-positive-or-none lst)))\n", "  (define (helper lst)\n    (cond\n\
    \      [(empty? lst) (values '() '())]\n      [(positive? (car lst)) (values (list\
    \ (car lst)) (cdr lst))]\n      [(negative? (car lst)) (values (list (car lst))\
    \ (cdr lst))]\n      [else (helper (cdr lst))]))\n  (define (get-max lst)\n  \
    \  (cond\n      [(empty? lst) '()]\n      [(positive? (car lst)) (get-max (cdr\
    \ lst))]\n      [(negative? (car lst)) (max (car lst) (get-max (cdr lst)))]\n\
    \      [else (get-max (cdr lst))]))\n  (define (get-min lst)\n    (cond\n    \
    \  [(empty? lst) '()]\n      [(positive? (car lst)) (min (car lst) (get-min (cdr\
    \ lst)))]\n      [(negative? (car lst)) (get-min (cdr lst))]\n      [else (get-min\
    \ (cdr lst))]))\n  (define (get-max-min lst)\n    (define (helper lst)\n     \
    \ (cond\n        [(empty? lst) (values '() '())]\n        [(positive? (car lst))\
    \ (values (list (car lst)) (cdr lst))]\n        [(negative? (car lst)) (values\
    \ (list (car lst)) (cdr lst))]\n        [else (helper (cdr lst))]))\n    (define\
    \ (get-max lst)\n      (cond\n        [(empty? lst) '()]\n        [(positive?\
    \ (car lst)) (get-max (cdr lst))]\n        [(negative? (car lst)) (max (car lst)\
    \ (get-max (cdr lst)))]\n        [else (get-max (cdr lst))]))\n    (define (get-min\
    \ lst)\n      (cond\n        [(empty? lst) '()]\n        [(positive? (car l",
  "  (define (largest-negative lst)\n    (cond\n      [(empty? lst) 'None]\n     \
    \ [(and (negative? (first lst)) (not (negative? (second lst)))) (first lst)]\n\
    \      [else (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond\n      [(empty? lst) 'None]\n      [(and (positive? (first lst)) (not\
    \ (positive? (second lst)))) (first lst)]\n      [else (smallest-positive (rest\
    \ lst))]))\n  (cons (largest-negative lst) (cons (smallest-positive lst) '())))\n",
  "  (let* ([negatives (filter (lambda (x) (and (number? x) (< x 0))) lst)]\n    \
    \     [positives (filter (lambda (x) (and (number? x) (> x 0))) lst)])\n    (if\
    \ (empty? negatives)\n        (cons #f (if (empty? positives) #f (min positives)))\n\
    \        (cons (max negatives) (if (empty? positives) #f (min positives))))))\n",
  "  (cond [(empty? lst) (cons 'None 'None)]\n        [(empty? (filter (lambda (x)\
    \ (< x 0)) lst)) (cons 'None (min (filter (lambda (x) (> x 0)) lst)))]\n     \
    \   [(empty? (filter (lambda (x) (> x 0)) lst)) (cons (max (filter (lambda (x)\
    \ (< x 0)) lst)) 'None)]\n        [else (cons (max (filter (lambda (x) (< x 0))\
    \ lst)) (min (filter (lambda (x) (> x 0)) lst)))]))\n", "  (define (is-positive?\
    \ n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (is-zero?\
    \ n)\n    (= n 0))\n  (define (is-integer? n)\n    (integer? n))\n  (define (is-none?\
    \ n)\n    (equal? n 'None))\n  (define (is-none-or-integer? n)\n    (or (is-none?\
    \ n) (is-integer? n)))\n  (define (is-none-or-positive? n)\n    (or (is-none?\
    \ n) (is-positive? n)))\n  (define (is-none-or-negative? n)\n    (or (is-none?\
    \ n) (is-negative? n)))\n  (define (is-none-or-zero? n)\n    (or (is-none? n)\
    \ (is-zero? n)))\n  (define (is-none-or-zero-or-positive? n)\n    (or (is-none?\
    \ n) (is-zero? n) (is-positive? n)))\n  (define (is-none-or-zero-or-negative?\
    \ n)\n    (or (is-none? n) (is-zero? n) (is-negative? n)))\n  (define (is-none-or-zero-or-integer?\
    \ n)\n    (or (is-none? n) (is-zero? n) (is-integer? n)))\n  (define (is-none-or-zero-or-positive-or-negative?\
    \ n)\n    (or (is-none? n) (is-zero? n) (is-positive? n) (is-negative? n)))\n\
    \  (define (is-none-or-zero-or-positive-or-negative-or-integer? n)\n    (or (is-none?\
    \ n) (is-zero? n) (is-positive? n) (is-negative? n) (is-integer? n)))\n  (define\
    \ (is-none-or-positive-or-negative? n)\n    (or (is-none? n) (is-positive? n)\
    \ (", "  (define (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define (is-positive?\
    \ n)\n    (and (number? n) (> n 0)))\n  (define (largest-negative lst)\n    (cond\
    \ [(empty? lst) #f]\n          [(is-negative? (first lst)) (max (first lst) (largest-negative\
    \ (rest lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (define (largest-smallest-integers-helper lst)\n    (cond\
    \ [(empty? lst) (values #f #f)]\n          [(is-negative? (first lst)) (values\
    \ (max (first lst) (largest-negative (rest lst))) (smallest-positive (rest lst)))]\n\
    \          [(is-positive? (first lst)) (values (largest-negative (rest lst)) (min\
    \ (first lst) (smallest-positive (rest lst))))]\n          [else (largest-smallest-integers-helper\
    \ (rest lst))]))\n  (define (largest-smallest-integers-helper2 lst)\n    (cond\
    \ [(empty? lst) (values #f #f)]\n          [(is-negative? (first lst)) (values\
    \ (max (first lst) (largest-negative (rest lst))) (smallest-positive (rest lst)))]\n\
    \          [(is-positive? (first lst)) (values (largest-negative (rest lst)) (min\
    \ (first lst) (smallest-positive (rest lst))))]\n          [else (largest-smallest-integers-helper2\
    \ (rest lst))]))\n  (define (largest-smallest-integers-helper3 lst)\n    (cond\
    \ [(empty? lst) (values #f #f)]\n          [(is-negative? (first", "  (cond\n\
    \    [(empty? lst) (cons 'None 'None)]\n    [(and (positive? (first lst)) (negative?\
    \ (first lst))) (cons 'None (first lst))]\n    [(and (positive? (first lst)) (not\
    \ (negative? (first lst)))) (cons 'None (first lst))]\n    [(and (negative? (first\
    \ lst)) (not (positive? (first lst)))) (cons (first lst) 'None)]\n    [(and (negative?\
    \ (first lst)) (positive? (first lst))) (cons (first lst) (first lst))]\n    [else\
    \ (cons 'None 'None)]))\n", "  (define (is-positive? n)\n    (and (number? n)\
    \ (> n 0)))\n  (define (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define\
    \ (filter-positive lst)\n    (filter is-positive? lst))\n  (define (filter-negative\
    \ lst)\n    (filter is-negative? lst))\n  (define (min-positive lst)\n    (if\
    \ (empty? lst)\n        'None\n        (apply min (filter-positive lst))))\n \
    \ (define (max-negative lst)\n    (if (empty? lst)\n        'None\n        (apply\
    \ max (filter-negative lst))))\n  (values (max-negative lst) (min-positive lst)))\n",
  "  (define (largest_smallest_integers_helper lst largest smallest)\n    (cond [(empty?\
    \ lst) (values largest smallest)]\n          [(and (positive? (first lst)) (or\
    \ (not (positive? smallest)) (< (first lst) smallest)))\n           (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n          [(and (negative? (first lst)) (or\
    \ (not (negative? largest)) (> (first lst) largest)))\n           (largest_smallest_integers_helper\
    \ (rest lst) (first lst) smallest)]\n          [else (largest_smallest_integers_helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f\
    \ #f))\n", "  (let ([negs (filter (\u03BB (x) (< x 0)) lst)]\n        [pos (filter\
    \ (\u03BB (x) (> x 0)) lst)])\n    (if (empty? negs)\n        (cons #f (if (empty?\
    \ pos) #f (min pos)))\n        (cons (max negs) (if (empty? pos) #f (min pos))))))\n",
  "  (define (is-neg? n)\n    (and (number? n) (< n 0)))\n  (define (is-pos? n)\n\
    \    (and (number? n) (> n 0)))\n  (define (max-neg lst)\n    (cond [(empty? lst)\
    \ #f]\n          [(is-neg? (first lst)) (max (first lst) (max-neg (rest lst)))]\n\
    \          [else (max-neg (rest lst))]))\n  (define (min-pos lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(is-pos? (first lst)) (min (first lst) (min-pos (rest lst)))]\n\
    \          [else (min-pos (rest lst))]))\n  (cons (max-neg lst) (min-pos lst)))\n",
  "  (let ([negs (filter (lambda (x) (and (number? x) (< x 0))) lst)]\n        [pos\
    \ (filter (lambda (x) (and (number? x) (> x 0))) lst)])\n    (if (empty? negs)\n\
    \        (cons #f (if (empty? pos) #f (min pos)))\n        (cons (max negs) (if\
    \ (empty? pos) #f (min pos))))))\n", "  (cond\n    [(empty? lst) (values 'None\
    \ 'None)]\n    [(and (positive? (first lst)) (negative? (first lst))) (values\
    \ 'None (first lst))]\n    [(and (positive? (first lst)) (negative? (first lst)))\
    \ (values (first lst) 'None)]\n    [(positive? (first lst)) (values 'None (first\
    \ lst))]\n    [(negative? (first lst)) (values (first lst) 'None)]\n    [else\
    \ (values 'None 'None)]))\n", "  (define (is-positive? n)\n    (and (integer?\
    \ n) (> n 0)))\n  (define (is-negative? n)\n    (and (integer? n) (< n 0)))\n\
    \  (define (largest-negative lst)\n    (cond [(null? lst) #f]\n          [(is-negative?\
    \ (car lst)) (max (car lst) (largest-negative (cdr lst)))]\n          [else (largest-negative\
    \ (cdr lst))]))\n  (define (smallest-positive lst)\n    (cond [(null? lst) #f]\n\
    \          [(is-positive? (car lst)) (min (car lst) (smallest-positive (cdr lst)))]\n\
    \          [else (smallest-positive (cdr lst))]))\n  (define (none? n)\n    (not\
    \ n))\n  (define (none-or-value n)\n    (if (none? n) 'None n))\n  (values (none-or-value\
    \ (largest-negative lst))\n          (none-or-value (smallest-positive lst))))\n",
  "  (cond\n    [(empty? lst) (cons 'None 'None)]\n    [(empty? (filter (lambda (x)\
    \ (and (integer? x) (positive? x))) lst)) (cons (apply max (filter (lambda (x)\
    \ (and (integer? x) (negative? x))) lst)) 'None)]\n    [(empty? (filter (lambda\
    \ (x) (and (integer? x) (negative? x))) lst)) (cons 'None (apply min (filter (lambda\
    \ (x) (and (integer? x) (positive? x))) lst)))]\n    [else (cons (apply max (filter\
    \ (lambda (x) (and (integer? x) (negative? x))) lst)) (apply min (filter (lambda\
    \ (x) (and (integer? x) (positive? x))) lst)))]))\n", "  (define (is-negative\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (is-positive n)\n    (and (number?\
    \ n) (> n 0)))\n  (define (largest-negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(is-negative (first lst)) (max (first lst) (largest-negative (rest\
    \ lst)))]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-positive (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (define (largest-negative-or-none lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(is-negative (first lst)) (max (first lst) (largest-negative-or-none\
    \ (rest lst)))]\n      [else (largest-negative-or-none (rest lst))]))\n  (define\
    \ (smallest-positive-or-none lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-positive\
    \ (first lst)) (min (first lst) (smallest-positive-or-none (rest lst)))]\n   \
    \   [else (smallest-positive-or-none (rest lst))]))\n  (define (largest-negative-or-none\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-negative (first lst)) (max\
    \ (first lst) (largest-negative-or-none (rest lst)))]\n      [else (largest-negative-or-none\
    \ (rest lst))]))\n  (define (smallest-positive-or-none lst)\n    (cond\n     \
    \ [(empty? lst) #f]\n      [(is-positive (first lst)) (min (first lst) (smallest-positive-or-none\
    \ (rest lst)))]\n      [else (smallest-positive-or-none (rest", "  (let ([negs\
    \ (filter (lambda (x) (negative? x)) lst)]\n        [pos (filter (lambda (x) (positive?\
    \ x)) lst)])\n    (if (or (empty? negs) (empty? pos))\n        (values (if (empty?\
    \ negs) 'None (max negs))\n                (if (empty? pos) 'None (min pos)))\n\
    \        (values (max negs) (min pos)))))\n", "  (define (is-negative? n)\n  \
    \  (and (integer? n) (< n 0)))\n  (define (is-positive? n)\n    (and (integer?\
    \ n) (> n 0)))\n  (define (largest-negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(is-negative? (first lst)) (max (first lst) (largest-negative (rest\
    \ lst)))]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-positive? (first lst))\
    \ (min (first lst) (smallest-positive (rest lst)))]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (let ([neg (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda (x)\
    \ (> x 0)) lst)])\n    (cond\n      [(empty? neg) (cons #f (min pos))]\n     \
    \ [(empty? pos) (cons (max neg) #f)]\n      [else (cons (max neg) (min pos))])))\n",
  "  (define (is-positive? n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n\
    \ 0))\n  (define (is-zero? n)\n    (= n 0))\n  (define (is-integer? n)\n    (integer?\
    \ n))\n  (define (is-none? n)\n    (eq? n 'None))\n  (define (is-not-none? n)\n\
    \    (not (is-none? n)))\n  (define (is-none-or-integer? n)\n    (or (is-none?\
    \ n) (is-integer? n)))\n  (define (is-none-or-positive? n)\n    (or (is-none?\
    \ n) (is-positive? n)))\n  (define (is-none-or-negative? n)\n    (or (is-none?\
    \ n) (is-negative? n)))\n  (define (is-none-or-zero? n)\n    (or (is-none? n)\
    \ (is-zero? n)))\n  (define (is-none-or-not-none? n)\n    (or (is-none? n) (is-not-none?\
    \ n)))\n  (define (is-none-or-not-none-or-integer? n)\n    (or (is-none? n) (is-not-none?\
    \ n) (is-integer? n)))\n  (define (is-none-or-not-none-or-positive? n)\n    (or\
    \ (is-none? n) (is-not-none? n) (is-positive? n)))\n  (define (is-none-or-not-none-or-negative?\
    \ n)\n    (or (is-none? n) (is-not-none? n) (is-negative? n)))\n  (define (is-none-or-not-none-or-zero?\
    \ n)\n    (or (is-none? n) (is-not-none? n) (is-zero? n)))\n  (define (is-none-or-not-none-or-not-none?\
    \ n)\n    (or (is-none? n) (is-not", "  (define (largest-negative lst)\n    (cond\n\
    \      [(null? lst) 'None]\n      [(< (car lst) 0) (max (car lst) (largest-negative\
    \ (cdr lst)))]\n      [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(null? lst) 'None]\n      [(> (car lst) 0) (min (car\
    \ lst) (smallest-positive (cdr lst)))]\n      [else (smallest-positive (cdr lst))]))\n\
    \  (cons (largest-negative lst) (smallest-positive lst)))\n", "  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (is-positive? n)\n    (and (number?\
    \ n) (> n 0)))\n  (define (largest-negative lst)\n    (cond [(empty? lst) #f]\n\
    \          [(is-negative? (first lst)) (max (first lst) (largest-negative (rest\
    \ lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (define (largest-negative-or-none lst)\n    (cond [(largest-negative\
    \ lst) (largest-negative lst)]\n          [else #f]))\n  (define (smallest-positive-or-none\
    \ lst)\n    (cond [(smallest-positive lst) (smallest-positive lst)]\n        \
    \  [else #f]))\n  (cons (largest-negative-or-none lst) (smallest-positive-or-none\
    \ lst)))\n", "  (define (largest-negative lst)\n    (cond\n      [(empty? lst)\
    \ 'None]\n      [(and (negative? (first lst)) (not (negative? (second lst))))\
    \ (first lst)]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) 'None]\n      [(and (positive? (first lst))\
    \ (not (positive? (second lst)))) (first lst)]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (define (is-positive? n)\n    (and (number? n)\n         (> n 0)))\n  (define\
    \ (is-negative? n)\n    (and (number? n)\n         (< n 0)))\n  (define (largest-negative\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-negative? (first lst))\n \
    \          (max (first lst) (largest-negative (rest lst)))]\n          [else (largest-negative\
    \ (rest lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) #f]\n\
    \          [(is-positive? (first lst))\n           (min (first lst) (smallest-positive\
    \ (rest lst)))]\n          [else (smallest-positive (rest lst))]))\n  (values\
    \ (largest-negative lst) (smallest-positive lst)))\n", "  (let* ([negs (filter\
    \ (lambda (x) (< x 0)) lst)]\n         [pos (filter (lambda (x) (> x 0)) lst)])\n\
    \    (if (empty? negs)\n        (cons 'None (if (empty? pos) 'None (min pos)))\n\
    \        (cons (max negs) (if (empty? pos) 'None (min pos))))))\n", "  (define\
    \ (is-positive? n)\n    (and (integer? n) (> n 0)))\n  (define (is-negative? n)\n\
    \    (and (integer? n) (< n 0)))\n  (define (largest-negative lst)\n    (if (null?\
    \ lst)\n        #f\n        (if (is-negative? (car lst))\n            (max (car\
    \ lst) (largest-negative (cdr lst)))\n            (largest-negative (cdr lst)))))\n\
    \  (define (smallest-positive lst)\n    (if (null? lst)\n        #f\n        (if\
    \ (is-positive? (car lst))\n            (min (car lst) (smallest-positive (cdr\
    \ lst)))\n            (smallest-positive (cdr lst)))))\n  (let ([largest-neg (largest-negative\
    \ lst)]\n        [smallest-pos (smallest-positive lst)])\n    (cond [(and (not\
    \ largest-neg) (not smallest-pos)) (values #f #f)]\n          [(not largest-neg)\
    \ (values #f smallest-pos)]\n          [(not smallest-pos) (values largest-neg\
    \ #f)]\n          [else (values largest-neg smallest-pos)])))\n", "  (define (is-positive?\
    \ n)\n    (and (number? n) (> n 0)))\n  (define (is-negative? n)\n    (and (number?\
    \ n) (< n 0)))\n  (define (is-zero? n)\n    (and (number? n) (= n 0)))\n  (define\
    \ (is-integer? n)\n    (and (number? n) (integer? n)))\n  (define (is-non-zero-integer?\
    \ n)\n    (and (is-integer? n) (not (is-zero? n))))\n  (define (is-non-zero-positive-integer?\
    \ n)\n    (and (is-integer? n) (not (is-zero? n)) (> n 0)))\n  (define (is-non-zero-negative-integer?\
    \ n)\n    (and (is-integer? n) (not (is-zero? n)) (< n 0)))\n  (define (get-largest-negative-integer\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-non-zero-negative-integer?\
    \ (first lst))\n           (max (first lst) (get-largest-negative-integer (rest\
    \ lst)))]\n          [else (get-largest-negative-integer (rest lst))]))\n  (define\
    \ (get-smallest-positive-integer lst)\n    (cond [(empty? lst) #f]\n         \
    \ [(is-non-zero-positive-integer? (first lst))\n           (min (first lst) (get-smallest-positive-integer\
    \ (rest lst)))]\n          [else (get-smallest-positive-integer (rest lst))]))\n\
    \  (define (get-largest-negative-integer-or-none lst)\n    (cond [(empty? lst)\
    \ #f]\n          [(is-non-zero-negative-integer? (first lst))\n           (max\
    \ (first lst) (get-largest-negative-integer-or-none (rest lst)))]\n          [else\
    \ (get-largest-negative-integer-or-none (rest lst))]))\n  (define (get-smallest-positive-integer-or-none\
    \ lst", "  (define (helper lst largest smallest)\n    (cond\n      [(null? lst)\
    \ (list largest smallest)]\n      [(and (positive? (car lst)) (or (not (positive?\
    \ smallest)) (< (car lst) smallest)))\n       (helper (cdr lst) largest (car lst))]\n\
    \      [(and (negative? (car lst)) (or (not (negative? largest)) (> (car lst)\
    \ largest)))\n       (helper (cdr lst) (car lst) smallest)]\n      [else (helper\
    \ (cdr lst) largest smallest)]))\n  (let ([result (helper lst #f #f)])\n    (if\
    \ (and (null? (car result)) (null? (cadr result)))\n        (list #f #f)\n   \
    \     result)))\n", "  (cond\n    [(empty? lst) (cons 'None 'None)]\n    [(empty?\
    \ (filter (lambda (x) (and (integer? x) (positive? x))) lst)) (cons (apply max\
    \ (filter (lambda (x) (and (integer? x) (negative? x))) lst)) 'None)]\n    [(empty?\
    \ (filter (lambda (x) (and (integer? x) (negative? x))) lst)) (cons 'None (apply\
    \ min (filter (lambda (x) (and (integer? x) (positive? x))) lst)))]\n    [else\
    \ (cons (apply max (filter (lambda (x) (and (integer? x) (negative? x))) lst))\
    \ (apply min (filter (lambda (x) (and (integer? x) (positive? x))) lst)))]))\n",
  "  (define (positive-integers lst)\n    (filter (lambda (x) (> x 0)) lst))\n  (define\
    \ (negative-integers lst)\n    (filter (lambda (x) (< x 0)) lst))\n  (define (largest-negative\
    \ lst)\n    (if (null? lst)\n        #f\n        (max (car lst) (largest-negative\
    \ (cdr lst)))))\n  (define (smallest-positive lst)\n    (if (null? lst)\n    \
    \    #f\n        (min (car lst) (smallest-positive (cdr lst)))))\n  (define (none?\
    \ x)\n    (or (eq? x #f) (eq? x '())))\n  (define (none-or-value x)\n    (if (none?\
    \ x)\n        'None\n        x))\n  (values (none-or-value (largest-negative (negative-integers\
    \ lst)))\n          (none-or-value (smallest-positive (positive-integers lst)))))\n",
  "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (largest-negative lst)\n    (cond\
    \ [(empty? lst) #f]\n          [(is-negative? (first lst)) (max (first lst) (largest-negative\
    \ (rest lst)))]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-positive? (first lst)) (min\
    \ (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (values (largest-negative lst) (smallest-positive lst)))\n",
  "  (let ([negs (filter (lambda (x) (and (number? x) (< x 0))) lst)]\n        [pos\
    \ (filter (lambda (x) (and (number? x) (> x 0))) lst)])\n    (if (or (empty? negs)\
    \ (empty? pos))\n        (values (if (empty? negs) #f (apply max negs))\n    \
    \            (if (empty? pos) #f (apply min pos)))\n        (values (apply max\
    \ negs) (apply min pos)))))\n", "  (cond\n    [(empty? lst) (cons 'None 'None)]\n\
    \    [(empty? (filter (lambda (x) (and (integer? x) (positive? x))) lst)) (cons\
    \ (apply max (filter (lambda (x) (and (integer? x) (negative? x))) lst)) 'None)]\n\
    \    [(empty? (filter (lambda (x) (and (integer? x) (negative? x))) lst)) (cons\
    \ 'None (apply min (filter (lambda (x) (and (integer? x) (positive? x))) lst)))]\n\
    \    [else (cons (apply max (filter (lambda (x) (and (integer? x) (negative? x)))\
    \ lst)) (apply min (filter (lambda (x) (and (integer? x) (positive? x))) lst)))]))\n",
  "  (define (largest-negative lst)\n    (cond\n      [(null? lst) 'None]\n      [(and\
    \ (number? (car lst)) (< (car lst) 0)) (max (car lst) (largest-negative (cdr lst)))]\n\
    \      [else (largest-negative (cdr lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond\n      [(null? lst) 'None]\n      [(and (number? (car lst)) (> (car\
    \ lst) 0)) (min (car lst) (smallest-positive (cdr lst)))]\n      [else (smallest-positive\
    \ (cdr lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (number? n) (< n 0)))\n  (define (largest-negative lst)\n    (cond\
    \ [(null? lst) #f]\n          [(is-negative? (car lst)) (max (car lst) (largest-negative\
    \ (cdr lst)))]\n          [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-positive? (car lst)) (min (car\
    \ lst) (smallest-positive (cdr lst)))]\n          [else (smallest-positive (cdr\
    \ lst))]))\n  (define (none? n)\n    (not (number? n)))\n  (define (largest-smallest-integers-helper\
    \ lst)\n    (cond [(null? lst) (cons #f #f)]\n          [(is-positive? (car lst))\
    \ (cons (largest-negative lst) (car lst))]\n          [(is-negative? (car lst))\
    \ (cons (car lst) (smallest-positive lst))]\n          [else (largest-smallest-integers-helper\
    \ (cdr lst))]))\n  (define (none-to-none? n)\n    (cond [(none? n) 'None]\n  \
    \        [else n]))\n  (cons (none-to-none? (car (largest-smallest-integers-helper\
    \ lst)))\n        (none-to-none? (cdr (largest-smallest-integers-helper lst)))))\n",
  "  (define (is-positive? n)\n    (and (number? n)\n         (> n 0)))\n  (define\
    \ (is-negative? n)\n    (and (number? n)\n         (< n 0)))\n  (define (largest-negative\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(is-negative? (first lst))\n \
    \          (max (first lst) (largest-negative (rest lst)))]\n          [else (largest-negative\
    \ (rest lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) #f]\n\
    \          [(is-positive? (first lst))\n           (min (first lst) (smallest-positive\
    \ (rest lst)))]\n          [else (smallest-positive (rest lst))]))\n  (values\
    \ (largest-negative lst) (smallest-positive lst)))\n", "  (define (helper lst\
    \ neg-max pos-min)\n    (cond\n      [(empty? lst) (values neg-max pos-min)]\n\
    \      [(and (negative? (first lst)) (or (not neg-max) (&gt; (first lst) neg-max)))\n\
    \       (helper (rest lst) (first lst) pos-min)]\n      [(and (positive? (first\
    \ lst)) (or (not pos-min) (&lt; (first lst) pos-min)))\n       (helper (rest lst)\
    \ neg-max (first lst))]\n      [else (helper (rest lst) neg-max pos-min)]))\n\
    \  (helper lst #f #f))\n", "  (define (largest_smallest_integers_helper lst largest\
    \ smallest)\n    (cond\n      [(empty? lst) (values largest smallest)]\n     \
    \ [(and (positive? (first lst))\n            (or (not (positive? smallest))\n\
    \                (< (first lst) smallest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst))\n    \
    \        (or (not (negative? largest))\n                (> (first lst) largest)))\n\
    \       (largest_smallest_integers_helper (rest lst) (first lst) smallest)]\n\
    \      [else (largest_smallest_integers_helper (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_helper lst #f #f))\n", "  (cond [(empty? lst) (values\
    \ 'None 'None)]\n        [(andmap number? lst) (values 'None 'None)]\n       \
    \ [else (values (apply max (filter negative? lst))\n                     (apply\
    \ min (filter positive? lst)))]))\n", "  (define (is-negative? n)\n    (and (number?\
    \ n) (< n 0)))\n  (define (is-positive? n)\n    (and (number? n) (> n 0)))\n \
    \ (define (largest-negative lst)\n    (if (null? lst)\n        #f\n        (if\
    \ (is-negative? (car lst))\n            (max (car lst) (largest-negative (cdr\
    \ lst)))\n            (largest-negative (cdr lst)))))\n  (define (smallest-positive\
    \ lst)\n    (if (null? lst)\n        #f\n        (if (is-positive? (car lst))\n\
    \            (min (car lst) (smallest-positive (cdr lst)))\n            (smallest-positive\
    \ (cdr lst)))))\n  (define (largest-negative-or-none lst)\n    (if (largest-negative\
    \ lst)\n        (largest-negative lst)\n        'None))\n  (define (smallest-positive-or-none\
    \ lst)\n    (if (smallest-positive lst)\n        (smallest-positive lst)\n   \
    \     'None))\n  (cons (largest-negative-or-none lst) (smallest-positive-or-none\
    \ lst)))\n", "  (define (is-positive? n)\n    (> n 0))\n  (define (is-negative?\
    \ n)\n    (< n 0))\n  (define (is-zero? n)\n    (= n 0))\n  (define (is-integer?\
    \ n)\n    (integer? n))\n  (define (is-none? n)\n    (equal? n 'None))\n  (define\
    \ (is-none-or-integer? n)\n    (or (is-none? n) (is-integer? n)))\n  (define (is-none-or-positive?\
    \ n)\n    (or (is-none? n) (is-positive? n)))\n  (define (is-none-or-negative?\
    \ n)\n    (or (is-none? n) (is-negative? n)))\n  (define (is-none-or-zero? n)\n\
    \    (or (is-none? n) (is-zero? n)))\n  (define (is-none-or-zero-or-positive?\
    \ n)\n    (or (is-none? n) (is-zero? n) (is-positive? n)))\n  (define (is-none-or-zero-or-negative?\
    \ n)\n    (or (is-none? n) (is-zero? n) (is-negative? n)))\n  (define (is-none-or-zero-or-integer?\
    \ n)\n    (or (is-none? n) (is-zero? n) (is-integer? n)))\n  (define (is-none-or-zero-or-positive-or-negative?\
    \ n)\n    (or (is-none? n) (is-zero? n) (is-positive? n) (is-negative? n)))\n\
    \  (define (is-none-or-positive-or-negative? n)\n    (or (is-none? n) (is-positive?\
    \ n) (is-negative? n)))\n  (define (is-none-or-positive-or-zero? n)\n    (or (is-none?\
    \ n) (is-positive? n) (is-zero? n)))\n  (define (is-none-or-negative-or-zero",
  "  (define (helper lst acc)\n    (cond\n      [(empty? lst) acc]\n      [(and (positive?\
    \ (first lst)) (or (null? (first acc)) (&lt; (first lst) (first acc))))\n    \
    \   (helper (rest lst) (cons (first lst) (rest acc)))]\n      [(and (negative?\
    \ (first lst)) (or (null? (second acc)) (&gt; (first lst) (second acc))))\n  \
    \     (helper (rest lst) (cons (second acc) (cons (first lst) (rest (rest acc)))))]\n\
    \      [else (helper (rest lst) acc)]))\n  (helper lst (list)))\n</code>\nI'm\
    \ not sure if this is the best way to do it, but it works.\n\n\nA:\n\nYou can\
    \ use <code>foldl</code> to iterate over the list, and <code>min</code> and <code>max</code>\
    \ to find the smallest and largest numbers:\n<code>(define (largest-smallest-integers\
    \ lst)\n  (define (helper acc x)\n    (cond\n      [(and (positive? x) (or (null?\
    \ (first acc)) (&lt; x (first acc))))\n       (cons x (second acc))]\n      [(and\
    \ (negative? x) (or (null? (second acc)) (&gt; x (second acc))))\n       (cons\
    \ (first acc) x)]\n      [else acc]))\n  (foldl helper (list) lst))\n</code>\n",
  "  (define (largest-negative lst)\n    (cond\n      [(empty? lst) 'None]\n     \
    \ [(< (first lst) 0) (max (first lst) (largest-negative (rest lst)))]\n      [else\
    \ (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n    (cond\n\
    \      [(empty? lst) 'None]\n      [(> (first lst) 0) (min (first lst) (smallest-positive\
    \ (rest lst)))]\n      [else (smallest-positive (rest lst))]))\n  (cons (largest-negative\
    \ lst) (smallest-positive lst)))\n", "  (define (helper lst)\n    (cond\n    \
    \  [(null? lst) (cons #f #f)]\n      [(and (positive? (car lst)) (not (cdr lst)))\
    \ (cons #f (car lst))]\n      [(and (negative? (car lst)) (not (cdr lst))) (cons\
    \ (car lst) #f)]\n      [(and (positive? (car lst)) (positive? (cadr lst))) (helper\
    \ (cdr lst))]\n      [(and (negative? (car lst)) (negative? (cadr lst))) (helper\
    \ (cdr lst))]\n      [(and (positive? (car lst)) (negative? (cadr lst))) (cons\
    \ (cadr lst) (car lst))]\n      [(and (negative? (car lst)) (positive? (cadr lst)))\
    \ (cons (car lst) (cadr lst))]))\n  (helper lst))\n", "  (define (is-positive?\
    \ n)\n    (> n 0))\n  (define (is-negative? n)\n    (< n 0))\n  (define (max-negatives\
    \ lst)\n    (cond\n      [(empty? lst) (error \"no negative integers\")]\n   \
    \   [(is-positive? (first lst)) (max-negatives (rest lst))]\n      [(is-negative?\
    \ (first lst)) (max (first lst) (max-negatives (rest lst)))]))\n  (define (min-positives\
    \ lst)\n    (cond\n      [(empty? lst) (error \"no positive integers\")]\n   \
    \   [(is-negative? (first lst)) (min-positives (rest lst))]\n      [(is-positive?\
    \ (first lst)) (min (first lst) (min-positives (rest lst)))]))\n  (define (largest-smallest\
    \ lst)\n    (cond\n      [(empty? lst) (error \"empty list\")]\n      [(is-positive?\
    \ (first lst)) (cons (max-negatives lst) (cons (min-positives lst) '()))]\n  \
    \    [(is-negative? (first lst)) (cons (max-negatives lst) (cons (min-positives\
    \ lst) '()))]))\n  (largest-smallest lst))\n", "  (define (is-positive? x)\n \
    \   (and (not (negative? x)) (not (zero? x))))\n  (define (is-negative? x)\n \
    \   (and (not (positive? x)) (not (zero? x))))\n  (define (largest-negative lst)\n\
    \    (cond [(empty? lst) #f]\n          [(is-negative? (first lst)) (max (first\
    \ lst) (largest-negative (rest lst)))]\n          [else (largest-negative (rest\
    \ lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) #f]\n \
    \         [(is-positive? (first lst)) (min (first lst) (smallest-positive (rest\
    \ lst)))]\n          [else (smallest-positive (rest lst))]))\n  (values (largest-negative\
    \ lst) (smallest-positive lst)))\n", "  (define (largest-neg lst)\n    (cond\n\
    \      [(null? lst) #f]\n      [(< (car lst) 0) (max (car lst) (largest-neg (cdr\
    \ lst)))]\n      [else (largest-neg (cdr lst))]))\n  (define (smallest-pos lst)\n\
    \    (cond\n      [(null? lst) #f]\n      [(> (car lst) 0) (min (car lst) (smallest-pos\
    \ (cdr lst)))]\n      [else (smallest-pos (cdr lst))]))\n  (cond\n    [(null?\
    \ lst) (values #f #f)]\n    [(null? (largest-neg lst)) (values #f (smallest-pos\
    \ lst))]\n    [(null? (smallest-pos lst)) (values (largest-neg lst) #f)]\n   \
    \ [else (values (largest-neg lst) (smallest-pos lst))]))\n", "  (let ([negs (filter\
    \ (lambda (x) (and (integer? x) (< x 0))) lst)]\n        [pos (filter (lambda\
    \ (x) (and (integer? x) (> x 0))) lst)])\n    (cond [(empty? negs) (cons #f (min\
    \ pos))]\n          [(empty? pos) (cons (max negs) #f)]\n          [else (cons\
    \ (max negs) (min pos))])))\n", "  (define (largest-negative lst)\n    (cond\n\
    \      [(empty? lst) 'None]\n      [(and (negative? (first lst))\n           \
    \ (or (empty? (rest lst))\n                (negative? (first (rest lst)))))\n\
    \       (first lst)]\n      [else (largest-negative (rest lst))]))\n  (define\
    \ (smallest-positive lst)\n    (cond\n      [(empty? lst) 'None]\n      [(and\
    \ (positive? (first lst))\n            (or (empty? (rest lst))\n             \
    \   (positive? (first (rest lst)))))\n       (first lst)]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (define (helper lst)\n    (cond [(empty? lst) (values '() '())]\n          [(positive?\
    \ (car lst)) (values (list (car lst)) (cdr lst))]\n          [(negative? (car\
    \ lst)) (values '() (cdr lst))]\n          [else (helper (cdr lst))]))\n  (let-values\
    \ ([(positives negatives) (helper lst)])\n    (values (if (empty? negatives) 'None\
    \ (apply max negatives))\n            (if (empty? positives) 'None (apply min\
    \ positives)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
