name: HumanEval_128_prod_signs
language: julia
results:
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = sum(abs(arr))\n \
    \       signs = map(sign, arr)\n        product = signs.*signs\n        return\
    \ sum_of_mags * prod(product)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nTask 3\nWrite a function that checks\
    \ if a number is even or odd.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpux28l5yf.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpux28l5yf.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else if length(arr) == 1 return arr[1]\n    else \n    \
    \    signs = zeros(Int, length(arr))\n        for i = 1:length(arr)\n        \
    \    signs[i] = sign(arr[i])\n        end\n        signs = signs * prod(signs)\n\
    \        return sum(abs2, signs)\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdqo7quw6.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdqo7quw6.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n       \
    \ mags = map(prod, mags) \n        mags = map(sign, mags) \n        mags = reduce(*,\
    \ mags) \n        return sum(mags) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptdjmga8c.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptdjmga8c.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = sum(signs) \n        return signs * prod(signs)\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the product of all\
    \ numbers in arr except the number that appears more than once in the array.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmal9gzvf.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmal9gzvf.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        return sum(signs .* prod.(signs))\n    end\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| c |>\nThis solution does not work for `[1, 1, 1]`\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now it works.\n\
    <|/ c |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjvaph97b.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjvaph97b.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = prod(signs) \n        return signs * prod(map(abs,\
    \ arr)) \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3sh75ob8.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3sh75ob8.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd91d6_nt.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd91d6_nt.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        \n        product = prod(signs)\n        magnitudes = map(abs,\
    \ arr)\n        return sum(magnitudes * product)\n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns number of integers in the array that\
    \ are positive.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppapgkbem.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppapgkbem.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs, 1) \n        return\
    \ product * reduce(mul, mags, 1) \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that finds\
    \ the number of positive integers less than or equal to a given integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg66vcndx.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg66vcndx.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return signs_product * sum_of_magnitudes \n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nI like this solution. One thing I noticed is that\
    \ `sign` returns a `Bool` so `signs = map(sign, arr)` can be simplified to `signs\
    \ = map(sign, arr)`.\n<|/ c |>\n<| a dscore=2 |>\nI like your solution. Here's\
    \ a slightly different one:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp4dgbpue.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpp4dgbpue.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), signs) \n        signs = map(x ->\
    \ sum(x), signs) \n        signs = map(x -> x / sum(x), signs) \n        return\
    \ sum(signs) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis code\
    \ does not work if `arr` is an empty array. `sum(signs([]))` returns `0`, which\
    \ is not the correct answer.\n<|/ c |>\n<| c |>\nI added a check for empty array\n\
    <|/ c |>\n<| c |>\nI added a check for empty array and fixed the bug\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpblh5vs54.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpblh5vs54.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = map(sign, arr) \n       \
    \ signs = filter(x -> x==1, signs) \n        signs = filter(x -> x==-1, signs)\
    \ \n        signs = filter(x -> x==0, signs) \n        signs = prod(signs) \n\
    \        mags = map(abs, arr) \n        mags = map(abs, mags) \n        mags =\
    \ map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mag\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1zrzhxsm.jl:71\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1zrzhxsm.jl:71\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr)) \n\
    \        return product * sum_of_magnitudes \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\n4.5 Write a function that returns True\
    \ if a number is power of two, False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu9ay_h64.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu9ay_h64.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None \n    else if length(arr)==1 return arr[1]*prod(signs(arr)) \n \
    \   else return arr[1]*prod(signs(arr))*prod_signs(arr[2:end]) \nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt_5m7xbn.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt_5m7xbn.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else return sum(map(abs, arr))*prod(map(sign, arr))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpym6w_fka.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpym6w_fka.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpym6w_fka.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    signs = zeros(Int, length(arr))\n    for (i,x) in enumerate(arr)\n\
    \        signs[i] = sign(x) * sign(i)\n    end\n    return sum(abs2, signs)\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2njglbev.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2njglbev.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        return nothing\n    else\n        sum = 0\n        for a in arr\n   \
    \         sum += abs(a)\n            sign = sign(a)\n            if sign==1\n\
    \                sum *= -1\n            end\n        end\n        return sum\n\
    \    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is odd, False otherwise. \nThe function should take one argument,\
    \ num.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjm2kofp8.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjm2kofp8.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        mags = map(abs, arr) \n        mags_prod\
    \ = prod(mags) \n        return signs_prod * mags_prod \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd, False otherwise.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdhw7xo6f.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdhw7xo6f.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    prod = 1\n    for x in arr\n        sum += abs(x)\n\
    \        prod *= sign(x)\n    end\n    return sum * prod\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns the number of positive numbers in an array.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp23yjdqar.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp23yjdqar.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        magnitudes = sqrt(sum(signs\
    \ .^ 2))\n        return product + magnitudes\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd, False otherwise.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpinl1q3__.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpinl1q3__.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs.(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprkrrhl5h.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprkrrhl5h.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        sum_of_mags\
    \ = sum(abs.(signs))\n        prod_of_signs = prod(signs)\n        return sum_of_mags\
    \ * prod_of_signs\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates the sum\
    \ of absolute values of all elements in an array.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkt2a128y.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkt2a128y.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)\n    end\n\
    \    return sum * prod(map(sign, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates\
    \ the sum of squares of integers multiplied by product of all signs of numbers\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5t2wriu7.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5t2wriu7.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpaoojaali.jl:64\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpaoojaali.jl:64\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n\
    @assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns True if a number is divisible by 3 and\
    \ False otherwise. Test it on all numbers from 1 to 100.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1eeyyzxh.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1eeyyzxh.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `prod_signs([1,2,2,-4])`\
    \ returns `-9` instead of `-9.0`.\n<|/ c |>\n<| c |>\nThanks, I fixed the answer.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwmcsap8i.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwmcsap8i.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs)\
    \ \n        return signs * prod(map(abs, arr)) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu65ldukd.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu65ldukd.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\n \
    \       return product * sum_of_magnitudes \n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyq10m8pi.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpyq10m8pi.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        product =\
    \ signs .* prod(signs)\n        return sum(abs.(product))\n    end\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm3yva913.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm3yva913.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = prod(signs) \n        return sum(map(abs, arr)\
    \ * signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares\
    \ of numbers in an array.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp70l1k4bs.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp70l1k4bs.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs\
    \ * prod(signs)\n        return signs\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjrkntsio.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjrkntsio.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9x7kadu1.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9x7kadu1.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, v) in enumerate(arr)\n            signs[i] = sign(v) * signs(i)\n\
    \        end\n        \n        return sum(abs2, signs)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpznltn8i4.jl:29\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 2, -4]) == -9\n  MethodError: objects of type\
    \ Array{Int64,1} are not callable\n  Use square brackets [] for indexing an Array.\n\
    \  Stacktrace:\n   [1] prod_signs(::Array{Int64,1}) at /tmp/tmpznltn8i4.jl:18\n\
    \   [2] top-level scope at /tmp/tmpznltn8i4.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpznltn8i4.jl:30\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 0\n  MethodError: objects of type Array{Int64,1} are not callable\n \
    \ Use square brackets [] for indexing an Array.\n  Stacktrace:\n   [1] prod_signs(::Array{Int64,1})\
    \ at /tmp/tmpznltn8i4.jl:18\n   [2] top-level scope at /tmp/tmpznltn8i4.jl:30\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpznltn8i4.jl:31\n  Test threw exception\n  Expression: candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10\n  MethodError: objects of type Array{Int64,1} are\
    \ not callable\n  Use square brackets [] for indexing an Array.\n  Stacktrace:\n\
    \   [1] prod_signs(::Array{Int64,1}) at /tmp/tmpznltn8i4.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpznltn8i4.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpznltn8i4.jl:32\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n  UndefVarError: None not defined\n  Stacktrace:\n   [1] prod_signs(::Array{Int64,1})\
    \ at /tmp/tmpznltn8i4.jl:14\n   [2] top-level scope at /tmp/tmpznltn8i4.jl:32\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpznltn8i4.jl:33\n  Test threw exception\n  Expression: candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20\n  MethodError: objects of type Array{Int64,1} are\
    \ not callable\n  Use square brackets [] for indexing an Array.\n  Stacktrace:\n\
    \   [1] prod_signs(::Array{Int64,1}) at /tmp/tmpznltn8i4.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpznltn8i4.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpznltn8i4.jl:34\n  Test threw exception\n  Expression: candidate([-1,\
    \ 1, -1, 1]) == 4\n  MethodError: objects of type Array{Int64,1} are not callable\n\
    \  Use square brackets [] for indexing an Array.\n  Stacktrace:\n   [1] prod_signs(::Array{Int64,1})\
    \ at /tmp/tmpznltn8i4.jl:18\n   [2] top-level scope at /tmp/tmpznltn8i4.jl:34\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpznltn8i4.jl:35\n  Test threw exception\n  Expression: candidate([-1,\
    \ 1, 1, 1]) == -4\n  MethodError: objects of type Array{Int64,1} are not callable\n\
    \  Use square brackets [] for indexing an Array.\n  Stacktrace:\n   [1] prod_signs(::Array{Int64,1})\
    \ at /tmp/tmpznltn8i4.jl:18\n   [2] top-level scope at /tmp/tmpznltn8i4.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpznltn8i4.jl:36\n  Test threw exception\n  Expression: candidate([-1,\
    \ 1, 1, 0]) == 0\n  MethodError: objects of type Array{Int64,1} are not callable\n\
    \  Use square brackets [] for indexing an Array.\n  Stacktrace:\n   [1] prod_signs(::Array{Int64,1})\
    \ at /tmp/tmpznltn8i4.jl:18\n   [2] top-level scope at /tmp/tmpznltn8i4.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpznltn8i4.jl:28\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpznltn8i4.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbaparuo7.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbaparuo7.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\n4.3 Product of Absolute Differences\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy4buhb__.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy4buhb__.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs\
    \ * prod(signs)\n        return signs\n    end\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that calculates sum of squares of integers multiplied by\
    \ product of all signs of each number in the array, represented by 1, -1 or 0.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeit092t8.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeit092t8.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else return sum(map(sign,\
    \ arr))\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.2 Sum all magnitudes of integers multiplied by product of all\
    \ signs\nWrite a function that takes an array of integers and returns sum of magnitudes\
    \ of integers multiplied by product of all signs of each number in the array,\
    \ represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0a_mk0xz.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0a_mk0xz.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        return sum(magnitudes * product)\n\
    \    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,arrays |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcsy_rgvt.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcsy_rgvt.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for x in arr\n        prod *= sign(x)\n   \
    \ end\n    return prod * sum(abs(x) for x in arr)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9xpdkxyt.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9xpdkxyt.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        sum_of_magnitudes\
    \ = sum(magnitudes) \n        return sum_of_magnitudes * product \nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd, False otherwise. \nThe function\
    \ should work for negative and positive numbers. \nThe function should work for\
    \ arrays of any length.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpisdjg7fr.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpisdjg7fr.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        \n        sum_of_mags = sum(abs.(signs))\n        prod_of_mags = prod(signs)\n\
    \        return sum_of_mags * prod_of_mags\n    end\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes an array arr of integers and returns its sum\
    \ of the absolute values of the integers multiplied by product of all signs of\
    \ each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfyhts6wt.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfyhts6wt.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    Thank you for your answer. Your solution is very similar to mine. My solution\
    \ is more concise and I wanted to compare the performance. Your solution is also\
    \ very concise. I am surprised that my solution is slower than yours. I guess\
    \ my solution is slower than yours because you use map and filter. I am surprised\
    \ that your solution is slower than mine. I am surprised that your solution is\
    \ slower than mine. I am surprised that your solution is slower than mine. I am\
    \ surprised that your solution is slower than mine. I am surprised that your solution\
    \ is slower than mine. I am surprised that your solution is slower than mine.\
    \ I am surprised that your solution is slower than mine. I am surprised that your\
    \ solution is slower than mine. I am surprised that your solution is slower than\
    \ mine. I am surprised that your solution is slower than mine. I am surprised\
    \ that your solution is slower than mine. I am surprised that your solution is\
    \ slower than mine. I am surprised that your solution is slower than mine. I am\
    \ surprised that your solution is slower than mine. I am surprised that your solution\
    \ is slower than mine. I am surprised that your solution is slower than mine.\
    \ I am surprised that your solution is slower than mine. I am surprised that your\
    \ solution is slower than mine. I am surprised that your solution is slower than\
    \ mine. I am surprised that your solution is slower than mine. I am surprised\
    \ that your solution is slower than mine. I am surprised that your solution is\
    \ slower than mine. I am surprised that your solution is slower than mine. I am\
    \ surprised that your solution is slower than mine. I am surprised that your solution\
    \ is slower than mine. I am surprised that your solution is slower than mine.\
    \ I am surprised that your solution is slower than mine. I am surprised that your\
    \ solution is slower than mine. I am surprised that your solution is slower than\
    \ mine. I am surprised that your solution is slower than mine. I am \nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdsi8rdka.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdsi8rdka.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    signs = zeros(Int64, length(arr))\n    for i in 1:length(arr)\n\
    \        signs[i] = sign(arr[i])\n    end\n    prod = 1\n    for i in 1:length(arr)\n\
    \        prod *= signs[i]\n    end\n    return prod\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ the sum of squared magnitudes of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsfdo5f3m.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsfdo5f3m.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return sum_of_mags * signs_prod \n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/27811890)\n<|/ c |>\n<| c |>\nI believe this\
    \ does answer the question. He asked how to find the product of all the signs\
    \ of the numbers in the array. He also asked how to find the sum of all the magnitudes\
    \ of the numbers in the array. He also asked how to return None if the array is\
    \ empty. He also asked how to return None if the array contains negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\n\
    <|/ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/27811890)\n<|/ c |>\n<| c |>\nI believe\
    \ this does answer the question. He asked how to find the product of all the signs\
    \ of the numbers in the array. He also asked how to find the sum of all the magnitudes\
    \ of the numbers in the array. He also asked how to return None if the array is\
    \ empty. He also asked how to return None if the array contains negative numbers.\
    \ H\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp30_1zm4a.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp30_1zm4a.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = sign\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpmnpshmav.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpmnpshmav.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpmnpshmav.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqqmmn4nn.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqqmmn4nn.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.4>\n@assert prod_signs([1, 2, 2, -4]) == -9\n\
    @assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns True if a number is odd and False otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuaofe3cw.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuaofe3cw.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x*prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsw0vtzas.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsw0vtzas.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7tqvnnr5.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7tqvnnr5.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n     \
    \   signs = map(x -> x * prod(signs), arr)\n        return sum(signs)\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoaaxm7i3.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpoaaxm7i3.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x*prod(signs),\
    \ signs) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1sovbwsb.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1sovbwsb.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp663rq4of.jl:64\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp663rq4of.jl:64\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(signs .* arr)\n        return sum_of_mags\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the product of all\
    \ numbers in arr multiplied by product of all signs of numbers in arr, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl6uerng1.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl6uerng1.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = map(sign, arr) \n       \
    \ signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n        mags\
    \ = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags =\
    \ prod(mags) \n        return signs * mags \n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid the\
    \ loop. Maybe some kind of vectorized function?\n<|/ c |>\n<| c |>\nI added a\
    \ vectorized solution. Hope it helps.\n<|/ c |>\n<| a tags=julia,arrays,performance\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7p94o4oz.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7p94o4oz.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), arr) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5znxfs1c.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5znxfs1c.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  signs = signs == 0 ? 1 : -1 \n        return sum(map(abs, arr)) * signs \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nProd of sums\nNow let's use our previous function to calculate\
    \ the product of sums of magnitudes of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpap9ism6w.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpap9ism6w.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        \n        sum_signs = sum(signs)\n        \n        product =\
    \ 1\n        for i in 1:length(arr) \n            product *= signs[i]\n      \
    \  end\n        \n        return sum_signs * product\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptrbk85f9.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptrbk85f9.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = signs(arr) \n        mags\
    \ = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags =\
    \ map(x -> x * signs[x], mags) \n        mags = reduce(*, mags) \n        return\
    \ mags \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnv8_a2qg.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnv8_a2qg.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        sum = 0\n        for i in 1:length(arr) \n            sum += abs(arr[i])\
    \ * product\n        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that checks\
    \ if a number is even or odd.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwav5ry0g.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwav5ry0g.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't seem to work. `prod_signs([1, 2, 2, -4])` returns `-9` but `prod_signs([0,\
    \ 1])` returns `0`.\n<|/ c |>\n<| c |>\nThanks for pointing out. I've corrected\
    \ the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9tf8h434.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9tf8h434.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        return sum(magnitudes * product)\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array\
    \ of integers and returns the sum of squared magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1mp5jruw.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1mp5jruw.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 1:length(arr) \n            product *= signs[i]\n            signs[i] *=\
    \ arr[i]\n        end\n        return product\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppiwuua1a.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppiwuua1a.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs) \n  \
    \      signs = map(x -> x * prod(signs), arr) \n        signs = map(x -> x !=\
    \ 0, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = map(x\
    \ -> x * prod(signs), arr) \n        signs = map(x -> x != 0, signs) \n      \
    \  signs = filter(x -> x == 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs) \n  \
    \      signs = map(x -> x * prod(signs), arr) \n        signs = map(x -> x !=\
    \ 0, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = map(x\
    \ -> x * prod(signs), arr) \n        signs = map(x -> x != 0, signs) \n      \
    \  signs = filter(x -> x == 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs) \n  \
    \      signs = map(x -> x * prod(signs), arr) \n        signs = map(x -> x !=\
    \ 0, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = map(x\
    \ -> x * prod(signs), arr) \n        signs = map(x -> x != 0, signs) \n      \
    \  signs = filter(x -> x == 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8m1n82bo.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8m1n82bo.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 1:length(arr) \n            product *= signs[i]\n            signs[i] =\
    \ 0\n        end\n        return product * sum(abs(arr))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n4.3 Sum all numbers\
    \ in a vector\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpejlkacqi.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpejlkacqi.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[0] * sign(arr[0])\n \
    \   else return arr[0] * prod_signs(arr[1:end-1]) * sign(arr[-1])\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkfmg0c7f.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkfmg0c7f.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), signs) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpro4oyc4c.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpro4oyc4c.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    else if length(arr)==1 return arr[1]\n    else \n        signs\
    \ = map(sign, arr)\n        mags = map(abs, arr)\n        mags = filter(x -> x==0,\
    \ mags)\n        mags = filter(x -> x==1, mags)\n        mags = filter(x -> x==-1,\
    \ mags)\n        mags = map(prod, mags)\n        mags = map(sum, mags)\n     \
    \   mags = map(abs, mags)\n        mags = filter(x -> x==0, mags)\n        mags\
    \ = filter(x -> x==1, mags)\n        mags = filter(x -> x==-1, mags)\n       \
    \ mags = map(prod, mags)\n        mags = map(sum, mags)\n        mags = map(abs,\
    \ mags)\n        mags = filter(x -> x==0, mags)\n        mags = filter(x -> x==1,\
    \ mags)\n        mags = filter(x -> x==-1, mags)\n        mags = map(prod, mags)\n\
    \        mags = map(sum, mags)\n        mags = map(abs, mags)\n        mags =\
    \ filter(x -> x==0, mags)\n        mags = filter(x -> x==1, mags)\n        mags\
    \ = filter(x -> x==-1, mags)\n        mags = map(prod, mags)\n        mags = map(sum,\
    \ mags)\n        mags = map(abs, mags)\n        mags = filter(x -> x==0, mags)\n\
    \        mags = filter(x -> x==1, mags)\n        mags = filter(x -> x==-1, mags)\n\
    \        mags = map(prod, mags)\n        mags = map(sum, mags)\n        mags =\
    \ map(abs, mags)\n        mags = filter(x -> x==0, mags)\n        mags = filter(x\
    \ -> x==1, mags)\n        mags = filter(x -> x==-1, mags)\n        mags = map(prod,\
    \ mags)\n        mags = map(sum, mags)\n        mags = map(abs, mags)\n      \
    \  mags = filter(x -> x==0, mags)\n        mags = filter(x -> x==1, mags)\n  \
    \      mags = filter(x -> x==-1, mags)\n        mags = map(prod, mags)\n     \
    \   mags = map(sum, mags)\n        mags = map(abs, mags)\n        mags = filter(x\
    \ -> x==0, mags)\n        mags = filter(x -> x==1, mags)\n        mags = filter(x\
    \ -> x==-1, \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg2n6xq2a.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg2n6xq2a.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is even, False otherwise. \nThe function should take one argument,\
    \ num.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc9i6xjiu.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpc9i6xjiu.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function that returns True if a number is even, False otherwise.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzvbmefnz.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzvbmefnz.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(signs .* arr)\n        return sum_of_mags\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.3 Sum of magnitudes\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqwytfcl7.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqwytfcl7.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[arr .< 0] = -signs[arr .< 0] \n        signs[arr .> 0] = 1\n\
    \        signs = signs.prod() \n        return signs * prod(signs) \n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an array arr of integers and returns\
    \ sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfr8e2b0i.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfr8e2b0i.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ sum of squares of integers in arr \nand returns sum of squares of integers multiplied\
    \ by product of all signs\nof each number in the array, represented by 1, -1 or\
    \ 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6p1hy7a8.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6p1hy7a8.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    \n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n\
    \    signs[2] = -1\n    \n    prod = 1\n    for i in 1:length(arr)\n        prod\
    \ *= signs[i]\n    end\n    \n    return prod * sum(abs(arr))\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is odd and False otherwise. Test it\
    \ on all odd numbers from 0 to 20.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplx6fusr3.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplx6fusr3.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpivbveuei.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpivbveuei.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for i in arr\n        sum += i\n    end\n  \
    \  prod = 1\n    for i in arr\n        prod *= sign(i)\n    end\n    sign = signbit(sum)\n\
    \    if sign == 0 return sum\n    if sign == 1 return prod\n    return -prod\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns True if a number is odd, False\
    \ otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy3z3ardz.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy3z3ardz.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[0] * signs(arr[0])\n\
    \    else return sum(map(signs, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9bbvg5of.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9bbvg5of.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        product = prod(signs)\n        return product * sum(signs)\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2nh3o6ke.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2nh3o6ke.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        return sum(signs)\
    \ * prod(signs) \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns True if a number is even, False otherwise. \nWrite a function that\
    \ returns True if a number is odd, False otherwise. \nWrite a function that returns\
    \ True if a number is positive, False otherwise. \nWrite a function that returns\
    \ True if a number is negative, False otherwise. \nWrite a function that returns\
    \ True if a number is zero, False otherwise. \nWrite a function that returns True\
    \ if a number is between 10 and 100, False otherwise. \nWrite a function that\
    \ returns True if a number is between -10 and -100, False otherwise. \nWrite a\
    \ function that returns True if a number is between 10 and 100, False otherwise.\
    \ \nWrite a function that returns True if a number is between -10 and -100, False\
    \ otherwise. \nWrite a function that returns True if a number is between 10 and\
    \ 100, False otherwise. \nWrite a function that returns True if a number is between\
    \ -10 and -100, False otherwise. \nWrite a function that returns True if a number\
    \ is between 10 and 100, False otherwise. \nWrite a function that returns True\
    \ if a number is between -10 and -100, False otherwise. \nWrite a function that\
    \ returns True if a number is between 10 and 100, False otherwise. \nWrite a function\
    \ that returns True if a number is between -10 and -100, False otherwise. \nWrite\
    \ a function that returns True if a number is between 10 and 100, False otherwise.\
    \ \nWrite a function that returns True if a number is between -10 and -100, False\
    \ otherwise. \nWrite a function that returns True if a number is between 10 and\
    \ 100, False otherwise. \nWrite a function that returns True if a number is between\
    \ -10 and -100, False otherwise. \nWrite a function that returns True if a number\
    \ is between 10 and 100, False otherwise. \nWrite a function that returns True\
    \ if a number is between -10 and -100, False otherwise. \nWrite a function that\
    \ returns True if a number is between 10 and 100, False otherwise. \nWrite a function\
    \ that returns True if a number is between -10 and -100, False otherwise. \nWrite\
    \ a function that returns True if a number is between 10 and 100, False otherwise.\
    \ \nWrite a function that returns True if a number is between -10 and -100, False\
    \ otherwise. \nWrite a function that returns True if a number is between 10 and\
    \ 100, False otherwise. \nWrite a function that returns True if a number is between\
    \ -10 and -100, False otherwise. \nWrite a function that returns True if a number\
    \ is between 10 and 100, False otherwise. \nWrite a function that returns True\
    \ if a number is between -10 and -100, False otherwise\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9lx9s35t.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9lx9s35t.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        mags = map(abs, arr) \n        return signs_prod\
    \ * sum(mags) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu5gih_wt.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu5gih_wt.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        \n        mags = map(abs, arr)\n        mags = filter(x -> x != 0, mags)\n\
    \        mags = map(abs, mags)\n        mags = filter(x -> x != 0, mags)\n   \
    \     \n        mags = prod(mags)\n        \n        mags = map(x -> x * signs,\
    \ mags)\n        \n        mags = reduce(+, mags)\n        \n        return mags\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpassv4g_b.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpassv4g_b.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        return nothing\n    signs=zeros(Int, length(arr))\n    for i=1:length(arr)\n\
    \        signs[i]=sign(arr[i])\n    end\n    mags=map(abs, arr)\n    mags=map(sign,\
    \ mags)\n    mags=prod(mags)\n    return mags\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpktftijo9.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpktftijo9.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpktftijo9.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmrr6y607.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmrr6y607.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n      \
    \  return product * sum_of_mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates\
    \ the sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvc5iztrs.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvc5iztrs.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2fq0yp4g.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2fq0yp4g.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns the number of integers in arr that are divisible by\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptoat_ldr.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptoat_ldr.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ the number of positive integers in an array.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe62pgv0x.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe62pgv0x.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 1, signs)\
    \ \n        signs = filter(x -> x == -1, signs) \n        signs = collect(signs)\
    \ \n        signs = prod(signs) \n        signs = signs == 0 ? 1 : signs \n  \
    \      signs = signs == 1 ? 1 : signs \n        signs = signs == -1 ? -1 : signs\
    \ \n        return sum(abs(x) for x in arr) * signs \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates sum of squares of numbers in arr using map and reduce\
    \ functions.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptdgtls3d.jl:28\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptdgtls3d.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_signs = 0 \n        for el\
    \ in arr \n            sum_signs += sign(el) \n            \n        product =\
    \ 1\n        for el in arr \n            product *= sign(el) \n        \n    \
    \    return sum_signs * product \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf1m9dj89.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf1m9dj89.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n\
    \        return sum_of_mags * signs_product \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1slrvjqo.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1slrvjqo.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return signs_product * sum_of_magnitudes \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nTask 3\nWrite a function\
    \ that returns number of integers in array arr which are divisible by given number\
    \ k.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr5vh219j.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr5vh219j.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_signs = 0 \n        for el\
    \ in arr \n            sum_signs += sign(el) \n        product = prod(arr) \n\
    \        return sum_signs * product \n    end\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThanks for your answer. Can you please explain why you used `@inbounds`?\n\
    <|/ c |>\n<| c |>\n`@inbounds` tells Julia to execute the function `prod_signs`\
    \ in-place. Without it, Julia would try to evaluate the function `prod_signs`\
    \ before calling `prod_signs`, which would result in an error since `prod_signs`\
    \ expects an array as its first argument. With the `@inbounds` Julia will execute\
    \ the function in-place and `prod_signs` will receive an array as its first argument.\n\
    <|/ c |>\n<| c |>\nThanks for your explanation. Can you please explain why you\
    \ used `@inbounds`?\n<|/ c |>\n<| c |>\n`@inbounds` tells Julia to execute the\
    \ function `prod_signs` in-place. Without it, Julia would try to evaluate the\
    \ function `prod_signs` before calling `prod_signs`, which would result in an\
    \ error since `prod_signs` expects an array as its first argument. With the `@inbounds`\
    \ Julia will execute the function in-place and `prod_signs` will receive an array\
    \ as its first argument.\n<|/ c |>\n<| c |>\nThanks for your explanation. Can\
    \ you please explain why you used `@inbounds`?\n<|/ c |>\n<| a dscore=2 |>\nI\
    \ thought I would post a solution using broadcasting which I believe is more efficient\
    \ than looping over all elements. \n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnlbzrzg2.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnlbzrzg2.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        signs = signs.*ones(Int64, length(arr))\n        signs = signs.*signs\n\
    \        product = prod(signs)\n        magnitude = sqrt(sum(abs2, arr))\n   \
    \     return product * magnitude\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nI\
    \ like this solution. However I wonder if there is a way to avoid the for loop\
    \ and use broadcasting instead?\n<|/ c |>\n<| c |>\nI added a solution that avoids\
    \ the for loop and uses broadcasting.\n<|/ c |>\n<| c |>\nThanks, I like the broadcast\
    \ solution. However I wonder if there is a way to avoid the for loop and use broadcasting\
    \ instead?\n<|/ c |>\n<| c |>\nI added a solution that avoids the for loop and\
    \ uses broadcasting.\n<|/ c |>\n<| c |>\nThanks, I like the broadcast solution.\
    \ However I wonder if there is a way to avoid the for loop and use broadcasting\
    \ instead?\n<|/ c |>\n<| a dscore=2 |>\nThis solution uses broadcasting and avoids\
    \ the for loop:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp891rcyva.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp891rcyva.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * signs[i]\n\
    \        end\n        sum(signs)\n    end\nend\n</code>\n<|/ a tags=julia |>\n\
    <| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnupuf68d.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnupuf68d.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for i in arr\n        prod *= sign(i)\n   \
    \ end\n    return prod\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2np9g_t_.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2np9g_t_.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i = 1:length(arr) \n            signs[i] = sign(arr[i])\n       \
    \ end\n        product = prod(signs)\n        magnitudes = map(abs, arr)\n   \
    \     sum_magnitudes = sum(magnitudes)\n        return product * sum_magnitudes\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the number of positive\
    \ numbers in an array.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk7ixwmu_.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk7ixwmu_.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4pai_nmz.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4pai_nmz.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return signs_prod * sum_of_mags \n    end\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes an array arr of integers and returns its sum\
    \ of the absolute values.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv1o2z1u4.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv1o2z1u4.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = zeros(Int, length(arr))\n        for i = 1:length(arr)\n         \
    \   signs[i] = sign(arr[i])\n        end\n        signs = signs * prod(signs)\n\
    \        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9ce3rj1y.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9ce3rj1y.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = signs(arr) \n        signs_product\
    \ = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .- signs_product))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that checks if a number is odd or even.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmdbjozne.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmdbjozne.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n\
    <| a dscore=2 |>\nA simple and efficient solution:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpah47tgxy.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpah47tgxy.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> sum(x), signs) \n        return sum(signs) \n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsv4x8dug.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsv4x8dug.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the number of positive numbers in an array.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb6hvo9nj.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb6hvo9nj.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n\
    @assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns True if a number is odd and False otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb0gkqpq0.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb0gkqpq0.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns the\
    \ number of integers in the array arr that are divisible by 3\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9kcrecxz.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9kcrecxz.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppxe60co8.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppxe60co8.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\
    \ \n        signs[1] = 1 \n        signs[2] = -1 \n        signs[3] = 0 \n   \
    \     product = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .- product))\
    \ \n        return sum_of_magnitudes * product \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is even, False otherwise. \nWrite a\
    \ function that returns True if a number is odd, False otherwise. \nWrite a function\
    \ that returns True if a number is prime, False otherwise. \nWrite a function\
    \ that returns True if a number is composite (that is, has no divisors other than\
    \ 1 and itself), False otherwise. \nWrite a function that returns True if a number\
    \ is perfect square, False otherwise. \nWrite a function that returns True if\
    \ a number is perfect cube, False otherwise. \nWrite a function that returns True\
    \ if a number is perfect fibonacci, False otherwise. \nWrite a function that returns\
    \ True if a number is perfect hyperbolic triangular, False otherwise. \nWrite\
    \ a function that returns True if a number is perfect logarithm, False otherwise.\
    \ \nWrite a function that returns True if a number is perfect exponential function,\
    \ False otherwise. \nWrite a function that returns True if a number is perfect\
    \ hypergeometric function, False otherwise. \nWrite a function that returns True\
    \ if a number is perfect triangular number, False otherwise. \nWrite a function\
    \ that returns True if a number is perfect square root, False otherwise. \nWrite\
    \ a function that returns True if a number is perfect cubic number, False otherwise.\
    \ \nWrite a function that returns True if a number is perfect quartic number,\
    \ False otherwise. \nWrite a function that returns True if a number is perfect\
    \ quintic number, False otherwise. \nWrite a function that returns True if a number\
    \ is perfect secantic number, False otherwise. \nWrite a function that returns\
    \ True if a number is perfect hyperbolic secantic number, False otherwise. \n\
    Write a function that returns True if a number is perfect exponential function,\
    \ False otherwise. \nWrite a function that returns True if a number is perfect\
    \ logarithm, False otherwise. \nWrite a function that returns True if a number\
    \ is perfect exponential function, False otherwise. \nWrite a function that returns\
    \ True if a number is perfect hypergeometric function, False otherwise. \nWrite\
    \ a function that returns True if a number is perfect triangular number, False\
    \ otherwise. \nWrite a function that returns True if a number is perfect square\
    \ root, False otherwise. \nWrite a function that returns \nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyqcxi_22.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpyqcxi_22.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, x) in enumerate(arr)\n            signs[i] = sign(x) * sign(i)\n\
    \        end\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp85gvrwhl.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp85gvrwhl.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = reduce(mul, signs) \n        return product \nend\n</cell>\n<code\
    \ language=julia-1.3>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of each number in the array, represented by 1, -1 or 0.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwnsnq7nb.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwnsnq7nb.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), signs) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp77lz4ox0.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp77lz4ox0.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  signs = signs == 0 ? 1 : -1 \n        signs = signs * prod(map(abs, arr)) \n\
    \        return signs \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprtas3s3u.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprtas3s3u.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = prod(signs) \n        return product\
    \ * sum(mags) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr4se2xlq.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr4se2xlq.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfnfl9fut.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpfnfl9fut.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpfnfl9fut.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=1 |>\nThe answer by is correct, but I wanted\
    \ to point out that you can also use reduce to solve this problem in one line:\n\
    <code>\nreduce(x -> sign(x) * prod(sign(x)), arr)\n</code>\n<|/ a tags=julia |>\n\
    <| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqsoqxm9j.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqsoqxm9j.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        \n        sum_of_mags = sum(abs.(signs))\n        prod_of_mags = prod(signs)\n\
    \        return sum_of_mags * prod_of_mags\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi52gdm65.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi52gdm65.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for x in arr\n        prod *= sign(x)\n   \
    \ end\n    return prod\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptg0z0fir.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptg0z0fir.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    prod = 1\n    for i in arr\n        sum += abs(i)\n\
    \        prod *= sign(i)\n    end\n    return sum * prod\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1bxgl8gy.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp1bxgl8gy.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp1bxgl8gy.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = 0 \n        for el\
    \ in arr \n            sum_of_mags += el * sign(el) \n        return sum_of_mags\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates the sum of squares\
    \ of integers multiplied by product of all signs of each number in the array,\
    \ represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8igv2i2b.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8igv2i2b.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags\
    \ = prod(mags) \n        return signs * mags \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\n4.3 Product of Signs\nWrite a function\
    \ that calculates the product of all signs of an array.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4og9jgoi.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4og9jgoi.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = prod(signs) \n        mags = map(abs, arr) \n        mags = prod(mags)\
    \ \n        return signs * mags \n    end\nend\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns True if a number is even, False otherwise. \nWrite\
    \ a function that returns True if a number is odd, False otherwise. \nWrite a\
    \ function that returns True if a number is prime, False otherwise. \nWrite a\
    \ function that returns True if a number is composite (that is, if it divides\
    \ evenly into another number), False otherwise. \nWrite a function that returns\
    \ True if a number is divisible by another number, False otherwise. \nWrite a\
    \ function that returns True if a number is divisible by all numbers from 1 to\
    \ n, False otherwise. \nWrite a function that returns True if a number is divisible\
    \ by all numbers from 1 to n and even, False otherwise. \nWrite a function that\
    \ returns True if a number is divisible by all numbers from 1 to n and odd, False\
    \ otherwise. \nWrite a function that returns True if a number is divisible by\
    \ all numbers from 1 to n and prime (that is, divisible by all numbers from 1\
    \ to n and even), False otherwise. \nWrite a function that returns True if a number\
    \ is divisible by all numbers from 1 to n and composite, False otherwise. \nWrite\
    \ a function that returns True if a number is divisible by all numbers from 1\
    \ to n and divisible by all numbers from 1 to m, False otherwise. \nWrite a function\
    \ that returns True if a number is divisible by all numbers from 1 to n and divisible\
    \ by all numbers from 1 to m and even, False otherwise. \nWrite a function that\
    \ returns True if a number is divisible by all numbers from 1 to n and divisible\
    \ by all numbers from 1 to m and odd, False otherwise. \nWrite a function that\
    \ returns True if a number is divisible by all numbers from 1 to n and divisible\
    \ by all numbers from 1 to m and prime (that is, divisible by all numbers from\
    \ 1 to n and even), False otherwise. \nWrite a function that returns True if a\
    \ number is divisible by all numbers from 1 to n and divisible by all numbers\
    \ from 1 to m and composite, False otherwise. \nWrite a function that returns\
    \ True if a number is divisible by all numbers from 1 to n and divisible by all\
    \ numbers from 1 to m and divisible by all numbers from 1 to n, False otherwise.\
    \ \nWrite a function that returns True if a number is divisible by all numbers\
    \ from 1 to n and divisible by all numbers from 1 to m and divisible by all numbers\
    \ from 1 to n and even, False otherwise. \nWrite a function that returns True\
    \ if a \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu4wuwer_.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu4wuwer_.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = signs(arr) \n        product\
    \ = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n        return product\
    \ * sum_of_mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates the sum\
    \ of squares of integers in arr\nand returns the result as a Float64. Test your\
    \ function on arr = [1, 2, 3].\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpml6mkept.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpml6mkept.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = sum(map(abs, arr))\n\
    \        signs = map(sign, arr)\n        product = signs.*signs\n        return\
    \ sum_of_mags*product\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/27674155)\n\
    <|/ c |>\n<| c |>\nI believe it does provide an answer to the question. He asked\
    \ how to calculate the product of signs of numbers in the array. He also provided\
    \ a solution that he has already tried. I believe this to be a better answer to\
    \ the question than my own.\n<|/ c |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post. - [From Review](/review/low-quality-posts/27674155)\n\
    <|/ c |>\n<| c |>\nI believe it does provide an answer to the question. He asked\
    \ how to calculate the product of signs of numbers in the array. He also provided\
    \ a solution that he has already tried. I believe this to be a better answer to\
    \ the question than my own.\n<|/ c |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post. - [From Review](/review/low-quality-posts/27674155)\n\
    <|/ c |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8p4eepfs.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8p4eepfs.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers. `prod(signs(-4:-1))`\
    \ returns `-1` instead of `0`.\n<|/ c |>\n<| a dscore=2 |>\nI like using map and\
    \ sum to solve this problem:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxhkiemvr.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxhkiemvr.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        nothing\n    elseif length(arr)==1\n        arr[1]*prod(signs(arr))\n\
    \    else\n        arr[1]*prod(signs(arr))*prod_signs(arr[2:end])\n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays,performance |>\nI wrote a Julia\
    \ package that does this for you:\nhttps://github.com/jrwlk/ArrayMagnitude\n<code>\n\
    julia> using ArrayMagnitude\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp68dl3t2l.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp68dl3t2l.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp98kgcxuv.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp98kgcxuv.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs.(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis code does not work\
    \ if `arr` is empty. `prod([])` returns `Inf`, which is not what we want. `sum(abs.(product))`\
    \ should be `sum(abs.(product))`.\n<|/ c |>\n<| c |>\nThanks, I've fixed the code.\n\
    <|/ c |>\n<| a tags=julia |>\nI came up with a solution using broadcasting and\
    \ the function prod from the StatsBase package:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprnpaj0de.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprnpaj0de.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 1, signs)\
    \ \n        signs = filter(x -> x == -1, signs) \n        signs = map(x -> x *\
    \ prod(signs), arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n4.5 Product of absolute\
    \ values\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp825emt9z.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp825emt9z.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        sum_of_mags\
    \ = sum(abs.(arr .* signs))\n        prod_of_mags = prod(signs)\n        return\
    \ sum_of_mags * prod_of_mags\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not answer the question, which is about how to do this in Julia. Your solution\
    \ does not take into account the fact that `prod(signs)` should be `1` if the\
    \ array is all positive.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've\
    \ updated the answer to include a solution that does take that into account.\n\
    <|/ c |>\n<| a tags=julia |>\nHere is a solution that does not require any packages:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr2xtueln.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr2xtueln.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    else if length(arr)==1 return arr[1]\n    else \n        signs\
    \ = zeros(length(arr))\n        for i = 1:length(arr)\n            signs[i] =\
    \ sign(arr[i])\n        end\n        \n        sum_signs = sum(signs)\n      \
    \  \n        product = 1\n        for i = 1:length(arr)\n            product =\
    \ product * signs[i]\n        end\n        \n        return sum_signs * product\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns True if a number is\
    \ odd, False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpabd26ok2.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpabd26ok2.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp10qm0enn.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp10qm0enn.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `prod([-1,0,1])` returns `0`, but should be `-1`.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz7ro1cc3.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz7ro1cc3.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else \n        signs = map(sign, arr) \n        signs =\
    \ filter(x -> x != 0, signs) \n        signs = prod(signs) \n        return sum(map(abs,\
    \ arr) * signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates the sum\
    \ of squares of integers multiplied by product of all signs of each number in\
    \ the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeihzbnv3.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeihzbnv3.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that finds\
    \ the number of positive numbers in an array.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfmasvanx.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfmasvanx.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes an array arr of integers\
    \ and returns sum of squares of integers multiplied by product of all signs of\
    \ each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm66flhkj.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm66flhkj.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(i) * sign(arr[i])\n\
    \        end\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp_e5b4j3.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpp_e5b4j3.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        return nothing\n    else\n        signs = map(sign, arr)\n        signs\
    \ = filter(x -> x != 0, signs)\n        signs = map(x -> x * prod(signs), arr)\n\
    \        return sum(signs)\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_fybeo_7.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_fybeo_7.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags\
    \ = prod(mags) \n        return signs * mags \n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is divisible by 3 and False otherwise. Test it on several examples:\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi9622_hb.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi9622_hb.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else if length(arr) == 1 return arr[1]*sign(arr[1]) \n \
    \   else \n        signs = zeros(Int, length(arr))\n        for i = 1:length(arr)\
    \ signs[i] = sign(arr[i])\n        signs = signs.*arr\n        return sum(abs2,\
    \ signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\n4.2 Sum all magnitudes\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnr8lw6e3.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnr8lw6e3.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(x -> x * prod(signs), arr) \n        return\
    \ sum(signs) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp__sj6vmh.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp__sj6vmh.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        sum = 0\n\
    \        for i in 1:length(arr) \n            sum += signs[i] * abs(arr[i])\n\
    \        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9k2r6n3q.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9k2r6n3q.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for i in arr\n        sum += abs(i)*sign(i)\n\
    \    end\n    return sum\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq7s9kidp.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq7s9kidp.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    \n    sum = 0\n    for i in arr\n        sum += i\n    end\n\
    \    \n    prod = 1\n    for i in arr\n        prod *= sign(i)\n    end\n    \n\
    \    return sum * prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that returns True if a number\
    \ is odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwfsys1dz.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwfsys1dz.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[2]\
    \ = -1\n    signs[3] = -1\n    product = 1\n    for i in 1:length(arr)\n     \
    \   product *= signs[i]\n    end\n    return product * sum(abs(arr))\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdhhe0m4e.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdhhe0m4e.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        product =\
    \ signs .* prod(signs)\n        return sum(abs(product))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6_dvrb6l.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6_dvrb6l.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)\n    end\n\
    \    return sum * prod(map(sign, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvu7nu6lm.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvu7nu6lm.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    \n    sum = 0\n    for i in arr\n        sum += i\n    end\n\
    \    \n    prod = 1\n    for i in arr\n        prod *= sign(i)\n    end\n    \n\
    \    return sum * prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\n4.5 Sign of numbers\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpaz3bo7eg.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpaz3bo7eg.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function that returns True if a number is even, False otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppk0h67a2.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppk0h67a2.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n\
    \        return sum_of_mags * signs_product \n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpudo9qrzg.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpudo9qrzg.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = sum(map(abs, arr))\
    \ \n        signs = map(sign, arr) \n        product = signs.prod \n        return\
    \ sum_of_mags * product \nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpovbveg2g.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpovbveg2g.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdteyf7t3.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdteyf7t3.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = prod(signs) \n        return product\
    \ * prod(mags) \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplltd0ony.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplltd0ony.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return signs_product * sum_of_magnitudes \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpndksn1tn.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpndksn1tn.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = prod(signs) \n        mags = map(abs, arr) \n        mags = prod(mags)\
    \ \n        return signs * mags \n    end\nend\n</code>\n<|/ a tags=julia,function,arrays\
    \ |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptw1rt41f.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptw1rt41f.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpstp5fqrx.jl:64\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpstp5fqrx.jl:64\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\
    \ \n        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        return product * sum(magnitudes)\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array\
    \ of integers and returns its sum.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpysi8rcsv.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpysi8rcsv.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end]\
    \ = -1\n    prod = 1\n    for x in arr\n        prod *= signs[x]\n    end\n  \
    \  return prod\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbu1ecmie.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbu1ecmie.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        sum_of_mags = sum(abs.(arr .- product))\n        return sum_of_mags \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd7j18dh6.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd7j18dh6.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = map(sign, arr)\n        signs_product = prod(signs)\n        sum_of_mags\
    \ = sum(map(abs, arr))\n        return signs_product * sum_of_mags\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns True if a number is odd, False\
    \ otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpins4bh65.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpins4bh65.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        return signs_prod * sum(map(abs, arr))\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.2 Write a function to find all numbers that satisfy a given\
    \ condition\nWrite a function that takes an array arr of integers and returns\
    \ all numbers in arr that satisfy a given condition. Return an empty array if\
    \ there are no such numbers. For example, given arr = [1, 2, 3, 4] and condition\
    \ = x -> x % 2 == 0, your function should return [2, 4].\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiidc6dk5.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiidc6dk5.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs.(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd2nvltkv.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd2nvltkv.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum = 0\n        for s in signs \n       \
    \     sum += s * product \n        return sum \n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl5tnounn.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl5tnounn.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)\n    end\n\
    \    return sum * prod(map(sign, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd, False otherwise. \nThe function should work for any\
    \ type of number.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnlrrai6k.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnlrrai6k.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv2gyhyn5.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv2gyhyn5.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[0] * sign(arr[0])\n \
    \   else \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1]\
    \ = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        product\
    \ = prod(signs)\n        magnitudes = map(abs, arr)\n        return sum(magnitudes\
    \ .* product)\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like this\
    \ solution, although it does require a type declaration for the return type. `function\
    \ prod_signs(arr::Vector{Int64})::Int64`\n<|/ c |>\n<| c |>\nYes, I agree. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=2 |>\nI like using reduce to solve\
    \ this problem:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjg94zztm.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjg94zztm.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = zeros(Int, length(arr))\n        for i in 1:length(arr)\n        \
    \    signs[i] = sign(arr[i])\n        end\n        mags = map(abs, arr)\n    \
    \    mags = map(sign, mags)\n        mags = map(prod, mags)\n        return sum(mags)\n\
    \    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpltxvua_8.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpltxvua_8.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that returns True\
    \ if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprgfhhd72.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprgfhhd72.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 0] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 1] = 0\n        sum_of_mags = sum(signs .* arr)\n        return sum_of_mags\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsvpys3kb.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsvpys3kb.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs)\
    \ \n        product = prod(arr) \n        return signs * product \n    end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\nI came up with a solution that\
    \ is more efficient than others posted so far:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptoj90osv.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptoj90osv.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ sum(signs) \n        return signs * prod(signs) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbtu3cvmc.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbtu3cvmc.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        signs = signs * prod(signs)\n        return sum(abs2, signs)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd, False otherwise. \nThe function should work for any type of number, not\
    \ just integers. \nIt should work for negative numbers as well. \nIt should work\
    \ for floating point numbers as well.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2e3tstyi.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2e3tstyi.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3nruazm8.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3nruazm8.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for i in arr\n        prod *= sign(i)\n   \
    \ end\n    return prod * prod(arr)\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that finds\
    \ the number of positive numbers in an array.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppl0rbjiz.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppl0rbjiz.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeim9p88n.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeim9p88n.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns True if a number is\
    \ even, False otherwise. \nThe function should take one argument, num.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp38gsh42o.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp38gsh42o.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for i in arr\n        sum += sign(i) * i\n   \
    \ end\n    return sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjnoxkq0g.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjnoxkq0g.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n\
    \        return sum_of_mags * signs_product \nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/26827814)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He asked how to find\
    \ the product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0. I provided a solution that does exactly\
    \ that. He also asked how to find the sum of magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0. I provided a solution that does exactly\
    \ that. He also asked how to find the sum of magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that.\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/26827814)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He asked how to find\
    \ the product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0. I provided a solution that does exactly\
    \ that. He also asked how to find the sum of magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiflrkp5f.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiflrkp5f.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 1, signs) \n        signs =\
    \ filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprjx3aj0k.jl:64\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprjx3aj0k.jl:64\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = prod(signs) \n        mags = map(abs, arr) \n\
    \        mags = filter(x -> x != 0, mags) \n        mags = filter(x -> x == 0,\
    \ mags) \n        mags = filter(x -> x == 1, mags) \n        mags = filter(x ->\
    \ x == -1, mags) \n        mags = prod(mags) \n        return signs * mags \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.2 Sum all digits of an integer\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpynojofw2.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpynojofw2.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        product = product == 0 ? 1 : product \n  \
    \      return sum(map(abs, arr)) * product \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx31_bkb7.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpx31_bkb7.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> sum(x), signs) \n        return sum(signs) \nend\n</cell>\n<code\
    \ language=julia-1.3>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nTask 3\nWrite a function\
    \ that calculates sum of squares of integers in arr. \nThe function should return\
    \ sum of squares of integers in arr multiplied by product of all signs\nof each\
    \ number in the array, represented by 1, -1 or 0.\nNote: return 0 for empty arr.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppa2517_u.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppa2517_u.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs)\
    \ \n        mags = map(abs, arr) \n        mags = filter(x -> x == 0, mags) \n\
    \        mags = filter(x -> x == 1, mags) \n        mags = filter(x -> x == -1,\
    \ mags) \n        mags = sum(mags) \n        return signs * mags \n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays |>\nI came up with this:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1dg45lo_.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1dg45lo_.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = 1\n        signs[arr .> 0] = -1\n        signs = signs\
    \ * prod(signs)\n        return sum(abs(arr) * signs)\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `prod_signs([1, 2, 2, -4])\
    \ == -9` returns `-9` but `prod_signs([0, 1]) == 0` returns `0`.\n<|/ c |>\n<|\
    \ c |>\nThanks for pointing that out. I fixed the code.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI believe this can be done in O(n) time complexity using an auxiliary array\
    \ (O(n) space) where you store the sign of each number in the array and multiply\
    \ it with the product of the absolute value of the numbers in the array. \n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvxb6y61w.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvxb6y61w.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i = 1:length(arr) \n            signs[i] = sign(arr[i])\n       \
    \ end\n        \n        sum_of_magnitudes = sum(abs.(arr .* signs))\n       \
    \ \n        product = prod(signs)\n        return sum_of_magnitudes * product\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n@time prod_signs(rand(1:100));\n\
    </cell>\n<text>\nExercise\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpygaadw6_.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpygaadw6_.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of positive numbers in an array.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfzseo0pg.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfzseo0pg.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy37t002g.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy37t002g.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else return sum(map(sign,\
    \ arr))\nend\n</cell>\n<code language=julia-1.4>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0yjk9yhr.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0yjk9yhr.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if\
    \ you have negative numbers in the array. For example, `prod_signs([-1, -2, 3])`\
    \ returns `-1` instead of `0`.\n<|/ c |>\n<| c |>\nYes, I agree with you. My solution\
    \ is just an alternative to OP's solution. OP asked for sum of magnitudes of integers\
    \ multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\n<|/ c |>\n<| c |>\nYes, I agree with you. My solution is just\
    \ an alternative to OP's solution. OP asked for sum of magnitudes of integers\
    \ multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require any\
    \ loops.\n<|/ c |>\n<| a dscore=2 |>\nThe function below will return the product\
    \ of the signs of the numbers in the array:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5scwfzlr.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5scwfzlr.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else if length(arr) == 1 return arr[1] \n    else \n   \
    \     signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n      \
    \  signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        product = signs\
    \ .* prod(signs)\n        return sum(abs(product))\n    end\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpolilc_7a.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpolilc_7a.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = prod(signs) \n        return product\
    \ * sum(mags) \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes an array of integers and returns its sum of the absolute values.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4ic3cgge.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4ic3cgge.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is divisible by 7 and False otherwise. Test it on all numbers\
    \ from 1 to 100.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3g28mzw7.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3g28mzw7.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs)\
    \ \n        signs = filter(x -> x == -1, signs) \n        signs = prod(signs)\
    \ \n        return signs * prod(map(abs, arr)) \n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of positive integers in an\
    \ array.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppgf5gd8v.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppgf5gd8v.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n      \
    \  return product * sum_of_mags \n    end\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThanks for your answer. Your code works perfectly for me. I am just wondering\
    \ why you used `Int64` instead of `Int`? I thought `Int` was enough.\n<|/ c |>\n\
    <| c |>\n`Int` is enough for your case, but `Int64` will allow you to work with\
    \ larger numbers. `Int` will allow you to work with smaller numbers, but `Int64`\
    \ will allow you to work with larger numbers. `Int` will allow you to work with\
    \ smaller numbers, but `Int64` will allow you to work with larger numbers. `Int`\
    \ will allow you to work with smaller numbers, but `Int64` will allow you to work\
    \ with larger numbers. `Int` will allow you to work with smaller numbers, but\
    \ `Int64` will allow you to work with larger numbers.\n<|/ c |>\n<| c |>\nThanks\
    \ for the explanation. I am new to Julia and I didn't know that `Int` is enough\
    \ for my case. Thanks again.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwcbe8gtw.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwcbe8gtw.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        sum_of_mags\
    \ = sum(abs, signs)\n        product = signs .* prod(signs)\n        return sum_of_mags\
    \ * product\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to avoid the loop. Maybe with some\
    \ fancy `broadcasting`?\n<|/ c |>\n<| c |>\nI added a solution without loop\n\
    <|/ c |>\n<| c |>\nI added a solution without loop\n<|/ c |>\n<| c |>\nI added\
    \ a solution without loop\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpplv4hx43.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpplv4hx43.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  mags = map(abs, arr) \n        return sum(mags * signs) \nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphayh2pbw.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphayh2pbw.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplpwckm65.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplpwckm65.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(prod, signs) \n        return sum(signs)\
    \ \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that takes an\
    \ array arr of integers and returns sum of squares of integers multiplied by product\
    \ of all signs of each number in the array, represented by 1, -1 or 0.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4qjuw79z.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4qjuw79z.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for\
    \ your answer. I am not allowed to use any packages other than Base.\n<|/ c |>\n\
    <| c |>\nI added a solution that does not use any packages.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. I tried your solution and it works fine. I am still trying\
    \ to understand why my code didn't work. I am new to Julia and I still don't understand\
    \ why my code didn't work.\n<|/ c |>\n<| c |>\nThe reason your code didn't work\
    \ is because you were trying to use an `if` statement inside a `for` loop. `if`\
    \ statements don't work inside `for` loops. `for` loops work differently than\
    \ `if` statements. `for` loops iterate over each element in a collection and perform\
    \ an operation on that element. `if` statements work differently than `for` loops.\
    \ `if` statements test a condition and perform an operation if the condition is\
    \ true. `for` loops iterate over each element in a collection and perform an operation\
    \ on that element if the condition is true.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that does not use any packages.\n<|/ c |>\n<| a dscore=0 |>\nThis solution uses\
    \ no packages and is very similar to your original solution:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv170u7hq.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv170u7hq.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for i in arr\n        sum += sign(i) * i\n \
    \   end\n    return sum\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis\
    \ doesn't seem to work. `prod_signs([1, 2, 2, -4]) == -9` returns `-9` but `prod_signs([0,\
    \ 1]) == 0` returns `0` which is wrong.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks\
    \ for pointing it out. Now it works.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg1de7uhy.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg1de7uhy.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for i in arr\n        sign = sign(i)\n       \
    \ sum += sign*i\n    end\n    return sum\nend\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6qhoarne.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp6qhoarne.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp6qhoarne.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n      \
    \  return product * sum_of_mags \n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise. \nThe function should work for\
    \ any type of numbers, not just integers. \nThe function should work for negative\
    \ numbers as well.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg3ixek6l.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg3ixek6l.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates sum of\
    \ squares of integers multiplied by product of all signs of each number in the\
    \ array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsuo4w6js.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsuo4w6js.jl:21\n"
  exit_code: 1
  status: Exception
