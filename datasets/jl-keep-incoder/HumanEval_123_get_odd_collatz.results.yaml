name: HumanEval_123_get_odd_collatz
language: julia
results:
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw0ssnhw1.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpw0ssnhw1.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpw0ssnhw1.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        if n % 2 == 1 \n            odd_collatz\
    \ .+= [n + 1]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpny4m3pgl.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpny4m3pgl.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 2 if n % 2 == 0 else n * 3]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the factorial of a\
    \ given positive integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkn7956ms.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkn7956ms.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = Vector{Int64}()\n\
    \        odd_list += get_odd_collatz(n/2)\n        odd_list += [n/2]\n       \
    \ odd_list += [n*3+1]\n        return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps01wbq5y.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmps01wbq5y.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 2 if n % 2 == 0 else n * 3 + 1 ]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_col\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg0qt6o32.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg0qt6o32.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3\n    odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes in a positive integer n and returns the\
    \ number of steps to reach 1 from n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzirvm9zp.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzirvm9zp.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3]\n    \n\
    \    return odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbvv575b6.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpbvv575b6.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpbvv575b6.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    if n == 1\n        odd_list\n \
    \   else\n        odd_list = odd_list + get_odd_collatz(n-1)\n        if n % 2\
    \ == 0\n            odd_list = odd_list + [n / 2]\n        else\n            odd_list\
    \ = odd_list + [n / 2] * 3\n        end\n    end\n    odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes in a positive integer n and returns the Collatz conjecture\
    \ sequence for n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnk1rangj.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnk1rangj.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x/2)\n    end\n    \n    odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer n and returns the number of\
    \ even numbers less than or equal to n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwac60x1y.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwac60x1y.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphqxzc83y.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmphqxzc83y.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmphqxzc83y.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an integer n and returns the number of steps it takes\
    \ to reach 1 from the starting number n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpor83k71c.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpor83k71c.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n % 2)\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfck0kopu.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpfck0kopu.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpfck0kopu.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    odd_list += [n*3+1]\n\
    \    \n    return odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpb34t63s9.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpb34t63s9.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpb34t63s9.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n / 2)\n        if n % 2 == 0 \n            odd_list +=\
    \ [n]\n        else\n            odd_list += [n * 3]\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_u1uu2g2.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_u1uu2g2.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an integer n and returns the nth Fibonacci number.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_kwxeb5o.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_kwxeb5o.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n-1) do \n        if i % 2 == 0 \n            odd_list.append(i)\n\
    \        else \n            odd_list.append(3*i+1)\n    end\n    \n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmp8pbea7nb.jl:23\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp8pbea7nb.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp8pbea7nb.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list\
    \ += [x/2]\n        else \n            odd_list += [x*3]\n    end\n    \n    odd_list\
    \ += [1]\n    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp29xv6c5c.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp29xv6c5c.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the factorial of a given positive integer\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpee5jyv6o.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpee5jyv6o.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbz503hdw.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbz503hdw.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/3]\n        return odd_collatz\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpinzhoa4p.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpinzhoa4p.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpinzhoa4p.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz = [odd_collatz[1]*2, odd_collatz[1]*3+1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the factorial of a\
    \ given positive integer n. \nFor example, factorial(5) = 5 x 4 x 3 x 2 x 1 =\
    \ 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz8bvdoiz.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz8bvdoiz.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n   \
    \     odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n\
    \        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n\
    \        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n\
    \        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collat\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp863b0dxq.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp863b0dxq.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp863b0dxq.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 1 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[2:end]\n    else \n        odd_collatz = [odd_collatz[1],\
    \ odd_collatz[1] * 3] + odd_collatz[2:end]\n    \n    return odd_collatz\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpin65eq7q.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpin65eq7q.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa1u8rz1n.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa1u8rz1n.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes in a positive integer n and returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8b9yhn03.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8b9yhn03.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n - 1)\n        if x % 2 == 0\n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x * 2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi3cf6pud.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi3cf6pud.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes in a positive integer n and returns\
    \ the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps9d9uuk0.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmps9d9uuk0.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n-1)\n\
    \    odd_collatz .+= [n/2]\n    if n % 2 == 1 \n        odd_collatz .+= [n*3]\n\
    \    odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the Collatz sequence up to n.\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvqvpuu89.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvqvpuu89.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[end]\n    else \n        odd_collatz = [odd_collatz[1] *\
    \ 3, odd_collatz[1] * 3] + odd_collatz[end]\n    \n    return odd_collatz\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk_2_lcpu.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk_2_lcpu.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz .+= [n]\n    else \n   \
    \     odd_collatz .+= [n * 3]\n    end\n    \n    return odd_collatz\nend\n</cell>\n\
    <code language=julia-1.5>\n@time get_odd_collatz(100)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes an integer n and returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw2w46wtr.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw2w46wtr.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n / 2]\n        odd_collatz += [n / 2 * 3]\n \
    \       odd_collatz += [n / 2 * 3 * 5]\n        odd_collatz += [n / 2 * 3 * 5\
    \ * 7]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9\
    \ * 11 * 13]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15]\n\
    \        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25]\n       \
    \ odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25\
    \ * 27]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11\
    \ * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31]\n        odd_collatz += [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31 *\
    \ 33]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29 * 31 * 33 * 35\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw6w5o4s3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw6w5o4s3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3 + 1\n     \
    \   return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the factorial of a\
    \ given positive integer. \nThe factorial of a positive integer is defined as\
    \ the product of all the positive integers less than or equal to it. \nFor example,\
    \ 5! = 5 x 4 x 3 x 2 x 1 = 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_6lcphpg.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_6lcphpg.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list += [i]\n            else \n                odd_list += [i*3]\n\
    \        end\n        odd_list += [n]\n        return odd_list\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the factorial of a given positive integer n.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa27rsu1h.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa27rsu1h.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n == 1 \n        odd_list = [n]\n    else\n    \
    \    odd_list = [1]\n        for i in 2:n\n            if i%2 == 0\n         \
    \       odd_list[i] = odd_list[i-1]*2\n            else\n                odd_list[i]\
    \ = odd_list[i-1]*3 + 1\n        end\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes an integer n and returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprhlfacd5.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprhlfacd5.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 3 + (n % 2 == 0)]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm59vu2pl.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm59vu2pl.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    return odd_list\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdtrmxx07.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpdtrmxx07.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpdtrmxx07.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes an integer $n$ and returns the\
    \ number of steps it takes to reach 1 from the initial value of $n$. For example,\
    \ if the initial value is 10, then the number of steps is 10.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy9j3x0j4.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy9j3x0j4.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_c087dqa.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_c087dqa.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    odd_collatz\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes in a positive integer n and returns the nth Fibonacci\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk72vr66p.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk72vr66p.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = Vector{Int64}()\n    odd_list = [1]\n    if n == 1\n      \
    \  odd_list\n    else\n        odd_list = odd_list + get_odd_collatz(n-1)\n  \
    \      odd_list = odd_list + [n/2]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptq0ah61t.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptq0ah61t.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes an integer $n$ and returns\
    \ the number of steps to reach 1 from $n$. For example, get_steps(3) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi5u6_gul.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi5u6_gul.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \    \n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"for\" after end of expression\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvppl_s_e.jl:22\n [2] include(::Module,\
    \ ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n\
    \ [4] _start() at ./client.jl:484\nin expression starting at /tmp/tmpvppl_s_e.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \        return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the nth Fibonacci number\
    \ using recursion.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"for\" after end of expression\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbdxs8xes.jl:22\n [2] include(::Module,\
    \ ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n\
    \ [4] _start() at ./client.jl:484\nin expression starting at /tmp/tmpbdxs8xes.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz += [n % 2]\n    if n % 2 == 1 \n        odd_collatz += [n\
    \ / 2]\n    odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n   \
    \ Given a positive integer n, return a sorted list that has the even numbers in\
    \ collatz sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdi64lspo.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdi64lspo.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3 + 1\n    odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the factorial of a given positive integer\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0n_72umu.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0n_72umu.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n / 2]\n        odd_collatz += [n / 2 * 3]\n \
    \       odd_collatz += [n / 2 * 3 * 5]\n        odd_collatz += [n / 2 * 3 * 5\
    \ * 7]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9\
    \ * 11 * 13]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15]\n\
    \        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25]\n       \
    \ odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25\
    \ * 27]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11\
    \ * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31]\n        odd_collatz += [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31 *\
    \ 33]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29 * 31 * 33 * 35\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9csh6kpf.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9csh6kpf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3+1]\n  \
    \  return odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3yay5a25.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3yay5a25.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3yay5a25.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for n in get_odd_collatz(n-1) do \n            if n % 2 == 0 \n        \
    \        odd_list.append(n) \n            else \n                odd_list.append(n*3\
    \ + 1)\n        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppt0n0_g5.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppt0n0_g5.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpta1pzvpy.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpta1pzvpy.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_nums = Vector{Int64}()\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpobbq26lh.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpobbq26lh.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_steps(10) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1edagvgs.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1edagvgs.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        if n % 2 == 1 \n            odd_collatz\
    \ .+= [n * 3]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a positive integer n and returns the nth Fibonacci\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwogi1qbw.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwogi1qbw.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the factorial of a given positive integer. \nThe\
    \ factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive \nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6of5b0xf.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6of5b0xf.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3yfqk5rt.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3yfqk5rt.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/5]\n        odd_collatz .+= [n/7]\n        odd_collatz .+= [n/11]\n \
    \       odd_collatz .+= [n/13]\n        odd_collatz .+= [n/17]\n        odd_collatz\
    \ .+= [n/19]\n        odd_collatz .+= [n/23]\n        odd_collatz .+= [n/29]\n\
    \        odd_collatz .+= [n/37]\n        odd_collatz .+= [n/53]\n        odd_collatz\
    \ .+= [n/59]\n        odd_collatz .+= [n/67]\n        odd_collatz .+= [n/83]\n\
    \        odd_collatz .+= [n/99]\n        odd_collatz .+= [n/107]\n        odd_collatz\
    \ .+= [n/113]\n        odd_collatz .+= [n/129]\n        odd_collatz .+= [n/131]\n\
    \        odd_collatz .+= [n/137]\n        odd_collatz .+= [n/143]\n        odd_collatz\
    \ .+= [n/149]\n        odd_collatz .+= [n/153]\n        odd_collatz .+= [n/157]\n\
    \        odd_collatz .+= [n/163]\n        odd_collatz .+= [n/169]\n        odd_collatz\
    \ .+= [n/173]\n        odd_collatz .+= [n/177]\n        odd_collatz .+= [n/183]\n\
    \        odd_collatz .+= [n/189]\n        odd_collatz .+= [n/193]\n        odd_collatz\
    \ .+= [n/197]\n        odd_collatz .+= [n/203]\n        odd_collatz .+= [n/209]\n\
    \        odd_collatz .+= [n/213]\n        odd_collatz .+= [n/217]\n        odd_collatz\
    \ .+= [n/\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzvhd0nod.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzvhd0nod.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz += [n / 2] * (n % 2 == 1 ? 1 : 3)\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a list of numbers and returns the number\
    \ of even numbers in the list.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8uq051xu.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8uq051xu.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an integer n and returns the nth\
    \ Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg_tw3scj.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg_tw3scj.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the nth term of the Fibonacci sequence. \nThe Fibonacci\
    \ sequence is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgv2ly00v.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgv2ly00v.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.4>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes an integer $n$ and returns the number of steps it\
    \ takes to reach 1 from $n$. For example, get_steps(5) should return 3.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx79rivfi.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpx79rivfi.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 1\n            odd_list.append(n/2)\n\
    \        else\n            odd_list.append(n*3+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the factorial of a given positive integer\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmen43nc9.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmen43nc9.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a positive integer n and returns the number\
    \ of steps it takes to reach 1 from the first even number.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxjvtkkjc.jl:28\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxjvtkkjc.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz += [n / 2]\n    if n % 2 == 1 \n        odd_collatz += [n\
    \ / 2]\n    end\n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp07ait62c.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp07ait62c.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp07ait62c.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp79b09_0z.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp79b09_0z.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list.append(i)\n            else \n                odd_list.append(i*2)\n\
    \        end\n        odd_list\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    Given a positive integer n, return a sorted list that has the even\
    \ numbers in collatz sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg03tgx9g.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg03tgx9g.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpo60adfe6.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpo60adfe6.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpo60adfe6.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n - 1) do \n        if i % 2 == 0 \n            odd_list.append(i)\n\
    \        else \n            odd_list.append(i*2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\n@time odd_list = get_odd_collatz(100)\n\
    </cell>\n<code language=julia-1.5>\n@time odd_list = get_odd_collatz(100)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes in a positive integer n and returns\
    \ the n-th Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1x9ue84i.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1x9ue84i.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the nth Fibonacci number.\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4jq49spt.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4jq49spt.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a positive integer n and returns the number of steps\
    \ to reach 1 from the starting number n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4474m98h.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4474m98h.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.3>\n@time get_odd_collatz(100)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplud_dcpq.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplud_dcpq.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        collatz = get_odd_collatz(n\
    \ / 2)\n        push!(collatz, n % 2 == 0 ? n : 3 * n + 1) \n        return collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_steps(5) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq7s2qhi3.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq7s2qhi3.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 3 if n % 2 == 0 else n * 2 + 1]\n        return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgiqb9gby.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgiqb9gby.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n-1)\
    \ \n        if x % 2 == 1 \n            odd_list += [x/2]\n        else \n   \
    \         odd_list += [x*3] + [1]\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes in a positive integer n and returns the nth term of the\
    \ Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp86fw2c38.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp86fw2c38.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x/2)\n        end\n    end\n    \n\
    \    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in an integer n and returns\
    \ the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi5njb2cv.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi5njb2cv.jl:33\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 3]\n   \
    \     return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnkprxxh_.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnkprxxh_.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 3 + (n % 2 == 0)]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a positive integer n and returns the\
    \ nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3wfte52n.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3wfte52n.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(3*x + 1)\n        end\n    end\n  \
    \  \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n@time odd_list\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_list =\
    \ get_odd_collatz(100)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpspv1h3xe.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpspv1h3xe.jl:33\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list.append(1)\n    odd_list.append(n)\n    while\
    \ odd_list[2] != 1\n        odd_list[1] = odd_list[2]\n        odd_list[2] = odd_list[1]\
    \ / 2\n        odd_list[1] = odd_list[1] % 2\n        odd_list.append(odd_list[2])\n\
    \    end\n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps to reach 1 from the first even number. For\
    \ example, get_evens_steps(5) returns 3.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0hrg9ht1.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0hrg9ht1.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    \n    while n != 1\n        if\
    \ n % 2 == 0\n            odd_list .= odd_list .+ [n / 2]\n            n = n /\
    \ 2\n        else\n            odd_list .= odd_list .+ [3*n+1, 3*n+2]\n      \
    \      n = (3*n+2)/2\n        end\n    end\n    return odd_list\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1s0fmtk7.jl:37\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  DimensionMismatch(\"\
    array could not be broadcast to match destination\")\n  Stacktrace:\n   [1] check_broadcast_shape\
    \ at ./broadcast.jl:509 [inlined]\n   [2] check_broadcast_axes at ./broadcast.jl:512\
    \ [inlined]\n   [3] check_broadcast_axes at ./broadcast.jl:516 [inlined]\n   [4]\
    \ instantiate at ./broadcast.jl:259 [inlined]\n   [5] materialize! at ./broadcast.jl:823\
    \ [inlined]\n   [6] get_odd_collatz(::Int64) at /tmp/tmp1s0fmtk7.jl:26\n   [7]\
    \ top-level scope at /tmp/tmp1s0fmtk7.jl:37\n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmp1s0fmtk7.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmp1s0fmtk7.jl:38\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  DimensionMismatch(\"array could not be broadcast to match destination\"\
    )\n  Stacktrace:\n   [1] check_broadcast_shape at ./broadcast.jl:509 [inlined]\n\
    \   [2] check_broadcast_axes at ./broadcast.jl:512 [inlined]\n   [3] check_broadcast_axes\
    \ at ./broadcast.jl:516 [inlined]\n   [4] instantiate at ./broadcast.jl:259 [inlined]\n\
    \   [5] materialize! at ./broadcast.jl:823 [inlined]\n   [6] get_odd_collatz(::Int64)\
    \ at /tmp/tmp1s0fmtk7.jl:26\n   [7] top-level scope at /tmp/tmp1s0fmtk7.jl:38\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmp1s0fmtk7.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmp1s0fmtk7.jl:39\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  DimensionMismatch(\"array could not be broadcast to match destination\"\
    )\n  Stacktrace:\n   [1] check_broadcast_shape at ./broadcast.jl:509 [inlined]\n\
    \   [2] check_broadcast_axes at ./broadcast.jl:512 [inlined]\n   [3] check_broadcast_axes\
    \ at ./broadcast.jl:516 [inlined]\n   [4] instantiate at ./broadcast.jl:259 [inlined]\n\
    \   [5] materialize! at ./broadcast.jl:823 [inlined]\n   [6] get_odd_collatz(::Int64)\
    \ at /tmp/tmp1s0fmtk7.jl:26\n   [7] top-level scope at /tmp/tmp1s0fmtk7.jl:39\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmp1s0fmtk7.jl:36\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1s0fmtk7.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_nums = Vector{Int64}()\n\
    \        odd_nums.push(get_odd_collatz(n-1))\n        odd_nums.push(get_odd_collatz(n/2))\n\
    \        odd_nums.push(get_odd_collatz(n*3+1)) \n        return odd_nums\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk5onie3e.jl:33\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  type Array has no field\
    \ push\n  Stacktrace:\n   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n\
    \   [2] get_odd_collatz(::Int64) at /tmp/tmpk5onie3e.jl:22\n   [3] top-level scope\
    \ at /tmp/tmpk5onie3e.jl:33\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpk5onie3e.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpk5onie3e.jl:34\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  type Array has no field push\n  Stacktrace:\n   [1] getproperty(::Array{Int64,1},\
    \ ::Symbol) at ./Base.jl:33\n   [2] get_odd_collatz(::Int64) at /tmp/tmpk5onie3e.jl:22\n\
    \   [3] top-level scope at /tmp/tmpk5onie3e.jl:34\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpk5onie3e.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpk5onie3e.jl:35\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  type Array has no field push\n  Stacktrace:\n   [1] getproperty(::Array{Int64,1},\
    \ ::Symbol) at ./Base.jl:33\n   [2] get_odd_collatz(::Int64) at /tmp/tmpk5onie3e.jl:22\n\
    \   [3] top-level scope at /tmp/tmpk5onie3e.jl:35\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpk5onie3e.jl:32\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk5onie3e.jl:30\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n == 1\n        odd_list = [n]\n    else\n     \
    \   odd_list = [1]\n        for i in 2:n\n            if isodd(i)\n          \
    \      odd_list .= [i/2, 3*i+1]\n            else\n                odd_list .=\
    \ [i/2, 3*i+1]\n        end\n    end\n    return odd_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpaiblqrua.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpaiblqrua.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.3>\nget_odd_collatz(10)\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that takes an integer n and returns the nth Fibonacci number.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp02pk_395.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp02pk_395.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n   \
    \     odd_collatz .+= [n * 2]\n        return odd_collatz\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the first n positive integers greater than or equal\
    \ to n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu73z0w_6.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu73z0w_6.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 3]\n   \
    \     return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppj943ac0.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppj943ac0.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the number of steps it takes to reach 1 from n.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps8ja0y4q.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmps8ja0y4q.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n==1 \n        odd_list = [n]\n    else\n      \
    \  odd_list = [1]\n        for i in 2:n\n            if i%2==0 \n            \
    \    odd_list.append(i/2)\n            else \n                odd_list.append(3*i+1)\n\
    \    end\n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcohkgl72.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcohkgl72.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the nth number in the Fibonacci sequence.\
    \ \nThe Fibonacci sequence is defined by the recurrence relation:\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx_yafhsu.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpx_yafhsu.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz3u3452i.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz3u3452i.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the factorial of a given positive integer.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsx8vu36v.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsx8vu36v.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz += [n / 2]\n    else \n\
    \        odd_collatz += [n / 2] * 3 + 1\n    \n    return odd_collatz\nend\n</cell>\n\
    <code language=julia-1.4>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the nth Fibonacci number using recursion.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5xcn6csi.jl:30\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5xcn6csi.jl:30\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    return odd_list\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwtax7y47.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwtax7y47.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwtax7y47.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 1 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[2:end]\n    else \n        odd_collatz = [odd_collatz[1],\
    \ odd_collatz[1] * 3] + odd_collatz[2:end]\n    \n    return odd_collatz\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkkkroeaa.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkkkroeaa.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        collatz = get_odd_collatz(n\
    \ / 2)\n        push!(collatz, n % 2)\n        return collatz\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpv11uxwua.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpv11uxwua.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpv11uxwua.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 0 \n        \
    \        odd_list.append(i)\n            else \n                odd_list.append(i*3\
    \ + 1)\n        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a positive integer n and returns the number of steps it takes to reach 1 from\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplpvtbdip.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplpvtbdip.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes an integer n and returns the nth\
    \ Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpco841398.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpco841398.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list += [i]\n            else \n                odd_list += [i*3]\n\
    \        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsu0s7eu6.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsu0s7eu6.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nProblem 3\nWrite a function that takes in a positive integer n and returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdy9gv1_w.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdy9gv1_w.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 2 % n]\n        odd_collatz .+= [n * 3 %\
    \ n]\n        return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpf3083rmy.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpf3083rmy.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpf3083rmy.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that takes in a positive integer n and returns the number of steps\
    \ to reach 1 from n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8dhx6iw_.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8dhx6iw_.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the number of steps it takes to reach 1 from the first odd number in the Collatz\
    \ sequence. For example, get_odd_steps(5) should return 3 since it takes 3 steps\
    \ to reach 1 from the first odd number in the Collatz sequence starting with 5.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2myv37yj.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2myv37yj.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n\
    \ - 1) \n        if x % 2 == 1 \n            odd_list.append(x)\n            odd_list.append(x/2)\n\
    \        else \n            odd_list.append(3*x + 1)\n    end\n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a positive integer n and returns the nth\
    \ term of the Fibonacci sequence.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnufgp56f.jl:30\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnufgp56f.jl:30\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdd9q3t9k.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpdd9q3t9k.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpdd9q3t9k.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n-1)\n\
    \    odd_collatz += [n/2]\n    if n % 2 == 1 \n        odd_collatz += [n*3]\n\
    \    odd_collatz\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    Given a\
    \ positive integer n, return a sorted list that has the even numbers in collatz\
    \ sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8fqdgfi1.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8fqdgfi1.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n / 2] * (n % 2 == 0 ? 1 : 3)\n        return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnz_wf11k.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpnz_wf11k.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpnz_wf11k.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 3 if n % 2 == 0 else n * 2 + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the first n prime numbers.\
    \ \nThe function should take an input n and return the prime numbers in increasing\
    \ order.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpo7u_97pa.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpo7u_97pa.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x * 2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a positive integer n and returns\
    \ the number of steps it takes to reach 1 from n.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1ed8uzfu.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1ed8uzfu.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9a4ldjlq.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp9a4ldjlq.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp9a4ldjlq.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7knbkas2.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7knbkas2.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 3 + (n % 2 == 0)]\n    odd_collatz .= odd_collatz\
    \ .+ get_odd_collatz(n / 2)\n    return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5mzpa92q.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5mzpa92q.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz += [n * 2 if n % 2 == 0 else n * 3]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_xeuvsz5.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_xeuvsz5.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n-1)\n\
    \    \n    if n % 2 == 0 \n        odd_collatz .+= [n/2]\n    else \n        odd_collatz\
    \ .+= [n*3]\n    \n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4xs8ytmf.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4xs8ytmf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_nums = get_odd_collatz(n/2)\n\
    \        odd_nums.push(3*n+1)\n        return odd_nums\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf08fedmp.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf08fedmp.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n-1) do \n        if i % 2 == 1 \n            odd_list.append(i)\n\
    \        else \n            odd_list.append(i*2)\n            \n            odd_list.append(i*3+1)\n\
    \    end\n    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ an integer n and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_k2rvtq6.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_k2rvtq6.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\
    \ + [n/2]\n        odd_collatz = [i for i in odd_collatz if i % 2 == 1]\n    \
    \    return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes an integer n and returns\
    \ the number of even numbers less than or equal to n.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe5dsdfo0.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe5dsdfo0.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 1\n            odd_list += [n/2]\n\
    \        else\n            odd_list += [n*3] + [n/2]\n    end\n    \n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgq6jl0hk.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgq6jl0hk.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeydd0m1v.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpeydd0m1v.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpeydd0m1v.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an integer $n$ and returns the\
    \ number of steps it takes to reach 1 from $n$. \nFor example, given $n = 10$,\
    \ the function should return $5$.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi2pr1sql.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi2pr1sql.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0qwdg8xm.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0qwdg8xm.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0qwdg8xm.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_nums = get_odd_collatz(n-1)\n\
    \        odd_nums.push(3*n+1)\n        return odd_nums\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6pbcdiot.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp6pbcdiot.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp6pbcdiot.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppweztbbs.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmppweztbbs.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmppweztbbs.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the factorial of a given number.\
    \ \nThe factorial of a number $n$ is defined as the product of all the positive\
    \ integers less than or equal to $n$. \nFor example, factorial(5) = 5 \xD7 4 \xD7\
    \ 3 \xD7 2 \xD7 1 = 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3x7fyohu.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3x7fyohu.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    if n == 1 \n        odd_list =\
    \ [1]\n        return odd_list\n    elseif n % 2 == 0 \n        odd_list = [n,\
    \ 3*n+1]\n        return odd_list\n    else\n        odd_list = [n, 3*n+1]\n \
    \       return odd_list\n    end\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a positive integer n\
    \ and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxr32o2q7.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxr32o2q7.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1vlf6dnn.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp1vlf6dnn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp1vlf6dnn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 3 if n % 2 == 0 else n * 2 + 1]\n        return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9s4bk3a_.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9s4bk3a_.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeg8sy7c5.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpeg8sy7c5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpeg8sy7c5.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = Vector{Int64}()\n    if n == 1\n        odd_list = [n]\n  \
    \  else\n        odd_list = get_odd_collatz(n / 2)\n        if n % 2 == 0\n  \
    \          odd_list.append(n / 2)\n        else\n            odd_list.append(3\
    \ * odd_list[-1] + 1)\n        end\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that takes in a positive integer n and returns the nth term of the\
    \ Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfsmya_55.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfsmya_55.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwyp399nn.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwyp399nn.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3\n    odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer n and returns the first n odd\
    \ numbers in Collatz sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8e5vorus.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8e5vorus.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert get_odd_collatz(5) == [1, 5]\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the Collatz conjecture for n \u2264\
    \ 100. Your function should work for any positive integer n.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1lqhca36.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1lqhca36.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n\
    \ - 1) \n        if x % 2 == 1 \n            odd_list += [x/2]\n        else \n\
    \            odd_list += [x * 3] + [1]\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the factorial of a given positive integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1ndizou0.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1ndizou0.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpihldkobq.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpihldkobq.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    odd_list = odd_list + [n / 2]\n\
    \    odd_list = odd_list + [n / 2 * 3]\n    odd_list = odd_list + [n / 2 * 3 *\
    \ 5]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7]\n    odd_list = odd_list +\
    \ [n / 2 * 3 * 5 * 7 * 9]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 *\
    \ 11]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13]\n    odd_list\
    \ = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15]\n    odd_list = odd_list\
    \ + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17]\n    odd_list = odd_list + [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19]\n    odd_list = odd_list + [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21]\n    odd_list = odd_list\
    \ + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23]\n    odd_list =\
    \ odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25]\n\
    \    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21\
    \ * 23 * 25 * 27]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13\
    \ * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29]\n    odd_list = odd_list + [n / 2 *\
    \ 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31]\n    odd_list\
    \ = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25\
    \ * 27 * 29 * 31 * 33]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11\
    \ * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31 * 33\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpegnjut7k.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpegnjut7k.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps26_y2fr.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmps26_y2fr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmps26_y2fr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a positive integer n and returns the nth\
    \ Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfr6_du14.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfr6_du14.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list.append(i)\n            else \n                odd_list.append(i*2)\n\
    \                odd_list.append(i*3+1)\n        end\n        return odd_list\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_xyn234.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn_xyn234.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz .+= [n]\n    else \n   \
    \     odd_collatz .+= [n] * 3 + 1\n    \n    return odd_collatz\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkjrcjdp_.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkjrcjdp_.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    \n    if n % 2 == 0 \n        odd_list += [n/2]\n\
    \    else \n        odd_list += [n*3]\n    \n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the factorial of a given positive integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjcj7ja4u.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjcj7ja4u.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for i in get_odd_collatz(n\
    \ - 1) do \n        if i % 2 == 1 \n            odd_list += [i]\n        else\
    \ \n            odd_list += [i * 3]\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the nth term of the Fibonacci sequence. \nThe Fibonacci\
    \ sequence is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsjog1ude.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsjog1ude.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x/2)\n    end\n    \n    odd_list\
    \ += [x+1 for x in odd_list if x % 2 != 1]\n    \n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a positive integer n and returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbbkwirld.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbbkwirld.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n-1)\
    \ do \n        if x % 2 == 1 \n            odd_list += [x/2]\n        else \n\
    \            odd_list += [x*3]\n    end\n    odd_list += [1]\n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes in a positive integer n and returns the\
    \ n-th Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnj3tsref.jl:30\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnj3tsref.jl:30\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        if n % 2 == 1 \n            odd_collatz\
    \ .+= [n + 1]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the factorial of a given positive integer. \nFor\
    \ example, factorial(5) = 5 x 4 x 3 x 2 x 1 = 120\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpztznhrap.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpztznhrap.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzr2jy58h.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpzr2jy58h.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpzr2jy58h.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    Given a positive integer n, return a sorted\
    \ list that has the even numbers in collatz sequence.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu3mi1vvp.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu3mi1vvp.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in 1:n\n        if isodd(i) == true\n            odd_list += [i]\n       \
    \ else\n            odd_list += [i/2]\n        end\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv4x41ppj.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv4x41ppj.jl:33\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp83ag8g3d.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp83ag8g3d.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp83ag8g3d.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphjvyvzmo.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphjvyvzmo.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a positive integer n and returns the number\
    \ of steps it takes to reach 1 from n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4k187aag.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4k187aag.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw78jyig7.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpw78jyig7.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpw78jyig7.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a positive integer n\
    \ and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnclk98n4.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnclk98n4.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\n@time odd_list = get_odd_collatz(10)\n</cell>\n<code\
    \ language=julia-1.5>\n@time odd_list = get_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a positive integer n and returns the\
    \ nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppm0zopgo.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppm0zopgo.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes in a positive integer n and returns the nth term of\
    \ the Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence\
    \ relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpch36l1v1.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpch36l1v1.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_nums = Vector{Int64}()\n\
    \    \n    for x in get_odd_collatz(n - 1)\n        if x % 2 == 1\n          \
    \  odd_nums += [x]\n        else\n            odd_nums += [x * 3]\n        end\n\
    \    end\n    \n    odd_nums\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the factorial of a\
    \ given number. \nThe factorial of a number $n$ is defined as the product of all\
    \ positive integers less than or equal to $n$.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnnmahtpx.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnnmahtpx.jl:33\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpl26nuhl4.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpl26nuhl4.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpl26nuhl4.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    odd_collatz\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the nth number in the Fibonacci sequence. \n\
    For example, get_fibonacci(3) should return 5.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6t285i84.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6t285i84.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/5]\n        odd_collatz .+= [n/7]\n        odd_collatz .+= [n/11]\n \
    \       odd_collatz .+= [n/13]\n        odd_collatz .+= [n/17]\n        odd_collatz\
    \ .+= [n/19]\n        odd_collatz .+= [n/23]\n        odd_collatz .+= [n/29]\n\
    \        odd_collatz .+= [n/37]\n        odd_collatz .+= [n/53]\n        odd_collatz\
    \ .+= [n/63]\n        odd_collatz .+= [n/79]\n        odd_collatz .+= [n/91]\n\
    \        odd_collatz .+= [n/103]\n        odd_collatz .+= [n/107]\n        odd_collatz\
    \ .+= [n/111]\n        odd_collatz .+= [n/113]\n        odd_collatz .+= [n/115]\n\
    \        odd_collatz .+= [n/117]\n        odd_collatz .+= [n/119]\n        odd_collatz\
    \ .+= [n/121]\n        odd_collatz .+= [n/123]\n        odd_collatz .+= [n/125]\n\
    \        odd_collatz .+= [n/127]\n        odd_collatz .+= [n/129]\n        odd_collatz\
    \ .+= [n/131]\n        odd_collatz .+= [n/133]\n        odd_collatz .+= [n/135]\n\
    \        odd_collatz .+= [n/137]\n        odd_collatz .+= [n/139]\n        odd_collatz\
    \ .+= [n/141]\n        odd_collatz .+= [n/143]\n        odd_collatz .+= [n/145]\n\
    \        odd_collatz .+= [n/147]\n        odd_collatz .+= [n/149]\n        odd_collatz\
    \ .+= [n/\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0i72dfim.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0i72dfim.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2dakuko4.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2dakuko4.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgte_9t83.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgte_9t83.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0\
    \ ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 ==\
    \ 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2\
    \ == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n\
    \ % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+=\
    \ n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6q0rg72x.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6q0rg72x.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the Collatz sequence for n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_iel6stt.jl:27\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_iel6stt.jl:27\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz = [odd_collatz[1], odd_collatz[2]*odd_collatz[1]] \n    \
    \    return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdkj_wke6.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpdkj_wke6.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpdkj_wke6.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .= [n/2]\n        if n % 2 == 1 \n            odd_collatz\
    \ .= [n*3]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the nth term of the Fibonacci sequence. \nThe Fibonacci\
    \ sequence is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp29jf4clz.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp29jf4clz.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0\
    \ ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 ==\
    \ 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2\
    \ == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n\
    \ % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+=\
    \ n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1hp08cp8.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1hp08cp8.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdcxwrjrs.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpdcxwrjrs.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpdcxwrjrs.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(3*x + 1)\n        end\n    end\n  \
    \  \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the nth term of the\
    \ Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8ux6g9nh.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8ux6g9nh.jl:33\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps to reach 1 from n.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj38v41kf.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj38v41kf.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_steps(5) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp175rg2f4.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp175rg2f4.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \    return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"for\" after end of expression\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt_xt9z0j.jl:22\n [2] include(::Module,\
    \ ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n\
    \ [4] _start() at ./client.jl:484\nin expression starting at /tmp/tmpt_xt9z0j.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list\
    \ += [x/2]\n        else \n            odd_list += [x*3] + [1]\n    end\n    \n\
    \    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp24ovkc9b.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp24ovkc9b.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes in a positive integer n and returns the\
    \ number of steps it takes to reach 1 from the starting number n.\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp8m9_k9_.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpp8m9_k9_.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i%2 == 1 \n          \
    \      odd_list += [i/2]\n            else \n                odd_list += [i*3]\n\
    \        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp95gh2cnz.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp95gh2cnz.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5r2urp54.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5r2urp54.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the factorial of a given positive integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe58sdul9.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe58sdul9.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \    odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a positive integer n\
    \ and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"for\" after end of expression\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6likxlb2.jl:22\n [2] include(::Module,\
    \ ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n\
    \ [4] _start() at ./client.jl:484\nin expression starting at /tmp/tmp6likxlb2.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .= [n/2]\n        odd_collatz .= odd_collatz .+ [n*3+1]\n\
    \        return odd_collatz\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpovi7pegf.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpovi7pegf.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 0 \n            odd_list.append(n/2)\n\
    \        else\n            odd_list.append(3*n+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_num_steps(5) should\
    \ return 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4e1b1jeq.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4e1b1jeq.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw4_t30y4.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw4_t30y4.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a positive integer n and returns the nth term of the\
    \ Collatz conjecture.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpim80lvy4.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpim80lvy4.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n-1) do \n        if i % 2 == 1 \n            odd_list\
    \ += [i]\n        else \n            odd_list += [i * 3]\n    end\n    \n    odd_list\
    \ += [n]\n    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(5)\n</cell>\n<text>\nProblem 3\nWrite a function that takes an\
    \ integer n and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkabktlva.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkabktlva.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcu062fns.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcu062fns.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprwjhwi5i.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprwjhwi5i.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0\
    \ ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 ==\
    \ 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2\
    \ == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n\
    \ % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+=\
    \ n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp917wm8de.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp917wm8de.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an integer n and returns the number of positive integers\
    \ less than or equal to n that have the Collatz sequence starting from 1.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpo9etu_yv.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpo9etu_yv.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n == 1 \n        odd_list = [n]\n    else\n    \
    \    odd_list = [1]\n        for i in 2:n\n            if isodd(i) == true\n \
    \               odd_list[i] = odd_list[i-1] * 2\n            else\n          \
    \      odd_list[i] = odd_list[i-1] * 3 + 1\n        end\n    end\n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpii3nhini.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpii3nhini.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 0 \n            odd_list.append(n/2)\n\
    \        else\n            odd_list.append(3*n+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a positive integer n and returns the\
    \ nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvimdw8wr.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvimdw8wr.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n - 1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x * 3 + 1)\n        end\n    end\n\
    \    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvkqbdsur.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvkqbdsur.jl:33\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpson4iq8t.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpson4iq8t.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n-1)\n\
    \        if x % 2 == 1\n            odd_list.append(x)\n        else\n       \
    \     odd_list.append(x*2 + 1)\n    end\n    return odd_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm0o6jnrs.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm0o6jnrs.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/5]\n        odd_collatz .+= [n/7]\n        odd_collatz .+= [n/11]\n \
    \       odd_collatz .+= [n/13]\n        odd_collatz .+= [n/17]\n        odd_collatz\
    \ .+= [n/19]\n        odd_collatz .+= [n/23]\n        odd_collatz .+= [n/29]\n\
    \        odd_collatz .+= [n/37]\n        odd_collatz .+= [n/53]\n        odd_collatz\
    \ .+= [n/59]\n        odd_collatz .+= [n/67]\n        odd_collatz .+= [n/83]\n\
    \        odd_collatz .+= [n/99]\n        odd_collatz .+= [n/107]\n        odd_collatz\
    \ .+= [n/131]\n        odd_collatz .+= [n/163]\n        odd_collatz .+= [n/193]\n\
    \        odd_collatz .+= [n/225]\n        odd_collatz .+= [n/251]\n        odd_collatz\
    \ .+= [n/289]\n        odd_collatz .+= [n/361]\n        odd_collatz .+= [n/523]\n\
    \        odd_collatz .+= [n/597]\n        odd_collatz .+= [n/673]\n        odd_collatz\
    \ .+= [n/823]\n        odd_collatz .+= [n/997]\n        odd_collatz .+= [n/1037]\n\
    \        odd_collatz .+= [n/1319]\n        odd_collatz .+= [n/1637]\n        odd_collatz\
    \ .+= [n/1937]\n        odd_collatz .+= [n/2237]\n        odd_collatz .+= [n/2537]\n\
    \        odd_collatz .+= [n/2897]\n        odd_collatz .+= [n/3617]\n        odd_\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpbtvvcnru.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpbtvvcnru.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpbtvvcnru.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list.append(1)\n    odd_list.append(n)\n    while\
    \ odd_list[2] != 1\n        odd_list[1] = odd_list[2]\n        odd_list[2] = odd_list[1]\
    \ / 2\n        odd_list[1] = odd_list[1] % 2\n    end\n    return odd_list\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes in a positive integer n and returns the nth Fibonacci\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph4xl176j.jl:28\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph4xl176j.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the factorial of a given positive integer. \nFor example,\
    \ factorial(5) returns 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnp3fvzfb.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnp3fvzfb.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[2:end]\n    else \n        odd_collatz = [odd_collatz[1],\
    \ odd_collatz[1] * 3] + odd_collatz[2:end]\n    end\n    \n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0vi5h6cu.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0vi5h6cu.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0vi5h6cu.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .= [n * 3 + (n % 2 == 0)]\n    odd_collatz .= odd_collatz[end-1]\n\
    \    odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppaho0eoi.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmppaho0eoi.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmppaho0eoi.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_nums = Vector{Int64}()\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr1nu1chw.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr1nu1chw.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n - 1) \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x * 2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the nth number in the Fibonacci\
    \ sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbp19b_0t.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbp19b_0t.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    \n    if n % 2 == 1 \n        odd_list += [n/2]\n\
    \    \n    odd_list += [n*3+1]\n    \n    return odd_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a positive integer n and returns the nth term of the Fibonacci\
    \ sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe6afbb5c.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe6afbb5c.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n*3+1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the nth term of the Fibonacci sequence. \nThe Fibonacci sequence\
    \ is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpio7b1lw4.jl:26\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpio7b1lw4.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list.append(1)\n    odd_list.append(n)\n    while\
    \ odd_list[2] != 1\n        odd_list[1] = odd_list[2]\n        odd_list[2] = odd_list[1]\
    \ / 2\n        odd_list[1] = odd_list[1] % 2\n        odd_list.append(odd_list[2])\n\
    \    end\n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpatco052m.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpatco052m.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .= [n/2]\n        odd_collatz .= odd_collatz .+ [n/3]\n \
    \       odd_collatz .= odd_collatz .+ [n/5]\n        odd_collatz .= odd_collatz\
    \ .+ [n/7]\n        odd_collatz .= odd_collatz .+ [n/11]\n        odd_collatz\
    \ .= odd_collatz .+ [n/13]\n        odd_collatz .= odd_collatz .+ [n/17]\n   \
    \     odd_collatz .= odd_collatz .+ [n/19]\n        odd_collatz .= odd_collatz\
    \ .+ [n/23]\n        odd_collatz .= odd_collatz .+ [n/29]\n        odd_collatz\
    \ .= odd_collatz .+ [n/31]\n        return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjq0rqaqm.jl:35\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjq0rqaqm.jl:35\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz = collatz\n        for i in collatz \n            if i %\
    \ 2 == 1 \n                odd_collatz += [i / 2]\n            else \n       \
    \         odd_collatz += [i * 3]\n        end\n        return odd_collatz\n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the number of positive integers less than or equal to n that are evenly divisible\
    \ by 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9an_w94t.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9an_w94t.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\n@time odd_collatz = get_odd_collatz(10)\n\
    </cell>\n<code language=julia-1.5>\n@time odd_collatz = get_odd_collatz(100)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that computes the factorial of a\
    \ given positive integer. \nThe factorial of a non-negative integer is defined\
    \ as the product of all positive integers less than or equal to that integer.\
    \ \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"]\" after end of expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpap2dtm31.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpap2dtm31.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpssyyl45l.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpssyyl45l.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpssyyl45l.jl:1\n"
  exit_code: 1
  status: Exception
