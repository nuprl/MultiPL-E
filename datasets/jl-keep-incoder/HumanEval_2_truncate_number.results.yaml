name: HumanEval_2_truncate_number
language: julia
results:
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    if truncate_number\
    \ == number\n        truncate_number = number\n    end\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    trun\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_rvfsqh4.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_rvfsqh4.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp84dky8bk.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp84dky8bk.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nNow let's see how we can use these functions\
    \ to solve the problem of finding the largest prime factor of a given number.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeyi1599b.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeyi1599b.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nThe function truncate_number has now been defined. Let's test it on a\
    \ few examples:\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcxpztltq.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcxpztltq.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    number = round(number)\n    \n    if number < 1:\n        return\
    \ number\n    \n    decimals = math.floor(math.log(number, 10))\n    \n    if\
    \ number % 1 == 0.0:\n        return number / 10 ** decimals\n    \n    return\
    \ number / 10 ** decimals + 1\nend\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.0)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.7)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.7)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.2)\n\
    </cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpki7yaif8.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpki7yaif8.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsqeebpw9.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsqeebpw9.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = round(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nNow let's try\
    \ it out on some examples:\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpllavsq_o.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpllavsq_o.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = floor(number)\n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    return truncate_number\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the number of digits in a given number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpshiuolzv.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpshiuolzv.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = round(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3cwk914t.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 4.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp3cwk914t.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3cwk914t.jl:17\ntest set: Test Failed at /tmp/tmp3cwk914t.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3cwk914t.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3cwk914t.jl:17\ntest set: Test Failed at /tmp/tmp3cwk914t.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3cwk914t.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3cwk914t.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3cwk914t.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9t_30kx_.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9t_30kx_.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjw22raqm.jl:17\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmpjw22raqm.jl:10\n\
    \   [2] top-level scope at /tmp/tmpjw22raqm.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjw22raqm.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpjw22raqm.jl:18\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpjw22raqm.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpjw22raqm.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjw22raqm.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpjw22raqm.jl:19\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpjw22raqm.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpjw22raqm.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjw22raqm.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjw22raqm.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp10gne3na.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp10gne3na.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nThe function\
    \ truncate_number above is now ready to be used in our next exercise.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpozug0ufn.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpozug0ufn.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nNow let's write\
    \ a function which can convert a number from one base to another.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0en2ccsf.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0en2ccsf.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    number = round(number)\n    \n    if number < 1:\n        return\
    \ number\n    \n    decimals = math.floor(math.log(number, 10))\n    \n    if\
    \ decimals == 0:\n        return number\n    \n    decimals = decimals + 1\n \
    \   \n    number = number - math.pow(10, -decimals)\n    \n    return number\n\
    </code>\n<|/ a tags=julia,rounding |>\n<| a dscore=2 |>\nThe accepted answer does\
    \ not work for negative numbers. Here is a version that does:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxeqsm87e.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxeqsm87e.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    if truncate_number\
    \ == 0.0\n        \n        return 0.0\n    \n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    \n    return truncate_number\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi9dxpxgr.jl:9\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpi9dxpxgr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpi9dxpxgr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to the nearest integer.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpji96c2x1.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpji96c2x1.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphs8to397.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphs8to397.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nNow let's see how we can use our truncate\
    \ function to round a number to the nearest multiple of $10$:\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphypak8wj.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphypak8wj.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = round(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nNow let's create a function that can convert a number from one base to\
    \ another.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoj1832jz.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpoj1832jz.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphc_zv2_z.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphc_zv2_z.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that converts a number from one base to another.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpedxklxib.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpedxklxib.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgxc_xejf.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgxc_xejf.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkpkxwi_z.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkpkxwi_z.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    return truncate_number\nend\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.7)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.7)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.0)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.5)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuk7vmnye.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuk7vmnye.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nThe function truncate_number above is equivalent to the Julia function\
    \ trunc\n(which truncates floating point numbers to integers).\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0_up3v9i.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0_up3v9i.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp13ufoqlg.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp13ufoqlg.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    if truncate_number < 0.5\n\
    \        truncate_number = truncate_number + 1.0\n    end\n    \n    return truncate_number\n\
    end\n</cell>\n<text>\nExercise 2\nWrite a function that returns the number of\
    \ digits in an integer.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplt1tf8nl.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplt1tf8nl.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    number = round(number)\n    \n    if number % 1 == 0.0:\n      \
    \  return number\n    else:\n        return number - number % 1\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nThe function\
    \ truncate_number above is called in the following cells.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3e02dn_n.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3e02dn_n.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmps0m3tc58.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmps0m3tc58.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0m3tc58.jl:17\ntest set: Test Failed at /tmp/tmps0m3tc58.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0m3tc58.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0m3tc58.jl:17\ntest set: Test Failed at /tmp/tmps0m3tc58.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0m3tc58.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0m3tc58.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps0m3tc58.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.1>\n# Tests\n@test truncate_number(3.5) == 0.5\n@test truncate_number(3.6)\
    \ == 0.6\n@test truncate_number(3.7) == 0.7\n@test truncate_number(3.8) == 0.8\n\
    @test truncate_number(3.9) == 0.9\n@test truncate_number(3.10) == 1.0\n@test truncate_number(3.11)\
    \ == 1.1\n@test truncate_number(3.12) == 1.2\n@test truncate_number(3.13) == 1.3\n\
    @test truncate_number(3.14) == 1.4\n@test truncate_number(3.15) == 1.5\n@test\
    \ truncate_number(3.16) == 1.6\n@test truncate_number(3.17) == 1.7\n@test truncate_number(3.18)\
    \ == 1.8\n@test truncate_number(3.19) == 1.9\n@test truncate_number(3.20) == 2.0\n\
    @test truncate_number(3.21) == 2.1\n@test truncate_number(3.22) == 2.2\n@test\
    \ truncate_number(3.23) == 2.3\n@test truncate_number(3.24) == 2.4\n@test truncate_number(3.25)\
    \ == 2.5\n@test truncate_number(3.26) == 2.6\n@test truncate_number(3.27) == 2.7\n\
    @test truncate_number(3.28) == 2.8\n@test truncate_number(3.29) == 2.9\n@test\
    \ truncate_number(3.30) == 3.0\n@test truncate_number(3.31) == 3.1\n@test truncate_number(3.32)\
    \ == 3.2\n@test truncate_number(3.33) == 3.3\n@test truncate_number(3.34) == 3.4\n\
    @test truncate_number(3.35) == 3.5\n@test truncate_number(3.36) == 3.6\n@test\
    \ truncate_number(3.37) == 3.7\n@test truncate_number(3.38) == 3.8\n@test truncate_number(3.39)\
    \ == 3.9\n@test truncate_number(3.40) == 4.0\n@test truncate_number(3.41) == 4.1\n\
    @test truncate_number(3.42) == 4.2\n@test truncate_number(3.43) == 4.3\n@test\
    \ truncate_number(3.44) == 4.4\n@test truncate_number(3.45) == 4.5\n@test truncate_number(3.46)\
    \ == 4.6\n@test truncate_number(3.47) == 4.7\n@test truncate_number(3.48) == 4.8\n\
    @test truncate_number(3.49) == 4.9\n@test truncate_number(3.50) == 5.0\n@test\
    \ trun\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4dic2aop.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4dic2aop.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number\n    \n    truncate_number = truncate_number\
    \ % 1\n    \n    if truncate_number < 0.5\n        truncate_number = truncate_number\
    \ * 2\n    end\n    \n    return truncate_number\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.0)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.7)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.7)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpublqa9aq.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpublqa9aq.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpfagvnk9b.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpfagvnk9b.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfagvnk9b.jl:17\ntest set: Test Failed at /tmp/tmpfagvnk9b.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfagvnk9b.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfagvnk9b.jl:17\ntest set: Test Failed at /tmp/tmpfagvnk9b.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfagvnk9b.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfagvnk9b.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfagvnk9b.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of digits in an integer.\
    \ \nFor example, truncate_number(1000) should return 3.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd1faszy4.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd1faszy4.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    if number < 1.0\n        return number\n    \n    digits = floor(log10(number))\n\
    \    decimals = digits-int(digits)\n    \n    number = round(number*10^decimals)/10^decimals\n\
    \    \n    return number\nend\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.0)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.7)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.7)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.2)\n\
    </cell>\n<code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcfh_lm_5.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcfh_lm_5.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# TEST truncate number (5b)\n@test truncate_number(3.4)\
    \ == trunc(3.4)\n</cell>\n<text>\nExercise 4\nWrite a function that returns the\
    \ floor of a number. \nFor negative numbers, floor rounds downwards. For positive\
    \ numbers, floor rounds upwards.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) ==\
    \ 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5rhy0o5r.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5rhy0o5r.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9cumjoyd.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9cumjoyd.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    return truncate_number\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a positive floating point number as input and returns the number rounded to\
    \ a specified number of decimal places.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7q1ycn3r.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7q1ycn3r.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    number = round(number)\n    \n    if number < 1:\n        return\
    \ number\n    \n    decimals = math.floor(math.log(number, 10))\n    \n    if\
    \ number % 1 == 0 and decimals > 1:\n        decimals -= 1\n    \n    return number\
    \ / 10 ** decimals\nend\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the number of digits\
    \ of an integer.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc_51bjsk.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpc_51bjsk.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5rkzk1vn.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5rkzk1vn.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpdcddeads.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpdcddeads.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdcddeads.jl:17\ntest set: Test Failed at /tmp/tmpdcddeads.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdcddeads.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdcddeads.jl:17\ntest set: Test Failed at /tmp/tmpdcddeads.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdcddeads.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdcddeads.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdcddeads.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpmy51vojn.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpmy51vojn.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmy51vojn.jl:17\ntest set: Test Failed at /tmp/tmpmy51vojn.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmy51vojn.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmy51vojn.jl:17\ntest set: Test Failed at /tmp/tmpmy51vojn.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmy51vojn.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmy51vojn.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmy51vojn.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    digits = floor(log10(number))\n    decimals = number - truncate_number(number)\n\
    \    \n    if digits == 0\n        digits = 1\n    \n    return truncate_number(decimals)\
    \ / pow(10.0, digits)\nend\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a positive floating point\
    \ number as input and returns the decimal part as a floating point number.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnzdtisb1.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnzdtisb1.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp51gx283q.jl:17\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp51gx283q.jl:17\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp51gx283q.jl:16\ntest set: Test Failed at /tmp/tmp51gx283q.jl:18\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp51gx283q.jl:18\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp51gx283q.jl:16\ntest set: Test Failed at /tmp/tmp51gx283q.jl:19\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp51gx283q.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp51gx283q.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp51gx283q.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\n</cell>\n<code language=julia-1.3>\n\
    truncate_number(3.5)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the number of digits of an integer.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgx25vrk6.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgx25vrk6.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    return truncate_number\nend\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmps0tqfpe6.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmps0tqfpe6.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0tqfpe6.jl:17\ntest set: Test Failed at /tmp/tmps0tqfpe6.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0tqfpe6.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0tqfpe6.jl:17\ntest set: Test Failed at /tmp/tmps0tqfpe6.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0tqfpe6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0tqfpe6.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps0tqfpe6.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the number of digits in an integer. For example,\
    \ truncate_number(1000) should return 3.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprq_icctc.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprq_icctc.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpuyy6fxec.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpuyy6fxec.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuyy6fxec.jl:17\ntest set: Test Failed at /tmp/tmpuyy6fxec.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuyy6fxec.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuyy6fxec.jl:17\ntest set: Test Failed at /tmp/tmpuyy6fxec.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuyy6fxec.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuyy6fxec.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuyy6fxec.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nThe function\
    \ truncate_number above is very similar to trunc (which truncates a number to\
    \ the nearest integer), but we also want to truncate decimal numbers to the nearest\
    \ integer. For example, truncate_number(3.5) should return 3.5, but truncate_number(3.49)\
    \ should return 3.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptsnek1ur.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptsnek1ur.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.0)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.7)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.7)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvt2s6z2q.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvt2s6z2q.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a positive floating point number as input\
    \ and returns the absolute value of that number.\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0awt6e5d.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0awt6e5d.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    </code>\n<|/ a tags=julia,floating-point,truncate |>\n<| a tags=julia,floating-point,truncate\
    \ |>\nThe easiest way is to use floor:\n<code>\njulia> floor(1.5)\n1\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1x1nfiy8.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1x1nfiy8.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppb8e1acy.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppb8e1acy.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nThe function\
    \ truncate_number above returns the decimal part of the number.\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8arxyoyj.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8arxyoyj.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpiytk8mpz.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmpiytk8mpz.jl:10\n\
    \   [2] top-level scope at /tmp/tmpiytk8mpz.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiytk8mpz.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpiytk8mpz.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpiytk8mpz.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpiytk8mpz.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiytk8mpz.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpiytk8mpz.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpiytk8mpz.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpiytk8mpz.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiytk8mpz.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiytk8mpz.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    digits = math.floor(math.log(number, 10))\n    decimals = math.modf(number\
    \ * 10^digits)[1]\n    \n    return number / 10^digits * 10^decimals\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise\nWrite\
    \ a function that returns the number of digits in an integer. For example, truncate_number(1000)\
    \ should return 3.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3yz7ya3y.jl:16\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3yz7ya3y.jl:16\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    </code>\n<|/ a tags=julia |>\n<| a dscore=1 |>\nThe truncate function works in\
    \ Julia 1.0 and 1.1 but not in Julia 1.2. \n<code>\njulia> truncate(3.5)\nERROR:\
    \ MethodError: no method matching truncate(::Float64)\nClosest candidates are:\n\
    \  truncate(::AbstractFloat) at float.jl:425\n  truncate(::AbstractFloat, ::Int64)\
    \ at float.jl:425\n  ...\nStacktrace:\n [1] top-level scope at none:0\n</code>\n\
    The truncate function was introduced in Julia 1.2 but was later removed in Julia\
    \ 1.0. \nThe truncate function was introduced in Julia 1.2 but was later removed\
    \ in Julia 1.0. \nThe truncate function was introduced in Julia 1.2 but was later\
    \ removed in Julia 1.0. \nThe truncate function was introduced in Julia 1.2 but\
    \ was later removed in Julia 1.0. \nThe truncate function was introduced in Julia\
    \ 1.2 but was later removed in Julia 1.0. \nThe truncate function was introduced\
    \ in Julia 1.2 but was later removed in Julia 1.0. \nThe truncate function was\
    \ introduced in Julia 1.2 but was later removed in Julia 1.0. \nThe truncate function\
    \ was introduced in Julia 1.2 but was later removed in Julia 1.0. \nThe truncate\
    \ function was introduced in Julia 1.2 but was later removed in Julia 1.0. \n\
    The truncate function was introduced in Julia 1.2 but was later removed in Julia\
    \ 1.0. \nThe truncate function was introduced in Julia 1.2 but was later removed\
    \ in Julia 1.0. \nThe truncate function was introduced in Julia 1.2 but was later\
    \ removed in Julia 1.0. \nThe truncate function was introduced in Julia 1.2 but\
    \ was later removed in Julia 1.0. \nThe truncate function was introduced in Julia\
    \ 1.2 but was later removed in Julia 1.0. \nThe truncate function was introduced\
    \ in Julia 1.2 but was later removed in Julia 1.0. \nThe truncate function was\
    \ introduced in Julia 1.2 but was later removed in Julia 1.0. \nThe truncate function\
    \ was introduced in Julia 1.2 but was later removed in Julia 1.0. \nThe truncate\
    \ function was introduced in Julia 1.2 but was later removed in Julia 1.0. \n\
    The truncate \nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t\
    @test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpui3bzzt1.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpui3bzzt1.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv57633lt.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv57633lt.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.4>\n# Test the truncate function\ntruncate_number(3.5)\n\
    </cell>\n<text>\nNow let's write a function that converts a decimal number to\
    \ its binary representation.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxz55d0nt.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxz55d0nt.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmppxb9gvmb.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmppxb9gvmb.jl:10\n\
    \   [2] top-level scope at /tmp/tmppxb9gvmb.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppxb9gvmb.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmppxb9gvmb.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmppxb9gvmb.jl:10\n   [2] top-level scope\
    \ at /tmp/tmppxb9gvmb.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppxb9gvmb.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmppxb9gvmb.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmppxb9gvmb.jl:10\n   [2] top-level scope\
    \ at /tmp/tmppxb9gvmb.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppxb9gvmb.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppxb9gvmb.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpqxtb1sl4.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpqxtb1sl4.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqxtb1sl4.jl:17\ntest set: Test Failed at /tmp/tmpqxtb1sl4.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqxtb1sl4.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqxtb1sl4.jl:17\ntest set: Test Failed at /tmp/tmpqxtb1sl4.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqxtb1sl4.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqxtb1sl4.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqxtb1sl4.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the truncation function\ntruncate_number(3.5)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that converts a number from one\
    \ base to another. \nFor example convert from decimal to hexadecimal.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuc88ggey.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuc88ggey.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = trunc(number)\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj9144gda.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj9144gda.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    return truncate_number\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nNow let's try it out on some random numbers:\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3c7t2bfj.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3c7t2bfj.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = round(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvpo2i3jn.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvpo2i3jn.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp2zs7q5l0.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp2zs7q5l0.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2zs7q5l0.jl:17\ntest set: Test Failed at /tmp/tmp2zs7q5l0.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2zs7q5l0.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2zs7q5l0.jl:17\ntest set: Test Failed at /tmp/tmp2zs7q5l0.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2zs7q5l0.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2zs7q5l0.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2zs7q5l0.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnfjllwhu.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnfjllwhu.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy75h8o55.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy75h8o55.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi16zv7oj.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi16zv7oj.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nNow let's write a function that will calculate the mean of a given vector:\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp73kuq3r7.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp73kuq3r7.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nThe function\
    \ truncate_number above is now a Julia function, and can be called from Julia\
    \ code just as we did with truncate_number_from_string above:\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf99_agl4.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf99_agl4.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp75_esig3.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp75_esig3.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp75_esig3.jl:17\ntest set: Test Failed at /tmp/tmp75_esig3.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp75_esig3.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp75_esig3.jl:17\ntest set: Test Failed at /tmp/tmp75_esig3.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp75_esig3.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp75_esig3.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp75_esig3.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    Now let's write a function that will compute the mean of a given vector of numbers.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl3vvh52d.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl3vvh52d.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to the nearest integer.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvm3eak0i.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvm3eak0i.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    if number < 0\n        error(\"Truncating negative numbers not supported\"\
    )\n    end\n    \n    digits = floor(log10(abs(number)))\n    \n    if digits\
    \ < 0\n        error(\"Truncating negative numbers not supported\")\n    end\n\
    \    \n    digits = max(digits, 0)\n    \n    digits = min(digits, 10)\n    \n\
    \    digits = digits - digits(number)\n    \n    digits = digits + digits(number)\n\
    \    \n    return number / 10^digits\nend\n</cell>\n<text>\nThe function truncate_number\
    \ takes the number as an argument and returns the truncated number.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbss9319i.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbss9319i.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    return truncate_number\n\
    </code>\n<|/ a tags=julia,truncate |>\n<| a tags=julia,truncate |>\nThe accepted\
    \ answer does not work for negative numbers. Here is a version that does:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpecnbqyxq.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpecnbqyxq.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg13ctomo.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg13ctomo.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5o8c_784.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5o8c_784.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqy4qtetv.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqy4qtetv.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3rxmz78z.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp3rxmz78z.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxmz78z.jl:17\ntest set: Test Failed at /tmp/tmp3rxmz78z.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3rxmz78z.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxmz78z.jl:17\ntest set: Test Failed at /tmp/tmp3rxmz78z.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3rxmz78z.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxmz78z.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3rxmz78z.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\n# export\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn8ubs7qj.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn8ubs7qj.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = floor(number)\n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    return truncate_number\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6xz3l_ln.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6xz3l_ln.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\ndef truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding why and/or how this code answers the\
    \ question improves its long-term value.\n<|/ c |>\n<| a tags=julia |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl0ldxsj1.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl0ldxsj1.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = floor(number)\n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    return truncate_number\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nNow let's see how we can use our truncate_number\
    \ function to truncate our data set. We'll start by creating a truncated data\
    \ set and then we'll use our truncate_number function to truncate our data set.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_tvk01lo.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_tvk01lo.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    if truncate_number\
    \ == number\n        truncate_number\n    else\n        truncate_number - truncate_number(number)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy4qa1qhy.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy4qa1qhy.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = floor(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nThe function truncate_number has two outputs: truncate_number itself and\
    \ truncate_number. \nThe first output is the truncated number and the second output\
    \ is the truncated number rounded to the nearest integer.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwcbnvkg0.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwcbnvkg0.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_mykpsp9.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_mykpsp9.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nThe function\
    \ truncate_number above is equivalent to the following Python code:\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeex_j02m.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeex_j02m.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpv_vkiuhc.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpv_vkiuhc.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv_vkiuhc.jl:17\ntest set: Test Failed at /tmp/tmpv_vkiuhc.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv_vkiuhc.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv_vkiuhc.jl:17\ntest set: Test Failed at /tmp/tmpv_vkiuhc.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv_vkiuhc.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv_vkiuhc.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv_vkiuhc.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5ar7c227.jl:17\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp5ar7c227.jl:17\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5ar7c227.jl:16\ntest set: Test Failed at /tmp/tmp5ar7c227.jl:18\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5ar7c227.jl:18\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5ar7c227.jl:16\ntest set: Test Failed at /tmp/tmp5ar7c227.jl:19\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5ar7c227.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5ar7c227.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5ar7c227.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpa_hmy00o.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmpa_hmy00o.jl:10\n\
    \   [2] top-level scope at /tmp/tmpa_hmy00o.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa_hmy00o.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpa_hmy00o.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpa_hmy00o.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpa_hmy00o.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa_hmy00o.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpa_hmy00o.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpa_hmy00o.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpa_hmy00o.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa_hmy00o.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa_hmy00o.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = round(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.7)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiknssdaf.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiknssdaf.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to the nearest integer.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2tltv0sm.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2tltv0sm.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    if number < 1.0\n        return number\n    \n    digits = floor(log10(number))\n\
    \    \n    if digits < 0\n        return number\n    \n    digits = digits - 1\n\
    \    \n    number = round(number * 10^digits)\n    \n    return number\nend\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=juli\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcsivsbuh.jl:25\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcsivsbuh.jl:25\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    \n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp1w7_qr0e.jl:19\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmp1w7_qr0e.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1w7_qr0e.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1w7_qr0e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1w7_qr0e.jl:20\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmp1w7_qr0e.jl:10\n   [2] top-level scope\
    \ at /tmp/tmp1w7_qr0e.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1w7_qr0e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1w7_qr0e.jl:21\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmp1w7_qr0e.jl:10\n   [2] top-level scope\
    \ at /tmp/tmp1w7_qr0e.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1w7_qr0e.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1w7_qr0e.jl:16\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl1tvq35y.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl1tvq35y.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    if number == 0.0:\n        return 0.0\n    \n    digits = math.floor(math.log(number,\
    \ 10))\n    decimals = number % 1.0\n    \n    if decimals < 1.0:\n        return\
    \ number - decimals\n    else:\n        return number - digits + 1.0\nend\n</cell>\n\
    <code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    trun\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbvmlt0z_.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbvmlt0z_.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n\
    </cell>\n<text>\nNow let's write a function that takes a vector of numbers and\
    \ returns the sum of the numbers in the vector. Make sure to handle edge cases\
    \ (empty vector, numbers summing to zero, etc.)\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppasoqo73.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppasoqo73.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp62bhfiir.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmp62bhfiir.jl:10\n\
    \   [2] top-level scope at /tmp/tmp62bhfiir.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62bhfiir.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmp62bhfiir.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmp62bhfiir.jl:10\n   [2] top-level scope\
    \ at /tmp/tmp62bhfiir.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62bhfiir.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmp62bhfiir.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmp62bhfiir.jl:10\n   [2] top-level scope\
    \ at /tmp/tmp62bhfiir.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62bhfiir.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp62bhfiir.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <code language=julia-1.5>\n# Test the function with negative numbers\ntruncate_number(-3.5)\n\
    </cell>\n<code language=julia-1.5>\n# Test the function with zero\ntruncate_number(0.0)\n\
    </cell>\n<code language=julia-1.5>\n# Test the function with negative zero\ntruncate_number(-0.0)\n\
    </cell>\n<code language=julia-1.5>\n# Test the function with NaN\ntruncate_number(NaN)\n\
    </cell>\n<code language=julia-1.5>\n# Test the function with Inf\ntruncate_number(Inf)\n\
    </cell>\n<code language=julia-1.5>\n# Test the function with Inf\ntruncate_number(-Inf)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the number of digits\
    \ in an integer.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsrtzwsrn.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsrtzwsrn.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise\nWrite\
    \ a function that takes a positive floating point number as input and returns\
    \ the integer part and the decimal part separately. Test your function by calling\
    \ it with the value 3.5.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp36fz9aot.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp36fz9aot.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn5q85p8h.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn5q85p8h.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    The function truncate_number above returns the decimal part of the number. Let's\
    \ see how it works:\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2p1mgr1o.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2p1mgr1o.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nNow let's write a function which can convert a number from one base to\
    \ another. We'll use our truncate_number function to truncate the decimal part\
    \ of a number and then use convert() to convert it to a different base.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0s6gt8fs.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0s6gt8fs.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to the nearest integer.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpen0qcs7x.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpen0qcs7x.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a positive floating point number as input and returns\
    \ the absolute value of that number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwjjkipgp.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwjjkipgp.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqm5mnaug.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqm5mnaug.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the number of digits of an integer.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplv62gc7o.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplv62gc7o.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjge7v8ip.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjge7v8ip.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to the nearest integer.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5iipgxm3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5iipgxm3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpzhftjl2h.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmpzhftjl2h.jl:10\n\
    \   [2] top-level scope at /tmp/tmpzhftjl2h.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhftjl2h.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhftjl2h.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpzhftjl2h.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpzhftjl2h.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhftjl2h.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhftjl2h.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpzhftjl2h.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpzhftjl2h.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhftjl2h.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzhftjl2h.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpssd1ciee.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpssd1ciee.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn0hojh_1.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn0hojh_1.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    Exercise\nWrite a function that returns the number of decimal places needed to\
    \ represent a given floating point number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd7lsnkxa.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd7lsnkxa.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nExercise: Write a function that takes a\
    \ floating point number as input and returns the decimal part as a floating point\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwralhgbp.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwralhgbp.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.0)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.3)\n</\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgz8q881z.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgz8q881z.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = floor(number)\n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    return truncate_number\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.7)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.0)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.7)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.4)\n</cell>\n\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq23bdloj.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq23bdloj.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpambui788.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpambui788.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    if truncate_number < 0.5\n\
    \        truncate_number = truncate_number + 1.0\n    end\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of digits in an integer.\
    \ For example, truncate_number(1000) should return 3.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpltqqkgcj.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpltqqkgcj.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a positive floating point number and returns the number\
    \ of decimal places it is composed of. For example, truncate_number(3.5) should\
    \ return 2.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t\
    @test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvh6_peqz.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvh6_peqz.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpfi9qwfyw.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpfi9qwfyw.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfi9qwfyw.jl:17\ntest set: Test Failed at /tmp/tmpfi9qwfyw.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfi9qwfyw.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfi9qwfyw.jl:17\ntest set: Test Failed at /tmp/tmpfi9qwfyw.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfi9qwfyw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfi9qwfyw.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfi9qwfyw.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg5dyivw1.jl:17\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmpg5dyivw1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpg5dyivw1.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg5dyivw1.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpg5dyivw1.jl:18\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpg5dyivw1.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpg5dyivw1.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg5dyivw1.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpg5dyivw1.jl:19\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpg5dyivw1.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpg5dyivw1.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg5dyivw1.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg5dyivw1.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.1>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdwk1iu4w.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdwk1iu4w.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp__jcwaao.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmp__jcwaao.jl:10\n\
    \   [2] top-level scope at /tmp/tmp__jcwaao.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp__jcwaao.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmp__jcwaao.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmp__jcwaao.jl:10\n   [2] top-level scope\
    \ at /tmp/tmp__jcwaao.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp__jcwaao.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmp__jcwaao.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmp__jcwaao.jl:10\n   [2] top-level scope\
    \ at /tmp/tmp__jcwaao.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp__jcwaao.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp__jcwaao.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp98662ccn.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp98662ccn.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpbtscdsdp.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpbtscdsdp.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtscdsdp.jl:17\ntest set: Test Failed at /tmp/tmpbtscdsdp.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbtscdsdp.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtscdsdp.jl:17\ntest set: Test Failed at /tmp/tmpbtscdsdp.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbtscdsdp.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtscdsdp.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbtscdsdp.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a positive floating point number as input\
    \ and returns the decimal part as a Float64 number.\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7_otn5sd.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7_otn5sd.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7is5whxz.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7is5whxz.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    return truncate_number\nend\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.7)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.1)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.2)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.7)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(4.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.1)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.2)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.3)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(5.7)\n</cell>\n<code language=julia-1.5>\ntruncate_number(5.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.1)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.2)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(6.3)\n</cell>\n<code language=julia-1.5>\ntruncate_number(6.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(6.5)\n</cell\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmposhhkv4g.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmposhhkv4g.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to a decimal number.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn7wjlf35.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn7wjlf35.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpavhvv4yl.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpavhvv4yl.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpavhvv4yl.jl:17\ntest set: Test Failed at /tmp/tmpavhvv4yl.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpavhvv4yl.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpavhvv4yl.jl:17\ntest set: Test Failed at /tmp/tmpavhvv4yl.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpavhvv4yl.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpavhvv4yl.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpavhvv4yl.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nNow let's write\
    \ a function that will compute the mean of a given vector of numbers.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpteydinnc.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpteydinnc.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# export\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbs58_k10.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbs58_k10.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpm840ll2y.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmpm840ll2y.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm840ll2y.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm840ll2y.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpm840ll2y.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpm840ll2y.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpm840ll2y.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm840ll2y.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpm840ll2y.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpm840ll2y.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpm840ll2y.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm840ll2y.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm840ll2y.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpmyc7g7mq.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpmyc7g7mq.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmyc7g7mq.jl:17\ntest set: Test Failed at /tmp/tmpmyc7g7mq.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmyc7g7mq.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmyc7g7mq.jl:17\ntest set: Test Failed at /tmp/tmpmyc7g7mq.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmyc7g7mq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmyc7g7mq.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmyc7g7mq.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpohg2oscs.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpohg2oscs.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpohg2oscs.jl:17\ntest set: Test Failed at /tmp/tmpohg2oscs.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpohg2oscs.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpohg2oscs.jl:17\ntest set: Test Failed at /tmp/tmpohg2oscs.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpohg2oscs.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpohg2oscs.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpohg2oscs.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to its decimal part.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2y4jw0xl.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2y4jw0xl.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3sykbl_h.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp3sykbl_h.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3sykbl_h.jl:17\ntest set: Test Failed at /tmp/tmp3sykbl_h.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3sykbl_h.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3sykbl_h.jl:17\ntest set: Test Failed at /tmp/tmp3sykbl_h.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3sykbl_h.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3sykbl_h.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3sykbl_h.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\n# export\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9chbhuex.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9chbhuex.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = trunc(number)\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb_lpqbki.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb_lpqbki.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    if truncate_number < 0.5\n\
    \        truncate_number = truncate_number + 1.0\n    end\n    \n    return truncate_number\n\
    end\n</cell>\n<text>\nThe function truncate_number above is called from the function\
    \ truncate_number below. Let's see how it works.\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_cd1yvg.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn_cd1yvg.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ a positive floating point number as input and returns the integer part and decimal\
    \ part separately.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprja4n9ww.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprja4n9ww.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqpej9xal.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqpej9xal.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <text>\nNow let's test our truncate function by applying it to a few different\
    \ numbers:\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6u2f9otn.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6u2f9otn.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp03rhec0z.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp03rhec0z.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = floor(number)\n    truncate_number = truncate_number\
    \ - truncate_number * truncate_number\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nThe function\
    \ truncate_number above is called with one argument, number::Float64. Julia will\
    \ automatically infer the type of the argument from the function definition. Julia\
    \ will also infer the type of the return value from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function definition. Julia\
    \ will also infer the type of the function from the function \nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg_yvwprv.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg_yvwprv.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = truncate_number(number)\n    \n    if truncate_number\
    \ == number\n        \n        return number\n    \n    truncate_number = truncate_number\
    \ - truncate_number % 1\n    \n    return truncate_number\nend\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.9)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.6)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.8)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.8)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoho6688j.jl:21\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpoho6688j.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nNow let's try it out on some random numbers:\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkg0fv55_.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkg0fv55_.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_akvbxjx.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_akvbxjx.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpblqu9pzm.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpblqu9pzm.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\n    return truncate_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpjkcrkb_4.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: truncate_number not defined\n\
    \  Stacktrace:\n   [1] truncate_number(::Float64) at /tmp/tmpjkcrkb_4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpjkcrkb_4.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjkcrkb_4.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpjkcrkb_4.jl:19\n  Test threw exception\n  Expression: candidate(1.25)\
    \ == 0.25\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpjkcrkb_4.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpjkcrkb_4.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjkcrkb_4.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpjkcrkb_4.jl:20\n  Test threw exception\n  Expression: candidate(123.0)\
    \ == 0.0\n  UndefVarError: truncate_number not defined\n  Stacktrace:\n   [1]\
    \ truncate_number(::Float64) at /tmp/tmpjkcrkb_4.jl:10\n   [2] top-level scope\
    \ at /tmp/tmpjkcrkb_4.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjkcrkb_4.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjkcrkb_4.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpejft1_hl.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpejft1_hl.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuw8cbi5p.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuw8cbi5p.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph2jkmulm.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph2jkmulm.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the number of digits of a given number. \nFor example\
    \ truncate_number(3.141592653589793) should return 3.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr6u1ypmi.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr6u1ypmi.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    digits = floor(log10(number))\n    decimals = number - truncate_number(number)\n\
    \    \n    if digits > decimals:\n        return truncate_number(number / 10.0)\n\
    \    \n    return number\n</code>\n<|/ a |>\n<| a tags=julia,floating-point |>\n\
    I wrote a package for Julia that does this for you:\nhttps://github.com/jrm/FloatTruncate\n\
    <code>\njulia> using FloatTruncate\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzv8qiyoz.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzv8qiyoz.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = round(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nNow let's use\
    \ our truncate_number function to truncate our data frame to only include data\
    \ points with an actual value greater than or equal to our cutoff.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfe3c_dcw.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfe3c_dcw.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpuv14h6qd.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmpuv14h6qd.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuv14h6qd.jl:17\ntest set: Test Failed at /tmp/tmpuv14h6qd.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuv14h6qd.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuv14h6qd.jl:17\ntest set: Test Failed at /tmp/tmpuv14h6qd.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuv14h6qd.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuv14h6qd.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuv14h6qd.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise\nWrite\
    \ a function that returns the first n prime numbers. \nHint: Use a for loop and\
    \ a prime number generator\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcop2s94p.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcop2s94p.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    number = round(number, digits=digits)\n    \n    if number % 1 ==\
    \ 0.0:\n        return number\n    else:\n        return number - math.floor(number)\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    The function truncate_number above is called in the following way:\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr4jzl9m8.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr4jzl9m8.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4dm6icsy.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4dm6icsy.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp8vdgqft3.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp8vdgqft3.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8vdgqft3.jl:17\ntest set: Test Failed at /tmp/tmp8vdgqft3.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8vdgqft3.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8vdgqft3.jl:17\ntest set: Test Failed at /tmp/tmp8vdgqft3.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8vdgqft3.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8vdgqft3.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8vdgqft3.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    number = round(number)\n    \n    if number < 1:\n        return\
    \ number\n    \n    decimal = number % 1\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n    \n    if number < 10:\n        return\
    \ number\n    \n    number = number / 10\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjhbuzpzr.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjhbuzpzr.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    </code>\n<|/ a tags=julia,floating-point |>\n<| c |>\nThis doesn't work if you\
    \ have a negative number like `-3.5`.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with negative numbers. Thanks for pointing that out.\n<|/ c |>\n<| a dscore=4\
    \ |>\nThe most straightforward way is to use round:\n<code>\njulia> round(3.5)\n\
    3\n</code>\n<|/ a tags=julia,floating-point |>\n<| a tags=julia,floating-point\
    \ |>\nThe easiest way is to use round:\n<code>\njulia> round(3.5)\n3\n</code>\n\
    <|/ a dscore=4 |>\n<| a |>\nThe easiest way is to use round:\n<code>\njulia> round(3.5)\n\
    3\n</code>\n<|/ a tags=julia,floating-point dscore=4 |>\n<| a dscore=3 |>\nThe\
    \ easiest way is to use round:\n<code>\njulia> round(3.5)\n3\n</code>\n<|/ a tags=julia,floating-point\
    \ |>\n<| a tags=julia,floating-point |>\nThe easiest way is to use round:\n<code>\n\
    julia> round(3.5)\n3\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe easiest\
    \ way is to use round:\n<code>\njulia> round(3.5)\n3\n</code>\n<|/ a tags=julia,floating-point\
    \ |>\n<| a tags=julia,floating-point |>\nThe easiest way is to use round:\n<code>\n\
    julia> round(3.5)\n3\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe easiest\
    \ way is to use round:\n<code>\njulia> round(3.5)\n3\n</code>\n<|/ a tags=julia,floating-point\
    \ |>\n<| a dscore=3 |>\nThe easiest way is to use round:\n<code>\njulia> round(3.5)\n\
    3\n</code>\n<|/ a tags=julia,floating-point |>\n<| a dscore=3 |>\nThe easiest\
    \ way is to use round:\n<code>\njulia> round(3.5)\n3\n</code>\n<|/ a tags=julia,floating-point\
    \ |>\n<| a tags=julia,floating-point |>\nThe easiest way is to use round:\n<code>\n\
    julia> round(3.5)\n3\n</code>\n<|/\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpalbvesp3.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpalbvesp3.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    return truncate_number\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a function that will return the decimal\
    \ part of a number. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmy3yfpib.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmy3yfpib.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmppriln2p2.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmppriln2p2.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppriln2p2.jl:17\ntest set: Test Failed at /tmp/tmppriln2p2.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppriln2p2.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppriln2p2.jl:17\ntest set: Test Failed at /tmp/tmppriln2p2.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppriln2p2.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppriln2p2.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppriln2p2.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    \n    return truncate_number\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    Now let's write a function that will compute the mean of a given vector of numbers.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphu9jk9q6.jl:15\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphu9jk9q6.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nNow let's write a function that can convert a number from one base to\
    \ another.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4li75cak.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4li75cak.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nNow let's write a function that takes a vector of numbers and returns\
    \ the sum of the numbers in the vector. Make sure to handle edge cases (like empty\
    \ vectors or vectors with only one element).\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwfx44ofn.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwfx44ofn.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.3>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the number of digits of an integer.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp20odnp10.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp20odnp10.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nNow let's implement\
    \ the function truncate_number_with_precision!:\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw4yx3npz.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw4yx3npz.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    return truncate_number\nend\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyfe3y1mt.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpyfe3y1mt.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    Truncate a floating point number to the nearest integer.\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmjt_pra9.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmjt_pra9.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3d1_mm67.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] top-level scope at /tmp/tmp3d1_mm67.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3d1_mm67.jl:17\ntest set: Test Failed at /tmp/tmp3d1_mm67.jl:19\n\
    \  Expression: candidate(1.25) == 0.25\n   Evaluated: 1.0 == 0.25\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3d1_mm67.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3d1_mm67.jl:17\ntest set: Test Failed at /tmp/tmp3d1_mm67.jl:20\n\
    \  Expression: candidate(123.0) == 0.0\n   Evaluated: 123.0 == 0.0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3d1_mm67.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3d1_mm67.jl:17\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3d1_mm67.jl:15\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = truncate_number(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpta5esw1u.jl:12\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpta5esw1u.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nNow let's write a function that can convert a number to a string with\
    \ two decimal places.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphwov3meq.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphwov3meq.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    truncate_number = number % 1\n    return truncate_number\nend\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqeo6gp7d.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqeo6gp7d.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = trunc(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbr592k8m.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbr592k8m.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = round(number)\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.1>\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2r9gvtam.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2r9gvtam.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test the function\ntruncate_number(3.5)\n</cell>\n\
    <text>\nThe function truncate_number above returns the decimal part of a positive\
    \ floating point number. Let's see how it works on a negative number.\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpth26odvi.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpth26odvi.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a positive floating point number and returns its integer\
    \ part.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpginktunl.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpginktunl.jl:13\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    number = round(number)\n    \n    if number < 1:\n        return\
    \ number\n    \n    decimals = math.floor(math.log(number, 10))\n    \n    return\
    \ number / 10 ** decimals\nend\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<text>\nNow let's implement a function that will compute the mean of\
    \ a given vector of numbers.\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppnv6o109.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppnv6o109.jl:14\n"
  exit_code: 1
  status: Exception
- program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number = number % 1\n    return truncate_number\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.6)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.4)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn9tsz20s.jl:13\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn9tsz20s.jl:13\n"
  exit_code: 1
  status: Exception
