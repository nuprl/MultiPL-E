name: HumanEval_49_modp
language: julia
prompt: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n \
  \   3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
  \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
  \ p::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
  \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
  @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
  \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
completions: ["    if n == 0 \n        then return 1\n    else if p < 0 \n       \
    \ then return modp(-n, p)\n    else if p < n \n        then return modp(n - p,\
    \ p)\n    else return modp(n, p - n)\nend\n</code>\n<|/ a tags=math,julia,algorithm\
    \ |>\n<| c |>\nThis code doesn't work. `modp(3, 5)` returns `3` instead of `2`.\n\
    <|/ c |>\n<| c |>\nI fixed the code. Thanks for pointing it out\n<|/ c |>\n<|\
    \ a tags=math,julia,algorithm |>\nHere's a Julia implementation that uses recursion:\n\
    <code>", "    if n == 0 \n        then return 1\n    else if n < 0\n        then\
    \ return modp(-n, p)\n    else if p == 0\n        then return 0\n    else if n\
    \ < p\n        then return modp(n, p)\n    else if n % p == 0\n        then return\
    \ modp(n, p)\n    else return modp(n + p - 1, p)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n  \
    \      then return p\n    else if p == 0 \n        then return 0\n    else if\
    \ p < 0 \n        then return modp(abs(n), abs(p))\n    else if n < 0 \n     \
    \   then return modp(-n, abs(p))\n    else if n < p \n        then return modp(n,\
    \ p)\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 then\
    \ return 1\n    if p == 0 then return 0\n    if n <= p then return n % p\n   \
    \ else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>", "    if\
    \ n == 0 \n        then return 0\n    else if n == 1 \n        then return p\n\
    \    else if p < 0 \n        then return modp(-n, p)\n    else if p > 0 \n   \
    \     then return modp(n, p - 1)\n    else if p < 1 \n        then return modp(n,\
    \ p - 1)\n    else if p > 1 \n        then return modp(n, p - 2)\n    else if\
    \ p < 2 \n        then return modp(n, p - 2)\n    else if p > 2 \n        then\
    \ return modp(n, p - 3)\n    else if p < 3 \n        then return modp(n, p - 3)\n\
    \    else if p > 3 \n        then return modp(n, p - 4)\n    else if p < 4 \n\
    \        then return modp(n, p - 4)\n    else if p > 4 \n        then return modp(n,\
    \ p - 5)\n    else if p < 5 \n        then return modp(n, p - 5)\n    else if\
    \ p > 5 \n        then return modp(n, p - 6)\n    else if p < 6 \n        then\
    \ return modp(n, p - 6)\n    else if p > 6 \n        then return modp(n, p - 7)\n\
    \    else if p < 7 \n        then return modp(n, p - 7)\n    else if p > 7 \n\
    \        then return modp(n, p - 8)\n    else if p < 8 \n        then return modp(n,\
    \ p - 8)\n    else if p > 8 \n        then return modp(n, p - 9)\n    else if\
    \ p < 9 \n        then return modp(n, p - 9)\n    else if p > 9 \n        then\
    \ return modp(n, p - 10)\n    else if p < 10 \n        then return modp(n, p -\
    \ 10)\n    else if p > 10 \n        then return modp(n, p - 11)\n    else if p\
    \ < 11 \n        then return modp(n, p - 11)\n    else if p > 11 \n        then\
    \ return modp(n, p - 12)\n    else if p < 12 \n        then return modp(n, p -\
    \ 12)\n    else if p > 12 \n        then return modp(n, p - 13)\n    else if p\
    \ < 13 \n        then return modp(n, p - 13)\n    else if p > 13 \n        then\
    \ return modp(n, p - 14)\n    else if p < 14 \n        then return modp(n, p -\
    \ 14)\n    else if p > 14 \n        then return modp(n, p - 15)\n    else if p\
    \ < 15 \n        then return modp", "    if n == 0 then return 1\n    if n ==\
    \ 1 then return p\n    if p < 0 then return modp(-n, p)\n    if p > p then return\
    \ modp(n, p)\n    if p < p then return modp(-n, p)\n    if p < 0 then return modp(n,\
    \ p)\n    return modp(-n, p)\nend\n</cell>\n<code language=julia-1.3>", "    if\
    \ n <= p then return n else return n % p\nend\n</cell>\n<code language=julia-1.3>",
  "    if n <= 0\n        error(\"n must be positive\")\n    if p <= 0\n        error(\"\
    p must be positive\")\n    if p == 0\n        error(\"p is zero\")\n    if n ==\
    \ 0\n        error(\"n is zero\")\n    if p == 1 && n == 1\n        1\n    else\n\
    \        modp(n / p, p)\nend\n</code>\n<|/ a tags=math,julia |>\n<| a dscore=2\
    \ |>\nI wanted to add an answer that uses only integer arithmetic and does not\
    \ require any packages. I used the fact that modular arithmetic is associative\
    \ and commutative to solve the problem by factoring both sides of the equation\
    \ into prime factors. I then used the fact that multiplication by 2 raises a number\
    \ to the power of its prime factors to solve the problem by raising the number\
    \ to the power of its prime factors. I then used the fact that addition and subtraction\
    \ are associative and commutative to solve the problem by adding or subtracting\
    \ the factors of the two numbers. I then used the fact that multiplication by\
    \ 2 raises a number to the power of its prime factors to solve the problem by\
    \ raising the number to the power of its prime factors. I then used the fact that\
    \ addition and subtraction are associative and commutative to solve the problem\
    \ by adding or subtracting the factors of the two numbers. I then used the fact\
    \ that multiplication by 2 raises a number to the power of its prime factors to\
    \ solve the problem by raising the number to the power of its prime factors. I\
    \ then used the fact that addition and subtraction are associative and commutative\
    \ to solve the problem by adding or subtracting the factors of the two numbers.\
    \ I then used the fact that multiplication by 2 raises a number to the power of\
    \ its prime factors to solve the problem by raising the number to the power of\
    \ its prime factors. I then used the fact that addition and subtraction are associative\
    \ and commutative to solve the problem by adding or subtracting the factors of\
    \ the two numbers. I then used the fact that multiplication by 2 raises a number\
    \ to the power of its prime factors to solve the problem by raising the number\
    \ to the power of its prime factors. I then used the fact that addition and subtraction\
    \ are associative and commutative to solve the problem by adding or subtracting\
    \ the factors of the two numbers. I then used the fact that multiplication by\
    \ 2 raises a number to the power of its prime factors to solve the problem by\
    \ raising the number to the power of its prime factors. I then used the fact that\
    \ addition and subtraction are associative and commutative to solve the problem\
    \ by adding or ", "    if p == 0 \n        then return 0\n    else if n == 0 \n\
    \        then return 1\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if p > 0 \n        then return modp(n, p - 1)\n    else \n        modp(n\
    \ / 2, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n==0 return 1\n \
    \   if n==1 return p\n    if p==0 return 0\n    if p==1 return 1\n    if p==2\
    \ return n\n    if p==3 return modp(2*n-1, p)\n    if p==4 return modp(2*n-1,\
    \ p-1)\n    if p==5 return modp(2*n-1, p+1)\n    if p==6 return modp(2*n-1, p+2)\n\
    \    if p==7 return modp(2*n-1, p+3)\n    if p==8 return modp(2*n-1, p+4)\n  \
    \  if p==9 return modp(2*n-1, p+5)\n    if p==10 return modp(2*n-1, p+6)\n   \
    \ if p==11 return modp(2*n-1, p+7)\n    if p==12 return modp(2*n-1, p+8)\n   \
    \ if p==13 return modp(2*n-1, p+9)\n    if p==14 return modp(2*n-1, p+10)\n  \
    \  if p==15 return modp(2*n-1, p+11)\n    if p==16 return modp(2*n-1, p+12)\n\
    \    if p==17 return modp(2*n-1, p+13)\n    if p==18 return modp(2*n-1, p+14)\n\
    \    if p==19 return modp(2*n-1, p+15)\n    if p==20 return modp(2*n-1, p+16)\n\
    \    if p==21 return modp(2*n-1, p+17)\n    if p==22 return modp(2*n-1, p+18)\n\
    \    if p==23 return modp(2*n-1, p+19)\n    if p==24 return modp(2*n-1, p+20)\n\
    \    if p==25 return modp(2*n-1, p+21)\n    if p==26 return modp(2*n-1, p+22)\n\
    \    if p==27 return modp(2*n-1, p+23)\n    if p==28 return modp(2*n-1, p+24)\n\
    \    if p==29 return modp(2*n-1, p+25)\n    if p==30 return modp(2*n-1, p+26)\n\
    \    if p==31 return modp(2*n-1, p+27)\n    if p==32 return modp(2*n-1, p+28)\n\
    \    if p==33 return modp(2*n-1, p+29)\n    if p==34 return modp(2*n-1, p+30)\n\
    \    if p==35 return modp(2*n-1, p+31)\n    if p==36 return modp(2*n-1, p+", " \
    \   if n==0 then return 1\n    if n==1 then return p\n    if p==0 then return\
    \ 0\n    if p==1 then return 1\n    if p==2 then return n\n    if p==3 then return\
    \ n+1\n    if p==4 then return n*2\n    if p==5 then return n*3\n    if p==6 then\
    \ return n*4\n    if p==7 then return n*5\n    if p==8 then return n*6\n    if\
    \ p==9 then return n*7\n    if p==10 then return n*8\n    if p==11 then return\
    \ n*9\n    if p==12 then return n*10\n    if p==13 then return n*11\n    if p==14\
    \ then return n*12\n    if p==15 then return n*13\n    if p==16 then return n*14\n\
    \    if p==17 then return n*15\n    if p==18 then return n*16\n    if p==19 then\
    \ return n*17\n    if p==20 then return n*18\n    if p==21 then return n*19\n\
    \    if p==22 then return n*20\n    if p==23 then return n*21\n    if p==24 then\
    \ return n*22\n    if p==25 then return n*23\n    if p==26 then return n*24\n\
    \    if p==27 then return n*25\n    if p==28 then return n*26\n    if p==29 then\
    \ return n*27\n    if p==30 then return n*28\n    if p==31 then return n*29\n\
    \    if p==32 then return n*30\n    if p==33 then return n*31\n    if p==34 then\
    \ return n*32\n    if p==35 then return n*33\n    if p==36 then return n*34\n\
    \    if p==37 then return n*35\n    if p==38 then return n*36\n    if p==39 then\
    \ return n*37\n    if p==40 then return n*38\n    if p==41 then return n*39\n\
    \    if p==42 then return n*40\n    if p==43 then return n*41\n    if p==44 then\
    \ return n*42\n    if p==45 then return n*43\n    if p==46 then return n*44\n\
    \    if p==47 then return n*45\n    if p==48 then return n*46\n    if p==49 then\
    \ return n*47\n    if p==50 then return n*48\n    if p==51 then return n*49\n\
    \    if p==52 then return n*50\n    if p==53 then return n*51\n", "    if n ==\
    \ 0 then return 1\n    if n == 1 then return p\n    if p < 0 then return modp(abs(n),\
    \ abs(p))\n    if p > p then return modp(abs(n), abs(p))\n    if p < p then return\
    \ modp(abs(n), p)\n    if p > n then return modp(abs(n), p)\n    return modp(abs(n),\
    \ p)\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"Return 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \"\"\"", "    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), p)\n    if p > p then return modp(n, p\
    \ - 1)\n    if p % 2 == 1 then return modp(n + p, p)\n    return modp(n + p, p\
    \ // 2)\nend\n</cell>\n<code language=julia-1.5>", "    if n==0 \n        then\
    \ return 0\n    else if n==1 \n        then return p\n    else if p==0 \n    \
    \    then return 0\n    else if p==1 \n        then return 1\n    else \n    \
    \    then return modp(n-1, p) + modp(n-1, p*p)\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 then return\
    \ 1\n    if n == 1 then return p\n    if p < 0 then return modp(-n, p)\n    if\
    \ p > p then return modp(n, p)\n    if p < p then return modp(n, p - p)\n    return\
    \ modp(n, p - p - 1)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n\
    \ modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n        then return 1\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if p == 0 \n  \
    \      then return 0\n    else if p < 0 \n        then return modp(-n, p)\n  \
    \  else if p < n \n        then return modp(n, p)\n    else \n        return modp(n-1,\
    \ p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \"\"\"", "    if n==0 \n        then return 1\n    else if n==1 \n\
    \        then return p\n    else if p==0 \n        then return 0\n    else if\
    \ p==1 \n        then return 1\n    else if p==2 \n        then return n\n   \
    \ else if p==3 \n        then return n*(n+1)/2\n    else if p==4 \n        then\
    \ return n*(n+1)*(2*n+1)\n    else if p==5 \n        then return n*(n+1)*(2*n+1)*(3*n+2)\n\
    \    else if p==6 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)\n    else\
    \ if p==7 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)\n    else\
    \ if p==8 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)*(11*n+7)\n\
    \    else if p==9 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)*(11*n+7)*(13*n+9)\n\
    \    else if p==10 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)*(11*n+7)*(13*n+9)*(17*n+11)\n\
    \    else if p==11 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)*(11*n+7)*(13*n+9)*(17*n+11)*(19*n+13)\n\
    \    else if p==12 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)*(11*n+7)*(13*n+9)*(17*n+11)*(19*n+13)*(23*n+17)\n\
    \    else if p==13 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)*(11*n+7)*(13*n+9)*(17*n+11)*(19*n+13)*(23*n+17)*(29*n+19)\n\
    \    else if p==14 \n        then return n*(n+1)*(2*n+1)*(3*n+2)*(5*n+3)*(7*n+5)*(",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, -p) \n    else if n <= p\
    \ \n        then return modp(n-1, p) \n    else return modp(n-1, p) + modp(n-1,\
    \ p-1)\nend\n</cell>\n<code language=julia-1.5>", "    if n <= p \n        then\
    \ n \n    else modp(n - p, p) \nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ doesn't work if n is negative or if p is negative.\n<|/ c |>\n<| c |>\nIt works\
    \ fine for me. `modp(3, 5)` returns `3`, `modp(1101, 101)` returns `2`, `modp(0,\
    \ 101)` returns `1`, `modp(3, 11)` returns `8`, `modp(100, 101)` returns `1`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `modp(3, -5)` returns `3` and `modp(1101,\
    \ -5)` returns `2`.\n<|/ c |>\n<| c |>\nIt works for me too. `modp(3, -5)` returns\
    \ `3` and `modp(1101, -5)` returns `2`.\n<|/ c |>\n<| c |>\nIt works for me too.\
    \ `modp(3, -5)` returns `3` and `modp(1101, -5)` returns `2`.\n<|/ c |>\n<| a\
    \ tags=math,julia |>\nI believe that this is the most efficient solution:\n<code>",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, -p) \n    else if n < 0\
    \ \n        then return modp(-n, p) \n    else if n < p \n        then return\
    \ modp(n, -p)\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 then return 1\n    if n == 1 then return p\n    if p < 0 then return\
    \ modp(abs(n), p)\n    if p > p then return modp(n, p-p)\n    if p % 2 == 1 then\
    \ return modp(n-1, p)\n    return modp(n-1, p-1)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 \n        then return p\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, -p) \n    else if p > 0\
    \ \n        then return modp(n, -p) \n    else \n        modp(n-1, p) + modp(n-1,\
    \ p-1)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your answer, but I think\
    \ it would be better to use a `while` loop instead of recursion.\n<|/ c |>\n<|\
    \ c |>\nYes, I agree with you. But the question was about recursion and I thought\
    \ that recursive solution is more readable and understandable for beginners.\n\
    <|/ c |>\n<| c |>\nI agree, it's more readable, but I wouldn't say it's more understandable\
    \ for beginners. Recursion is great for understanding how things work, but for\
    \ someone who doesn't know what a while loop is, it's hard to understand how it\
    \ works.\n<|/ c |>\n<| c |>\nI agree with you. But the question was about recursion\
    \ and I thought that recursive solution is more readable and understandable for\
    \ beginners.\n<|/ c |>\n<| c |>\nI agree, it's more readable, but I wouldn't say\
    \ it's more understandable for beginners. Recursion is great for understanding\
    \ how things work, but for someone who doesn't know what a while loop is, it's\
    \ hard to understand how it works.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "   \
    \ if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, p)\n    else if n < 0 \n\
    \        then return modp(-n, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else \n        then return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 then return 1\n    if p == 0 then return 0\n    if p < 2 then return\
    \ 0\n    if p < n then return modp(n - 1, p) \n    if p > n then return modp(n,\
    \ p - 1)\n    return modp(n - 1, p)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 then return 1\n    if p == 0 then return 0\n    if p > n then return\
    \ modp(n - p, p)\n    if p < n then return modp(n, p - n)\n    \n    \n\"\"\"\
    Return n mod p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 then return 1\n    if n ==\
    \ 1 then return p\n    if p < 0 then return modp(abs(n), abs(p))\n    if p > p\
    \ then return modp(n, p - 1)\n    if p % 2 == 0 then return modp(n-1, p-1)\n \
    \   else return modp(n-1, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\
    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>>\
    \ modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n \
    \   8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n <= 0 \n        then\
    \ return 0\n    else if n == 1\n        then return p\n    else if p == 0 \n \
    \       then return 0\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n\
    \    else if p < n \n        then return modp(n - abs(p), p)\n    else \n    \
    \    then return modp(n - abs(p), p - abs(n))\nend\n</cell>\n<code language=julia-1.5>",
  "    if p == 0 \n        then return 1\n    else if n == 0 \n        then return\
    \ 0\n    else if p == 1 \n        then return n\n    else \n        return modp(n\
    \ / p, p) * p\nend\n</cell>\n<code language=julia-1.4>", "    if n == 0 \n   \
    \     then return 1\n    else if p == 0 \n        then return 0\n    else if n\
    \ < 0 \n        then return modp(-n, p)\n    else if p < 0 \n        then return\
    \ modp(n, -p) \n    else if n < p \n        then return modp(n, p) \n    else\
    \ \n        return modp((n-p) mod p, p) \nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return n*(n+1)/2\n    if p==4\
    \ then return n*(n+1)*(2*n+1)/6\n    if p==5 then return n*(n+1)*(2*n+1)*(3*n+1)/24\n\
    \    if p==6 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)/120\n    if p==7 then\
    \ return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)/720\n    if p==8 then return\
    \ n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)/5040\n    if p==9 then return\
    \ n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)/40320\n    if p==10\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)/36288\n\
    \    if p==11 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)/67108864\n\
    \    if p==12 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)/134217728\n\
    \    if p==13 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)/268435456\n\
    \    if p==14 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31*n+1)/393216\n\
    \    if p==15 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31",
  "    if n < 0 \n        error(\"modp requires non-negative integers\")\n    else\
    \ if n < p \n        error(\"modp requires positive integers\")\n    else if n\
    \ == 0 \n        error(\"modp requires non-zero integers\")\n    else if p ==\
    \ 0 \n        error(\"modp requires non-zero integers\")\n    else if p == 1 \n\
    \        return n\n    else \n        return modp(n / p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n   \
    \ >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if p == 0 \n        then return 0\n    else if n == 0 \n        then return\
    \ 1\n    else if p == 1 \n        then return n\n    else if n % p == 0 \n   \
    \     then return modp(n / p, p)\n    else return modp(n / p, p) * p\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n == 0 \n        then return 1\n    else if\
    \ p == 0 \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n == 0 \n        then return p\n    else if n == 1 \n        then return\
    \ p\n    else if p == 1 \n        then return p\n    else if p < 2 \n        then\
    \ return modp(n - 1, p)\n    else if p < 3 \n        then return modp(n - 2, p)\n\
    \    else if p < 5 \n        then return modp(n - 3, p)\n    else if p < 7 \n\
    \        then return modp(n - 4, p)\n    else if p < 11 \n        then return\
    \ modp(n - 5, p)\n    else if p < 13 \n        then return modp(n - 6, p)\n  \
    \  else if p < 17 \n        then return modp(n - 7, p)\n    else if p < 19 \n\
    \        then return modp(n - 8, p)\n    else if p < 21 \n        then return\
    \ modp(n - 9, p)\n    else if p < 23 \n        then return modp(n - 10, p)\n \
    \   else if p < 25 \n        then return modp(n - 11, p)\n    else if p < 27 \n\
    \        then return modp(n - 12, p)\n    else if p < 29 \n        then return\
    \ modp(n - 13, p)\n    else if p < 31 \n        then return modp(n - 14, p)\n\
    \    else if p < 33 \n        then return modp(n - 15, p)\n    else if p < 35\
    \ \n        then return modp(n - 16, p)\n    else if p < 37 \n        then return\
    \ modp(n - 17, p)\n    else if p < 39 \n        then return modp(n - 18, p)\n\
    \    else if p < 41 \n        then return modp(n - 19, p)\n    else if p < 43\
    \ \n        then return modp(n - 20, p)\n    else if p < 45 \n        then return\
    \ modp(n - 21, p)\n    else if p < 47 \n        then return modp(n - 22, p)\n\
    \    else if p < 49 \n        then return modp(n - 23, p)\n    else if p < 51\
    \ \n        then return modp(n - 24, p)\n    else if p < 53 \n        then return\
    \ modp(n - 25, p)\n    else if p < 55 \n        then return modp(n - 26, ", " \
    \   if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, -p) \n    else if n < 0\
    \ \n        then return modp(-n, p) \n    else if n < p \n        then return\
    \ modp(n, p) \n    else return modp(n, p) \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n < 0 \n   \
    \     error(\"modp requires non-negative integers\")\n    else if p < 0 \n   \
    \     error(\"modp requires non-negative integers\")\n    else if n == 0 \n  \
    \      error(\"modp requires non-zero integers\")\n    else if p == 0 \n     \
    \   error(\"modp requires non-zero integers\")\n    else if p > n \n        error(\"\
    modp requires non-negative integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 \n        error(\"modp\
    \ requires non-positive integers\")\n    else if p < 2 ", "    if n == 0 \n  \
    \      then return 0\n    else if n < 0 \n        then return modp(abs(n), p)\n\
    \    else if n < p \n        then return modp(n + p, p)\n    else return modp((n\
    \ - p) * (p % n) + p, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n\
    \ == 0 \n        then return p\n    else if p == 0 \n        then return 0\n \
    \   else if p < 0 \n        then return modp(-n, -p) \n    else if n < 0 \n  \
    \      then return modp(-n, p) \n    else if n == 1 \n        then return p\n\
    \    else if p == 1 \n        then return 0\n    else if p < n \n        then\
    \ return modp(n, p)\n    else if n < p \n        then return modp(n, -p) \n  \
    \  else return modp((n-p), p) \nend\n</cell>\n<code language=julia-1.5>", "  \
    \  if n == 0 then return 1\n    if n == 1 then return p\n    if p < 0 then return\
    \ modp(-n, p)\n    if p > p then return modp(n, p)\n    if p < p then return modp(n,\
    \ p - p)\n    if p > p then return modp(n, p - p)\n    return modp(n, p - p)\n\
    end", "    if n < 0 \n        error(\"n must be positive\")\n    else if p < 0\
    \ \n        error(\"p must be positive\")\n    else if n == 0 \n        error(\"\
    n must be positive\")\n    else if p == 0 \n        error(\"p must be positive\"\
    )\n    else if p == 1 \n        return n\n    else if n == 1 \n        return\
    \ p\n    else if n % p == 0 \n        return modp(n / p, p)\n    else \n     \
    \   return modp(n / p, p) * p\nend\n</cell>\n<code language=julia-1.3>", "   \
    \ if n == 0 then return 1\n    if p == 0 then return 0\n    if p < 0 then return\
    \ modp(-n, p)\n    if p > n then return modp(n, p)\n    if n == p then return\
    \ 0\n    if n < p then return modp(n, p)\n    if n <= p then return modp(n, p)\n\
    \    if n > p then return modp(n, p)\n    if n == p then return 1\n    if n ==\
    \ 0 then return 1\n    if n == 1 then return 0\n    if n == 2 then return 1\n\
    \    if n == 3 then return 2\n    if n == 4 then return 3\n    if n == 5 then\
    \ return 4\n    if n == 6 then return 5\n    if n == 7 then return 6\n    if n\
    \ == 8 then return 7\n    if n == 9 then return 8\n    if n == 10 then return\
    \ 9\n    if n == 11 then return 10\n    if n == 12 then return 11\n    if n ==\
    \ 13 then return 12\n    if n == 14 then return 13\n    if n == 15 then return\
    \ 14\n    if n == 16 then return 15\n    if n == 17 then return 16\n    if n ==\
    \ 18 then return 17\n    if n == 19 then return 18\n    if n == 20 then return\
    \ 19\n    if n == 21 then return 20\n    if n == 22 then return 21\n    if n ==\
    \ 23 then return 22\n    if n == 24 then return 23\n    if n == 25 then return\
    \ 24\n    if n == 26 then return 25\n    if n == 27 then return 26\n    if n ==\
    \ 28 then return 27\n    if n == 29 then return 28\n    if n == 30 then return\
    \ 29\n    if n == 31 then return 30\n    if n == 32 then return 31\n    if n ==\
    \ 33 then return 32\n    if n == 34 then return 33\n    if n == 35 then return\
    \ 34\n    if n == 36 then return 35\n    if n == 37 then return 36\n    if n ==\
    \ 38 then return 37\n    if n == 39 then return 38\n    if n == 40 then return\
    \ 39\n    if n == 41 then return 40\n    if n == 42 then return 41\n    if n ==\
    \ 43 then return 42\n    if n == 44 then return 43\n    if n == 45 then return\
    \ 44\n    if n == 46 then return 45\n    if n == 47 then return 46\n    if n ==\
    \ 48 then return 47\n    if n == 49 then return 48\n    if n == 50 then return\
    \ 49\n    if n == 51 then return 50\n    if n == 52 then return 51\n    if n ==\
    \ 53 then return 52\n    if n == 54 then return 53\n    if n == 55 then return\
    \ 54\n    if n == 56 then return 55\n    if n == 57 then return 56\n    if ",
  "    if n < 0 \n        error(\"modp requires n >= 0\")\n    else if p == 0 \n \
    \       error(\"modp requires p != 0\")\n    else if p == 1 \n        error(\"\
    modp requires p != 1\")\n    else if n == 0 \n        error(\"modp requires n\
    \ != 0\")\n    else if n == 1 \n        return p\n    else \n        return modp(n\
    \ / p, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p\
    \ (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if p == 0 \n        then return 0\n    else if\
    \ n == 0 \n        then return 1\n    else if p == 1 \n        then return n\n\
    \    else if p < 0 \n        then return modp(-n, p)\n    else if p > 1 \n   \
    \     then return modp(n, p - 1)\n    else \n        modp n-1, p-1\nend\n</code>\n\
    <|/ a tags=algorithm,math,modular-arithmetic |>\n<| a dscore=2 |>\nThe algorithm\
    \ is called \"binary exponentiation\".\n<|/ a tags=algorithm,math,modular-arithmetic\
    \ |>\n<| a dscore=2 |>\nThe algorithm is called \"binary exponentiation\".\n<|/\
    \ a tags=algorithm,math,modular-arithmetic |>\n<| a dscore=2 |>\nThe algorithm\
    \ is called \"binary exponentiation\".\n<|/ a tags=algorithm,math,modular-arithmetic\
    \ |>\n<| a dscore=2 |>\nThe algorithm is called \"binary exponentiation\".\n<|/\
    \ a tags=algorithm,math,modular-arithmetic |>\n<| a |>\nThe algorithm is called\
    \ \"binary exponentiation\".\n<|/ a dscore=2 tags=algorithm,math,modular-arithmetic\
    \ |>\n<| a dscore=2 |>\nThe algorithm is called \"binary exponentiation\".\n<|/\
    \ a tags=algorithm,math,modular-arithmetic |>\n<| a tags=algorithm,math,modular-arithmetic\
    \ |>\nThe algorithm is called \"binary exponentiation\".\n<|/ a dscore=2 |>\n\
    <| a tags=algorithm,math,modular-arithmetic |>\nThe algorithm is called \"binary\
    \ exponentiation\".\n<|/ a dscore=2 |>\n<| a tags=algorithm,math,modular-arithmetic\
    \ |>\nThe algorithm is called \"binary exponentiation\".\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nThe algorithm is called \"binary exponentiation\".\n<|/ a tags=algorithm,math,modular-arithmetic\
    \ |>\n<| a tags=algorithm,math,modular-arithmetic |>\nThe algorithm is called\
    \ \"binary exponentiation\".\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe algorithm\
    \ is called \"binary exponentiation\".\n<|/ a tags=algorithm,math,modular-arithmetic\
    \ |>\n<| a dscore=2 |>\nThe algorithm is called \"binary exponentiation\".\n<|/\
    \ a tag", "    if n==0 then return 1\n    if n==1 then return p\n    if p==0 then\
    \ return 0\n    if p==1 then return 1\n    if p==2 then return n\n    if p==3\
    \ then return modp(2*n, p)\n    if p==4 then return modp(3*n, p)\n    if p==5\
    \ then return modp(4*n, p)\n    if p==6 then return modp(5*n, p)\n    if p==7\
    \ then return modp(6*n, p)\n    if p==8 then return modp(7*n, p)\n    if p==9\
    \ then return modp(8*n, p)\n    if p==10 then return modp(9*n, p)\n    if p==11\
    \ then return modp(10*n, p)\n    if p==12 then return modp(11*n, p)\n    if p==13\
    \ then return modp(12*n, p)\n    if p==14 then return modp(13*n, p)\n    if p==15\
    \ then return modp(14*n, p)\n    if p==16 then return modp(15*n, p)\n    if p==17\
    \ then return modp(16*n, p)\n    if p==18 then return modp(17*n, p)\n    if p==19\
    \ then return modp(18*n, p)\n    if p==20 then return modp(19*n, p)\n    if p==21\
    \ then return modp(20*n, p)\n    if p==22 then return modp(21*n, p)\n    if p==23\
    \ then return modp(22*n, p)\n    if p==24 then return modp(23*n, p)\n    if p==25\
    \ then return modp(24*n, p)\n    if p==26 then return modp(25*n, p)\n    if p==27\
    \ then return modp(26*n, p)\n    if p==28 then return modp(27*n, p)\n    if p==29\
    \ then return modp(28*n, p)\n    if p==30 then return modp(29*n, p)\n    if p==31\
    \ then return modp(30*n, p)\n    if p==32 then return modp(31*n, p)\n    if p==33\
    \ then return modp(32*n, p)\n    if p==34 then return modp(33*n, p)\n    if p==35\
    \ then return modp(34*n, p)\n    if p==36 then return modp(35*n, p)\n    if p==37\
    \ then return modp(36*n, p)\n    if p==38 then return modp(37*n, p)\n    if p==39\
    \ then return ", "    if n == 0 then return 1\n    if n == 1 then return p\n \
    \   if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(n, p - 1)\n    return modp(n, p - 1)\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n == 0 \n        then return 1\n\
    \    else if n == 1 \n        then return p\n    else if p < n \n        then\
    \ return modp(n - 1, p) \n        else return modp(n, p - 1)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    if n==0 || p==0 \n        then return 0\n    else\
    \ if n==1\n        then return p\n    else if p==1\n        then return 1\n  \
    \  else if p==2\n        then return n\n    else if p==3\n        then return\
    \ n*(n+1)/2\n    else if p==4\n        then return n*(n+1)*(2*n+1)/6\n    else\
    \ if p==5\n        then return n*(n+1)*(2*n+1)*(3*n+1)/24\n    else if p==6\n\
    \        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)/120\n    else if p==7\n \
    \       then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)/720\n    else if p==8\n\
    \        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)/5040\n  \
    \  else if p==9\n        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)/40320\n\
    \    else if p==10\n        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)/362880\n\
    \    else if p==11\n        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)/86400\n\
    \    else if p==12\n        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)/604800\n\
    \    else if p==13\n        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(11*n+1)/25200\n\
    \    else if p==14\n        then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(11*n+1)",
  "    if n == 0 \n        then return p\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(-n, abs(p))\n    else if n < p \n        then\
    \ return modp(n, p - n)\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n  \
    \      then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ p == 1 \n        then return n\n    else if p < 0 \n        then return modp(-n,\
    \ p)\n    else if p > 0 \n        then return modp(n, p mod n)\n    else return\
    \ modp(n, p mod n)\nend\n</cell>\n<code language=julia-1.0>", "    if n <= 0\n\
    \        error(\"modp(): n must be positive\")\n    \n    if p <= 0\n        error(\"\
    modp(): p must be positive\")\n    \n    if n == 0\n        return p\n    \n \
    \   if p == 0\n        return n\n    \n    if n == 1\n        return p\n    \n\
    \    if p == 1\n        return n\n    \n    if n % p == 0\n        return modp(n\
    \ / p, p)\n    \n    if n % p == 1\n        return modp((n - p) / p, p)\n    \n\
    \    if n % p == 2\n        return modp((n - p) / p + 1, p)\n    \n    if n %\
    \ p == 3\n        return modp((n - p) / p + 2, p)\n    \n    if n % p == 4\n \
    \       return modp((n - p) / p + 3, p)\n    \n    if n % p == 5\n        return\
    \ modp((n - p) / p + 4, p)\n    \n    if n % p == 6\n        return modp((n -\
    \ p) / p + 5, p)\n    \n    if n % p == 7\n        return modp((n - p) / p + 6,\
    \ p)\n    \n    if n % p == 8\n        return modp((n - p) / p + 7, p)\n    \n\
    \    if n % p == 9\n        return modp((n - p) / p + 8, p)\n    \n    if n %\
    \ p == 10\n        return modp((n - p) / p + 9, p)\n    \n    if n % p == 11\n\
    \        return modp((n - p) / p + 10, p)\n    \n    if n % p == 12\n        return\
    \ modp((n - p) / p + 11, p)\n    \n    if n % p == 13\n        return modp((n\
    \ - p) / p + 12, p)\n    \n    if n % p == 14\n        return modp((n - p) / p\
    \ + 13, p)\n    \n    if n % p == 15\n        return modp((n - p) / p + 14, p)\n\
    \    \n    if n % p == 16\n        return modp((n - p) / p + 15, p)\n    \n  \
    \  if n % p == 17\n        return modp((n - p) / p + 16, p)\n    \n    if n %\
    \ p == 18\n        return modp((n - p) / p + 17, p)\n    \n    if n % p == 19\n\
    \        return modp((n - p) / p + 18, p)\n    \n    if n % p == 20\n        return\
    \ modp((n - p) / p + 19, p)\n    \n    if n % p == 21\n        return modp((n\
    \ - p) / p + 20, p)\n    \n    if n % p == 22\n        return modp((n - p) / p\
    \ + 21, p)\n    \n    if n % ", "    if n == 0 \n        then return p\n    else\
    \ if p == 0 \n        then return 0\n    else if p < 0 \n        then return modp(-n,\
    \ -p) \n    else if n <= p \n        then return modp(n - p, p)\n    else return\
    \ modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>", "    if n <= 0\n \
    \       error(\"modp(n,p)\")\n    elseif p <= 0\n        error(\"modp(n,p)\")\n\
    \    elseif p > n\n        error(\"modp(n,p)\")\n    else\n        return ((n%p)+p)%p\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 \n        then\
    \ return 1\n    else if p < 0 \n        then return modp(-n, p)\n    else if p\
    \ < n \n        then return modp(n, p)\n    else return modp(n mod p, p)\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n==0 then return 1\n    if n==1 then\
    \ return p\n    if p==0 then return 0\n    if p==1 then return 1\n    if p==2\
    \ then return n\n    if p==3 then return n+1\n    if p==4 then return n*2\n  \
    \  if p==5 then return n*3\n    if p==6 then return n*4\n    if p==7 then return\
    \ n*5\n    if p==8 then return n*6\n    if p==9 then return n*7\n    if p==10\
    \ then return n*8\n    if p==11 then return n*9\n    if p==12 then return n*10\n\
    \    if p==13 then return n*11\n    if p==14 then return n*12\n    if p==15 then\
    \ return n*13\n    if p==16 then return n*14\n    if p==17 then return n*15\n\
    \    if p==18 then return n*16\n    if p==19 then return n*17\n    if p==20 then\
    \ return n*18\n    if p==21 then return n*19\n    if p==22 then return n*20\n\
    \    if p==23 then return n*21\n    if p==24 then return n*22\n    if p==25 then\
    \ return n*23\n    if p==26 then return n*24\n    if p==27 then return n*25\n\
    \    if p==28 then return n*26\n    if p==29 then return n*27\n    if p==30 then\
    \ return n*28\n    if p==31 then return n*29\n    if p==32 then return n*30\n\
    \    if p==33 then return n*31\n    if p==34 then return n*32\n    if p==35 then\
    \ return n*33\n    if p==36 then return n*34\n    if p==37 then return n*35\n\
    \    if p==38 then return n*36\n    if p==39 then return n*37\n    if p==40 then\
    \ return n*38\n    if p==41 then return n*39\n    if p==42 then return n*40\n\
    \    if p==43 then return n*41\n    if p==44 then return n*42\n    if p==45 then\
    \ return n*43\n    if p==46 then return n*44\n    if p==47 then return n*45\n\
    \    if p==48 then return n*46\n    if p==49 then return n*47\n    if p==50 then\
    \ return n*48\n    if p==51 then return n*49\n    if p==52 then return n*50\n\
    \    if p==53 then return n*51\n", "    if n == 0 \n        then return 1\n  \
    \  else if p == 0 \n        then return 0\n    else if p == 1 \n        then return\
    \ n\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(abs(n), abs(p))\n    else if n < p \n     \
    \   then return modp(n - p, p)\n    else if n > p \n        then return modp(n,\
    \ p - abs(n))\n    end\nend\n</cell>\n<code language=julia-1.5>", "    if n <\
    \ 0 \n        error(\"modp requires n >= 0\")\n    if p < 0 \n        error(\"\
    modp requires p >= 0\")\n    if p > n \n        error(\"modp requires p <= n\"\
    )\n    if n == 0 \n        error(\"modp requires n != 0\")\n    if p == 0 \n \
    \       error(\"modp requires p != 0\")\n    if p == 1 \n        return n\n  \
    \  if p == 2 \n        return n+1\n    if p == 3 \n        return n*2\n    if\
    \ p == 4 \n        return n*3\n    if p == 5 \n        return n*4\n    if p ==\
    \ 6 \n        return n*5\n    if p == 7 \n        return n*6\n    if p == 8 \n\
    \        return n*7\n    if p == 9 \n        return n*8\n    if p == 10 \n   \
    \     return n*9\n    if p == 11 \n        return n*10\n    if p == 12 \n    \
    \    return n*11\n    if p == 13 \n        return n*12\n    if p == 14 \n    \
    \    return n*13\n    if p == 15 \n        return n*14\n    if p == 16 \n    \
    \    return n*15\n    if p == 17 \n        return n*16\n    if p == 18 \n    \
    \    return n*17\n    if p == 19 \n        return n*18\n    if p == 20 \n    \
    \    return n*19\n    if p == 21 \n        return n*20\n    if p == 22 \n    \
    \    return n*21\n    if p == 23 \n        return n*22\n    if p == 24 \n    \
    \    return n*23\n    if p == 25 \n        return n*24\n    if p == 26 \n    \
    \    return n*25\n    if p == 27 \n        return n*26\n    if p == 28 \n    \
    \    return n*27\n    if p == 29 \n        return n*28\n    if p == 30 \n    \
    \    return n*29\n    if p == 31 \n        return n*30\n    if p == 32 \n    \
    \    return n*31\n    if p == 33 \n        return n*32\n    if p == 34 \n    \
    \    return n*33\n    if p == 35 \n        return n*34\n    if p == 36 \n    \
    \    return n*35\n    if p == 37 \n        return n*36\n    if p == 38 \n    \
    \    return n*37\n    if p == 39 \n        return n*38\n    if p == 40 \n    \
    \    return n*39\n    if p == 41 \n        return n*40\n    if p == 42 \n    \
    \    return n*41\n    if p == 43 \n        return n*42\n    if p == 44 \n    \
    \    return n*43\n    if p == 45 \n        return n*44\n    if p == 46 \n    \
    \    return n*45\n    if p == 47 \n        return n*46\n    if p == 48 \n    \
    \    return n*47\n    if p == 49 \n        return n*48\n    if p == 50 \n", " \
    \   if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if n <= p \n        then return modp(n - 1, p) \n        else return\
    \ modp(n mod p, p) \nend\n</cell>\n<code language=julia-1.0>", "    if n <= 0\n\
    \        error(\"modp requires n >= 0\")\n    end\n    if p <= 0\n        error(\"\
    modp requires p >= 0\")\n    end\n    if p == 0 || n == 0\n        return n\n\
    \    end\n    if p == 1\n        return n\n    end\n    if n == 1\n        return\
    \ p\n    end\n    if n % p == 0\n        return modp(n / p, p)\n    end\n    return\
    \ modp(n / p, p) * p\nend", "    if n==0 \n        then return 1\n    else if\
    \ p==0 \n        then return 0\n    else if n==1 \n        then return p\n   \
    \ else if p==1 \n        then return n\n    else if n==p \n        then return\
    \ n\n    else if n==p+1 \n        then return p\n    else if p==p+1 \n       \
    \ then return p\n    else if n==p+2 \n        then return p\n    else if p==p+2\
    \ \n        then return p\n    else if n==p+3 \n        then return p\n    else\
    \ if p==p+3 \n        then return p\n    else if n==p+4 \n        then return\
    \ p\n    else if p==p+4 \n        then return p\n    else if n==p+5 \n       \
    \ then return p\n    else if p==p+5 \n        then return p\n    else if n==p+6\
    \ \n        then return p\n    else if p==p+6 \n        then return p\n    else\
    \ if n==p+7 \n        then return p\n    else if p==p+7 \n        then return\
    \ p\n    else if n==p+8 \n        then return p\n    else if p==p+8 \n       \
    \ then return p\n    else if n==p+9 \n        then return p\n    else if p==p+9\
    \ \n        then return p\n    else if n==p+10 \n        then return p\n    else\
    \ if p==p+10 \n        then return p\n    else if n==p+11 \n        then return\
    \ p\n    else if p==p+11 \n        then return p\n    else if n==p+12 \n     \
    \   then return p\n    else if p==p+12 \n        then return p\n    else if n==p+13\
    \ \n        then return p\n    else if p==p+13 \n        then return p\n    else\
    \ if n==p+14 \n        then return p\n    else if p==p+14 \n        then return\
    \ p\n    else if n==p+15 \n        then return p\n    else if p==p+15 \n     \
    \   then return p\n    else if n==p+16 \n        then return p\n    else if p==p+16\
    \ \n        then return p\n    else if n==p", "    if n == 0 then return 1\n \
    \   if n == 1 then return p\n    if p < 0 then return modp(abs(n), -p)\n    if\
    \ p > p then return modp(n, p - p)\n    if p % 2 == 0 then return modp(n, (p -\
    \ 1)/2)\n    else return modp(n, (p - 1)/2) + modp(n-1, (p - 1)/2)\nend\n</cell>\n\
    <code language=julia-1.4>", "    if n == 0 \n        then return p\n    else if\
    \ p == 0 \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-n, abs(p))\n    else\
    \ if n < p \n        then return modp(n, p)\n    else \n        then return modp(n\
    \ + p, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p\
    \ (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if n == 0 \n        then return 0\n    else if\
    \ p == 0 \n        then return 1\n    else if p > n \n        then return modp(n\
    \ - p, p)\n    else \n        modp(n - p, p) + modp(n, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    if n == 0 \n        then return 1\n    else if p\
    \ == 0 \n        then return 0\n    else if p == 1 \n        then return n\n \
    \   else if p < 0 \n        then return modp(-n, p)\n    else if n <= p \n   \
    \     then return modp(n - p, p)\n    else return modp(n + p, p)\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n == 0 \n        then return p\n    else if\
    \ p == 0 \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n <= p \n        then return modp(n - p, p)\n    else return\
    \ modp(n + p, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 then\
    \ return 1\n    else if p == 0 then return 0\n    else if n <= p then return modp(n\
    \ - 1, p) + 1\n    else return modp(p, n)\nend \n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if p == 0 \n  \
    \      then return 0\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n\
    \    else if n < p \n        then return modp(n, p) \n    else \n        return\
    \ modp((n-p), p) \nend\n</cell>\n<code language=julia-1.5>", "    if n==0 \n \
    \       then return 1\n    else if n==1 \n        then return p\n    else if p==0\
    \ \n        then return 0\n    else if p==1 \n        then return 1\n    else\
    \ if p==2 \n        then return n\n    else if p==3 \n        then return modp(2*n,\
    \ p-1)\n    else if p==4 \n        then return modp(2*n+1, p-1)\n    else if p==5\
    \ \n        then return modp(2*n+2, p-1)\n    else if p==6 \n        then return\
    \ modp(2*n+3, p-1)\n    else if p==7 \n        then return modp(2*n+4, p-1)\n\
    \    else if p==8 \n        then return modp(2*n+5, p-1)\n    else if p==9 \n\
    \        then return modp(2*n+6, p-1)\n    else if p==10 \n        then return\
    \ modp(2*n+7, p-1)\n    else if p==11 \n        then return modp(2*n+8, p-1)\n\
    \    else if p==12 \n        then return modp(2*n+9, p-1)\n    else if p==13 \n\
    \        then return modp(2*n+10, p-1)\n    else if p==14 \n        then return\
    \ modp(2*n+11, p-1)\n    else if p==15 \n        then return modp(2*n+12, p-1)\n\
    \    else if p==16 \n        then return modp(2*n+13, p-1)\n    else if p==17\
    \ \n        then return modp(2*n+14, p-1)\n    else if p==18 \n        then return\
    \ modp(2*n+15, p-1)\n    else if p==19 \n        then return modp(2*n+16, p-1)\n\
    \    else if p==20 \n        then return modp(2*n+17, p-1)\n    else if p==21\
    \ \n        then return modp(2*n+18, p-1)\n    else if p==22 \n        then return\
    \ modp(2*n+19, p-1)\n    else if p==23 \n        then return modp(2*n+20, p-1)\n\
    \    else if p==24 \n        then return modp(2*n+21, p-1)\n    else if p==25\
    \ \n        then return modp(2*n+22, p-1)\n    else if p==26 \n        then return\
    \ modp(2*n+23, p-1)\n    ", "    if n==0 \n        then return p\n    else if\
    \ n==1 \n        then return p\n    else if p==0 \n        then return 0\n   \
    \ else if p==1 \n        then return 1\n    else if p==2 \n        then return\
    \ n\n    else if p==3 \n        then return modp(2*n, p-1)\n    else if p==4 \n\
    \        then return modp(3*n, p-1)\n    else if p==5 \n        then return modp(4*n,\
    \ p-1)\n    else if p==6 \n        then return modp(5*n, p-1)\n    else if p==7\
    \ \n        then return modp(6*n, p-1)\n    else if p==8 \n        then return\
    \ modp(7*n, p-1)\n    else if p==9 \n        then return modp(8*n, p-1)\n    else\
    \ if p==10 \n        then return modp(9*n, p-1)\n    else if p==11 \n        then\
    \ return modp(10*n, p-1)\n    else if p==12 \n        then return modp(11*n, p-1)\n\
    \    else if p==13 \n        then return modp(12*n, p-1)\n    else if p==14 \n\
    \        then return modp(13*n, p-1)\n    else if p==15 \n        then return\
    \ modp(14*n, p-1)\n    else if p==16 \n        then return modp(15*n, p-1)\n \
    \   else if p==17 \n        then return modp(16*n, p-1)\n    else if p==18 \n\
    \        then return modp(17*n, p-1)\n    else if p==19 \n        then return\
    \ modp(18*n, p-1)\n    else if p==20 \n        then return modp(19*n, p-1)\n \
    \   else if p==21 \n        then return modp(20*n, p-1)\n    else if p==22 \n\
    \        then return modp(21*n, p-1)\n    else if p==23 \n        then return\
    \ modp(22*n, p-1)\n    else if p==24 \n        then return modp(23*n, p-1)\n \
    \   else if p==25 \n        then return modp(24*n, p-1)\n    else if p==26 \n\
    \        then return modp(25*n, p-1)\n    else if p==27 \n        then return\
    \ modp(26*n, p-1)\n    else if p==28 \n        then ", "    if n == 0 then return\
    \ 1\n    if n == 1 then return p\n    if p < 0 then return 0\n    if p > n then\
    \ return 0\n    if p < n then return modp(n - p, p)\n    \n    if p % 2 == 1 then\
    \ return modp(n / 2, p)\n    \n    p -= 1\n    \n    if p % 2 == 1 then return\
    \ modp(n / 2, p)\n    \n    p -= 1\n    \n    if p % 2 == 1 then return modp(n\
    \ / 2, p)\n    \n    p -= 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n\
    \    \n    p -= 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n\
    \    p -= 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -=\
    \ 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n  \
    \  \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n    \n  \
    \  if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n    \n    if p\
    \ % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n    \n    if p % 2 ==\
    \ 1 then return modp(n / 2, p)\n    \n    p -= 1\n    \n    if p % 2 == 1 then\
    \ return modp(n / 2, p)\n    \n    p -= 1\n    \n    if p % 2 == 1 then return\
    \ modp(n / 2, p)\n    \n    p -= 1\n    \n    if p % 2 == 1 then return modp(n\
    \ / 2, p)\n    \n    p -= 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n\
    \    \n    p -= 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n\
    \    p -= 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -=\
    \ 1\n    \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n  \
    \  \n    if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n    \n  \
    \  if p % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n    \n    if p\
    \ % 2 == 1 then return modp(n / 2, p)\n    \n    p -= 1\n    \n    if p % 2 ==\
    \ 1 then ", "    if n == 0 then return 1\n    if n == 1 then return p\n    if\
    \ p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ abs(p))\n    if p < p then return modp(abs(n), p)\n    if p > n then return\
    \ modp(abs(n), p)\n    return modp(n, p % n)\nend\n</cell>\n<code language=julia-1.5>",
  "    if p == 0 \n        then return 0\n    else if p == 1 \n        then return\
    \ n\n    else if p < 0 \n        then return modp(-n, p)\n    else if p > 1 \n\
    \        then return modp(n, p - 1)\n    else \n        then return modp(n * 2,\
    \ p)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 then return 1\n\
    \    if n == 1 then return p\n    if p < 0 then return modp(abs(n), abs(p))\n\
    \    if p > p then return modp(n, p)\n    if p < p then return modp(n, p - 1)\n\
    \    if p > p then return modp(n, p - 2)\n    if p < p then return modp(n, p -\
    \ 3)\n    if p > p then return modp(n, p - 4)\n    if p < p then return modp(n,\
    \ p - 5)\n    if p > p then return modp(n, p - 6)\n    if p < p then return modp(n,\
    \ p - 7)\n    if p > p then return modp(n, p - 8)\n    if p < p then return modp(n,\
    \ p - 9)\n    if p > p then return modp(n, p - 10)\n    if p < p then return modp(n,\
    \ p - 11)\n    if p > p then return modp(n, p - 12)\n    if p < p then return\
    \ modp(n, p - 13)\n    if p > p then return modp(n, p - 14)\n    if p < p then\
    \ return modp(n, p - 15)\n    if p > p then return modp(n, p - 16)\n    if p <\
    \ p then return modp(n, p - 17)\n    if p > p then return modp(n, p - 18)\n  \
    \  if p < p then return modp(n, p - 19)\n    if p > p then return modp(n, p -\
    \ 20)\n    if p < p then return modp(n, p - 21)\n    if p > p then return modp(n,\
    \ p - 22)\n    if p < p then return modp(n, p - 23)\n    if p > p then return\
    \ modp(n, p - 24)\n    if p < p then return modp(n, p - 25)\n    if p > p then\
    \ return modp(n, p - 26)\n    if p < p then return modp(n, p - 27)\n    if p >\
    \ p then return modp(n, p - 28)\n    if p < p then return modp(n, p - 29)\n  \
    \  if p > p then return modp(n, p - 30)\n    if p < p then return modp(n, p -\
    \ 31)\n    if p > p then return modp(n, p - 32)\n    if p < p then return modp(n,\
    \ p - 33)\n    if p > p then return modp(n, p - 34)\n    if p < p then return\
    \ modp(n, p - 35)\n    if p > p then return modp(n, p - 36)\n    if p < p then\
    \ return modp(n, p - 37)\n    if p > p then return modp(n, p - 38)\n    if p <\
    \ p ", "    if n == 0 then return 1\n    if n == 1 then return p\n    if p ==\
    \ 0 then return 0\n    if p == 1 then return 1\n    if p < 0 then return modp(abs(n),\
    \ abs(p))\n    if p > 1 then return modp(n/2, p/2)\n    if p < 2 then return modp(n/2,\
    \ p)\n    if p < 3 then return modp(n/2, p/2)\n    if p < 4 then return modp(n/2,\
    \ p/2)\n    if p < 5 then return modp(n/2, p/2)\n    if p < 6 then return modp(n/2,\
    \ p/2)\n    if p < 7 then return modp(n/2, p/2)\n    if p < 8 then return modp(n/2,\
    \ p/2)\n    if p < 9 then return modp(n/2, p/2)\n    if p < 10 then return modp(n/2,\
    \ p/2)\n    if p < 11 then return modp(n/2, p/2)\n    if p < 12 then return modp(n/2,\
    \ p/2)\n    if p < 13 then return modp(n/2, p/2)\n    if p < 14 then return modp(n/2,\
    \ p/2)\n    if p < 15 then return modp(n/2, p/2)\n    if p < 16 then return modp(n/2,\
    \ p/2)\n    if p < 17 then return modp(n/2, p/2)\n    if p < 18 then return modp(n/2,\
    \ p/2)\n    if p < 19 then return modp(n/2, p/2)\n    if p < 20 then return modp(n/2,\
    \ p/2)\n    if p < 21 then return modp(n/2, p/2)\n    if p < 22 then return modp(n/2,\
    \ p/2)\n    if p < 23 then return modp(n/2, p/2)\n    if p < 24 then return modp(n/2,\
    \ p/2)\n    if p < 25 then return modp(n/2, p/2)\n    if p < 26 then return modp(n/2,\
    \ p/2)\n    if p < 27 then return modp(n/2, p/2)\n    if p < 28 then return modp(n/2,\
    \ p/2)\n    if p < 29 then return modp(n/2, p/2)\n    if p < 30 then return modp(n/2,\
    \ p/2)\n    if p < 31 then return modp(n/2, p/2)\n    if p < 32 then return modp(n/2,\
    \ p/2)\n    if p < 33 then return modp(n/2, p/2)\n    if p < 34 then return mod",
  "    if n < 0 \n        error(\"modp requires non-negative integers\")\n    else\
    \ if n < p \n        error(\"modp requires non-negative integers\")\n    else\
    \ if n == 0 \n        error(\"modp requires non-zero integers\")\n    else if\
    \ p == 0 \n        error(\"modp requires non-zero integers\")\n    else if p ==\
    \ 1 \n        error(\"modp requires non-zero integers\")\n    else if p > n \n\
    \        error(\"modp requires non-zero integers\")\n    else \n        return\
    \ n\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 \n        then return\
    \ 1\n    else if p == 0 \n        then return 0\n    else if p < 0 \n        then\
    \ return modp(abs(n), abs(p))\n    else if n < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < p \n        then return modp(n-1, p)\n    else if n\
    \ > p \n        then return modp(n, p-n)\n    else return modp(n-1, p)\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n < 0 \n        error(\"modp requires n >= 0\")\n    else if n < p \n  \
    \      error(\"modp requires n >= p\")\n    else if n == 0 \n        error(\"\
    modp requires n != 0\")\n    else if p == 0 \n        error(\"modp requires p\
    \ != 0\")\n    else if p == 1 \n        error(\"modp requires p != 1\")\n    else\
    \ if p == -1 \n        error(\"modp requires p != -1\")\n    else if p == Inf\
    \ \n        error(\"modp requires p != Inf\")\n    else if p == -Inf \n      \
    \  error(\"modp requires p != -Inf\")\n    else if p == NaN \n        error(\"\
    modp requires p != NaN\")\n    else if p == Infinity \n        error(\"modp requires\
    \ p != Infinity\")\n    else if p == -Infinity \n        error(\"modp requires\
    \ p != -Infinity\")\n    else if p == NaN \n        error(\"modp requires p !=\
    \ NaN\")\n    else if p < 0 \n        error(\"modp requires p >= 0\")\n    else\
    \ if p > 1 \n        error(\"modp requires p <= 1\")\n    else if p < 1 \n   \
    \     error(\"modp requires p >= 1\")\n    else if p > Inf \n        error(\"\
    modp requires p <= Inf\")\n    else if p < Inf \n        error(\"modp requires\
    \ p >= Inf\")\n    else if p > NaN \n        error(\"modp requires p <= NaN\"\
    )\n    else if p < NaN \n        error(\"modp requires p >= NaN\")\n    else if\
    \ p < 0 \n        error(\"modp requires p >= 0\")\n    else if p > 1 \n      \
    \  error(\"modp requires p <= 1\")\n    else if p < 1 \n        error(\"modp requires\
    \ p >= 1\")\n    else if p > Inf \n        error(\"modp requires p <= Inf\")\n\
    \    else if p < Inf \n        error(\"modp requires p >= Inf\")\n    else if\
    \ p > NaN \n        error(\"modp requires p <= NaN\")\n    else if p < NaN \n\
    \        error(\"modp requires p >= NaN\")\n    else if p < 0 \n        error(\"\
    modp requires p >= 0\")\n    else if p > 1 \n        error(\"modp requires p <=\
    \ 1\")\n    else if p < 1 \n        error(\"modp requires p >= 1\")\n    else\
    \ if p > Inf \n        error(\"modp requires p <= Inf\")\n    else ", "    if\
    \ n <= p \n        then n \n        else modp(n mod p, p) \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n == 0 \n        then return 1\n    else if n < 0\n        then return modp(-n,\
    \ p)\n    else if p == 0\n        then return 0\n    else if p < 0\n        then\
    \ return modp(-n, p)\n    else if p < n\n        then return modp(n, p)\n    else\
    \ if p > n\n        then return modp(n, p)\n    else if p < n\n        then return\
    \ modp(n, p)\n    else if p > n\n        then return modp(n, p)\n    else if p\
    \ < n\n        then return modp(n, p)\n    else if p > n\n        then return\
    \ modp(n, p)\n    else if p < n\n        then return modp(n, p)\n    else if p\
    \ > n\n        then return modp(n, p)\n    else if p < n\n        then return\
    \ modp(n, p)\n    else if p > n\n        then return modp(n, p)\n    else if p\
    \ < n\n        then return modp(n, p)\n    else if p > n\n        then return\
    \ modp(n, p)\n    else if p < n\n        then return modp(n, p)\n    else if p\
    \ > n\n        then return modp(n, p)\n    else if p < n\n        then return\
    \ modp(n, p)\n    else if p > n\n        then return modp(n, p)\n    else if p\
    \ < n\n        then return modp(n, p)\n    else if p > n\n        then return\
    \ modp(n, p)\n    else if p < n\n        then return modp(n, p)\n    else if p\
    \ > n\n        then return modp(n, p)\n    else if p < n\n        then return\
    \ modp(n, p)\n    else if p > n\n        then return modp(n, p)\n    else if p\
    \ < n\n        then return modp(n, p)\n    else if p > n\n        then return\
    \ modp(n, p)\n    else if p < n\n        then return modp(n, p)\n    else if p\
    \ > n\n        then return modp(n, p)\n    else if p < n\n        then return\
    \ modp(n, p)\n    else if p > n\n        then return modp(n, p)\n    else if p\
    \ < n\n        then return modp(n, p)\n    else if p > n\n        then return\
    \ modp(n, p)\n    else if p < n\n        then return mod", "    if n == 0 then\
    \ return 1\n    if p == 0 then return 0\n    if p < 0 then return modp(abs(n),\
    \ abs(p))\n    if n <= p then return modp(n - p, p)\n    if n < p then return\
    \ modp(n, p - n)\nend\n</code>\n<|/ a tags=math,julia |>\n<| c |>\nI guess this\
    \ should be `modp(abs(n), abs(p))`\n<|/ c |>\n<| c |>\nYes, thank you. I fixed\
    \ it.\n<|/ c |>\n<| a tags=math,julia |>\nThe accepted answer does not work for\
    \ negative numbers. Here is a solution that works for negative numbers:\n<code>",
  "    if n <= 0 \n        then return 0\n    else if n <= p \n        then return\
    \ 1\n    else \n        return modp(n - p, p)\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n  \
    \      then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ p == 1 \n        then return n\n    else \n        return modp(n - 1, p) \n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"", "    if n < 0 \n        error(\"modp requires n >= 0\")\n \
    \   \n    if p == 0 \n        error(\"modp requires p != 0\")\n    \n    if n\
    \ == 0 \n        error(\"modp requires n != 0\")\n    \n    if p == 1 \n     \
    \   error(\"modp requires p != 1\")\n    \n    if p == -1 \n        error(\"modp\
    \ requires p != -1\")\n    \n    if p < 0 \n        error(\"modp requires p >=\
    \ 0\")\n    \n    if p > 1 \n        error(\"modp requires p <= 1\")\n    \n \
    \   if p == 0 \n        error(\"modp requires p != 0\")\n    \n    if n == 1 \n\
    \        error(\"modp requires n != 1\")\n    \n    if n == -1 \n        error(\"\
    modp requires n != -1\")\n    \n    if n < 0 \n        error(\"modp requires n\
    \ >= 0\")\n    \n    if n > 1 \n        error(\"modp requires n <= 1\")\n    \n\
    \    if n == 0 \n        error(\"modp requires n != 0\")\n    \n    if p == 0\
    \ \n        error(\"modp requires p != 0\")\n    \n    if n == 1 \n        error(\"\
    modp requires n != 1\")\n    \n    if n == -1 \n        error(\"modp requires\
    \ n != -1\")\n    \n    if n < 0 \n        error(\"modp requires n >= 0\")\n \
    \   \n    if n > 1 \n        error(\"modp requires n <= 1\")\n    \n    if n ==\
    \ 0 \n        error(\"modp requires n != 0\")\n    \n    if p == 0 \n        error(\"\
    modp requires p != 0\")\n    \n    if n == 1 \n        error(\"modp requires n\
    \ != 1\")\n    \n    if n == -1 \n        error(\"modp requires n != -1\")\n \
    \   \n    if n < 0 \n        error(\"modp requires n >= 0\")\n    \n    if n >\
    \ 1 \n        error(\"modp requires n <= 1\")\n    \n    if n == 0 \n        error(\"\
    modp requires n != 0\")\n    \n    if p == 0 \n        error(\"modp requires p\
    \ != 0\")\n    \n    if n == 1 \n        error(\"modp requires n != 1\")\n   \
    \ \n    if n == -1 \n        error(\"modp requires n != -1\")\n    \n    if n\
    \ < 0 \n        error(\"modp requires n >= 0\")\n    \n    if n > 1 \n       \
    \ error(\"modp requires n <= 1\")\n    \n    if n == 0 \n        error(\"modp\
    \ requires n != 0\")\n    \n    if p == 0 \n        error(\"modp requires p !=\
    \ 0\")\n    \n    if n == 1 \n        error(\"modp requires n != 1\")\n    \n\
    \    if n == ", "    if n == 0 \n        then return p\n    else if p == 0 \n\
    \        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if p < n \n        then return modp(n, p)\n    else return modp(n-1,\
    \ p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \"\"\"", "    if n == 0 \n        then return 1\n    else if p ==\
    \ 0 \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n-1, p)\n    else if n > p \n        then\
    \ return modp(n, p-abs(n))\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(abs(n), abs(p))\n    else if n < p \n     \
    \   then return modp(n - p, p)\n    else if n < p \n        then return modp(n\
    \ - p, p)\n    else \n        then return modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    if n==0 then return 1\n    if n==1 then return p\n\
    \    if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return\
    \ n\n    if p==3 then return n+1\n    if p==4 then return n*2\n    if p==5 then\
    \ return n*3\n    if p==6 then return n*4\n    if p==7 then return n*5\n    if\
    \ p==8 then return n*6\n    if p==9 then return n*7\n    if p==10 then return\
    \ n*8\n    if p==11 then return n*9\n    if p==12 then return n*10\n    if p==13\
    \ then return n*11\n    if p==14 then return n*12\n    if p==15 then return n*13\n\
    \    if p==16 then return n*14\n    if p==17 then return n*15\n    if p==18 then\
    \ return n*16\n    if p==19 then return n*17\n    if p==20 then return n*18\n\
    \    if p==21 then return n*19\n    if p==22 then return n*20\n    if p==23 then\
    \ return n*21\n    if p==24 then return n*22\n    if p==25 then return n*23\n\
    \    if p==26 then return n*24\n    if p==27 then return n*25\n    if p==28 then\
    \ return n*26\n    if p==29 then return n*27\n    if p==30 then return n*28\n\
    \    if p==31 then return n*29\n    if p==32 then return n*30\n    if p==33 then\
    \ return n*31\n    if p==34 then return n*32\n    if p==35 then return n*33\n\
    \    if p==36 then return n*34\n    if p==37 then return n*35\n    if p==38 then\
    \ return n*36\n    if p==39 then return n*37\n    if p==40 then return n*38\n\
    \    if p==41 then return n*39\n    if p==42 then return n*40\n    if p==43 then\
    \ return n*41\n    if p==44 then return n*42\n    if p==45 then return n*43\n\
    \    if p==46 then return n*44\n    if p==47 then return n*45\n    if p==48 then\
    \ return n*46\n    if p==49 then return n*47\n    if p==50 then return n*48\n\
    \    if p==51 then return n*49\n    if p==52 then return n*50\n    if p==53 then\
    \ return n*51\n", "    if n == 0 \n        then return p\n    else if p == 0 \n\
    \        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n <= p \n        then return modp(n, p mod n)\n    else return modp(n,\
    \ p - n)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 then return\
    \ 1\n    if p == 0 then return 0\n    if p == 1 then return n\n    if p < 0 then\
    \ return modp(abs(n), abs(p))\n    if p > 1 then return modp(n / p, p)\n    if\
    \ p < 2 then return modp(n / p, p)\n    if p < 3 then return modp(n / p, p)\n\
    \    if p < 4 then return modp(n / p, p)\n    if p < 5 then return modp(n / p,\
    \ p)\n    if p < 6 then return modp(n / p, p)\n    if p < 7 then return modp(n\
    \ / p, p)\n    if p < 8 then return modp(n / p, p)\n    if p < 9 then return modp(n\
    \ / p, p)\n    if p < 10 then return modp(n / p, p)\n    if p < 11 then return\
    \ modp(n / p, p)\n    if p < 12 then return modp(n / p, p)\n    if p < 13 then\
    \ return modp(n / p, p)\n    if p < 14 then return modp(n / p, p)\n    if p <\
    \ 15 then return modp(n / p, p)\n    if p < 16 then return modp(n / p, p)\n  \
    \  if p < 17 then return modp(n / p, p)\n    if p < 18 then return modp(n / p,\
    \ p)\n    if p < 19 then return modp(n / p, p)\n    if p < 20 then return modp(n\
    \ / p, p)\n    if p < 21 then return modp(n / p, p)\n    if p < 22 then return\
    \ modp(n / p, p)\n    if p < 23 then return modp(n / p, p)\n    if p < 24 then\
    \ return modp(n / p, p)\n    if p < 25 then return modp(n / p, p)\n    if p <\
    \ 26 then return modp(n / p, p)\n    if p < 27 then return modp(n / p, p)\n  \
    \  if p < 28 then return modp(n / p, p)\n    if p < 29 then return modp(n / p,\
    \ p)\n    if p < 30 then return modp(n / p, p)\n    if p < 31 then return modp(n\
    \ / p, p)\n    if p < 32 then return modp(n / p, p)\n    if p < 33 then return\
    \ modp(n / p, p)\n    if p < 34 then return modp(n / p, p)\n    if p < 35 then\
    \ return modp(n / p, p)\n    if p < 36 then return modp(n / p, p)\n    if p <\
    \ 37 then return ", "    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, -p)\n    else if n % p == 0 \n        then return\
    \ modp(n, p)\n    else return modp(n, p - n % p) \nend\n</cell>\n<code language=julia-1.3>",
  "    if n <= p \n        then return n \n        else return modp(n - p, p)\n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if n==0 then return 1\n    else if n==1 then\
    \ return p\n    else if p==0 then return 0\n    else if p==1 then return 1\n \
    \   else if p==2 then return n\n    else if p==3 then return modp(2*n, p)\n  \
    \  else if p==4 then return modp(3*n, p)\n    else if p==5 then return modp(4*n,\
    \ p)\n    else return modp(5*n, p)\nend\n</cell>\n<code language=julia-1.5>",
  "    if p == 0 \n        then return 0\n    else if p == 1 \n        then return\
    \ n\n    else if n <= p \n        then return modp(n - p, p)\n    else \n    \
    \    then return modp(n - p, p) + p\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return n^m modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n  \
    \      then return p\n    else if p < 0 \n        then return modp(-n, p)\n  \
    \  else if p > 0 \n        then return modp(n, -p) \n    else \n        then return\
    \ modp(n-1, p-1)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 \n\
    \        then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ n <= p \n        then return modp(n - 1, p) \n        else return modp((n -\
    \ p) % p + p, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 \n\
    \        then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ n <= p \n        then return modp(n - 1, p) \n        else return modp(n, p\
    \ % n) \nend\n</code>\n<|/ a tags=algorithm,math,modular-arithmetic |>\n<| c |>\n\
    This doesn't work for negative numbers. modp(3, -5) returns 2 instead of 3.\n\
    <|/ c |>\n<| c |>\nI didn't say it wouldn't, I said it wouldn't. modp(3, -5) returns\
    \ 2 because modp(3, -5) returns modp(3, 5).\n<|/ c |>\n<| c |>\nI see. But I still\
    \ think it would be better to have modp(3, -5) return 3 instead of 2.\n<|/ c |>\n\
    <| c |>\nI agree. modp(3, -5) should return 3 instead of 2. modp(3, 5) should\
    \ return 2 instead of 3.\n<|/ c |>\n<| c |>\nI agree with you. modp(3, -5) should\
    \ return 3 instead of 2. modp(3, 5) should return 2 instead of 3.\n<|/ c |>\n\
    <| a tags=algorithm,math,modular-arithmetic |>\nThe simplest solution is to use\
    \ modular arithmetic:\n<code>", "    if n == 0 \n        then return 1\n    else\
    \ if p == 0 \n        then return 0\n    else if n <= p \n        then return\
    \ modp(n - 1, p) \n        else return modp(n mod p, p) \nend\n</code>\n<|/ a\
    \ tags=math,julia,algorithm |>\n<| c |>\nI believe this answer does not work when\
    \ n is negative and p is positive.\n<|/ c |>\n<| c |>\nI believe this answer does\
    \ not work when n is negative and p is positive.\n<|/ c |>\n<| c |>\nI believe\
    \ this answer does not work when n is negative and p is positive.\n<|/ c |>\n\
    <| c |>\nI believe this answer does not work when n is negative and p is positive.\n\
    <|/ c |>\n<| c |>\nI believe this answer does not work when n is negative and\
    \ p is positive.\n<|/ c |>\n<| a dscore=5 |>\nI believe this answer does not work\
    \ when n is negative and p is positive.\n<code>", "    if n == 0 then return 1\n\
    \    if p == 0 then return 0\n    if n < p then return modp(n - 1, p) \n    else\
    \ return modp(n, p % n)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n        then return 1\n\
    \    else if p == 0 \n        then return 0\n    else if p < 0 \n        then\
    \ return modp(-n, -p) \n    else if n < 0 \n        then return modp(-n, p) \n\
    \    else if n < p \n        then return modp(n, -p)\n    else if n == p \n  \
    \      then return 1\n    else return modp(n, p) \nend \n\"\"\"\n\"\"\"\n    modpow(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modpow(-n,\
    \ -p) \n    else if n < 0 \n        then return modpow(-n, p) \n    else if n\
    \ < p \n        then return modpow(n, -p)\n    else if n == p \n        then return\
    \ 1\n    else return modpow(n, p) \nend \n\"\"\"\n\"\"\"\n    modpow(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modpow(-n,\
    \ -p) \n    else if n < 0 \n        then return modpow(-n, p) \n    else if n\
    \ < p \n        then return modpow(n, -p)\n    else if n == p \n        then return\
    \ 1\n    else return modpow(n, p) \nend \n\"\"\"\n\"\"\"\n    modpow(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modpow(-n,\
    \ -p) \n    else if n < 0 \n        then return modpow(-n, p) \n    else if n\
    \ < p \n        then return modpow(n, -p)\n    else if n == p \n        then return\
    \ 1\n    else return modpow(n, p) \nend \n\"\"\"\n\"\"\"\n    modpow(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modpow(-n,\
    \ -p) \n    else if n < 0 \n        then return modpow(-n, p) \n    else if n\
    \ < p \n        then return modpow(n, -p)", "    if n == 0 then return 1\n   \
    \ if p == 0 then return 0\n    if p < 0 then return modp(-n, p)\n    if p > n\
    \ then return modp(n, p)\n    if p % 2 == 1 then return modp(n + p, p)\n    if\
    \ p % 2 == 0 then return modp(n, p - 1)\n    return modp(n + p, p - 1)\nend\n\
    </cell>\n<code language=julia-1.4>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(abs(n), abs(p))\n    else if n < p \n     \
    \   then return modp(abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return modp(abs(n), p)\n    else if n <\
    \ p \n        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(abs(n), p)\n \
    \   else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(abs(n), p)\n \
    \   else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(abs(n), p)\n \
    \   else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(abs(n), p)\n \
    \   else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(abs(n), p)\n \
    \   else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(abs(n), p)\n \
    \   else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(abs(n), p)\n    else if n < p \n        then ", "  \
    \  if n == 0 then return 1\n    else if p == 0 then return 0\n    else if p <\
    \ n then return modp(n - 1, p)\n    else return modp(n - p, p)\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n == 0 then return 1\n    if p == 0 then return 0\n    if p < 0 then return\
    \ modp(-n, p)\n    if p < n then return modp(n, p)\n    if n % p == 0 then return\
    \ modp(n / p, p)\n    return modp((n - p) / p, p)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 then return 1\n    if p == 0 then return 0\n    if n <= p then return\
    \ n % p\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return nth root of p (be aware of numerics).\n    >>> nthroot(3, 5)\n  \
    \  1.73205080756888\n    >>> nthroot(1101, 101)\n    2.269718246246\n    >>> nthroot(0,\
    \ 101)\n    1.0\n    >>> nthroot(3, 11)\n    2.449293598294\n    >>> nthroot(100,\
    \ 101)\n    1.0\n    \"\"\"", "    if n == 0 \n        then return 1\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p < n \n        then\
    \ return modp(n, p)\n    else return modp(n-1, p) + modp(n-1, p-1)\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n == 0 then return 1\n    else if p == 0 then\
    \ return 0\n    else if n <= p then return modp(n - 1, p) \n    else return modp(p,\
    \ n)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 then return 1\n\
    \    if p == 0 then return 0\n    if n < p then return modp(n - 1, p) \n    else\
    \ return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"Return\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"", "    if n <= 0\n        error(\"modp requires\
    \ n >= 0\")\n    else if p <= 0\n        error(\"modp requires p >= 0\")\n   \
    \ else if p > n\n        error(\"modp requires p <= n\")\n    else if p < 2\n\
    \        error(\"modp requires p >= 2\")\n    else if p == 2\n        return n\n\
    \    else if p == 3\n        return n+1\n    else if p == 6\n        return n+2\n\
    \    else if p == 8\n        return n+3\n    else if p == 15\n        return n+4\n\
    \    else if p == 24\n        return n+5\n    else if p == 49\n        return\
    \ n+6\n    else if p == 99\n        return n+7\n    else if p == 100\n       \
    \ return n+8\n    else if p == 101\n        return n+9\n    else if p == 110\n\
    \        return n+10\n    else if p == 111\n        return n+11\n    else if p\
    \ == 127\n        return n+12\n    else if p == 255\n        return n+13\n   \
    \ else if p == 256\n        return n+14\n    else if p == 257\n        return\
    \ n+15\n    else if p == 258\n        return n+16\n    else if p == 259\n    \
    \    return n+17\n    else if p == 260\n        return n+18\n    else if p ==\
    \ 261\n        return n+19\n    else if p == 262\n        return n+20\n    else\
    \ if p == 263\n        return n+21\n    else if p == 264\n        return n+22\n\
    \    else if p == 265\n        return n+23\n    else if p == 266\n        return\
    \ n+24\n    else if p == 267\n        return n+25\n    else if p == 268\n    \
    \    return n+26\n    else if p == 269\n        return n+27\n    else if p ==\
    \ 270\n        return n+28\n    else if p == 271\n        return n+29\n    else\
    \ if p == 272\n        return n+30\n    else if p == 273\n        return n+31\n\
    \    else if p == 274\n        return n+32\n    else if p == 275\n        return\
    \ n+33\n    else if p == 276\n        return n+34\n    else if p == 277\n    \
    \    return n+35\n    else if p == 278\n        return n+36\n    else if ", " \
    \   if n == 0 \n        then return 1\n    else if n == 1 \n        then return\
    \ p\n    else if p == 0 \n        then return 0\n    else if p < 0 \n        then\
    \ return modp(abs(n), abs(p))\n    else if p > 0 \n        then return modp(n-1,\
    \ p)\n    else if n <= p \n        then return modp(n - 1, p + p)\n    else \n\
    \        then return modp(n-1, p)\nend\n</code>\n<|/ a tags=algorithm,math,modular-arithmetic\
    \ |>\n<| c |>\nThis doesn't work. Try modp(3, 5). You'll get 3 instead of 2.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it yourself. It returns 2 instead of 3.\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try modp(3, 5). You'll get 3 instead of 2.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it yourself. It returns 2 instead of 3.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it yourself. It returns 2 instead of 3.\n\
    <|/ c |>\n<| a tags=algorithm,math,modular-arithmetic |>\nThe algorithm is as\
    \ follows:", "    if n == 0 \n        then return 1\n    else if p == 0 \n   \
    \     then return 0\n    else if p == 1 \n        then return n\n    else if n\
    \ % p == 0 \n        then return modp(n / p, p)\n    else return modp(n / p, p)\
    \ * p\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if n == 0 \n        then return 1\n    else if\
    \ p == 0 \n        then return 0\n    else if n <= p \n        then return modp(n\
    \ - 1, p) \n        else return modp(n mod p, p) \nend\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| c |>\nThe `mod` function isn't a standard function in Julia. Do you mean\
    \ `mod`?\n<|/ c |>\n<| c |>\nYes, I meant `mod`. Thanks for pointing that out.\n\
    <|/ c |>\n<| a dscore=4 |>\nThe algorithm is called \"Euclid's algorithm\". It\
    \ can be implemented efficiently in O(log n) time using binary search and O(1)\
    \ space.\n<|/ a tags=math,algorithm,modular-arithmetic |>\n<| c |>\nThe algorithm\
    \ is called \"Euclid's algorithm\". It can be implemented efficiently in O(log\
    \ n) time using binary search and O(1) space.\n<|/ c |>\n<| c |>\nThe algorithm\
    \ is called \"Euclid's algorithm\". It can be implemented efficiently in O(log\
    \ n) time using binary search and O(1) space.\n<|/ c |>\n<| c |>\nThe algorithm\
    \ is called \"Euclid's algorithm\". It can be implemented efficiently in O(log\
    \ n) time using binary search and O(1) space.\n<|/ c |>\n<| a dscore=4 |>\nThe\
    \ algorithm is called \"Euclid's algorithm\". It can be implemented efficiently\
    \ in O(log n) time using binary search and O(1) space.\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| a tags=math,algorithm,modular-arithmetic |>\nThe algorithm is called\
    \ \"Euclid's algorithm\". It can be implemented efficiently in O(log n) time using\
    \ binary search and O(1) space.\n<|/ a dscore=4 |>\n<| a dscore=4 |>\nThe algorithm\
    \ is called \"Euclid's algorithm\". It can be implemented efficiently in O(log\
    \ n) time using binary search and O(1) space.\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| a dscore=3 |>\nThe algorithm is called \"Euclid's algorithm\". It can\
    \ be implemented efficiently in O(log n) time using binary search and O(1) space.\n\
    <|/ a tags=math,algorithm,modular-arithmetic ", "    if n == 0 \n        then\
    \ return 1\n    else if p == 0 \n        then return 0\n    else if p < 0 \n \
    \       then return modp(abs(n), abs(p))\n    else if n < 0 \n        then return\
    \ modp(abs(n), abs(p))\n    else if n < p \n        then return modp(n - p, p)\n\
    \    else if n > p \n        then return modp(n, p - abs(n))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if p < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if p > n \n        error(\"modp requires non-negative\
    \ integers\")\n    else \n        return n & (p-1)\nend", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return n+1\n    if p==4 then\
    \ return n+2\n    if p==5 then return n+3\n    if p==6 then return n+4\n    if\
    \ p==7 then return n+5\n    if p==8 then return n+6\n    if p==9 then return n+7\n\
    \    if p==10 then return n+8\n    if p==11 then return n+9\n    if p==12 then\
    \ return n+10\n    if p==13 then return n+11\n    if p==14 then return n+12\n\
    \    if p==15 then return n+13\n    if p==16 then return n+14\n    if p==17 then\
    \ return n+15\n    if p==18 then return n+16\n    if p==19 then return n+17\n\
    \    if p==20 then return n+18\n    if p==21 then return n+19\n    if p==22 then\
    \ return n+20\n    if p==23 then return n+21\n    if p==24 then return n+22\n\
    \    if p==25 then return n+23\n    if p==26 then return n+24\n    if p==27 then\
    \ return n+25\n    if p==28 then return n+26\n    if p==29 then return n+27\n\
    \    if p==30 then return n+28\n    if p==31 then return n+29\n    if p==32 then\
    \ return n+30\n    if p==33 then return n+31\n    if p==34 then return n+32\n\
    \    if p==35 then return n+33\n    if p==36 then return n+34\n    if p==37 then\
    \ return n+35\n    if p==38 then return n+36\n    if p==39 then return n+37\n\
    \    if p==40 then return n+38\n    if p==41 then return n+39\n    if p==42 then\
    \ return n+40\n    if p==43 then return n+41\n    if p==44 then return n+42\n\
    \    if p==45 then return n+43\n    if p==46 then return n+44\n    if p==47 then\
    \ return n+45\n    if p==48 then return n+46\n    if p==49", "    if n == 0 \n\
    \        then return 0\n    else if p == 0 \n        then return 1\n    else if\
    \ p < 0 \n        then return modp(-n, -p) \n    else if p > 0 \n        then\
    \ return modp(n, p) \n    else \n        modp(n / 2, p) + modp(n / 2, p)\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if p == 0 \n        then return 0\n    else if n == 0 \n        then return\
    \ 1\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(abs(n), abs(p))\n    else if n < p \n     \
    \   then return modp(n - p, p)\n    else if n > p \n        then return modp(n,\
    \ p - abs(n))\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n  \
    \      then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ n <= p \n        then return modp(n - 1, p) \n        else return modp(n - 1,\
    \ modp(p, n))\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if n <= 0\n        error(\"modp(): n must be\
    \ positive\")\n    else if p <= 0\n        error(\"modp(): p must be positive\"\
    )\n    else if p < n\n        error(\"modp(): p must be >= n\")\n    else if p\
    \ == 0 || n == 0\n        error(\"modp(): p and n must be != 0\")\n    else if\
    \ p == 1\n        1\n    else if p == 2\n        2\n    else if p == 3\n     \
    \   3\n    else if p == 4\n        4\n    else if p == 5\n        5\n    else\
    \ if p == 6\n        6\n    else if p == 7\n        7\n    else if p == 8\n  \
    \      8\n    else if p == 9\n        9\n    else if p == 10\n        10\n   \
    \ else if p == 11\n        11\n    else if p == 12\n        12\n    else if p\
    \ == 13\n        13\n    else if p == 14\n        14\n    else if p == 15\n  \
    \      15\n    else if p == 16\n        16\n    else if p == 17\n        17\n\
    \    else if p == 18\n        18\n    else if p == 19\n        19\n    else if\
    \ p == 20\n        20\n    else if p == 21\n        21\n    else if p == 22\n\
    \        22\n    else if p == 23\n        23\n    else if p == 24\n        24\n\
    \    else if p == 25\n        25\n    else if p == 26\n        26\n    else if\
    \ p == 27\n        27\n    else if p == 28\n        28\n    else if p == 29\n\
    \        29\n    else if p == 30\n        30\n    else if p == 31\n        31\n\
    \    else if p == 32\n        32\n    else if p == 33\n        33\n    else if\
    \ p == 34\n        34\n    else if p == 35\n        35\n    else if p == 36\n\
    \        36\n    else if p == 37\n        37\n    else if p == 38\n        38\n\
    \    else if p == 39\n        39\n    else if p == 40\n        40\n    else if\
    \ p == 41\n        41\n    else if p == 42\n        42\n    else if p == 43\n\
    \        43\n    else if p == 44\n        44\n    else if p == 45\n        45\n\
    \    else if p == 46\n        46\n", "    if n == 0 \n        then return 1\n\
    \    else if p == 0 \n        then return 0\n    else if p < 0 \n        then\
    \ return modp(-n, -p) \n    else if n < 0 \n        then return modp(-n, p) \n\
    \    else if n < p \n        then return modp(n, p)\n    else return modp(n +\
    \ p - 1, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 \n     \
    \   then return 1\n    else if n < 0 \n        then return modp(-n, p)\n    else\
    \ if p == 0 \n        then return 0\n    else if p < 0 \n        then return modp(-n,\
    \ p)\n    else if p > 0 \n        then return modp(n, p-1)\n    else \n      \
    \  error(\"modp called with negative arguments\")\n    end\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers. `modp(2, -5)`\
    \ returns `1` instead of `-1`.\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return modp(2*n, p)\n    if p==4\
    \ then return modp(3*n, p)\n    if p==5 then return modp(4*n, p)\n    if p==6\
    \ then return modp(5*n, p)\n    if p==7 then return modp(6*n, p)\n    if p==8\
    \ then return modp(7*n, p)\n    if p==9 then return modp(8*n, p)\n    if p==10\
    \ then return modp(9*n, p)\n    if p==11 then return modp(10*n, p)\n    if p==12\
    \ then return modp(11*n, p)\n    if p==13 then return modp(12*n, p)\n    if p==14\
    \ then return modp(13*n, p)\n    if p==15 then return modp(14*n, p)\n    if p==16\
    \ then return modp(15*n, p)\n    if p==17 then return modp(16*n, p)\n    if p==18\
    \ then return modp(17*n, p)\n    if p==19 then return modp(18*n, p)\n    if p==20\
    \ then return modp(19*n, p)\n    if p==21 then return modp(20*n, p)\n    if p==22\
    \ then return modp(21*n, p)\n    if p==23 then return modp(22*n, p)\n    if p==24\
    \ then return modp(23*n, p)\n    if p==25 then return modp(24*n, p)\n    if p==26\
    \ then return modp(25*n, p)\n    if p==27 then return modp(26*n, p)\n    if p==28\
    \ then return modp(27*n, p)\n    if p==29 then return modp(28*n, p)\n    if p==30\
    \ then return modp(29*n, p)\n    if p==31 then return modp(30*n, p)\n    if p==32\
    \ then return modp(31*n, p)\n    if p==33 then return modp(32*n, p)\n    if p==34\
    \ then return modp(33*n, p)\n    if p==35 then return modp(34*n, p)\n    if p==36\
    \ then return modp(35*n, p)\n    if p==37 then return modp(36*n, p)\n    if p==38\
    \ then return modp(37*n, p)\n    if p==39 then return ", "    if n == 0 then return\
    \ 1\n    if n == 1 then return p\n    if p < 0 then return modp(abs(n), abs(p))\n\
    \    if p > p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ -p) \n    \n    if n % p == 0 then return modp(n / p, p)\n    \n    if n % p\
    \ == 1 then return modp(n / p, p)\n    \n    if n % p == 2 then return modp(n\
    \ / p, p)\n    \n    if n % p == 3 then return modp(n / p, p)\n    \n    if n\
    \ % p == 4 then return modp(n / p, p)\n    \n    if n % p == 5 then return modp(n\
    \ / p, p)\n    \n    if n % p == 6 then return modp(n / p, p)\n    \n    if n\
    \ % p == 7 then return modp(n / p, p)\n    \n    if n % p == 8 then return modp(n\
    \ / p, p)\n    \n    if n % p == 9 then return modp(n / p, p)\n    \n    if n\
    \ % p == 10 then return modp(n / p, p)\n    \n    if n % p == 11 then return modp(n\
    \ / p, p)\n    \n    if n % p == 12 then return modp(n / p, p)\n    \n    if n\
    \ % p == 13 then return modp(n / p, p)\n    \n    if n % p == 14 then return modp(n\
    \ / p, p)\n    \n    if n % p == 15 then return modp(n / p, p)\n    \n    if n\
    \ % p == 16 then return modp(n / p, p)\n    \n    if n % p == 17 then return modp(n\
    \ / p, p)\n    \n    if n % p == 18 then return modp(n / p, p)\n    \n    if n\
    \ % p == 19 then return modp(n / p, p)\n    \n    if n % p == 20 then return modp(n\
    \ / p, p)\n    \n    if n % p == 21 then return modp(n / p, p)\n    \n    if n\
    \ % p == 22 then return modp(n / p, p)\n    \n    if n % p == 23 then return modp(n\
    \ / p, p)\n    \n    if n % p == 24 then return modp(n / p, p)\n    \n    if n\
    \ % p == 25 then return modp(n / p, p)\n    \n    if n % p == 26 then return modp(n\
    \ / p, p)\n    \n    if n % p == 27 then return modp(n / p, p)\n    \n    if n\
    \ % p == 28 then return modp(n / p, p)\n    \n", "    if n <= 0\n    then return\
    \ 0\n    else if n <= p\n    then return n\n    else return modp(n - p, p)\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n == 0 \n        then return p\n\
    \    else if p == 0 \n        then return 0\n    else if p < 0 \n        then\
    \ return modp(abs(n), abs(p))\n    else if n < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n == p \n        then return 0\n    else if n < p \n  \
    \      then return modp(abs(n), abs(p))\n    else return modp(abs(n), abs(p))\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"", "    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n == p \n\
    \        then return 1\n    else if n < p \n        then return modp(n, p)\n \
    \   else if n >= p \n        then return modp(n, p) \n    else return modp(n +\
    \ p - 1, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n <= 0 \n     \
    \   then return 0\n    else if n == 1 \n        then return p\n    else \n   \
    \     modp(n / 2, p) + p * modp(n / 2, p)\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nI like your solution, but I wonder why you chose to write `modp(n / 2,\
    \ p)` instead of `modp(n / 2, p + p)`?\n<|/ c |>\n<| c |>\nI chose `modp(n / 2,\
    \ p)` because I wanted to avoid the division altogether. `modp(n / 2, p + p)`\
    \ would require a division followed by a multiplication. `modp(n / 2, p)` would\
    \ require a multiplication followed by a division.\n<|/ c |>\n<| c |>\nI see.\
    \ Thanks for your explanation.\n<|/ c |>\n<| a tags=math,julia |>\nThe solution\
    \ is very simple:\n<code>", "    if n == 0 \n        then return 1\n    else if\
    \ p == 0 \n        then return 0\n    else if n <= p \n        then return modp(n\
    \ - 1, p) \n        else return modp(p, n)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 \n        then return p\n    else if n < 0 \n        then return\
    \ modp(-n, p)\n    else if p == 0 \n        then return 0\n    else if p < 0 \n\
    \        then return modp(-n, p)\n    else if p < n \n        then return modp(n,\
    \ p)\n    else return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n  \
    \      then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ p < 0 \n        then return modp(abs(n), abs(p))\n    else if n < 0 \n     \
    \   then return modp(abs(n), abs(p))\n    else if n < p \n        then return\
    \ modp(n - p, p)\n    else if n < p \n        then return modp(n - p, p)\n   \
    \ else \n        then return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n  \
    \      then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ n < p \n        then return modp(n - 1, p) \n        else return modp(n, p %\
    \ n) \nend\n</cell>\n<code language=julia-1.5>", "    if p == 0 \n        then\
    \ return 1\n    else if n <= p \n        then return n\n        else return modp(n-1,\
    \ p) % p\n    end\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 \n\
    \        then return 1\n    else if p == 0 \n        then return 0\n    else if\
    \ p < 0 \n        then return modp(-n, -p) \n    else if n < 0 \n        then\
    \ return modp(-n, p) \n    else if n < p \n        then return modp(n, p)\n  \
    \  else return modp(n + p - 1, p)\nend\n</cell>\n<code language=julia-1.5>", " \
    \   if p == 0 \n        then return 0\n    else if n < 0 \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(n + p, p)\n  \
    \  else return modp((n - p) * (p % n) + p, p)\nend\n</cell>\n<code language=julia-1.0>",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(abs(n), abs(p))\n    else if n < p \n     \
    \   then return modp(n - p, p)\n    else if n < p \n        then return modp(n\
    \ - p, p)\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n < 0 \n        error(\"modp(n,p)\")\n    if p < 0 \n        error(\"modp(n,p)\"\
    )\n    if n < p \n        error(\"modp(n,p)\")\n    if n == 0 \n        error(\"\
    modp(n,p)\")\n    if p == 0 \n        error(\"modp(n,p)\")\n    if n == p \n \
    \       error(\"modp(n,p)\")\n    if n == 1 \n        return n\n    if p == 1\
    \ \n        return p\n    if n == p \n        return n\n    if n % p == 0 \n \
    \       return n\n    if n % p == 1 \n        return p\n    if n % p == 2 \n \
    \       return p + 1\n    if n % p == 3 \n        return p + 2\n    if n % p ==\
    \ 4 \n        return p + 3\n    if n % p == 5 \n        return p + 4\n    if n\
    \ % p == 6 \n        return p + 5\n    if n % p == 7 \n        return p + 6\n\
    \    if n % p == 8 \n        return p + 7\n    if n % p == 9 \n        return\
    \ p + 8\n    if n % p == 10 \n        return p + 9\n    if n % p == 11 \n    \
    \    return p + 10\n    if n % p == 12 \n        return p + 11\n    if n % p ==\
    \ 13 \n        return p + 12\n    if n % p == 14 \n        return p + 13\n   \
    \ if n % p == 15 \n        return p + 14\n    if n % p == 16 \n        return\
    \ p + 15\n    if n % p == 17 \n        return p + 16\n    if n % p == 18 \n  \
    \      return p + 17\n    if n % p == 19 \n        return p + 18\n    if n % p\
    \ == 20 \n        return p + 19\n    if n % p == 21 \n        return p + 20\n\
    \    if n % p == 22 \n        return p + 21\n    if n % p == 23 \n        return\
    \ p + 22\n    if n % p == 24 \n        return p + 23\n    if n % p == 25 \n  \
    \      return p + 24\n    if n % p == 26 \n        return p + 25\n    if n % p\
    \ == 27 \n        return p + 26\n    if n % p == 28 \n        return p + 27\n\
    \    if n % p == 29 \n        return p + 28\n    if n % p == 30 \n        return\
    \ p + 29\n    if n % p == 31 \n        return p + 30\n    if n % p == 32 \n  \
    \      return p + 31\n    if n % p == 33 \n        return p + 32\n    if n % p\
    \ == 34 \n        return p + 33\n    if n % p == 35 \n        return p + 34\n\
    \    if n % p == 36 \n        return p + 35\n    if n % p == 37 \n        return\
    \ p + 36\n    if n % p == 38 \n", "    if n <= 0 \n        error(\"modp: n must\
    \ be positive\")\n    else if p <= 0 \n        error(\"modp: p must be positive\"\
    )\n    else if p > n \n        error(\"modp: p must be <= n\")\n    else if p\
    \ < 2 \n        error(\"modp: p must be >= 2\")\n    else if p < 3 \n        error(\"\
    modp: p must be >= 3\")\n    else if p < 5 \n        error(\"modp: p must be >=\
    \ 5\")\n    else if p < 7 \n        error(\"modp: p must be >= 7\")\n    else\
    \ if p < 11 \n        error(\"modp: p must be >= 11\")\n    else if p < 13 \n\
    \        error(\"modp: p must be >= 13\")\n    else if p < 17 \n        error(\"\
    modp: p must be >= 17\")\n    else if p < 19 \n        error(\"modp: p must be\
    \ >= 19\")\n    else if p < 23 \n        error(\"modp: p must be >= 23\")\n  \
    \  else if p < 29 \n        error(\"modp: p must be >= 29\")\n    else if p <\
    \ 37 \n        error(\"modp: p must be >= 37\")\n    else if p < 43 \n       \
    \ error(\"modp: p must be >= 43\")\n    else if p < 59 \n        error(\"modp:\
    \ p must be >= 59\")\n    else if p < 91 \n        error(\"modp: p must be >=\
    \ 91\")\n    else if p < 127 \n        error(\"modp: p must be >= 127\")\n   \
    \ else if p < 255 \n        error(\"modp: p must be >= 255\")\n    else if p <\
    \ 511 \n        error(\"modp: p must be >= 511\")\n    else if p < 1029 \n   \
    \     error(\"modp: p must be >= 1029\")\n    else if p < 2047 \n        error(\"\
    modp: p must be >= 2047\")\n    else if p < 4095\n        error(\"modp: p must\
    \ be >= 4095\")\n    else if p < 8191\n        error(\"modp: p must be >= 8191\"\
    )\n    else if p < 16383\n        error(\"modp: p must be >= 16383\")\n    else\
    \ if p < 32767\n        error(\"modp: p must be >= 32767\")\n    else if p < 65535\n\
    \        error(\"modp: p must be >= 65535\")\n    else if p < 131071\n       \
    \ error(\"modp: p must be >= 131071\")\n    else if p < 262143\n        error(\"\
    modp: p must be >= 262143\")", "    if n <= 0\n        error(\"modp requires n\
    \ >= 0\")\n    end\n    if p <= 0\n        error(\"modp requires p >= 0\")\n \
    \   end\n    if p < n\n        error(\"modp requires p >= n\")\n    end\n    return\
    \ n & (-p-1)\nend\n\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>>\
    \ modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n  \
    \  1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if n >= p\n        then return modp(n - p, p)\n    else return modp(n\
    \ - p, p + p)\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"Return 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if n <= 0\n        error(\"modp() only accepts\
    \ non-negative integers\")\n    end\n    if p <= 0\n        error(\"modp() only\
    \ accepts non-negative integers\")\n    end\n    if p > n\n        error(\"modp()\
    \ only accepts non-negative integers\")\n    end\n    return n & (p-1)\nend\n\
    </cell>\n<code language=julia-1.5>", "    if p == 0 \n        then return 1\n\
    \    else if p == 1 \n        then return n\n    else if n <= p \n        then\
    \ return modp(n - p, p)\n    else return modp(n, p - 1)\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return modp(n-1, 2)\n    if p==4\
    \ then return modp(n-1, 3)\n    if p==5 then return modp(n-1, 4)\n    if p==6\
    \ then return modp(n-1, 5)\n    if p==7 then return modp(n-1, 6)\n    if p==8\
    \ then return modp(n-1, 7)\n    if p==9 then return modp(n-1, 8)\n    if p==10\
    \ then return modp(n-1, 9)\n    if p==11 then return modp(n-1, 10)\n    if p==12\
    \ then return modp(n-1, 11)\n    if p==13 then return modp(n-1, 12)\n    if p==14\
    \ then return modp(n-1, 13)\n    if p==15 then return modp(n-1, 14)\n    if p==16\
    \ then return modp(n-1, 15)\n    if p==17 then return modp(n-1, 16)\n    if p==18\
    \ then return modp(n-1, 17)\n    if p==19 then return modp(n-1, 18)\n    if p==20\
    \ then return modp(n-1, 19)\n    if p==21 then return modp(n-1, 20)\n    if p==22\
    \ then return modp(n-1, 21)\n    if p==23 then return modp(n-1, 22)\n    if p==24\
    \ then return modp(n-1, 23)\n    if p==25 then return modp(n-1, 24)\n    if p==26\
    \ then return modp(n-1, 25)\n    if p==27 then return modp(n-1, 26)\n    if p==28\
    \ then return modp(n-1, 27)\n    if p==29 then return modp(n-1, 28)\n    if p==30\
    \ then return modp(n-1, 29)\n    if p==31 then return modp(n-1, 30)\n    if p==32\
    \ then return modp(n-1, 31)\n    if p==33 then return modp(n-1, 32)\n    if p==34\
    \ then return modp(n-1, 33)\n    if p==35 then return modp(n-1, 34)\n    if p==36\
    \ then return modp(n-1, 35)\n    if p==37 then return modp(n-1, 36)\n    if p==38\
    \ then return modp(n-1, 37)\n    if p==39 then return modp(n-1, 38)\n    if p==40\
    \ then return modp(n-1, 39)", "    if n == 0 then return 1\n    if p == 0 then\
    \ return 0\n    if n <= p then return 1\n    if p < n then return modp(n - p,\
    \ p)\n    \n    \n    \"\"\"\n    Compute n^p modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n <= 0 \n        then return 0\n    else if n <= p \n        then return\
    \ 1\n    else \n        return modp(n - p, p) + 1\nend\n</cell>\n<code language=julia-1.5>",
  "    if n==0 then return 1\n    if n==1 then return p\n    if p==0 then return 0\n\
    \    if p==1 then return 1\n    if p==2 then return n\n    if p==3 then return\
    \ n+1\n    if p==4 then return n*2\n    if p==5 then return n*3\n    if p==6 then\
    \ return n*4\n    if p==7 then return n*5\n    if p==8 then return n*6\n    if\
    \ p==9 then return n*7\n    if p==10 then return n*8\n    if p==11 then return\
    \ n*9\n    if p==12 then return n*10\n    if p==13 then return n*11\n    if p==14\
    \ then return n*12\n    if p==15 then return n*13\n    if p==16 then return n*14\n\
    \    if p==17 then return n*15\n    if p==18 then return n*16\n    if p==19 then\
    \ return n*17\n    if p==20 then return n*18\n    if p==21 then return n*19\n\
    \    if p==22 then return n*20\n    if p==23 then return n*21\n    if p==24 then\
    \ return n*22\n    if p==25 then return n*23\n    if p==26 then return n*24\n\
    \    if p==27 then return n*25\n    if p==28 then return n*26\n    if p==29 then\
    \ return n*27\n    if p==30 then return n*28\n    if p==31 then return n*29\n\
    \    if p==32 then return n*30\n    if p==33 then return n*31\n    if p==34 then\
    \ return n*32\n    if p==35 then return n*33\n    if p==36 then return n*34\n\
    \    if p==37 then return n*35\n    if p==38 then return n*36\n    if p==39 then\
    \ return n*37\n    if p==40 then return n*38\n    if p==41 then return n*39\n\
    \    if p==42 then return n*40\n    if p==43 then return n*41\n    if p==44 then\
    \ return n*42\n    if p==45 then return n*43\n    if p==46 then return n*44\n\
    \    if p==47 then return n*45\n    if p==48 then return n*46\n    if p==49 then\
    \ return n*47\n    if p==50 then return n*48\n    if p==51 then return n*49\n\
    \    if p==52 then return n*50\n    if p==53 then return n*51\n", "    if n ==\
    \ 0 \n        then return 1\n    else if p == 0 \n        then return 0\n    else\
    \ if p < 0 \n        then return modp(abs(n), abs(p))\n    else if n < 0 \n  \
    \      then return modp(abs(n), abs(p))\n    else if n <= p \n        then return\
    \ modp(n - p, p)\n    else if n >= p \n        then return modp(n, p - abs(n))\n\
    \    else \n        error(\"modp: n must be < p and p must be >= 0\")\nend\n</cell>\n\
    <code language=julia-1.4>", "    if n==0 then return 1\n    if n==1 then return\
    \ p\n    if n==p then return 1\n    if p==0 then return 0\n    if p==1 then return\
    \ n\n    if p==2 then return n+1\n    if p==3 then return n*(n+1)/2\n    if p==4\
    \ then return n*(n+1)*(2*n+1)/6\n    if p==5 then return n*(n+1)*(2*n+1)*(3*n+1)/5\n\
    \    if p==6 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)/4\n    if p==7 then return\
    \ n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)/25\n    if p==8 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)/125\n\
    \    if p==9 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)/625\n\
    \    if p==10 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)/1680\n\
    \    if p==11 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)/122\n\
    \    if p==12 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)/720\n\
    \    if p==13 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(11*n+1)/5040\n\
    \    if p==14 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(11*n+1)*(12*n+1)/40320\n\
    \    if p==15 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, -p) \n    else if n <= p\
    \ \n        then return modp(n - p, p) \n    else return modp(n, p - n)\nend \n\
    </code>\n<|/ a tags=math,algorithm,modular-arithmetic |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. For example, `modp(2, -5)` returns `1` instead of\
    \ `-1`.\n<|/ c |>\n<| c |>\nIt works for negative numbers. `modp(2, -5)` returns\
    \ `-1` instead of `1`.\n<|/ c |>\n<| c |>\nIt works for negative numbers. `modp(2,\
    \ -5)` returns `-1` instead of `1`.\n<|/ c |>\n<| c |>\nIt works for negative\
    \ numbers. `modp(2, -5)` returns `-1` instead of `1`.\n<|/ c |>\n<| c |>\nIt works\
    \ for negative numbers. `modp(2, -5)` returns `-1` instead of `1`.\n<|/ c |>\n\
    <| a tags=math,algorithm,modular-arithmetic |>\n<code>\nint modp(int a, int b)\
    \ {\n    int c = a % b;\n    if (c >= b) return 0;\n    return c;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't work for negative numbers. For example,\
    \ `modp(2, -5)` returns `1` instead of `-1`.\n<|/ c |>\n<| c |>\nIt works for\
    \ negative numbers. `modp(2, -5)` returns `-1` instead of `1`.\n<|/ c |>\n<| c\
    \ |>\nIt works for negative numbers. `modp(2, -5)` returns `-1` instead of `1`.\n\
    <|/ c |>\n<| c |>\nIt works for negative numbers. `modp(2, -5)` returns `-1` instead\
    \ of `1`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\nint modp(int a, int b) {\n    int\
    \ c = a % b;\n    if (c >= b) return 0;\n    return c;\n}\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. For example, `modp(2, -5)`\
    \ returns `1` instead of `-1`.\n<|/ c |>\n<| c |>\nIt works for ", "    if n ==\
    \ 0 \n        then return 1\n    else if p == 0 \n        then return 0\n    else\
    \ if p < 0 \n        then return modp(abs(n), abs(p))\n    else if n < 0 \n  \
    \      then return modp(abs(n), abs(p))\n    else if n <= p \n        then return\
    \ modp(n - p, p)\n    else \n        then return modp((p - n) mod p, p)\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n <= 0\n        error(\"modp(): n\
    \ must be positive\")\n    end\n    if p <= 0\n        error(\"modp(): p must\
    \ be positive\")\n    end\n    if p > n\n        error(\"modp(): p must be <=\
    \ n\")\n    end\n    return ((p % n) + n) % n\nend\n</cell>\n<code language=julia-1.5>",
  "    if n <= 0\n        error(\"modp: n must be positive\")\n    else if p <= 0\n\
    \        error(\"modp: p must be positive\")\n    else if p > n\n        error(\"\
    modp: p must be <= n\")\n    else if p < 2\n        error(\"modp: p must be >=\
    \ 2\")\n    else if p > 2\n        error(\"modp: p must be <= 2\")\n    else if\
    \ n == 0\n        error(\"modp: n must be positive\")\n    else if p == 0\n  \
    \      error(\"modp: p must be positive\")\n    else if n == 1\n        error(\"\
    modp: n must be positive\")\n    else if p == 1\n        error(\"modp: p must\
    \ be positive\")\n    else if n <= p\n        error(\"modp: n must be <= p\")\n\
    \    else\n        return n\nend\n</cell>\n<code language=julia-1.5>", "    if\
    \ n == 0 then return 1\n    if p == 0 then return 0\n    if p < 2 then return\
    \ 0\n    if p < n then return modp(n - 1, p) + 1\n    if p < 2 * n then return\
    \ modp(n - 1, p)\n    else return modp(n - 1, p - 1) + 1\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n   \
    \ >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p == 1 \n        then return n\n    else if p == 2 \n       \
    \ then return n*2\n    else if p == 3 \n        then return n*3\n    else if p\
    \ == 4 \n        then return n*4\n    else if p == 5 \n        then return n*5\n\
    \    else if p == 6 \n        then return n*6\n    else if p == 7 \n        then\
    \ return n*7\n    else if p == 8 \n        then return n*8\n    else if p == 9\
    \ \n        then return n*9\n    else if p == 10 \n        then return n*10\n\
    \    else if p == 11 \n        then return n*11\n    else if p == 12 \n      \
    \  then return n*12\n    else if p == 13 \n        then return n*13\n    else\
    \ if p == 14 \n        then return n*14\n    else if p == 15 \n        then return\
    \ n*15\n    else if p == 16 \n        then return n*16\n    else if p == 17 \n\
    \        then return n*17\n    else if p == 18 \n        then return n*18\n  \
    \  else if p == 19 \n        then return n*19\n    else if p == 20 \n        then\
    \ return n*20\n    else if p == 21 \n        then return n*21\n    else if p ==\
    \ 22 \n        then return n*22\n    else if p == 23 \n        then return n*23\n\
    \    else if p == 24 \n        then return n*24\n    else if p == 25 \n      \
    \  then return n*25\n    else if p == 26 \n        then return n*26\n    else\
    \ if p == 27 \n        then return n*27\n    else if p == 28 \n        then return\
    \ n*28\n    else if p == 29 \n        then return n*29\n    else if p == 30 \n\
    \        then return n*30\n    else if p == 31 \n        then return n*31\n  \
    \  else if p == 32 \n        then return n*32\n    else if p == 33 \n        then\
    \ return n*33\n    else if p == 34 \n        then return n*34\n    else if p ==\
    \ 35 \n        then return n*35\n    else if p == 36 \n        then return n*36\n\
    \    else if p == 37 \n        then return n*37\n    else if p == 38 \n      \
    \  then return n*38\n    else if p == 39", "    if n == 0 \n        then return\
    \ 1\n    else if p == 0 \n        then return 0\n    else if p == 1 \n       \
    \ then return n\n    else if p < 0 \n        then return modp(-n, p)\n    else\
    \ if n % p == 0 \n        then return modp(n, p / 2)\n    else return modp(n,\
    \ p / 2)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return nth root of p\
    \ (be aware of numerics).\n    >>> nthroot(3, 5)\n    1.73205080756888\n    >>>\
    \ nthroot(1101, 101)\n    2.2698777458779\n    >>> nthroot(0, 101)\n    1.0\n\
    \    >>> nthroot(3, 11)\n    1.73205080756888\n    >>> nthroot(100, 101)\n   \
    \ 1.0\n    \"\"\"", "    if n <= 0\n        error(\"modp(): n must be positive\"\
    )\n    else if p <= 0\n        error(\"modp(): p must be positive\")\n    else\
    \ if p < n\n        error(\"modp(): p must be >= n\")\n    else\n        return\
    \ n & (p-1)\nend", "    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n < p \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n == 0 \n        error(\"modp requires non-zero integers\"\
    )\n    else if p == 0 \n        error(\"modp requires non-zero integers\")\n \
    \   else if p == 1 \n        error(\"modp requires non-zero integers\")\n    else\
    \ if p == 2 \n        return n\n    else if p == 3 \n        return n\n    else\
    \ if p == 4 \n        return n\n    else if p == 5 \n        return n\n    else\
    \ if p == 6 \n        return n\n    else if p == 7 \n        return n\n    else\
    \ if p == 8 \n        return n\n    else if p == 9 \n        return n\n    else\
    \ if p == 10 \n        return n\n    else if p == 11 \n        return n\n    else\
    \ if p == 12 \n        return n\n    else if p == 13 \n        return n\n    else\
    \ if p == 14 \n        return n\n    else if p == 15 \n        return n\n    else\
    \ if p == 16 \n        return n\n    else if p == 17 \n        return n\n    else\
    \ if p == 18 \n        return n\n    else if p == 19 \n        return n\n    else\
    \ if p == 20 \n        return n\n    else if p == 21 \n        return n\n    else\
    \ if p == 22 \n        return n\n    else if p == 23 \n        return n\n    else\
    \ if p == 24 \n        return n\n    else if p == 25 \n        return n\n    else\
    \ if p == 26 \n        return n\n    else if p == 27 \n        return n\n    else\
    \ if p == 28 \n        return n\n    else if p == 29 \n        return n\n    else\
    \ if p == 30 \n        return n\n    else if p == 31 \n        return n\n    else\
    \ if p == 32 \n        return n\n    else if p == 33 \n        return n\n    else\
    \ if p == 34 \n        return n\n    else if p == 35 \n        return n\n    else\
    \ if p == 36 \n        return n\n    else if p == 37 \n        return n\n    else\
    \ if p == 38 \n        return n\n    else if p == 39 \n        return n\n    else\
    \ if p == 40 \n        return n\n    else if p == 41 \n        return n\n    else\
    \ if p == 42 \n        return n\n    else if p == 43 \n        return n\n    else\
    \ if p == 44 \n        return n\n    else if p == 45 \n        return n", "  \
    \  if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p == 1 \n        then return n\n    else if p > 1 \n        then\
    \ return modp(n / p, p)\n    else \n        then return modp((n - 1) * (p + 1),\
    \ p)\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"Return n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \"\"\"", "    if n==0 then return 1\n    else if n==1 then return\
    \ p\n    else if p==0 then return 0\n    else if p==1 then return 1\n    else\
    \ if p==2 then return n\n    else if p==3 then return modp(2*n, p)\n    else if\
    \ p==4 then return modp(3*n, p)\n    else if p==5 then return modp(4*n, p)\n \
    \   else if p==6 then return modp(5*n, p)\n    else if p==7 then return modp(6*n,\
    \ p)\n    else if p==8 then return modp(7*n, p)\n    else if p==9 then return\
    \ modp(8*n, p)\n    else if p==10 then return modp(9*n, p)\n    else if p==11\
    \ then return modp(10*n, p)\n    else if p==12 then return modp(11*n, p)\n   \
    \ else if p==13 then return modp(12*n, p)\n    else if p==14 then return modp(13*n,\
    \ p)\n    else if p==15 then return modp(14*n, p)\n    else if p==16 then return\
    \ modp(15*n, p)\n    else if p==17 then return modp(16*n, p)\n    else if p==18\
    \ then return modp(17*n, p)\n    else if p==19 then return modp(18*n, p)\n   \
    \ else if p==20 then return modp(19*n, p)\n    else if p==21 then return modp(20*n,\
    \ p)\n    else if p==22 then return modp(21*n, p)\n    else if p==23 then return\
    \ modp(22*n, p)\n    else if p==24 then return modp(23*n, p)\n    else if p==25\
    \ then return modp(24*n, p)\n    else if p==26 then return modp(25*n, p)\n   \
    \ else if p==27 then return modp(26*n, p)\n    else if p==28 then return modp(27*n,\
    \ p)\n    else if p==29 then return modp(28*n, p)\n    else if p==30 then return\
    \ modp(29*n, p)\n    else if p==31 then return modp(30*n, p)\n    else if p==32\
    \ then return modp(31*n, p)\n    else if p==33 then return modp(32*n, p)\n   \
    \ else if ", "    if n == 0 \n        then return 1\n    else if n < 0 \n    \
    \    then return modp(abs(n), p)\n    else if p < 0 \n        then return modp(n,\
    \ abs(p))\n    else if p < 2\n        then return modp(n >> 1, p)\n    else if\
    \ p < 4\n        then return modp(n >> 2, p)\n    else if p < 8\n        then\
    \ return modp(n >> 3, p)\n    else if p < 16\n        then return modp(n >> 4,\
    \ p)\n    else if p < 32\n        then return modp(n >> 5, p)\n    else if p <\
    \ 64\n        then return modp(n >> 6, p)\n    else if p < 128\n        then return\
    \ modp(n >> 7, p)\n    else if p < 256\n        then return modp(n >> 8, p)\n\
    \    else if p < 512\n        then return modp(n >> 9, p)\n    else if p < 1024\n\
    \        then return modp(n >> 10, p)\n    else if p < 2048\n        then return\
    \ modp(n >> 11, p)\n    else if p < 4096\n        then return modp(n >> 12, p)\n\
    \    else if p < 8192\n        then return modp(n >> 13, p)\n    else if p < 16384\n\
    \        then return modp(n >> 14, p)\n    else if p < 32768\n        then return\
    \ modp(n >> 15, p)\n    else if p < 65536\n        then return modp(n >> 16, p)\n\
    \    else if p < 131072\n        then return modp(n >> 17, p)\n    else if p <\
    \ 262144\n        then return modp(n >> 18, p)\n    else if p < 524288\n     \
    \   then return modp(n >> 19, p)\n    else if p < 1048576\n        then return\
    \ modp(n >> 20, p)\n    else if p < 2097152\n        then return modp(n >> 21,\
    \ p)\n    else if p < 4194304\n        then return modp(n >> 22, p)\n    else\
    \ if p < 8388608\n        then return modp(n >> 23, p)\n    else if p < 16777216\n\
    \        then return modp(n >> 24, p)\n    else if p < 33554432\n        then\
    \ return modp(n >> 25, p)\n    else if p < 67108864\n        then return modp(n\
    \ >> 26, p)\n    else if p ", "    if n == 0 \n        then return 1\n    else\
    \ if p == 0 \n        then return 0\n    else if n >= p\n        then return modp(n\
    \ - p, p)\n    else return modp(n - p, modp(n, p))\nend\n</cell>\n<code language=julia-1.5>",
  "    if n <= 0\n        error(\"modp(n,p)\")\n    else if p == 0\n        error(\"\
    modp(n,p)\")\n    else if p < 0\n        error(\"modp(n,p)\")\n    else if n <\
    \ p\n        error(\"modp(n,p)\")\n    else\n        return n%p\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n < 0 \n        error(\"modp requires n >=\
    \ 0\")\n    else if n < p \n        error(\"modp requires n >= p\")\n    else\
    \ if n == 0 \n        error(\"modp requires n != 0\")\n    else if p == 0 \n \
    \       error(\"modp requires p != 0\")\n    else if p == 1 \n        error(\"\
    modp requires p != 1\")\n    else if p == 2 \n        error(\"modp requires p\
    \ != 2\")\n    else if p == 3 \n        error(\"modp requires p != 3\")\n    else\
    \ if p == 4 \n        error(\"modp requires p != 4\")\n    else if p == 5 \n \
    \       error(\"modp requires p != 5\")\n    else if p == 6 \n        error(\"\
    modp requires p != 6\")\n    else if p == 7 \n        error(\"modp requires p\
    \ != 7\")\n    else if p == 8 \n        error(\"modp requires p != 8\")\n    else\
    \ if p == 9 \n        error(\"modp requires p != 9\")\n    else if p == 10 \n\
    \        error(\"modp requires p != 10\")\n    else if p == 11 \n        error(\"\
    modp requires p != 11\")\n    else if p == 12 \n        error(\"modp requires\
    \ p != 12\")\n    else if p == 13 \n        error(\"modp requires p != 13\")\n\
    \    else if p == 14 \n        error(\"modp requires p != 14\")\n    else if p\
    \ == 15 \n        error(\"modp requires p != 15\")\n    else if p == 16 \n   \
    \     error(\"modp requires p != 16\")\n    else if p == 17 \n        error(\"\
    modp requires p != 17\")\n    else if p == 18 \n        error(\"modp requires\
    \ p != 18\")\n    else if p == 19 \n        error(\"modp requires p != 19\")\n\
    \    else if p == 20 \n        error(\"modp requires p != 20\")\n    else if p\
    \ == 21 \n        error(\"modp requires p != 21\")\n    else if p == 22 \n   \
    \     error(\"modp requires p != 22\")\n    else if p == 23 \n        error(\"\
    modp requires p != 23\")\n    else if p == 24 \n        error(\"modp requires\
    \ p != 24\")\n    else if p == 25 \n        error(\"modp requires p != 25\")\n\
    \    else if p == 26 \n        error(\"modp requires p != 26\")\n    else if p\
    \ == 27 \n        error(\"modp requires p != 27\")\n    else if p == 28 \n", " \
    \   if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(abs(n), abs(p))\n    else if n < p \n     \
    \   then return modp(n - p, p)\n    else \n        then return modp(n - p, p)\n\
    end\n</cell>\n<code language=julia-1.5>", "    if n==0 then return 1 \n    else\
    \ if p==0 then return 0 \n    else if n==p then return 1 \n    else if n<p then\
    \ return modp(modp(n,p)+p, p) \n    else return modp(n-p,p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n   \
    \ >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n <= 0 | p <= 0 | p == 0 \n        then throw(DomainError(\"modp\"))\n \
    \   else if n == 0 \n        then 0\n    else if p == 0 \n        then 1\n   \
    \ else if p == 1 \n        then n\n    else if p < 1 \n        then throw(DomainError(\"\
    modp\"))\n    else if p > n\n        then throw(DomainError(\"modp\"))\n    else\
    \ if p < 2 \n        then 1\n    else if p < 3 \n        then 2\n    else if p\
    \ < 5 \n        then 3\n    else if p < 7 \n        then 4\n    else if p < 11\
    \ \n        then 5\n    else if p < 17 \n        then 6\n    else if p < 19 \n\
    \        then 7\n    else if p < 29 \n        then 8\n    else if p < 59 \n  \
    \      then 9\n    else if p < 91 \n        then 10\n    else if p < 121 \n  \
    \      then 11\n    else if p < 151 \n        then 12\n    else if p < 181 \n\
    \        then 13\n    else if p < 211 \n        then 14\n    else if p < 241 \n\
    \        then 15\n    else if p < 271 \n        then 16\n    else if p < 301 \n\
    \        then 17\n    else if p < 331 \n        then 18\n    else if p < 361 \n\
    \        then 19\n    else if p < 391 \n        then 20\n    else if p < 421\n\
    \        then 21\n    else if p < 451\n        then 22\n    else if p < 481\n\
    \        then 23\n    else if p < 511\n        then 24\n    else if p < 541\n\
    \        then 25\n    else if p < 571\n        then 26\n    else if p < 601\n\
    \        then 27\n    else if p < 631\n        then 28\n    else if p < 661\n\
    \        then 29\n    else if p < 691\n        then 30\n    else if p < 721\n\
    \        then 31\n    else if p < 751\n        then 32\n    else if p < 781\n\
    \        then 33\n    else if p < 811\n        then 34\n    else if p < 841\n\
    \        then 35\n    else if p < 871\n        then 36\n", "    if n < 0 \n  \
    \      error(\"modp requires n >= 0\")\n    if p < 0 \n        error(\"modp requires\
    \ p >= 0\")\n    if n == 0 \n        error(\"modp requires n > 0\") \n    if p\
    \ == 0 \n        error(\"modp requires p > 0\") \n    if p == 1 \n        return\
    \ n\n    if p == 2 \n        return n+1\n    if p == 3 \n        return n*2\n\
    \    if p == 4 \n        return n*3\n    if p == 5 \n        return n*4\n    if\
    \ p == 6 \n        return n*5\n    if p == 7 \n        return n*6\n    if p ==\
    \ 8 \n        return n*7\n    if p == 9 \n        return n*8\n    if p == 10 \n\
    \        return n*9\n    if p == 11 \n        return n*10\n    if p == 12 \n \
    \       return n*11\n    if p == 13 \n        return n*12\n    if p == 14 \n \
    \       return n*13\n    if p == 15 \n        return n*14\n    if p == 16 \n \
    \       return n*15\n    if p == 17 \n        return n*16\n    if p == 18 \n \
    \       return n*17\n    if p == 19 \n        return n*18\n    if p == 20 \n \
    \       return n*19\n    if p == 21 \n        return n*20\n    if p == 22 \n \
    \       return n*21\n    if p == 23 \n        return n*22\n    if p == 24 \n \
    \       return n*23\n    if p == 25 \n        return n*24\n    if p == 26 \n \
    \       return n*25\n    if p == 27 \n        return n*26\n    if p == 28 \n \
    \       return n*27\n    if p == 29 \n        return n*28\n    if p == 30 \n \
    \       return n*29\n    if p == 31 \n        return n*30\n    if p == 32 \n \
    \       return n*31\n    if p == 33 \n        return n*32\n    if p == 34 \n \
    \       return n*33\n    if p == 35 \n        return n*34\n    if p == 36 \n \
    \       return n*35\n    if p == 37 \n        return n*36\n    if p == 38 \n \
    \       return n*37\n    if p == 39 \n        return n*38\n    if p == 40 \n \
    \       return n*39\n    if p == 41 \n        return n*40\n    if p == 42 \n \
    \       return n*41\n    if p == 43 \n        return n*42\n    if p == 44 \n \
    \       return n*43\n    if p == 45 \n        return n*44\n    if p == 46 \n \
    \       return n*45\n    if p == 47 \n        return n*46\n    if p == 48 \n \
    \       return n*47\n    if p == 49 \n        return n*48\n    if p == 50 \n \
    \       return n*49\n    if p == 51 \n        return n*50\n    if p", "    if\
    \ n == 0 \n        then return 1\n    else if n < 0 \n        then return modp(abs(n),\
    \ p)\n    else if p == 0 \n        then return 0\n    else if p < 0 \n       \
    \ then return modp(abs(n), abs(p))\n    else if p < n \n        then return modp(n\
    \ - p, p)\n    else if p > n \n        then return modp(n, p - n)\n    else return\
    \ modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if n == 0 \n        then return p\n    else if\
    \ p == 0 \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n-1, p)\n    else return modp(n-1, p-1)\n\
    end\n</cell>\n<code language=julia-1.5>", "    if n <= 0 \n        error(\"n must\
    \ be positive\")\n    else if p <= 0 \n        error(\"p must be positive\")\n\
    \    else if p > n \n        error(\"p must be <= n\")\n    else if n == 0 \n\
    \        error(\"n must be positive\")\n    else if p == 0 \n        error(\"\
    p must be positive\")\n    else if p == 1 \n        error(\"p must be odd\")\n\
    \    else if p == 2 \n        error(\"p must be even\")\n    else if p == 3 \n\
    \        error(\"p must be prime\")\n    else if p == 5 \n        error(\"p must\
    \ be composite\")\n    else if p == 7 \n        error(\"p must be perfect square\"\
    )\n    else if p == 11 \n        error(\"p must be prime or perfect square\")\n\
    \    else if p == 13 \n        error(\"p must be prime or perfect cube\")\n  \
    \  else if p == 17 \n        error(\"p must be prime or perfect fifth power\"\
    )\n    else if p == 19 \n        error(\"p must be prime or perfect seventh power\"\
    )\n    else if p == 29 \n        error(\"p must be prime or perfect ninth power\"\
    )\n    else if p == 37 \n        error(\"p must be prime or perfect tenth power\"\
    )\n    else if p == 47 \n        error(\"p must be prime or perfect eleventh power\"\
    )\n    else if p == 59 \n        error(\"p must be prime or perfect twelfth power\"\
    )\n    else if p == 73 \n        error(\"p must be prime or perfect thirteenth\
    \ power\")\n    else if p == 79 \n        error(\"p must be prime or perfect fourteenth\
    \ power\")\n    else if p == 89 \n        error(\"p must be prime or perfect fifteenth\
    \ power\")\n    else if p == 93 \n        error(\"p must be prime or perfect sixteenth\
    \ power\")\n    else if p == 99 \n        error(\"p must be prime or perfect seventeenth\
    \ power\")\n    else if p == 107 \n        error(\"p must be prime or perfect\
    \ eighteenth power\")\n    else if p == 113 \n        error(\"p must be prime\
    \ or perfect nineteenth power\")\n    else if p == 131 \n        error(\"p must\
    \ be prime or perfect twenty first power\")\n    else if p == 137 \n        error(\"\
    p must be prime or perfect twenty seventh power\")\n    else if p == 139 \n",
  "    if n == 0 then return 1\n    if n == 1 then return p\n    if p < 0 then return\
    \ modp(abs(n), -p)\n    if p > p then return modp(abs(n), p)\n    if p < p then\
    \ return modp(abs(n), -p) \n    return modp(abs(n), p)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, -p) \n    else if n < 0\
    \ \n        then return modp(-n, p) \n    else if n < p \n        then return\
    \ modp(n, -p)\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.3>",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, p)\n    else if n <= p \n\
    \        then return modp(n - p, p)\n    else return modp(n + p, p)\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p == 1 \n        then return n\n    else if p > 1 \n        then\
    \ return modp(n / p, p)\n    else \n        then return modp((n mod p) + p, p)\n\
    end\n</cell>\n<code language=julia-1.5>", "    if n==0 then return 1\n    if n==1\
    \ then return p\n    if n==2 then return p+1\n    if n==3 then return p+2\n  \
    \  if n==4 then return p+3\n    if n==5 then return p+4\n    if n==6 then return\
    \ p+5\n    if n==7 then return p+6\n    if n==8 then return p+7\n    if n==9 then\
    \ return p+8\n    if n==10 then return p+9\n    if n==11 then return p+10\n  \
    \  if n==12 then return p+11\n    if n==13 then return p+12\n    if n==14 then\
    \ return p+13\n    if n==15 then return p+14\n    if n==16 then return p+15\n\
    \    if n==17 then return p+16\n    if n==18 then return p+17\n    if n==19 then\
    \ return p+18\n    if n==20 then return p+19\n    if n==21 then return p+20\n\
    \    if n==22 then return p+21\n    if n==23 then return p+22\n    if n==24 then\
    \ return p+23\n    if n==25 then return p+24\n    if n==26 then return p+25\n\
    \    if n==27 then return p+26\n    if n==28 then return p+27\n    if n==29 then\
    \ return p+28\n    if n==30 then return p+29\n    if n==31 then return p+30\n\
    \    if n==32 then return p+31\n    if n==33 then return p+32\n    if n==34 then\
    \ return p+33\n    if n==35 then return p+34\n    if n==36 then return p+35\n\
    \    if n==37 then return p+36\n    if n==38 then return p+37\n    if n==39 then\
    \ return p+38\n    if n==40 then return p+39\n    if n==41 then return p+40\n\
    \    if n==42 then return p+41\n    if n==43 then return p+42\n    if n==44 then\
    \ return p+43\n    if n==45 then return p+44\n    if n==46 then return p+45\n\
    \    if n==47 then return p+46\n    if n==48 then return p+47\n    if n==49 then\
    \ return p+48\n    if n==50 then return p", "    if p == 0 \n        then return\
    \ 1\n    else if n == 0 \n        then return 0\n    else if p == 1 \n       \
    \ then return n\n    else \n        return modp(n / p, p) * p\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n == 0 \n        then return 1\n    else if n < 0\n        then return modp(abs(n),\
    \ p)\n    else if p == 0\n        then return 0\n    else if p < 0\n        then\
    \ return modp(n, abs(p))\n    else if p < n\n        then return modp(n, p)\n\
    \    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>", " \
    \   if n < 0 \n        error(\"modp requires n >= 0\")\n    else if p == 0 \n\
    \        error(\"modp requires p != 0\")\n    else if p == 1 \n        error(\"\
    modp requires p != 1\")\n    else if n == 0 \n        error(\"modp requires n\
    \ != 0\")\n    else if n == 1 \n        return p\n    else \n        return modp(n\
    \ - 1, p * p)\nend\n</cell>\n<code language=julia-1.5>", "    if p == 0 \n   \
    \     then return 0\n    else if p == 1 \n        then return n\n    else if n\
    \ <= p \n        then return modp(n - p, p)\n    else return modp(n - p, p - 1)\n\
    end\n</cell>\n<code language=julia-1.4>", "    if p == 0 \n        then return\
    \ 0\n    else if n == 0 \n        then return p\n    else \n        return modp(n\
    \ / p, p) * p\nend\n</cell>\n<code language=julia-1.4>", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return modp(2*n-1, p)\n    if\
    \ p==4 then return modp(3*n-1, p)\n    if p==5 then return modp(4*n-1, p)\n  \
    \  if p==6 then return modp(5*n-1, p)\n    if p==7 then return modp(6*n-1, p)\n\
    \    if p==8 then return modp(7*n-1, p)\n    if p==9 then return modp(8*n-1, p)\n\
    \    if p==10 then return modp(9*n-1, p)\n    if p==11 then return modp(10*n-1,\
    \ p)\n    if p==12 then return modp(11*n-1, p)\n    if p==13 then return modp(12*n-1,\
    \ p)\n    if p==14 then return modp(13*n-1, p)\n    if p==15 then return modp(14*n-1,\
    \ p)\n    if p==16 then return modp(15*n-1, p)\n    if p==17 then return modp(16*n-1,\
    \ p)\n    if p==18 then return modp(17*n-1, p)\n    if p==19 then return modp(18*n-1,\
    \ p)\n    if p==20 then return modp(19*n-1, p)\n    if p==21 then return modp(20*n-1,\
    \ p)\n    if p==22 then return modp(21*n-1, p)\n    if p==23 then return modp(22*n-1,\
    \ p)\n    if p==24 then return modp(23*n-1, p)\n    if p==25 then return modp(24*n-1,\
    \ p)\n    if p==26 then return modp(25*n-1, p)\n    if p==27 then return modp(26*n-1,\
    \ p)\n    if p==28 then return modp(27*n-1, p)\n    if p==29 then return modp(28*n-1,\
    \ p)\n    if p==30 then return modp(29*n-1, p)\n    if p==31 then return modp(30*n-1,\
    \ p)\n    if p==32 then return modp(31*n-1, p)\n    if p==33 then return modp(32*n-1,\
    \ p)\n    if p==34 then return modp(33*n-1, p)\n    if p==35 then return modp(34*n-1,\
    \ p)\n    if p==36 then return modp(35*n-1, p)\n    if p==37 then return modp(36*n-1,\
    \ p)\n    if p==38 then return modp(37*n-1, p)\n    if p", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return n+1\n    if p==4 then\
    \ return n*2\n    if p==5 then return n*3\n    if p==6 then return n*4\n    if\
    \ p==7 then return n*5\n    if p==8 then return n*6\n    if p==9 then return n*7\n\
    \    if p==10 then return n*8\n    if p==11 then return n*9\n    if p==12 then\
    \ return n*10\n    if p==13 then return n*11\n    if p==14 then return n*12\n\
    \    if p==15 then return n*13\n    if p==16 then return n*14\n    if p==17 then\
    \ return n*15\n    if p==18 then return n*16\n    if p==19 then return n*17\n\
    \    if p==20 then return n*18\n    if p==21 then return n*19\n    if p==22 then\
    \ return n*20\n    if p==23 then return n*21\n    if p==24 then return n*22\n\
    \    if p==25 then return n*23\n    if p==26 then return n*24\n    if p==27 then\
    \ return n*25\n    if p==28 then return n*26\n    if p==29 then return n*27\n\
    \    if p==30 then return n*28\n    if p==31 then return n*29\n    if p==32 then\
    \ return n*30\n    if p==33 then return n*31\n    if p==34 then return n*32\n\
    \    if p==35 then return n*33\n    if p==36 then return n*34\n    if p==37 then\
    \ return n*35\n    if p==38 then return n*36\n    if p==39 then return n*37\n\
    \    if p==40 then return n*38\n    if p==41 then return n*39\n    if p==42 then\
    \ return n*40\n    if p==43 then return n*41\n    if p==44 then return n*42\n\
    \    if p==45 then return n*43\n    if p==46 then return n*44\n    if p==47 then\
    \ return n*45\n    if p==48 then return n*46\n    if p==49 then return n*47\n\
    \    if p==50 then return n*48\n    if p==51 then return n*49\n    if p==52 then\
    \ return n*50\n    if p==53 then return n*51\n", "    if n <= 0\n    then return\
    \ 0\n    else if n <= p\n    then return 1\n    else return modp(n - 1, p) + modp(n,\
    \ p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \"\"\"", "    if p == 0 \n        then return 0\n    else if n <=\
    \ p \n        then return n\n    else \n        then return modp(n - p, p)\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n == 0 \n        then return 1\n\
    \    else if p == 0 \n        then return 0\n    else if p < 0 \n        then\
    \ return modp(abs(n), abs(p))\n    else if n < 0 \n        then return modp(-n,\
    \ abs(p))\n    else if n < p \n        then return modp(n, p)\n    else return\
    \ modp((n-p), p)\nend\n</cell>\n<code language=julia-1.5>", "    if n==0 \n  \
    \      then return 1\n    else if n==1 \n        then return p\n    else if p==0\
    \ \n        then return 0\n    else if p==1 \n        then return n\n    else\
    \ if p==2 \n        then return n*(n+1)\n    else if p==3 \n        then return\
    \ n*(n+1)*(n+2)\n    else if p==4 \n        then return n*(n+1)*(n+2)*(n+3)\n\
    \    else if p==5 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)\n    else if\
    \ p==6 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)\n    else if p==7\
    \ \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)\n    else if p==8\
    \ \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)*(n+7)\n    else\
    \ if p==9 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)*(n+7)*(n+8)\n\
    \    else if p==10 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)*(n+7)*(n+8)*(n+9)\n\
    \    else if p==11 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)*(n+7)*(n+8)*(n+9)*(n+10)\n\
    \    else if p==12 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)*(n+7)*(n+8)*(n+9)*(n+10)*(n+11)\n\
    \    else if p==13 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)*(n+7)*(n+8)*(n+9)*(n+10)*(n+11)*(n+12)\n\
    \    else if p==14 \n        then return n*(n+1)*(n+2)*(n+3)*(n+4)*(n+5)*(n+6)*(n+7)*(n+8)*(n+9)*(n+10)*(n+11)*(n+12",
  "    if n==0 || p==0 \n        then return 0\n    else if n==1\n        then return\
    \ p\n    else if p==1\n        then return 1\n    else if p==2\n        then return\
    \ n\n    else if n==p\n        then return n\n    else if n==p+1\n        then\
    \ return p\n    else if p==p+1\n        then return p\n    else if n==p+2\n  \
    \      then return p\n    else if n==p+3\n        then return p\n    else if n==p+4\n\
    \        then return p\n    else if n==p+5\n        then return p\n    else if\
    \ n==p+6\n        then return p\n    else if n==p+7\n        then return p\n \
    \   else if n==p+8\n        then return p\n    else if n==p+9\n        then return\
    \ p\n    else if n==p+10\n        then return p\n    else if n==p+11\n       \
    \ then return p\n    else if n==p+12\n        then return p\n    else if n==p+13\n\
    \        then return p\n    else if n==p+14\n        then return p\n    else if\
    \ n==p+15\n        then return p\n    else if n==p+16\n        then return p\n\
    \    else if n==p+17\n        then return p\n    else if n==p+18\n        then\
    \ return p\n    else if n==p+19\n        then return p\n    else if n==p+20\n\
    \        then return p\n    else if n==p+21\n        then return p\n    else if\
    \ n==p+22\n        then return p\n    else if n==p+23\n        then return p\n\
    \    else if n==p+24\n        then return p\n    else if n==p+25\n        then\
    \ return p\n    else if n==p+26\n        then return p\n    else if n==p+27\n\
    \        then return p\n    else if n==p+28\n        then return p\n    else if\
    \ n==p+29\n        then return p\n    else if n==p+30\n        then return p\n\
    \    else if n==p+31\n        then return p\n    else if n==", "    if n <= 0\n\
    \        error(\"n must be positive\")\n    else if p <= 0\n        error(\"p\
    \ must be positive\")\n    else if p > n\n        error(\"p must be <= n\")\n\
    \    else\n        return n%p\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\
    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>>\
    \ modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n \
    \   8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n <= 0\n        error(\"\
    modp: n must be positive\")\n    else if p <= 0\n        error(\"modp: p must\
    \ be positive\")\n    else if p > n\n        error(\"modp: p must be <= n\")\n\
    \    else\n        return modp(n - 1, p) % p\nend\n</cell>\n<code language=julia-1.1>",
  "    if n < 0 \n        error(\"modp() only works with positive numbers\")\n   \
    \ else if n < p \n        error(\"modp() only works with positive numbers\")\n\
    \    else if n == 0 \n        error(\"modp() only works with positive numbers\"\
    )\n    else \n        return n\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    The answer by is correct but does not work for negative numbers. Here is a version\
    \ that works for negative numbers:\n<code>", "    if n==0 \n        then return\
    \ 0\n    else if n==1 \n        then return p\n    else \n        modp(n / 2,\
    \ p) + p * modp(n / 2, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n\
    \ == 0 \n        then return p\n    else if p == 0 \n        then return 0\n \
    \   else if p == 1 \n        then return 1\n    else if p == 2 \n        then\
    \ return n\n    else if p < 0 \n        then return modp(n, -p)\n    else if p\
    \ > 0 \n        then return modp(n / p, p)\n    else return modp(n, -p)\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n == 0 \n        then return 1\n\
    \    else if p == 0 \n        then return 0\n    else if p < 0 \n        then\
    \ return modp(-n, -p) \n    else if n < 0 \n        then return modp(-n, p) \n\
    \    else if n < p \n        then return modp(n, p) \n    else return modp(n-1,\
    \ p) + modp(n-1, p-1)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your answer,\
    \ but I think it would be better to explain what it does and why it works.\n<|/\
    \ c |>\n<| c |>\nI added some explanation.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "    if n <= 0\n    then return 0\n    else if n <= p\n    then return n\n    else\
    \ return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"", "    if n==0 then return 1\n    else if\
    \ n==1 then return p\n    else return modp(n / p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n <= p \n  \
    \      then return n \n        else return modp(n - p, p)\n    else return 0\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"", "    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(n - 1, modp(n, p - 1)) + p\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    if n < 0 \n        error(\"modp requires positive\
    \ arguments\")\n    if p < 0 \n        error(\"modp requires positive arguments\"\
    )\n    if p > n \n        error(\"modp requires positive arguments\")\n    if\
    \ n == 0 \n        error(\"modp requires positive arguments\")\n    if p == 0\
    \ \n        error(\"modp requires positive arguments\")\n    if p == 1 \n    \
    \    return n\n    if p == 2 \n        return n\n    if p == 3 \n        return\
    \ n\n    if p == 4 \n        return n\n    if p == 5 \n        return n\n    if\
    \ p == 6 \n        return n\n    if p == 7 \n        return n\n    if p == 8 \n\
    \        return n\n    if p == 9 \n        return n\n    if p == 10 \n       \
    \ return n\n    if p == 11 \n        return n\n    if p == 12 \n        return\
    \ n\n    if p == 13 \n        return n\n    if p == 14 \n        return n\n  \
    \  if p == 15 \n        return n\n    if p == 16 \n        return n\n    if p\
    \ == 17 \n        return n\n    if p == 18 \n        return n\n    if p == 19\
    \ \n        return n\n    if p == 20 \n        return n\n    if p == 21 \n   \
    \     return n\n    if p == 22 \n        return n\n    if p == 23 \n        return\
    \ n\n    if p == 24 \n        return n\n    if p == 25 \n        return n\n  \
    \  if p == 26 \n        return n\n    if p == 27 \n        return n\n    if p\
    \ == 28 \n        return n\n    if p == 29 \n        return n\n    if p == 30\
    \ \n        return n\n    if p == 31 \n        return n\n    if p == 32 \n   \
    \     return n\n    if p == 33 \n        return n\n    if p == 34 \n        return\
    \ n\n    if p == 35 \n        return n\n    if p == 36 \n        return n\n  \
    \  if p == 37 \n        return n\n    if p == 38 \n        return n\n    if p\
    \ == 39 \n        return n\n    if p == 40 \n        return n\n    if p == 41\
    \ \n        return n\n    if p == 42 \n        return n\n    if p == 43 \n   \
    \     return n\n    if p == 44 \n        return n\n    if p == 45 \n        return\
    \ n\n    if p == 46 \n        return n\n    if p == 47 \n        return n\n  \
    \  if p == 48 \n        return n\n    if p == 49 \n        return n\n    if p\
    \ == 50 \n        return n\n    if p == 51 \n        return n\n    if p == 52\
    \ \n        return n\n    if p == 53 \n        return n\n    if p == 54 \n   \
    \     return n\n    if p == 55 \n        return n\n    if p == ", "    if n <=\
    \ p \n        then return n \n        else return modp(n - p, p)\n    end\nend\n\
    </cell>\n<code language=julia-1.4>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    if n==0 then return 1\n    if n==1 then return p\n    if p==0 then return 0\n\
    \    if p==1 then return 1\n    if p==2 then return n\n    if p==3 then return\
    \ n+1\n    if p==4 then return n+2\n    if p==5 then return n+3\n    if p==6 then\
    \ return n+4\n    if p==7 then return n+5\n    if p==8 then return n+6\n    if\
    \ p==9 then return n+7\n    if p==10 then return n+8\n    if p==11 then return\
    \ n+9\n    if p==12 then return n+10\n    if p==13 then return n+11\n    if p==14\
    \ then return n+12\n    if p==15 then return n+13\n    if p==16 then return n+14\n\
    \    if p==17 then return n+15\n    if p==18 then return n+16\n    if p==19 then\
    \ return n+17\n    if p==20 then return n+18\n    if p==21 then return n+19\n\
    \    if p==22 then return n+20\n    if p==23 then return n+21\n    if p==24 then\
    \ return n+22\n    if p==25 then return n+23\n    if p==26 then return n+24\n\
    \    if p==27 then return n+25\n    if p==28 then return n+26\n    if p==29 then\
    \ return n+27\n    if p==30 then return n+28\n    if p==31 then return n+29\n\
    \    if p==32 then return n+30\n    if p==33 then return n+31\n    if p==34 then\
    \ return n+32\n    if p==35 then return n+33\n    if p==36 then return n+34\n\
    \    if p==37 then return n+35\n    if p==38 then return n+36\n    if p==39 then\
    \ return n+37\n    if p==40 then return n+38\n    if p==41 then return n+39\n\
    \    if p==42 then return n+40\n    if p==43 then return n+41\n    if p==44 then\
    \ return n+42\n    if p==45 then return n+43\n    if p==46 then return n+44\n\
    \    if p==47 then return n+45\n    if p==48 then return n+46\n    if p==49",
  "    if n == 0 \n        then return p\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, -p) \n    else if p > 0\
    \ \n        then return modp(n, p) \n    else \n        modp(n / 2, p) + modp(n\
    \ / 2, p - 1)\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 then return\
    \ 1\n    if p == 0 then return 0\n    if p < 0 then return modp(abs(n), abs(p))\n\
    \    if p > n then return modp(abs(n), abs(p))\n    if n == p then return 0\n\
    \    if n < p then return modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n),\
    \ abs(p))\n    if n == 0 then return 1\n    if n == p then return 1\n    if n\
    \ == 0 then return 1\n    if n == p then return 1\n    if n < p then return modp(abs(n),\
    \ abs(p))\n    if n < 0 then return modp(abs(n), abs(p))\n    if n < p then return\
    \ modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n), abs(p))\n    if\
    \ n < p then return modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n),\
    \ abs(p))\n    if n < p then return modp(abs(n), abs(p))\n    if n < 0 then return\
    \ modp(abs(n), abs(p))\n    if n < p then return modp(abs(n), abs(p))\n    if\
    \ n < 0 then return modp(abs(n), abs(p))\n    if n < p then return modp(abs(n),\
    \ abs(p))\n    if n < 0 then return modp(abs(n), abs(p))\n    if n < p then return\
    \ modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n), abs(p))\n    if\
    \ n < p then return modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n),\
    \ abs(p))\n    if n < p then return modp(abs(n), abs(p))\n    if n < 0 then return\
    \ modp(abs(n), abs(p))\n    if n < p then return modp(abs(n), abs(p))\n    if\
    \ n < 0 then return modp(abs(n), abs(p))\n    if n < p then return modp(abs(n),\
    \ abs(p))\n    if n < 0 then return modp(abs(n), abs(p))\n    if n < p then return\
    \ modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n), abs(p))\n    if\
    \ n < p then return modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n),\
    \ abs(p))\n    if n < p then return modp(abs(n), abs(p))\n    if n < 0 then return\
    \ modp(abs(n), abs(p))\n    if n < p then return modp(abs(n), abs(p))\n    if\
    \ n < 0 then return modp(abs(n), abs(p))\n    if n < p then return modp(abs(n),\
    \ abs(p))\n    if n < 0 then return ", "    if n==0 then return 1 \n    else if\
    \ n==1 then return p \n    else if p==0 then return 0 \n    else if p==1 then\
    \ return 1 \n    else if p==2 then return n \n    else if p==3 then return n*n\
    \ \n    else if p==4 then return n*n*n \n    else if p==5 then return n*n*n*n\
    \ \n    else if p==6 then return n*n*n*n*n \n    else if p==7 then return n*n*n*n*n*n\
    \ \n    else if p==8 then return n*n*n*n*n*n*n \n    else if p==9 then return\
    \ n*n*n*n*n*n*n*n \n    else if p==10 then return n*n*n*n*n*n*n*n*n \n    else\
    \ if p==11 then return n*n*n*n*n*n*n*n*n*n \n    else if p==12 then return n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p==13 then return n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==14\
    \ then return n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==15 then return n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p==16 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==17\
    \ then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==18 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p==19 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==20\
    \ then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==21 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p==22 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if\
    \ p==23 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==24 then return\
    \ n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==25 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p", "    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n - p, p)\n    if p < n then return modp(n, p -\
    \ n)\n    return modp(n - p, p) + modp(n, p)\nend\n</cell>\n<code language=julia-1.5>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
