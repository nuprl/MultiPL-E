name: HumanEval_58_common
language: julia
results:
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 do \n        if !contains(common, el) \n            common = Set([el])\n\
    \        else \n            common = Set([el] ++ common)\n        end\n    end\n\
    \    \n    for el in l2 do \n        if !contains(common, el) \n            common\
    \ = Set([el])\n        else \n            common = Set([el] ++ common)\n     \
    \   end\n    end\n    \n    return common\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\nI wrote a Julia package called SetOps.jl that implements set\
    \ operations in Julia. Here are some examples:\n<code>\njulia> SetOps.union([1,2,3],\
    \ [2,3,4])\nSet([1,2,3,4])\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpj09gzh7_.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpj09gzh7_.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for elt in\
    \ l1 do \n        if elt in l2 \n            common = common + elt\n        end\n\
    \    end\n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpxx1_3lhm.jl:11\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpxx1_3lhm.jl:11\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@test\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n\
    @test common([5, 3, 2, 8], [3, 2]) == [2, 3]\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns the number of times each element appears in two vectors.\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp98_o0xtc.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp98_o0xtc.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7qau_lq0.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp7qau_lq0.jl:18\n   [2] top-level scope at /tmp/tmp7qau_lq0.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7qau_lq0.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp7qau_lq0.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp7qau_lq0.jl:18\n   [2] top-level scope at /tmp/tmp7qau_lq0.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7qau_lq0.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp7qau_lq0.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp7qau_lq0.jl:18\n   [2] top-level scope at /tmp/tmp7qau_lq0.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7qau_lq0.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp7qau_lq0.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp7qau_lq0.jl:18\n   [2] top-level scope at /tmp/tmp7qau_lq0.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7qau_lq0.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7qau_lq0.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnpxj6oc1.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnpxj6oc1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnpxj6oc1.jl:26\ntest set: Test Failed at /tmp/tmpnpxj6oc1.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpnpxj6oc1.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnpxj6oc1.jl:26\ntest set: Test Failed at /tmp/tmpnpxj6oc1.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpnpxj6oc1.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnpxj6oc1.jl:26\ntest set: Test Failed at /tmp/tmpnpxj6oc1.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpnpxj6oc1.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnpxj6oc1.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnpxj6oc1.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = Set([x] + common)\n    end\n    for x in l2 do \n    \
    \    common = Set([x] + common)\n    end\n    return common\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpsn00_x62.jl:11\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpsn00_x62.jl:11\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm70vwyon.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm70vwyon.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgr358sti.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgr358sti.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        push!(common, el)\n    end\n    \n    for el in l2\n     \
    \   push!(common, el)\n    end\n    \n    common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsvt6y2iz.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpsvt6y2iz.jl:20\n   [2] top-level scope at /tmp/tmpsvt6y2iz.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsvt6y2iz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpsvt6y2iz.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpsvt6y2iz.jl:20\n   [2] top-level scope at /tmp/tmpsvt6y2iz.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsvt6y2iz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpsvt6y2iz.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpsvt6y2iz.jl:20\n   [2] top-level scope at /tmp/tmpsvt6y2iz.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsvt6y2iz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpsvt6y2iz.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpsvt6y2iz.jl:20\n   [2] top-level scope at /tmp/tmpsvt6y2iz.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsvt6y2iz.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsvt6y2iz.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa20i53cz.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n   \
    \ sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpa20i53cz.jl:20\n   [2] top-level scope at /tmp/tmpa20i53cz.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa20i53cz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpa20i53cz.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpa20i53cz.jl:20\n   [2] top-level scope at /tmp/tmpa20i53cz.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa20i53cz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpa20i53cz.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpa20i53cz.jl:20\n   [2] top-level scope at /tmp/tmpa20i53cz.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa20i53cz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpa20i53cz.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at range.jl:969\n    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpa20i53cz.jl:20\n   [2] top-level scope at /tmp/tmpa20i53cz.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa20i53cz.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa20i53cz.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_ia6crbh.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_ia6crbh.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        if !contains(common, el)\n            common = Set([el])\n\
    \        else\n            common = Set([el] ++ common)\n        end\n    end\n\
    \    \n    for el in l2\n        if !contains(common, el)\n            common\
    \ = Set([el])\n        else\n            common = Set([el] ++ common)\n      \
    \  end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgh7gokua.jl:35\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: contains not defined\n  Stacktrace:\n   [1]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgh7gokua.jl:13\n   [2]\
    \ top-level scope at /tmp/tmpgh7gokua.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgh7gokua.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpgh7gokua.jl:36\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgh7gokua.jl:13\n\
    \   [2] top-level scope at /tmp/tmpgh7gokua.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgh7gokua.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpgh7gokua.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: contains not defined\n \
    \ Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgh7gokua.jl:13\n\
    \   [2] top-level scope at /tmp/tmpgh7gokua.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgh7gokua.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpgh7gokua.jl:38\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpgh7gokua.jl:13\n   [2] top-level scope at /tmp/tmpgh7gokua.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgh7gokua.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgh7gokua.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl8d5y3gm.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl8d5y3gm.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_yvgqifb.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp_yvgqifb.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp_yvgqifb.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7jov14wp.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7jov14wp.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr9o6ekk3.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n   \
    \ sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpr9o6ekk3.jl:18\n   [2] top-level scope at /tmp/tmpr9o6ekk3.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9o6ekk3.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpr9o6ekk3.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpr9o6ekk3.jl:18\n   [2] top-level scope at /tmp/tmpr9o6ekk3.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9o6ekk3.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpr9o6ekk3.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpr9o6ekk3.jl:18\n   [2] top-level scope at /tmp/tmpr9o6ekk3.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9o6ekk3.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpr9o6ekk3.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at range.jl:969\n    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpr9o6ekk3.jl:18\n   [2] top-level scope at /tmp/tmpr9o6ekk3.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9o6ekk3.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr9o6ekk3.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpezkr6i4d.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpezkr6i4d.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_kelsij4.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_kelsij4.jl:20\n   [2] top-level scope at /tmp/tmp_kelsij4.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_kelsij4.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp_kelsij4.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_kelsij4.jl:20\n   [2] top-level scope at /tmp/tmp_kelsij4.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_kelsij4.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp_kelsij4.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_kelsij4.jl:20\n   [2] top-level scope at /tmp/tmp_kelsij4.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_kelsij4.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp_kelsij4.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_kelsij4.jl:20\n   [2] top-level scope at /tmp/tmp_kelsij4.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_kelsij4.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_kelsij4.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsv9lburo.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsv9lburo.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpino734wd.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpino734wd.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptubmph8a.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptubmph8a.jl:17\n   [2] top-level scope at /tmp/tmptubmph8a.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptubmph8a.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmptubmph8a.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptubmph8a.jl:17\n   [2] top-level scope at /tmp/tmptubmph8a.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptubmph8a.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmptubmph8a.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptubmph8a.jl:17\n   [2] top-level scope at /tmp/tmptubmph8a.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptubmph8a.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmptubmph8a.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptubmph8a.jl:17\n   [2] top-level scope at /tmp/tmptubmph8a.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptubmph8a.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptubmph8a.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if !contains(common, x)\n            push!(common, x)\n   \
    \     end\n    end\n    \n    for x in l2\n        if !contains(common, x)\n \
    \           push!(common, x)\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp8jdexdgs.jl:31\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: contains not defined\n  Stacktrace:\n   [1]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp8jdexdgs.jl:13\n   [2]\
    \ top-level scope at /tmp/tmp8jdexdgs.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8jdexdgs.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp8jdexdgs.jl:32\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp8jdexdgs.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8jdexdgs.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8jdexdgs.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp8jdexdgs.jl:33\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: contains not defined\n \
    \ Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp8jdexdgs.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8jdexdgs.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8jdexdgs.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp8jdexdgs.jl:34\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp8jdexdgs.jl:13\n   [2] top-level scope at /tmp/tmp8jdexdgs.jl:34\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8jdexdgs.jl:30\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8jdexdgs.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ elt in l1 do \n        if elt in l2 \n            common = union(common, elt)\n\
    \        end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpio24uznl.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpio24uznl.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n                break\n            else\n                common\
    \ = Set([a]) & common\n        end\n    end\n    \n    return common\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpked2lnkh.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpked2lnkh.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpked2lnkh.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2z83q576.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp2z83q576.jl:18\n   [2] top-level scope at /tmp/tmp2z83q576.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2z83q576.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp2z83q576.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp2z83q576.jl:18\n   [2] top-level scope at /tmp/tmp2z83q576.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2z83q576.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp2z83q576.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp2z83q576.jl:18\n   [2] top-level scope at /tmp/tmp2z83q576.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2z83q576.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp2z83q576.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp2z83q576.jl:18\n   [2] top-level scope at /tmp/tmp2z83q576.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2z83q576.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2z83q576.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd2gv8_48.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpd2gv8_48.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2gv8_48.jl:24\ntest set: Test Failed at /tmp/tmpd2gv8_48.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpd2gv8_48.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2gv8_48.jl:24\ntest set: Test Failed at /tmp/tmpd2gv8_48.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpd2gv8_48.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2gv8_48.jl:24\ntest set: Test Failed at /tmp/tmpd2gv8_48.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpd2gv8_48.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2gv8_48.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd2gv8_48.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdxe_ahwm.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Int64}\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpdxe_ahwm.jl:12\n   [2] top-level scope at /tmp/tmpdxe_ahwm.jl:19\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxe_ahwm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdxe_ahwm.jl:20\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpdxe_ahwm.jl:12\n   [2] top-level scope at /tmp/tmpdxe_ahwm.jl:20\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxe_ahwm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdxe_ahwm.jl:21\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpdxe_ahwm.jl:12\n   [2] top-level scope at /tmp/tmpdxe_ahwm.jl:21\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxe_ahwm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdxe_ahwm.jl:22\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Int64} to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpdxe_ahwm.jl:12\n   [2] top-level scope at /tmp/tmpdxe_ahwm.jl:22\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxe_ahwm.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdxe_ahwm.jl:16\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwf5d2m4_.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwf5d2m4_.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwf5d2m4_.jl:26\ntest set: Test Failed at /tmp/tmpwf5d2m4_.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpwf5d2m4_.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwf5d2m4_.jl:26\ntest set: Test Failed at /tmp/tmpwf5d2m4_.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpwf5d2m4_.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwf5d2m4_.jl:26\ntest set: Test Failed at /tmp/tmpwf5d2m4_.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpwf5d2m4_.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwf5d2m4_.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwf5d2m4_.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4jpls6ln.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4jpls6ln.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4jpls6ln.jl:24\ntest set: Test Failed at /tmp/tmp4jpls6ln.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp4jpls6ln.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4jpls6ln.jl:24\ntest set: Test Failed at /tmp/tmp4jpls6ln.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp4jpls6ln.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4jpls6ln.jl:24\ntest set: Test Failed at /tmp/tmp4jpls6ln.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp4jpls6ln.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4jpls6ln.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4jpls6ln.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps42ugxw1.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmps42ugxw1.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmps42ugxw1.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        common = Set([el]) | common\n    end\n    \n    for el in\
    \ l2\n        common = Set([el]) | common\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn2n4ygnv.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn2n4ygnv.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in common\n            continue\n        push!(common,\
    \ x)\n    end\n    \n    for x in l2\n        if x in common\n            continue\n\
    \        push!(common, x)\n    end\n    \n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmptk2xn3wr.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmptk2xn3wr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmptk2xn3wr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if !contains(common, x)\n            push!(common, x)\n   \
    \     end\n    end\n    \n    for x in l2\n        if !contains(common, x)\n \
    \           push!(common, x)\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpe1a2cyt5.jl:31\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: contains not defined\n  Stacktrace:\n   [1]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpe1a2cyt5.jl:13\n   [2]\
    \ top-level scope at /tmp/tmpe1a2cyt5.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe1a2cyt5.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmpe1a2cyt5.jl:32\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpe1a2cyt5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe1a2cyt5.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe1a2cyt5.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmpe1a2cyt5.jl:33\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: contains not defined\n \
    \ Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpe1a2cyt5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe1a2cyt5.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe1a2cyt5.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmpe1a2cyt5.jl:34\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpe1a2cyt5.jl:13\n   [2] top-level scope at /tmp/tmpe1a2cyt5.jl:34\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe1a2cyt5.jl:30\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe1a2cyt5.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common = Set([a])\n\
    \                break\n        end\n    end\n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpooou20x0.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpooou20x0.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpooou20x0.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        push!(common, x)\n    end\n    \n    for x in l2 do \n\
    \        push!(common, x)\n    end\n    \n    return sort(common)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4b_4zsu2.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmp4b_4zsu2.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common.add(a)\n \
    \           end\n        end\n    end\n    return common\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmph6bveid2.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmph6bveid2.jl:14\n   [3] top-level scope at /tmp/tmph6bveid2.jl:25\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmph6bveid2.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmph6bveid2.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmph6bveid2.jl:14\n   [3] top-level scope at /tmp/tmph6bveid2.jl:26\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmph6bveid2.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmph6bveid2.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmph6bveid2.jl:14\n   [3] top-level scope at /tmp/tmph6bveid2.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmph6bveid2.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmph6bveid2.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmph6bveid2.jl:18\n   [2] top-level scope at /tmp/tmph6bveid2.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph6bveid2.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph6bveid2.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common.add(a)\n\
    \            end\n        end\n    end\n    \n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpgkn0xmm0.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpgkn0xmm0.jl:15\n   [3] top-level scope at /tmp/tmpgkn0xmm0.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpgkn0xmm0.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpgkn0xmm0.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpgkn0xmm0.jl:15\n   [3] top-level scope at /tmp/tmpgkn0xmm0.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpgkn0xmm0.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpgkn0xmm0.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpgkn0xmm0.jl:15\n   [3] top-level scope at /tmp/tmpgkn0xmm0.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpgkn0xmm0.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpgkn0xmm0.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgkn0xmm0.jl:20\n   [2] top-level scope at /tmp/tmpgkn0xmm0.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgkn0xmm0.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgkn0xmm0.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el1 in l1\n        for el2 in l2\n            if el1 == el2\n              \
    \  common = Set([el1])\n            else\n                common = Set([el1])\
    \ \u222A common\n            end\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpm7nqjevn.jl:29\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Int64}\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpm7nqjevn.jl:22\n   [2] top-level scope at /tmp/tmpm7nqjevn.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm7nqjevn.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpm7nqjevn.jl:30\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpm7nqjevn.jl:22\n   [2] top-level scope at /tmp/tmpm7nqjevn.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm7nqjevn.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpm7nqjevn.jl:31\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpm7nqjevn.jl:22\n   [2] top-level scope at /tmp/tmpm7nqjevn.jl:31\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm7nqjevn.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpm7nqjevn.jl:32\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpm7nqjevn.jl:22\n   [2] top-level scope at /tmp/tmpm7nqjevn.jl:32\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm7nqjevn.jl:28\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm7nqjevn.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5,\
    \ 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2,\
    \ 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8],\
    \ [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8], [3,\
    \ 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n\
    </cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n\
    <code language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5,\
    \ 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2,\
    \ 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8],\
    \ [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8], [3,\
    \ 2])\n</cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n\
    </cell>\n<code language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n\
    <code language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time common([5,\
    \ 3, 2, 8], [3, 2])\n</cell>\n<code language=\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4_abh1bm.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4_abh1bm.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 \n        common = Set([el] + common)\n    end\n    \n    for el in\
    \ l2 \n        common = Set([el] + common)\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg14vjczv.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg14vjczv.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpd4u97ws9.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpd4u97ws9.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpd4u97ws9.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for el in\
    \ l1\n        common = Set([el]) & common\n    end\n    for el in l2\n       \
    \ common = Set([el]) & common\n    end\n    return common\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpj0t1tp04.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching &(::Set{Int64}, ::Set{Any})\n\
    \  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpj0t1tp04.jl:12\n   [2] top-level scope at /tmp/tmpj0t1tp04.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj0t1tp04.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpj0t1tp04.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching &(::Set{Int64},\
    \ ::Set{Any})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpj0t1tp04.jl:12\n   [2] top-level scope at /tmp/tmpj0t1tp04.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj0t1tp04.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpj0t1tp04.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching &(::Set{Int64},\
    \ ::Set{Any})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpj0t1tp04.jl:12\n   [2] top-level scope at /tmp/tmpj0t1tp04.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj0t1tp04.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpj0t1tp04.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching &(::Set{Int64}, ::Set{Any})\n  Closest candidates are:\n    &(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpj0t1tp04.jl:12\n\
    \   [2] top-level scope at /tmp/tmpj0t1tp04.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj0t1tp04.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj0t1tp04.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for el in\
    \ l1\n        common = Set([el] + common)\n    end\n    for el in l2\n       \
    \ common = Set([el] + common)\n    end\n    return common\nend\n</cell>\n<code\
    \ language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyic0eapm.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpyic0eapm.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7fsqaa45.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7fsqaa45.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg280876e.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpg280876e.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg280876e.jl:24\ntest set: Test Failed at /tmp/tmpg280876e.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpg280876e.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg280876e.jl:24\ntest set: Test Failed at /tmp/tmpg280876e.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpg280876e.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg280876e.jl:24\ntest set: Test Failed at /tmp/tmpg280876e.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpg280876e.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg280876e.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg280876e.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ elt in l1 \n        if elt in l2 \n            common = common.add!(elt)\n \
    \       end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqapkfzfn.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add!\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpqapkfzfn.jl:14\n   [3] top-level scope at /tmp/tmpqapkfzfn.jl:25\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpqapkfzfn.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpqapkfzfn.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add!\n  Stacktrace:\n \
    \  [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpqapkfzfn.jl:14\n   [3] top-level scope at /tmp/tmpqapkfzfn.jl:26\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpqapkfzfn.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpqapkfzfn.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add!\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpqapkfzfn.jl:14\n   [3] top-level scope at /tmp/tmpqapkfzfn.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpqapkfzfn.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpqapkfzfn.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqapkfzfn.jl:18\n   [2] top-level scope at /tmp/tmpqapkfzfn.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqapkfzfn.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqapkfzfn.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzktbbduq.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzktbbduq.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzktbbduq.jl:26\ntest set: Test Failed at /tmp/tmpzktbbduq.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpzktbbduq.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzktbbduq.jl:26\ntest set: Test Failed at /tmp/tmpzktbbduq.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpzktbbduq.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzktbbduq.jl:26\ntest set: Test Failed at /tmp/tmpzktbbduq.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpzktbbduq.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzktbbduq.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzktbbduq.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkwvl4f39.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkwvl4f39.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7nsj6ckw.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp7nsj6ckw.jl:13\n   [3] top-level scope at /tmp/tmp7nsj6ckw.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7nsj6ckw.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp7nsj6ckw.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp7nsj6ckw.jl:13\n   [3] top-level scope at /tmp/tmp7nsj6ckw.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7nsj6ckw.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp7nsj6ckw.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp7nsj6ckw.jl:13\n   [3] top-level scope at /tmp/tmp7nsj6ckw.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7nsj6ckw.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp7nsj6ckw.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp7nsj6ckw.jl:13\n   [3]\
    \ top-level scope at /tmp/tmp7nsj6ckw.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7nsj6ckw.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7nsj6ckw.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el1 in l1\n        for el2 in l2\n            if el1 == el2\n              \
    \  common = Set([el1])\n                break\n        end\n    end\n    \n  \
    \  return common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxxiwmlvp.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxxiwmlvp.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for elt in\
    \ l1 do \n        common = common & Set(elt)\n    end\n    for elt in l2 do \n\
    \        common = common & Set(elt)\n    end\n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdlg_kpq7.jl:11\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpdlg_kpq7.jl:11\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common.add(a)\n\
    \            end\n        end\n    end\n    \n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpms26fmh5.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpms26fmh5.jl:15\n   [3] top-level scope at /tmp/tmpms26fmh5.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpms26fmh5.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpms26fmh5.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpms26fmh5.jl:15\n   [3] top-level scope at /tmp/tmpms26fmh5.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpms26fmh5.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpms26fmh5.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpms26fmh5.jl:15\n   [3] top-level scope at /tmp/tmpms26fmh5.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpms26fmh5.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpms26fmh5.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpms26fmh5.jl:20\n   [2] top-level scope at /tmp/tmpms26fmh5.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpms26fmh5.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpms26fmh5.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: expected \"]\"\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpohkef3by.jl:51\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpohkef3by.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfwk510fc.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfwk510fc.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfwk510fc.jl:24\ntest set: Test Failed at /tmp/tmpfwk510fc.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpfwk510fc.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfwk510fc.jl:24\ntest set: Test Failed at /tmp/tmpfwk510fc.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpfwk510fc.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfwk510fc.jl:24\ntest set: Test Failed at /tmp/tmpfwk510fc.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpfwk510fc.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfwk510fc.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfwk510fc.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpt0nrakkw.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpt0nrakkw.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpt0nrakkw.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        common = Set([el]) & common\n    end\n    \n    for el in\
    \ l2\n        common = Set([el]) & common\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp6av2juaz.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching &(::Set{Int64}, ::Set{Any})\n\
    \  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp6av2juaz.jl:13\n   [2] top-level scope at /tmp/tmp6av2juaz.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6av2juaz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6av2juaz.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching &(::Set{Int64},\
    \ ::Set{Any})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp6av2juaz.jl:13\n   [2] top-level scope at /tmp/tmp6av2juaz.jl:28\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6av2juaz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6av2juaz.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching &(::Set{Int64},\
    \ ::Set{Any})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp6av2juaz.jl:13\n   [2] top-level scope at /tmp/tmp6av2juaz.jl:29\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6av2juaz.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6av2juaz.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching &(::Set{Int64}, ::Set{Any})\n  Closest candidates are:\n    &(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp6av2juaz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6av2juaz.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6av2juaz.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6av2juaz.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxul4zl0t.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpxul4zl0t.jl:17\n   [2] top-level scope at /tmp/tmpxul4zl0t.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxul4zl0t.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpxul4zl0t.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpxul4zl0t.jl:17\n   [2] top-level scope at /tmp/tmpxul4zl0t.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxul4zl0t.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpxul4zl0t.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpxul4zl0t.jl:17\n   [2] top-level scope at /tmp/tmpxul4zl0t.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxul4zl0t.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpxul4zl0t.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpxul4zl0t.jl:17\n   [2] top-level scope at /tmp/tmpxul4zl0t.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxul4zl0t.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxul4zl0t.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp60t8nf7c.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp60t8nf7c.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp60t8nf7c.jl:24\ntest set: Test Failed at /tmp/tmp60t8nf7c.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp60t8nf7c.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp60t8nf7c.jl:24\ntest set: Test Failed at /tmp/tmp60t8nf7c.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp60t8nf7c.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp60t8nf7c.jl:24\ntest set: Test Failed at /tmp/tmp60t8nf7c.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp60t8nf7c.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp60t8nf7c.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp60t8nf7c.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6yq_tmxc.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp6yq_tmxc.jl:18\n   [2] top-level scope at /tmp/tmp6yq_tmxc.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6yq_tmxc.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp6yq_tmxc.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp6yq_tmxc.jl:18\n   [2] top-level scope at /tmp/tmp6yq_tmxc.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6yq_tmxc.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp6yq_tmxc.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp6yq_tmxc.jl:18\n   [2] top-level scope at /tmp/tmp6yq_tmxc.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6yq_tmxc.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp6yq_tmxc.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp6yq_tmxc.jl:18\n   [2] top-level scope at /tmp/tmp6yq_tmxc.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6yq_tmxc.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6yq_tmxc.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in l2\n            common.add(x)\n        end\n    end\n\
    \    \n    return common\nend\n</cell>\n<text>\nThe function above is called common()\
    \ because it is short for common elements. It is also called a set because it\
    \ is used to store unique elements. A set is like a list but does not allow duplicates.\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi8tsui6h.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi8tsui6h.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpoiwbkwbs.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpoiwbkwbs.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpoiwbkwbs.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for elt in\
    \ l1 \n        if elt in l2 \n            common = union(common, elt)\n      \
    \  end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpv9tcmkic.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpv9tcmkic.jl:17\n   [2] top-level scope at /tmp/tmpv9tcmkic.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv9tcmkic.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpv9tcmkic.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpv9tcmkic.jl:17\n   [2] top-level scope at /tmp/tmpv9tcmkic.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv9tcmkic.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpv9tcmkic.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpv9tcmkic.jl:17\n   [2] top-level scope at /tmp/tmpv9tcmkic.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv9tcmkic.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpv9tcmkic.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpv9tcmkic.jl:17\n   [2] top-level scope at /tmp/tmpv9tcmkic.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv9tcmkic.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv9tcmkic.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp93mml24t.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp93mml24t.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqky9hpdy.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqky9hpdy.jl:20\n   [2] top-level scope at /tmp/tmpqky9hpdy.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqky9hpdy.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpqky9hpdy.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqky9hpdy.jl:20\n   [2] top-level scope at /tmp/tmpqky9hpdy.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqky9hpdy.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpqky9hpdy.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqky9hpdy.jl:20\n   [2] top-level scope at /tmp/tmpqky9hpdy.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqky9hpdy.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpqky9hpdy.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqky9hpdy.jl:20\n   [2] top-level scope at /tmp/tmpqky9hpdy.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqky9hpdy.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqky9hpdy.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ elt in l1 \n        if elt in l2 \n            common = union(common, elt)\n\
    \        end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwevg26p8.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpwevg26p8.jl:18\n   [2] top-level scope at /tmp/tmpwevg26p8.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwevg26p8.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpwevg26p8.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpwevg26p8.jl:18\n   [2] top-level scope at /tmp/tmpwevg26p8.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwevg26p8.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpwevg26p8.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpwevg26p8.jl:18\n   [2] top-level scope at /tmp/tmpwevg26p8.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwevg26p8.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpwevg26p8.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpwevg26p8.jl:18\n   [2] top-level scope at /tmp/tmpwevg26p8.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwevg26p8.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwevg26p8.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5nngfsy3.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5nngfsy3.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcedacurl.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpcedacurl.jl:17\n   [2] top-level scope at /tmp/tmpcedacurl.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcedacurl.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpcedacurl.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpcedacurl.jl:17\n   [2] top-level scope at /tmp/tmpcedacurl.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcedacurl.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpcedacurl.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpcedacurl.jl:17\n   [2] top-level scope at /tmp/tmpcedacurl.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcedacurl.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpcedacurl.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpcedacurl.jl:17\n   [2] top-level scope at /tmp/tmpcedacurl.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcedacurl.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcedacurl.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        if !contains(common, el)\n            common = Set([el])\n\
    \        end\n    end\n    \n    for el in l2\n        if !contains(common, el)\n\
    \            common = Set([el])\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp81_9v4ap.jl:31\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: contains not defined\n  Stacktrace:\n   [1]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp81_9v4ap.jl:13\n   [2]\
    \ top-level scope at /tmp/tmp81_9v4ap.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp81_9v4ap.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp81_9v4ap.jl:32\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp81_9v4ap.jl:13\n\
    \   [2] top-level scope at /tmp/tmp81_9v4ap.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp81_9v4ap.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp81_9v4ap.jl:33\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: contains not defined\n \
    \ Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp81_9v4ap.jl:13\n\
    \   [2] top-level scope at /tmp/tmp81_9v4ap.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp81_9v4ap.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp81_9v4ap.jl:34\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp81_9v4ap.jl:13\n   [2] top-level scope at /tmp/tmp81_9v4ap.jl:34\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp81_9v4ap.jl:30\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp81_9v4ap.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl7ed64l8.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpl7ed64l8.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl7ed64l8.jl:24\ntest set: Test Failed at /tmp/tmpl7ed64l8.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpl7ed64l8.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl7ed64l8.jl:24\ntest set: Test Failed at /tmp/tmpl7ed64l8.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpl7ed64l8.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl7ed64l8.jl:24\ntest set: Test Failed at /tmp/tmpl7ed64l8.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpl7ed64l8.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl7ed64l8.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl7ed64l8.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_yrrltzq.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_yrrltzq.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1ksjty6d.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1ksjty6d.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1ksjty6d.jl:24\ntest set: Test Failed at /tmp/tmp1ksjty6d.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp1ksjty6d.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1ksjty6d.jl:24\ntest set: Test Failed at /tmp/tmp1ksjty6d.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp1ksjty6d.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1ksjty6d.jl:24\ntest set: Test Failed at /tmp/tmp1ksjty6d.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp1ksjty6d.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1ksjty6d.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1ksjty6d.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgqlmutbx.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgqlmutbx.jl:20\n   [2] top-level scope at /tmp/tmpgqlmutbx.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgqlmutbx.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpgqlmutbx.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgqlmutbx.jl:20\n   [2] top-level scope at /tmp/tmpgqlmutbx.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgqlmutbx.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpgqlmutbx.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgqlmutbx.jl:20\n   [2] top-level scope at /tmp/tmpgqlmutbx.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgqlmutbx.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpgqlmutbx.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgqlmutbx.jl:20\n   [2] top-level scope at /tmp/tmpgqlmutbx.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgqlmutbx.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgqlmutbx.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 do \n        common = Set([el] + common)\n    end\n    \n    for el\
    \ in l2 do \n        common = Set([el] + common)\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpez427fo6.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpez427fo6.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common.add(a)\n \
    \           end\n        end\n    end\n    return common\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp2x7t2agw.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp2x7t2agw.jl:14\n   [3] top-level scope at /tmp/tmp2x7t2agw.jl:25\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2x7t2agw.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp2x7t2agw.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp2x7t2agw.jl:14\n   [3] top-level scope at /tmp/tmp2x7t2agw.jl:26\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2x7t2agw.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp2x7t2agw.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp2x7t2agw.jl:14\n   [3] top-level scope at /tmp/tmp2x7t2agw.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2x7t2agw.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp2x7t2agw.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp2x7t2agw.jl:18\n   [2] top-level scope at /tmp/tmp2x7t2agw.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2x7t2agw.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2x7t2agw.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5x8s7zgn.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5x8s7zgn.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5x8s7zgn.jl:24\ntest set: Test Failed at /tmp/tmp5x8s7zgn.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp5x8s7zgn.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5x8s7zgn.jl:24\ntest set: Test Failed at /tmp/tmp5x8s7zgn.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp5x8s7zgn.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5x8s7zgn.jl:24\ntest set: Test Failed at /tmp/tmp5x8s7zgn.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp5x8s7zgn.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5x8s7zgn.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5x8s7zgn.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n            else\n                common = Set([a] ++ common)\n\
    \        end\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeooj3tul.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeooj3tul.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvkbq4jey.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpvkbq4jey.jl:20\n   [2] top-level scope at /tmp/tmpvkbq4jey.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkbq4jey.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpvkbq4jey.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpvkbq4jey.jl:20\n   [2] top-level scope at /tmp/tmpvkbq4jey.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkbq4jey.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpvkbq4jey.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpvkbq4jey.jl:20\n   [2] top-level scope at /tmp/tmpvkbq4jey.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkbq4jey.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpvkbq4jey.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpvkbq4jey.jl:20\n   [2] top-level scope at /tmp/tmpvkbq4jey.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkbq4jey.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvkbq4jey.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp162lfcnq.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp162lfcnq.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp162lfcnq.jl:26\ntest set: Test Failed at /tmp/tmp162lfcnq.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp162lfcnq.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp162lfcnq.jl:26\ntest set: Test Failed at /tmp/tmp162lfcnq.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp162lfcnq.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp162lfcnq.jl:26\ntest set: Test Failed at /tmp/tmp162lfcnq.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp162lfcnq.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp162lfcnq.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp162lfcnq.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ \n        push!(common, x)\n    end\n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcikl5h5h.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcikl5h5h.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjkn5vnvp.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjkn5vnvp.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_qn_p1xw.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_qn_p1xw.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_qn_p1xw.jl:24\ntest set: Test Failed at /tmp/tmp_qn_p1xw.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp_qn_p1xw.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_qn_p1xw.jl:24\ntest set: Test Failed at /tmp/tmp_qn_p1xw.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp_qn_p1xw.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_qn_p1xw.jl:24\ntest set: Test Failed at /tmp/tmp_qn_p1xw.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp_qn_p1xw.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_qn_p1xw.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_qn_p1xw.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprbd8ufbt.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmprbd8ufbt.jl:17\n   [2] top-level scope at /tmp/tmprbd8ufbt.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprbd8ufbt.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmprbd8ufbt.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmprbd8ufbt.jl:17\n   [2] top-level scope at /tmp/tmprbd8ufbt.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprbd8ufbt.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmprbd8ufbt.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmprbd8ufbt.jl:17\n   [2] top-level scope at /tmp/tmprbd8ufbt.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprbd8ufbt.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmprbd8ufbt.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmprbd8ufbt.jl:17\n   [2] top-level scope at /tmp/tmprbd8ufbt.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprbd8ufbt.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprbd8ufbt.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptlmszz_u.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptlmszz_u.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n@time common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code language=julia-1.5>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the number of unique elements in a given vector. \nWrite a function\
    \ that returns the \nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq29rblea.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq29rblea.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp89sh32ai.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp89sh32ai.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp89sh32ai.jl:26\ntest set: Test Failed at /tmp/tmp89sh32ai.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp89sh32ai.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp89sh32ai.jl:26\ntest set: Test Failed at /tmp/tmp89sh32ai.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp89sh32ai.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp89sh32ai.jl:26\ntest set: Test Failed at /tmp/tmp89sh32ai.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp89sh32ai.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp89sh32ai.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp89sh32ai.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    @test common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n\
    @test common([5, 3, 2, 8], [3, 2]) == [2, 3]\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of times each element appears in two vectors.\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpaw1gk62z.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpaw1gk62z.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw9l46xmm.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpw9l46xmm.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9l46xmm.jl:26\ntest set: Test Failed at /tmp/tmpw9l46xmm.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpw9l46xmm.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9l46xmm.jl:26\ntest set: Test Failed at /tmp/tmpw9l46xmm.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpw9l46xmm.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9l46xmm.jl:26\ntest set: Test Failed at /tmp/tmpw9l46xmm.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpw9l46xmm.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9l46xmm.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw9l46xmm.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common.add(x)\n    end\n    for x in l2\n        common.add(x)\n    end\n\
    \    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsn9bif4j.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsn9bif4j.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        for j in l2\n            if i == j\n                common\
    \ = Set([i, j])\n            end\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpt3obii62.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Int64}\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt3obii62.jl:20\n   [2] top-level scope at /tmp/tmpt3obii62.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt3obii62.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpt3obii62.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt3obii62.jl:20\n   [2] top-level scope at /tmp/tmpt3obii62.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt3obii62.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpt3obii62.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt3obii62.jl:20\n   [2] top-level scope at /tmp/tmpt3obii62.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt3obii62.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpt3obii62.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt3obii62.jl:20\n   [2] top-level scope at /tmp/tmpt3obii62.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt3obii62.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt3obii62.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqaus4h8s.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqaus4h8s.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpapo2o9yi.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpapo2o9yi.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpapo2o9yi.jl:26\ntest set: Test Failed at /tmp/tmpapo2o9yi.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpapo2o9yi.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpapo2o9yi.jl:26\ntest set: Test Failed at /tmp/tmpapo2o9yi.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpapo2o9yi.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpapo2o9yi.jl:26\ntest set: Test Failed at /tmp/tmpapo2o9yi.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpapo2o9yi.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpapo2o9yi.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpapo2o9yi.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplbwqvor3.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplbwqvor3.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppg9vzsl3.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmppg9vzsl3.jl:12\n   [2] top-level scope at /tmp/tmppg9vzsl3.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppg9vzsl3.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmppg9vzsl3.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmppg9vzsl3.jl:12\n\
    \   [2] top-level scope at /tmp/tmppg9vzsl3.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppg9vzsl3.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmppg9vzsl3.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmppg9vzsl3.jl:12\n\
    \   [2] top-level scope at /tmp/tmppg9vzsl3.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppg9vzsl3.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmppg9vzsl3.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmppg9vzsl3.jl:12\n\
    \   [2] top-level scope at /tmp/tmppg9vzsl3.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppg9vzsl3.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppg9vzsl3.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3cy1my33.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3cy1my33.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3cy1my33.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ elt in l1 \n        if elt in l2 \n            common = union(common, elt)\n\
    \        end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq4e5f6zy.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpq4e5f6zy.jl:18\n   [2] top-level scope at /tmp/tmpq4e5f6zy.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq4e5f6zy.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpq4e5f6zy.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpq4e5f6zy.jl:18\n   [2] top-level scope at /tmp/tmpq4e5f6zy.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq4e5f6zy.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpq4e5f6zy.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpq4e5f6zy.jl:18\n   [2] top-level scope at /tmp/tmpq4e5f6zy.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq4e5f6zy.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpq4e5f6zy.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpq4e5f6zy.jl:18\n   [2] top-level scope at /tmp/tmpq4e5f6zy.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq4e5f6zy.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq4e5f6zy.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ \u222A l2\n        push!(common, x)\n    end\n    \n    return common\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7ovns2ih.jl:17\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7ovns2ih.jl:17\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common = Set([i | common])\n    end\n    \n    for i in l2\n\
    \        common = Set([i | common])\n    end\n    \n    return common\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe8ffmog2.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe8ffmog2.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpb7jbr1ol.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpb7jbr1ol.jl:12\n   [2] top-level scope at /tmp/tmpb7jbr1ol.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb7jbr1ol.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpb7jbr1ol.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpb7jbr1ol.jl:12\n\
    \   [2] top-level scope at /tmp/tmpb7jbr1ol.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb7jbr1ol.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpb7jbr1ol.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpb7jbr1ol.jl:12\n\
    \   [2] top-level scope at /tmp/tmpb7jbr1ol.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb7jbr1ol.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpb7jbr1ol.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpb7jbr1ol.jl:12\n\
    \   [2] top-level scope at /tmp/tmpb7jbr1ol.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb7jbr1ol.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb7jbr1ol.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return Set([x for x in common if x != 0])\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3d7slwem.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3d7slwem.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common = Set([i | common])\n    end\n    \n    for i in l2\n\
    \        common = Set([i | common])\n    end\n    \n    return common\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpkkfz0hfl.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching |(::Int64, ::Set{Any})\n \
    \ Closest candidates are:\n    |(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    |(::T, !Matched::T) where T<:Union{Int128, Int16, Int32,\
    \ Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:300\n    |(::Integer)\
    \ at operators.jl:507\n    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpkkfz0hfl.jl:13\n   [2] top-level scope at /tmp/tmpkkfz0hfl.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkkfz0hfl.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpkkfz0hfl.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching |(::Int64, ::Set{Any})\n\
    \  Closest candidates are:\n    |(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    |(::T, !Matched::T) where T<:Union{Int128, Int16, Int32,\
    \ Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:300\n    |(::Integer)\
    \ at operators.jl:507\n    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpkkfz0hfl.jl:13\n   [2] top-level scope at /tmp/tmpkkfz0hfl.jl:28\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkkfz0hfl.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpkkfz0hfl.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching |(::Int64,\
    \ ::Set{Any})\n  Closest candidates are:\n    |(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    |(::T, !Matched::T) where T<:Union{Int128, Int16, Int32,\
    \ Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:300\n    |(::Integer)\
    \ at operators.jl:507\n    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpkkfz0hfl.jl:13\n   [2] top-level scope at /tmp/tmpkkfz0hfl.jl:29\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkkfz0hfl.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpkkfz0hfl.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching |(::Int64, ::Set{Any})\n  Closest candidates are:\n    |(::Any, ::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    |(::T, !Matched::T)\
    \ where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64,\
    \ UInt8} at int.jl:300\n    |(::Integer) at operators.jl:507\n    ...\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpkkfz0hfl.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkkfz0hfl.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkkfz0hfl.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkkfz0hfl.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg4vx3s7s.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpg4vx3s7s.jl:20\n   [2] top-level scope at /tmp/tmpg4vx3s7s.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg4vx3s7s.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpg4vx3s7s.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpg4vx3s7s.jl:20\n   [2] top-level scope at /tmp/tmpg4vx3s7s.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg4vx3s7s.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpg4vx3s7s.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpg4vx3s7s.jl:20\n   [2] top-level scope at /tmp/tmpg4vx3s7s.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg4vx3s7s.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpg4vx3s7s.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpg4vx3s7s.jl:20\n   [2] top-level scope at /tmp/tmpg4vx3s7s.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg4vx3s7s.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg4vx3s7s.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqlpuzkcb.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqlpuzkcb.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7rz6lbvc.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7rz6lbvc.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ elt in l1 do \n        if elt in l2 \n            common = union(common, elt)\n\
    \        end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpj8jdk1_r.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpj8jdk1_r.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuwbep_sg.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuwbep_sg.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx0b11yy2.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpx0b11yy2.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx0b11yy2.jl:24\ntest set: Test Failed at /tmp/tmpx0b11yy2.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpx0b11yy2.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx0b11yy2.jl:24\ntest set: Test Failed at /tmp/tmpx0b11yy2.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpx0b11yy2.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx0b11yy2.jl:24\ntest set: Test Failed at /tmp/tmpx0b11yy2.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpx0b11yy2.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx0b11yy2.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx0b11yy2.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps7ttl4yf.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmps7ttl4yf.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in common\n            continue\n        push!(common,\
    \ x)\n    end\n    \n    for x in l2\n        if x in common\n            continue\n\
    \        push!(common, x)\n    end\n    \n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmpzfid2_5q.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpzfid2_5q.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpzfid2_5q.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdia93jmx.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdia93jmx.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwddrliyo.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpwddrliyo.jl:13\n   [3] top-level scope at /tmp/tmpwddrliyo.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpwddrliyo.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpwddrliyo.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpwddrliyo.jl:13\n   [3] top-level scope at /tmp/tmpwddrliyo.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpwddrliyo.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpwddrliyo.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpwddrliyo.jl:13\n   [3] top-level scope at /tmp/tmpwddrliyo.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpwddrliyo.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpwddrliyo.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpwddrliyo.jl:13\n   [3]\
    \ top-level scope at /tmp/tmpwddrliyo.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpwddrliyo.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwddrliyo.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj3wche8j.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj3wche8j.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptr_v46e5.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptr_v46e5.jl:18\n   [2] top-level scope at /tmp/tmptr_v46e5.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptr_v46e5.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmptr_v46e5.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptr_v46e5.jl:18\n   [2] top-level scope at /tmp/tmptr_v46e5.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptr_v46e5.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmptr_v46e5.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptr_v46e5.jl:18\n   [2] top-level scope at /tmp/tmptr_v46e5.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptr_v46e5.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmptr_v46e5.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptr_v46e5.jl:18\n   [2] top-level scope at /tmp/tmptr_v46e5.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptr_v46e5.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptr_v46e5.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_44ln0t5.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp_44ln0t5.jl:12\n   [2] top-level scope at /tmp/tmp_44ln0t5.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_44ln0t5.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp_44ln0t5.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_44ln0t5.jl:12\n\
    \   [2] top-level scope at /tmp/tmp_44ln0t5.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_44ln0t5.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp_44ln0t5.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_44ln0t5.jl:12\n\
    \   [2] top-level scope at /tmp/tmp_44ln0t5.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_44ln0t5.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp_44ln0t5.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_44ln0t5.jl:12\n\
    \   [2] top-level scope at /tmp/tmp_44ln0t5.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_44ln0t5.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_44ln0t5.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for el in\
    \ l1\n        common = Set([el] + common)\n    end\n    for el in l2\n       \
    \ common = Set([el] + common)\n    end\n    return common\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpaqj2ef57.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching +(::Array{Int64,1}, ::Set{Any})\n\
    \  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    +(::Array, !Matched::Array...) at arraymath.jl:44\n\
    \    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsematrix.jl:1652\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpaqj2ef57.jl:12\n   [2] top-level scope at /tmp/tmpaqj2ef57.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaqj2ef57.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpaqj2ef57.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching +(::Array{Int64,1},\
    \ ::Set{Any})\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    +(::Array, !Matched::Array...) at arraymath.jl:44\n\
    \    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsematrix.jl:1652\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpaqj2ef57.jl:12\n   [2] top-level scope at /tmp/tmpaqj2ef57.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaqj2ef57.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpaqj2ef57.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching +(::Array{Int64,1},\
    \ ::Set{Any})\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    +(::Array, !Matched::Array...) at arraymath.jl:44\n\
    \    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsematrix.jl:1652\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpaqj2ef57.jl:12\n   [2] top-level scope at /tmp/tmpaqj2ef57.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaqj2ef57.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpaqj2ef57.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching +(::Array{Int64,1}, ::Set{Any})\n  Closest candidates are:\n    +(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    +(::Array,\
    \ !Matched::Array...) at arraymath.jl:44\n    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsematrix.jl:1652\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpaqj2ef57.jl:12\n   [2] top-level scope at /tmp/tmpaqj2ef57.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaqj2ef57.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaqj2ef57.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplye1y_jr.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmplye1y_jr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmplye1y_jr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvy7f1zzz.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpvy7f1zzz.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpvy7f1zzz.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppm7utsnp.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmppm7utsnp.jl:17\n   [2] top-level scope at /tmp/tmppm7utsnp.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppm7utsnp.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmppm7utsnp.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmppm7utsnp.jl:17\n   [2] top-level scope at /tmp/tmppm7utsnp.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppm7utsnp.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmppm7utsnp.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmppm7utsnp.jl:17\n   [2] top-level scope at /tmp/tmppm7utsnp.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppm7utsnp.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmppm7utsnp.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmppm7utsnp.jl:17\n   [2] top-level scope at /tmp/tmppm7utsnp.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppm7utsnp.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppm7utsnp.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a vector and returns a vector where each element is the product of the\
    \ corresponding elements in the original vectors.\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsfaz97fg.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsfaz97fg.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</code>\n<|/ a tags=julia |>\n\
    <| a tags=julia |>\nThe most efficient way is to use Sets:\n<code>\njulia> function\
    \ common(l1::Vector{Int64}, l2::Vector{Int64})::Vector{Int64}\n           common\
    \ = Set()\n           for x in l1\n               push!(common, x)\n         \
    \  end\n           for x in l2\n               push!(common, x)\n           end\n\
    \           return collect(common)\n       end\ncommon (generic function with\
    \ 1 method)\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi80y079h.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi80y079h.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6wzek2n0.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6wzek2n0.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5n03tr39.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5n03tr39.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpykvigv8l.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpykvigv8l.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = common & Set(l2)\n    end\n    \n    return common\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpo_zhuqum.jl:22\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching &(::Set{Any}, ::Set{Int64})\n\
    \  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpo_zhuqum.jl:12\n   [2] top-level scope at /tmp/tmpo_zhuqum.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_zhuqum.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_zhuqum.jl:23\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching &(::Set{Any},\
    \ ::Set{Int64})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpo_zhuqum.jl:12\n   [2] top-level scope at /tmp/tmpo_zhuqum.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_zhuqum.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_zhuqum.jl:24\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching &(::Set{Any},\
    \ ::Set{Int64})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpo_zhuqum.jl:12\n   [2] top-level scope at /tmp/tmpo_zhuqum.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_zhuqum.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_zhuqum.jl:25\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching &(::Set{Any}, ::Set{Int64})\n  Closest candidates are:\n    &(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpo_zhuqum.jl:12\n\
    \   [2] top-level scope at /tmp/tmpo_zhuqum.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_zhuqum.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo_zhuqum.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_ph2k3ai.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_ph2k3ai.jl:20\n   [2] top-level scope at /tmp/tmp_ph2k3ai.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ph2k3ai.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp_ph2k3ai.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_ph2k3ai.jl:20\n   [2] top-level scope at /tmp/tmp_ph2k3ai.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ph2k3ai.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp_ph2k3ai.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_ph2k3ai.jl:20\n   [2] top-level scope at /tmp/tmp_ph2k3ai.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ph2k3ai.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp_ph2k3ai.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_ph2k3ai.jl:20\n   [2] top-level scope at /tmp/tmp_ph2k3ai.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ph2k3ai.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_ph2k3ai.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpba22trvt.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n   \
    \ sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpba22trvt.jl:20\n   [2] top-level scope at /tmp/tmpba22trvt.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba22trvt.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpba22trvt.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpba22trvt.jl:20\n   [2] top-level scope at /tmp/tmpba22trvt.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba22trvt.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpba22trvt.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpba22trvt.jl:20\n   [2] top-level scope at /tmp/tmpba22trvt.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba22trvt.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpba22trvt.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at range.jl:969\n    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpba22trvt.jl:20\n   [2] top-level scope at /tmp/tmpba22trvt.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba22trvt.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpba22trvt.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n            else\n                common = Set([a] ++ common)\n\
    \        end\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprtnf4fso.jl:23\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprtnf4fso.jl:23\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmic535ob.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmic535ob.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmic535ob.jl:24\ntest set: Test Failed at /tmp/tmpmic535ob.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpmic535ob.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmic535ob.jl:24\ntest set: Test Failed at /tmp/tmpmic535ob.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpmic535ob.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmic535ob.jl:24\ntest set: Test Failed at /tmp/tmpmic535ob.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpmic535ob.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmic535ob.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmic535ob.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el1 in l1\n        for el2 in l2\n            if el1 == el2\n              \
    \  common = Set([el1])\n            else\n                common = Set([el1])\
    \ \u222A common\n            end\n        end\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3ypywq68.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3ypywq68.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpasogodtp.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpasogodtp.jl:12\n   [2] top-level scope at /tmp/tmpasogodtp.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpasogodtp.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpasogodtp.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpasogodtp.jl:12\n\
    \   [2] top-level scope at /tmp/tmpasogodtp.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpasogodtp.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpasogodtp.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpasogodtp.jl:12\n\
    \   [2] top-level scope at /tmp/tmpasogodtp.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpasogodtp.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmpasogodtp.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpasogodtp.jl:12\n\
    \   [2] top-level scope at /tmp/tmpasogodtp.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpasogodtp.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpasogodtp.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2v26zbia.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2v26zbia.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2v26zbia.jl:24\ntest set: Test Failed at /tmp/tmp2v26zbia.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp2v26zbia.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2v26zbia.jl:24\ntest set: Test Failed at /tmp/tmp2v26zbia.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp2v26zbia.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2v26zbia.jl:24\ntest set: Test Failed at /tmp/tmp2v26zbia.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp2v26zbia.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2v26zbia.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2v26zbia.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoc0sog52.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpoc0sog52.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3e8h461x.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp3e8h461x.jl:13\n   [3] top-level scope at /tmp/tmp3e8h461x.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp3e8h461x.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp3e8h461x.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp3e8h461x.jl:13\n   [3] top-level scope at /tmp/tmp3e8h461x.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp3e8h461x.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp3e8h461x.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp3e8h461x.jl:13\n   [3] top-level scope at /tmp/tmp3e8h461x.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp3e8h461x.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp3e8h461x.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp3e8h461x.jl:13\n   [3]\
    \ top-level scope at /tmp/tmp3e8h461x.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp3e8h461x.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3e8h461x.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj4r9_xvv.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj4r9_xvv.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb28o36un.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpb28o36un.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb28o36un.jl:24\ntest set: Test Failed at /tmp/tmpb28o36un.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpb28o36un.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb28o36un.jl:24\ntest set: Test Failed at /tmp/tmpb28o36un.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpb28o36un.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb28o36un.jl:24\ntest set: Test Failed at /tmp/tmpb28o36un.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpb28o36un.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb28o36un.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb28o36un.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpc25iegwt.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpc25iegwt.jl:18\n   [2] top-level scope at /tmp/tmpc25iegwt.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc25iegwt.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpc25iegwt.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpc25iegwt.jl:18\n   [2] top-level scope at /tmp/tmpc25iegwt.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc25iegwt.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpc25iegwt.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpc25iegwt.jl:18\n   [2] top-level scope at /tmp/tmpc25iegwt.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc25iegwt.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpc25iegwt.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpc25iegwt.jl:18\n   [2] top-level scope at /tmp/tmpc25iegwt.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc25iegwt.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc25iegwt.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = Set([x] + common)\n    end\n    for x in l2 do \n    \
    \    common = Set([x] + common)\n    end\n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpkogi39jh.jl:11\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmpkogi39jh.jl:11\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n@time common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code language=julia-1.5>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9p3rj0hk.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9p3rj0hk.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptgzvzwla.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptgzvzwla.jl:17\n   [2] top-level scope at /tmp/tmptgzvzwla.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptgzvzwla.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmptgzvzwla.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptgzvzwla.jl:17\n   [2] top-level scope at /tmp/tmptgzvzwla.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptgzvzwla.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmptgzvzwla.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptgzvzwla.jl:17\n   [2] top-level scope at /tmp/tmptgzvzwla.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptgzvzwla.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmptgzvzwla.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmptgzvzwla.jl:17\n   [2] top-level scope at /tmp/tmptgzvzwla.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptgzvzwla.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptgzvzwla.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        if x in common\n            continue\n        for y in l2\n         \
    \   if y in common\n                continue\n            if x == y\n        \
    \        common = Set([x])\n                break\n        end\n    end\n    return\
    \ common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplf27ugjk.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplf27ugjk.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common = Set([i | common])\n    end\n    \n    for i in l2\n\
    \        common = Set([i | common])\n    end\n    \n    return common\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpzerdsx6p.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching |(::Int64, ::Set{Any})\n \
    \ Closest candidates are:\n    |(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    |(::T, !Matched::T) where T<:Union{Int128, Int16, Int32,\
    \ Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:300\n    |(::Integer)\
    \ at operators.jl:507\n    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpzerdsx6p.jl:13\n   [2] top-level scope at /tmp/tmpzerdsx6p.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzerdsx6p.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpzerdsx6p.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching |(::Int64, ::Set{Any})\n\
    \  Closest candidates are:\n    |(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    |(::T, !Matched::T) where T<:Union{Int128, Int16, Int32,\
    \ Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:300\n    |(::Integer)\
    \ at operators.jl:507\n    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpzerdsx6p.jl:13\n   [2] top-level scope at /tmp/tmpzerdsx6p.jl:28\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzerdsx6p.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpzerdsx6p.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching |(::Int64,\
    \ ::Set{Any})\n  Closest candidates are:\n    |(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n    |(::T, !Matched::T) where T<:Union{Int128, Int16, Int32,\
    \ Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:300\n    |(::Integer)\
    \ at operators.jl:507\n    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpzerdsx6p.jl:13\n   [2] top-level scope at /tmp/tmpzerdsx6p.jl:29\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzerdsx6p.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpzerdsx6p.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching |(::Int64, ::Set{Any})\n  Closest candidates are:\n    |(::Any, ::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    |(::T, !Matched::T)\
    \ where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64,\
    \ UInt8} at int.jl:300\n    |(::Integer) at operators.jl:507\n    ...\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzerdsx6p.jl:13\n\
    \   [2] top-level scope at /tmp/tmpzerdsx6p.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzerdsx6p.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzerdsx6p.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq56yptf_.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq56yptf_.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwbmzutus.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwbmzutus.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmlmjkvfr.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpmlmjkvfr.jl:20\n   [2] top-level scope at /tmp/tmpmlmjkvfr.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmlmjkvfr.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpmlmjkvfr.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpmlmjkvfr.jl:20\n   [2] top-level scope at /tmp/tmpmlmjkvfr.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmlmjkvfr.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpmlmjkvfr.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpmlmjkvfr.jl:20\n   [2] top-level scope at /tmp/tmpmlmjkvfr.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmlmjkvfr.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpmlmjkvfr.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpmlmjkvfr.jl:20\n   [2] top-level scope at /tmp/tmpmlmjkvfr.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmlmjkvfr.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmlmjkvfr.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that returns the number of times each element appears in two lists.\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfmb51fmh.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfmb51fmh.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n@time common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code language=julia-1.5>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\nWrite a function\
    \ that returns the number of unique elements in a given list.\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg70mlcgm.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg70mlcgm.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx5z2fs88.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpx5z2fs88.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc1hoejmd.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpc1hoejmd.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@test\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n\
    @test common([5, 3, 2, 8], [3, 2]) == [2, 3]\n</cell>\n<text>\nExercise: Write\
    \ a function that returns the number of unique elements in two vectors.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7sf5wpc8.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7sf5wpc8.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.3>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprd99eten.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprd99eten.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        if x in common\n            continue\n        push!(common, x)\n    end\n\
    \    for x in l2\n        if x in common\n            continue\n        push!(common,\
    \ x)\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp92zcmtep.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp92zcmtep.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        if !contains(common, el)\n            common = Set([el])\n\
    \        else\n            common = Set([el] ++ common)\n        end\n    end\n\
    \    \n    for el in l2\n        if !contains(common, el)\n            common\
    \ = Set([el])\n        else\n            common = Set([el] ++ common)\n      \
    \  end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkgzuasoy.jl:35\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: contains not defined\n  Stacktrace:\n   [1]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpkgzuasoy.jl:13\n   [2]\
    \ top-level scope at /tmp/tmpkgzuasoy.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkgzuasoy.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpkgzuasoy.jl:36\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpkgzuasoy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkgzuasoy.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkgzuasoy.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpkgzuasoy.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: contains not defined\n \
    \ Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpkgzuasoy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkgzuasoy.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkgzuasoy.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpkgzuasoy.jl:38\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpkgzuasoy.jl:13\n   [2] top-level scope at /tmp/tmpkgzuasoy.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkgzuasoy.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkgzuasoy.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt60l09ok.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt60l09ok.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt60l09ok.jl:24\ntest set: Test Failed at /tmp/tmpt60l09ok.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpt60l09ok.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt60l09ok.jl:24\ntest set: Test Failed at /tmp/tmpt60l09ok.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpt60l09ok.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt60l09ok.jl:24\ntest set: Test Failed at /tmp/tmpt60l09ok.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpt60l09ok.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt60l09ok.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt60l09ok.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvdydff9w.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvdydff9w.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4k_17e6n.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n   \
    \ sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp4k_17e6n.jl:20\n   [2] top-level scope at /tmp/tmp4k_17e6n.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4k_17e6n.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp4k_17e6n.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp4k_17e6n.jl:20\n   [2] top-level scope at /tmp/tmp4k_17e6n.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4k_17e6n.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp4k_17e6n.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp4k_17e6n.jl:20\n   [2] top-level scope at /tmp/tmp4k_17e6n.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4k_17e6n.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp4k_17e6n.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at range.jl:969\n    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp4k_17e6n.jl:20\n   [2] top-level scope at /tmp/tmp4k_17e6n.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4k_17e6n.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4k_17e6n.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsvmc7apj.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsvmc7apj.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpes6t7t5g.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpes6t7t5g.jl:20\n   [2] top-level scope at /tmp/tmpes6t7t5g.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpes6t7t5g.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpes6t7t5g.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpes6t7t5g.jl:20\n   [2] top-level scope at /tmp/tmpes6t7t5g.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpes6t7t5g.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpes6t7t5g.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpes6t7t5g.jl:20\n   [2] top-level scope at /tmp/tmpes6t7t5g.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpes6t7t5g.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpes6t7t5g.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpes6t7t5g.jl:20\n   [2] top-level scope at /tmp/tmpes6t7t5g.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpes6t7t5g.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpes6t7t5g.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzsfs80mq.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpzsfs80mq.jl:18\n   [2] top-level scope at /tmp/tmpzsfs80mq.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzsfs80mq.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpzsfs80mq.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpzsfs80mq.jl:18\n   [2] top-level scope at /tmp/tmpzsfs80mq.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzsfs80mq.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpzsfs80mq.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpzsfs80mq.jl:18\n   [2] top-level scope at /tmp/tmpzsfs80mq.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzsfs80mq.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpzsfs80mq.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpzsfs80mq.jl:18\n   [2] top-level scope at /tmp/tmpzsfs80mq.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzsfs80mq.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzsfs80mq.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn5_e0t2o.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpn5_e0t2o.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn5_e0t2o.jl:26\ntest set: Test Failed at /tmp/tmpn5_e0t2o.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpn5_e0t2o.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn5_e0t2o.jl:26\ntest set: Test Failed at /tmp/tmpn5_e0t2o.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpn5_e0t2o.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn5_e0t2o.jl:26\ntest set: Test Failed at /tmp/tmpn5_e0t2o.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpn5_e0t2o.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn5_e0t2o.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn5_e0t2o.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in l2\n            common.add(x)\n        end\n    end\n\
    \    \n    return common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb3tjj2dn.jl:20\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb3tjj2dn.jl:20\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for elt in\
    \ l1 \u222A l2\n        common = common \u222A Set([elt])\n    end\n    return\
    \ common\nend\n</cell>\n<text>\nThe function above is called common in Julia.\
    \ Julia has a built-in set data structure that allows us to efficiently find common\
    \ elements. We use the \u222A operator to find the common elements. We then return\
    \ the common elements.\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfj6zud_b.jl:16\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfj6zud_b.jl:16\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</code>\n<|/ a tags=julia,set |>\n<| c |>\nThis doesn't\
    \ work for me. `julia> common([1,2,3], [4,5,6])\n2-element Array{Int64,1}:\n 3\n\
    \ 2`\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I guess you\
    \ used a previous version of Julia.\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\
    \ and it works. I guess you used a previous version of Julia.\n<|/ c |>\n<| c\
    \ |>\nI tested it on Julia 0.6.2 and it works. I guess you used a previous version\
    \ of Julia.\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I guess\
    \ you used a previous version of Julia.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a\
    \ package for this:\nhttps://github.com/JuliaCollections/Sets.jl\n<code>\njulia>\
    \ using Sets\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi_0rf2bz.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi_0rf2bz.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el1 in l1\n        for el2 in l2\n            if el1 == el2\n              \
    \  common = Set([el1])\n            else\n                common = Set([el1])\
    \ \u222A common\n            end\n        end\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp95i_090j.jl:24\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp95i_090j.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmpfv7v8e.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmpfv7v8e.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpfv7v8e.jl:24\ntest set: Test Failed at /tmp/tmpmpfv7v8e.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpmpfv7v8e.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpfv7v8e.jl:24\ntest set: Test Failed at /tmp/tmpmpfv7v8e.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpmpfv7v8e.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpfv7v8e.jl:24\ntest set: Test Failed at /tmp/tmpmpfv7v8e.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpmpfv7v8e.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpfv7v8e.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmpfv7v8e.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for el in\
    \ l1 \u222A l2\n        common = common \u222A Set([el])\n    end\n    return\
    \ common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpgfupejyt.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgfupejyt.jl:14\n   [2] top-level scope at /tmp/tmpgfupejyt.jl:21\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfupejyt.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgfupejyt.jl:22\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgfupejyt.jl:14\n   [2] top-level scope at /tmp/tmpgfupejyt.jl:22\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfupejyt.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgfupejyt.jl:23\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgfupejyt.jl:14\n   [2] top-level scope at /tmp/tmpgfupejyt.jl:23\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfupejyt.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgfupejyt.jl:24\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpgfupejyt.jl:14\n   [2] top-level scope at /tmp/tmpgfupejyt.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfupejyt.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgfupejyt.jl:18\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphn8b3270.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmphn8b3270.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmphn8b3270.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el1 in l1\n        for el2 in l2\n            if el1 == el2\n              \
    \  common = Set([el1])\n            else\n                common = Set([el1])\
    \ \u222A common\n            end\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpt8j8vhpc.jl:29\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Int64}\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt8j8vhpc.jl:22\n   [2] top-level scope at /tmp/tmpt8j8vhpc.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt8j8vhpc.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpt8j8vhpc.jl:30\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt8j8vhpc.jl:22\n   [2] top-level scope at /tmp/tmpt8j8vhpc.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt8j8vhpc.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpt8j8vhpc.jl:31\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Int64} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt8j8vhpc.jl:22\n   [2] top-level scope at /tmp/tmpt8j8vhpc.jl:31\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt8j8vhpc.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpt8j8vhpc.jl:32\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpt8j8vhpc.jl:22\n   [2] top-level scope at /tmp/tmpt8j8vhpc.jl:32\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt8j8vhpc.jl:28\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt8j8vhpc.jl:26\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2pn5rzbq.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp2pn5rzbq.jl:13\n   [3] top-level scope at /tmp/tmp2pn5rzbq.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2pn5rzbq.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp2pn5rzbq.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp2pn5rzbq.jl:13\n   [3] top-level scope at /tmp/tmp2pn5rzbq.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2pn5rzbq.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp2pn5rzbq.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp2pn5rzbq.jl:13\n   [3] top-level scope at /tmp/tmp2pn5rzbq.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2pn5rzbq.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp2pn5rzbq.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp2pn5rzbq.jl:13\n   [3]\
    \ top-level scope at /tmp/tmp2pn5rzbq.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2pn5rzbq.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2pn5rzbq.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3a8c1dyc.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp3a8c1dyc.jl:17\n   [2] top-level scope at /tmp/tmp3a8c1dyc.jl:24\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3a8c1dyc.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp3a8c1dyc.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp3a8c1dyc.jl:17\n   [2] top-level scope at /tmp/tmp3a8c1dyc.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3a8c1dyc.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp3a8c1dyc.jl:26\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp3a8c1dyc.jl:17\n   [2] top-level scope at /tmp/tmp3a8c1dyc.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3a8c1dyc.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp3a8c1dyc.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp3a8c1dyc.jl:17\n   [2] top-level scope at /tmp/tmp3a8c1dyc.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3a8c1dyc.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3a8c1dyc.jl:21\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqnbyryvt.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqnbyryvt.jl:20\n   [2] top-level scope at /tmp/tmpqnbyryvt.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqnbyryvt.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpqnbyryvt.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqnbyryvt.jl:20\n   [2] top-level scope at /tmp/tmpqnbyryvt.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqnbyryvt.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpqnbyryvt.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqnbyryvt.jl:20\n   [2] top-level scope at /tmp/tmpqnbyryvt.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqnbyryvt.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpqnbyryvt.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpqnbyryvt.jl:20\n   [2] top-level scope at /tmp/tmpqnbyryvt.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqnbyryvt.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqnbyryvt.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptxjmsxiu.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmptxjmsxiu.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmptxjmsxiu.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu8no0jsa.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu8no0jsa.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<text>\nThe function above returns a sorted\
    \ unique common elements for two lists.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd3grvowy.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd3grvowy.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjmznc_up.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjmznc_up.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb3wyuls7.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb3wyuls7.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        if x in common\n            push!(common, x)\n        else\n        \
    \    push!(common, x)\n        end\n    end\n    for x in l2\n        if x in\
    \ common\n            push!(common, x)\n        else\n            push!(common,\
    \ x)\n        end\n    end\n    common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_m3sdo9x.jl:32\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_m3sdo9x.jl:25\n   [2] top-level scope at /tmp/tmp_m3sdo9x.jl:32\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_m3sdo9x.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_m3sdo9x.jl:33\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_m3sdo9x.jl:25\n   [2] top-level scope at /tmp/tmp_m3sdo9x.jl:33\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_m3sdo9x.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_m3sdo9x.jl:34\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_m3sdo9x.jl:25\n   [2] top-level scope at /tmp/tmp_m3sdo9x.jl:34\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_m3sdo9x.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_m3sdo9x.jl:35\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp_m3sdo9x.jl:25\n   [2] top-level scope at /tmp/tmp_m3sdo9x.jl:35\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_m3sdo9x.jl:31\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_m3sdo9x.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy97za8u1.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n   \
    \ sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpy97za8u1.jl:18\n   [2] top-level scope at /tmp/tmpy97za8u1.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy97za8u1.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpy97za8u1.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpy97za8u1.jl:18\n   [2] top-level scope at /tmp/tmpy97za8u1.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy97za8u1.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpy97za8u1.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpy97za8u1.jl:18\n   [2] top-level scope at /tmp/tmpy97za8u1.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy97za8u1.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpy97za8u1.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at range.jl:969\n    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpy97za8u1.jl:18\n   [2] top-level scope at /tmp/tmpy97za8u1.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy97za8u1.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy97za8u1.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        if x in l2 \n            common = common.add(x)\n     \
    \   end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmprn87j_zs.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmprn87j_zs.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0ntx1fuw.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0ntx1fuw.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n                break\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5xxiwzc3.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp5xxiwzc3.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp5xxiwzc3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptksq6np5.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptksq6np5.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjzotk5d3.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpjzotk5d3.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjzotk5d3.jl:26\ntest set: Test Failed at /tmp/tmpjzotk5d3.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpjzotk5d3.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjzotk5d3.jl:26\ntest set: Test Failed at /tmp/tmpjzotk5d3.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpjzotk5d3.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjzotk5d3.jl:26\ntest set: Test Failed at /tmp/tmpjzotk5d3.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpjzotk5d3.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjzotk5d3.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjzotk5d3.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpni7s2wlb.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpni7s2wlb.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        push!(common, i)\n    end\n    \n    for i in l2\n        push!(common,\
    \ i)\n    end\n    \n    return collect(common)\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the number of times a value appears in two\
    \ lists.\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw_ub456q.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw_ub456q.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common.add(a)\n\
    \            end\n        end\n    end\n    \n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpa8accyjf.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpa8accyjf.jl:15\n   [3] top-level scope at /tmp/tmpa8accyjf.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpa8accyjf.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8accyjf.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpa8accyjf.jl:15\n   [3] top-level scope at /tmp/tmpa8accyjf.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpa8accyjf.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8accyjf.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpa8accyjf.jl:15\n   [3] top-level scope at /tmp/tmpa8accyjf.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpa8accyjf.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8accyjf.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpa8accyjf.jl:20\n   [2] top-level scope at /tmp/tmpa8accyjf.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8accyjf.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa8accyjf.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4oywkyf6.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4oywkyf6.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4oywkyf6.jl:24\ntest set: Test Failed at /tmp/tmp4oywkyf6.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp4oywkyf6.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4oywkyf6.jl:24\ntest set: Test Failed at /tmp/tmp4oywkyf6.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp4oywkyf6.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4oywkyf6.jl:24\ntest set: Test Failed at /tmp/tmp4oywkyf6.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp4oywkyf6.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4oywkyf6.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4oywkyf6.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf8s9m0d5.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf8s9m0d5.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 do \n        if !contains(common, el) then \n            common = Set([el])\n\
    \        else \n            common = Set([el] + common)\n        end\n    end\n\
    \    \n    for el in l2 do \n        if !contains(common, el) then \n        \
    \    common = Set([el])\n        else \n            common = Set([el] + common)\n\
    \        end\n    end\n    \n    return common\nend\n</code>\n<|/ a tags=julia,set\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid the\
    \ O(n^2) complexity of the `contains` calls.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that avoids O(n^2) complexity\n<|/ c |>\n<| a tags=julia,set |>\nThe solution\
    \ by is great, but I wanted to add an alternative that uses only a single loop\
    \ and is also faster than the solution by (at least on my machine):\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5l_6qk9k.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmp5l_6qk9k.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise:\
    \ Write a function that returns the number of common elements in two vectors.\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu0zus9ib.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu0zus9ib.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpulz37vl0.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpulz37vl0.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpulz37vl0.jl:24\ntest set: Test Failed at /tmp/tmpulz37vl0.jl:26\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpulz37vl0.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpulz37vl0.jl:24\ntest set: Test Failed at /tmp/tmpulz37vl0.jl:27\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpulz37vl0.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpulz37vl0.jl:24\ntest set: Test Failed at /tmp/tmpulz37vl0.jl:28\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpulz37vl0.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpulz37vl0.jl:24\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpulz37vl0.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        common = Set([el]) & common\n    end\n    \n    for el in\
    \ l2\n        common = Set([el]) & common\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp6dlww1h9.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching &(::Set{Int64}, ::Set{Any})\n\
    \  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp6dlww1h9.jl:13\n   [2] top-level scope at /tmp/tmp6dlww1h9.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6dlww1h9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6dlww1h9.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching &(::Set{Int64},\
    \ ::Set{Any})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp6dlww1h9.jl:13\n   [2] top-level scope at /tmp/tmp6dlww1h9.jl:28\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6dlww1h9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6dlww1h9.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching &(::Set{Int64},\
    \ ::Set{Any})\n  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp6dlww1h9.jl:13\n   [2] top-level scope at /tmp/tmp6dlww1h9.jl:29\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6dlww1h9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6dlww1h9.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching &(::Set{Int64}, ::Set{Any})\n  Closest candidates are:\n    &(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp6dlww1h9.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6dlww1h9.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6dlww1h9.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6dlww1h9.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        common = Set([x] ++ common)\n    end\n    \n    for x in\
    \ l2 do \n        common = Set([x] ++ common)\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp39vhtcla.jl:12\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmp39vhtcla.jl:12\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common.add(a)\n\
    \            end\n        end\n    end\n    \n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp21hl0xi9.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmp21hl0xi9.jl:15\n   [3] top-level scope at /tmp/tmp21hl0xi9.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp21hl0xi9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp21hl0xi9.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp21hl0xi9.jl:15\n   [3] top-level scope at /tmp/tmp21hl0xi9.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp21hl0xi9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp21hl0xi9.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp21hl0xi9.jl:15\n   [3] top-level scope at /tmp/tmp21hl0xi9.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp21hl0xi9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp21hl0xi9.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmp21hl0xi9.jl:20\n   [2] top-level scope at /tmp/tmp21hl0xi9.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp21hl0xi9.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp21hl0xi9.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpii4w8das.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1}, ::Array{Int64,1})\
    \ at /tmp/tmpii4w8das.jl:13\n   [3] top-level scope at /tmp/tmpii4w8das.jl:27\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpii4w8das.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpii4w8das.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n  \
    \ [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpii4w8das.jl:13\n   [3] top-level scope at /tmp/tmpii4w8das.jl:28\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpii4w8das.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpii4w8das.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] common(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpii4w8das.jl:13\n   [3] top-level scope at /tmp/tmpii4w8das.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpii4w8das.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpii4w8das.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ common(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpii4w8das.jl:13\n   [3]\
    \ top-level scope at /tmp/tmpii4w8das.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpii4w8das.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpii4w8das.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl1j0t7ic.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl1j0t7ic.jl:20\n   [2] top-level scope at /tmp/tmpl1j0t7ic.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1j0t7ic.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpl1j0t7ic.jl:28\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl1j0t7ic.jl:20\n   [2] top-level scope at /tmp/tmpl1j0t7ic.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1j0t7ic.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpl1j0t7ic.jl:29\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: Cannot `convert` an object\
    \ of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl1j0t7ic.jl:20\n   [2] top-level scope at /tmp/tmpl1j0t7ic.jl:29\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1j0t7ic.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpl1j0t7ic.jl:30\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Set{Any} to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl1j0t7ic.jl:20\n   [2] top-level scope at /tmp/tmpl1j0t7ic.jl:30\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1j0t7ic.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl1j0t7ic.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyuc9ve7i.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [7, 4, 9, 34, 653, 3, 2, 121, 5, 1] == [1, 5, 653]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpyuc9ve7i.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuc9ve7i.jl:26\ntest set: Test Failed at /tmp/tmpyuc9ve7i.jl:28\n\
    \  Expression: candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n   Evaluated: [2, 3,\
    \ 5, 8] == [2, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpyuc9ve7i.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuc9ve7i.jl:26\ntest set: Test Failed at /tmp/tmpyuc9ve7i.jl:29\n\
    \  Expression: candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n   Evaluated:\
    \ [4, 2, 3, 8] == [2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpyuc9ve7i.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuc9ve7i.jl:26\ntest set: Test Failed at /tmp/tmpyuc9ve7i.jl:30\n\
    \  Expression: candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n\
    \   Evaluated: [4, 2, 3, 8] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpyuc9ve7i.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuc9ve7i.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyuc9ve7i.jl:24\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv2vrwxlw.jl:19\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv2vrwxlw.jl:19\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ elt in l1 \n        common = Set([elt] + common)\n    end\n    \n    for elt\
    \ in l2 \n        common = Set([elt] + common)\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp28abltib.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp28abltib.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl7fc_0dz.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n   \
    \ sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl7fc_0dz.jl:18\n   [2] top-level scope at /tmp/tmpl7fc_0dz.jl:25\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl7fc_0dz.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpl7fc_0dz.jl:26\n  Test threw exception\n  Expression: candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl7fc_0dz.jl:18\n   [2] top-level scope at /tmp/tmpl7fc_0dz.jl:26\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl7fc_0dz.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpl7fc_0dz.jl:27\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching sort(::Set{Any})\n\
    \  Closest candidates are:\n    sort(!Matched::AbstractUnitRange) at range.jl:969\n\
    \    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl7fc_0dz.jl:18\n   [2] top-level scope at /tmp/tmpl7fc_0dz.jl:27\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl7fc_0dz.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpl7fc_0dz.jl:28\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at range.jl:969\n    sort(!Matched::AbstractRange) at range.jl:972\n    sort(!Matched::SparseArrays.SparseVector{Tv,Ti};\
    \ kws...) where {Tv, Ti} at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/SparseArrays/src/sparsevector.jl:1914\n\
    \    ...\n  Stacktrace:\n   [1] common(::Array{Int64,1}, ::Array{Int64,1}) at\
    \ /tmp/tmpl7fc_0dz.jl:18\n   [2] top-level scope at /tmp/tmpl7fc_0dz.jl:28\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl7fc_0dz.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl7fc_0dz.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2z7fqtq1.jl:22\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2z7fqtq1.jl:22\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpigj42wt9.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpigj42wt9.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpigj42wt9.jl:1\n"
  exit_code: 1
  status: Exception
