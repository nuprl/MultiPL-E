name: HumanEval_68_pluck
language: java
results:
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwtkbqnse.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        long smallestIndex = 0;\n        long smallestValue = 0;\n   \
    \     long index = 0;\n        for (Long i : arr) {\n            if (i % 2 ==\
    \ 0) {\n                if (smallestEvenValue == 0) {\n                    smallestEvenValue\
    \ = i;\n                    smallestIndex = index;\n                    smallestValue\
    \ = i;\n                } else {\n                    if (smallestEvenValue <\
    \ i) {\n                        smallestEvenValue = i;\n                     \
    \   smallestIndex = index;\n                        smallestValue = i;\n     \
    \               }\n                }\n                index++;\n            }\
    \ else {\n                if (smallestEvenValue == 0) {\n                    smallestEvenValue\
    \ = i;\n                    smallestIndex = index;\n                    smallestValue\
    \ = i;\n                } else {\n                    if (smallestEvenValue <\
    \ i) {\n                        smallestEvenValue = i;\n                     \
    \   smallestIndex = index;\n                        smallestValue = i;\n     \
    \               }\n                }\n                index++;\n            }\n\
    \        }\n        result.add(smallestValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa7w_4rhw.java:75)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmixqctyx.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj3h7kbcb.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo9sfkp5o.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        if (smallestEven != Long.MAX_VALUE) {\n    \
    \        result.add(smallestEven);\n            result.add(smallestIndex);\n \
    \       }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_w3_34pj.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MIN_VALUE;\n        int smallestIndex = 0;\n        for(long value :\
    \ arr) {\n            if(value % 2 == 0) {\n                if(smallestEvenValue\
    \ < value) {\n                    smallestEvenValue = value;\n               \
    \     smallestIndex = arr.indexOf(value);\n                }\n            }\n\
    \        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm6psnfbb.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if (value\
    \ % 2 == 0) {\n                if (smallestEven > value) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        result.add(smallestEven);\n      \
    \  result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcsd0z4z5.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgqyg8z11.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long i : arr)\
    \ {\n            if(i%2 == 0) {\n                if(i<smallestEven) {\n      \
    \              smallestEven = i;\n                    smallestIndex = arr.indexOf(i);\n\
    \                }\n            }\n        }\n        if(smallestEven == Long.MAX_VALUE)\
    \ {\n            return result;\n        }\n        for(long i : arr) {\n    \
    \        if(i%2 == 0) {\n                if(i==smallestEven) {\n             \
    \       result.add(smallestEven);\n                    result.add(smallestIndex);\n\
    \                }\n            }\n        }\n        return result;\n\n    }\n\
    \    public static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm8p831jm.java:53: error: no suitable method found for add(int)\n\
    \                    result.add(smallestIndex);\n                          ^\n\
    \    method Collection.add(Long) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to Long)\n    method List.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractCollection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method AbstractList.add(Long) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to Long)\n    method ArrayList.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        res.add(smallestEven);\n        res.add(smallestIndex);\n  \
    \      return res;\n\n    }\n    public static void main(String[] args) {\n  \
    \  assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp74uqdett.java:47: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            long value = arr.get(i);\n            if\
    \ (value % 2 == 0) {\n                if (smallestEven > value) {\n          \
    \          smallestEven = value;\n                    smallestIndex = i;\n   \
    \             }\n            }\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            res.add(smallestEven);\n            res.add(smallestIndex);\n\
    \        }\n        return res;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqu9yxpm7.java:49: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven == Long.MAX_VALUE) {\n                    smallestEven =\
    \ arr.get(i);\n                    smallestIndex = i;\n                } else\
    \ {\n                    if (arr.get(i) < smallestEven) {\n                  \
    \      smallestEven = arr.get(i);\n                        smallestIndex = i;\n\
    \                    }\n                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpak7vcbgx.java:52: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            int\
    \ index = i;\n            while(index > 0 && arr.get(index - 1) % 2 == 0) {\n\
    \                index--;\n            }\n            if(value < smallestEven)\
    \ {\n                smallestEven = value;\n                smallestIndex = index;\n\
    \            }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpze9wuwtv.java:50: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MIN_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n           \
    \     smallestEven = Math.min(smallestEven, arr.get(i));\n                smallestIndex\
    \ = i;\n            }\n        }\n        if (smallestEven != Long.MIN_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprg1fdtj8.java:46: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = arr.get(0);\n        int smallestIndex = 0;\n        for (int i = 1; i < arr.size();\
    \ i++) {\n            if (arr.get(i) % 2 == 0) {\n                if (smallestEvenValue\
    \ > arr.get(i)) {\n                    smallestEvenValue = arr.get(i);\n     \
    \               smallestIndex = i;\n                }\n            }\n       \
    \ }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_e734ks1.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6uf0_nvs.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        for(long value : arr) {\n    \
    \        if(value % 2 == 0) {\n                smallestEvenValue = value;\n  \
    \              smallestIndex = arr.indexOf(value);\n            }\n        }\n\
    \        if(smallestEvenValue == 0) {\n            return result;\n        }\n\
    \        for(long value : arr) {\n            if(value % 2 == 0) {\n         \
    \       if(value < smallestEvenValue) {\n                    smallestEvenValue\
    \ = value;\n                    smallestIndex = arr.indexOf(value);\n        \
    \        }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa4_68nwe.java:56: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long i : arr)\
    \ {\n            if(i%2 == 0) {\n                if(i<smallestEven) {\n      \
    \              smallestEven = i;\n                    smallestIndex = arr.indexOf(i);\n\
    \                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdq14ve70.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int index = 0;\n\
    \        for(int i = 0; i < arr.size(); i++) {\n            long value = arr.get(i);\n\
    \            int even = value % 2 == 0;\n            if(even && value < smallestEven)\
    \ {\n                smallestEven = value;\n                smallestIndex = i;\n\
    \            }\n            else if(even && value == smallestEven) {\n       \
    \         result.add(smallestEven);\n                result.add(smallestIndex);\n\
    \            }\n        }\n        if(result.isEmpty()) {\n            return\
    \ result;\n        }\n        else if(result.size() == 1) {\n            ArrayList<Long>\
    \ result2 = new ArrayList<>();\n            result2.add(result.get(0));\n    \
    \        result2.add(result.get(1));\n            return result2;\n        }\n\
    \        else {\n            ArrayList<Long> result2 = new ArrayList<>();\n  \
    \          for(int i = 0; i < result.size(); i++) {\n                long value\
    \ = result.get(i);\n                int even = value % 2 == 0;\n             \
    \   if(even && value < smallestEven) {\n                    smallestEven = value;\n\
    \                    smallestIndex = i;\n                }\n                else\
    \ if(even && value == smallestEven) {\n                    result2.add(smallestEven);\n\
    \                    result2.add(smallestIndex);\n                }\n        \
    \    }\n            return result2;\n        }\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplagfzhwz.java:41: error: incompatible types: boolean cannot be\
    \ converted to int\n            int even = value % 2 == 0;\n                 \
    \                ^\n/tmp/tmplagfzhwz.java:42: error: bad operand types for binary\
    \ operator '&&'\n            if(even && value < smallestEven) {\n            \
    \        ^\n  first type:  int\n  second type: boolean\n/tmp/tmplagfzhwz.java:46:\
    \ error: bad operand types for binary operator '&&'\n            else if(even\
    \ && value == smallestEven) {\n                         ^\n  first type:  int\n\
    \  second type: boolean\n/tmp/tmplagfzhwz.java:48: error: no suitable method found\
    \ for add(int)\n                result.add(smallestIndex);\n                 \
    \     ^\n    method Collection.add(Long) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to Long)\n    method List.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractCollection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method AbstractList.add(Long) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to Long)\n    method ArrayList.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n/tmp/tmplagfzhwz.java:64:\
    \ error: incompatible types: boolean cannot be converted to int\n            \
    \    int even = value % 2 == 0;\n                                     ^\n/tmp/tmplagfzhwz.java:65:\
    \ error: bad operand types for binary operator '&&'\n                if(even &&\
    \ value < smallestEven) {\n                        ^\n  first type:  int\n  second\
    \ type: boolean\n/tmp/tmplagfzhwz.java:69: error: bad operand types for binary\
    \ operator '&&'\n                else if(even && value == smallestEven) {\n  \
    \                           ^\n  first type:  int\n  second type: boolean\n/tmp/tmplagfzhwz.java:71:\
    \ error: no suitable method found for add(int)\n                    result2.add(smallestIndex);\n\
    \                           ^\n    method Collection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be conver"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx508l56d.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpprf7942c.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            long value = arr.get(i);\n\
    \            if (value % 2 == 0) {\n                if (value < smallestEven)\
    \ {\n                    smallestEven = value;\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        if (smallestEven\
    \ != Long.MAX_VALUE) {\n            res.add(smallestEven);\n            res.add(smallestIndex);\n\
    \        }\n        return res;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp4x_vxi4.java:50: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int index = 0;\n\
    \        for(int i = 0; i < arr.size(); i++) {\n            long value = arr.get(i);\n\
    \            if(value % 2 == 0) {\n                if(smallestEvenValue < value)\
    \ {\n                    smallestEvenValue = value;\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        if(smallestEvenValue\
    \ == Long.MAX_VALUE) {\n            return result;\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj98muvaw.java:52: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        Arrays.sort(arr);\n\
    \        long smallestEvenValue = arr.get(0);\n        int smallestIndex = 0;\n\
    \        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) %\
    \ 2 == 0) {\n                smallestEvenValue = arr.get(i);\n               \
    \ smallestIndex = i;\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4rznalb2.java:36: error: no suitable method found for sort(ArrayList<Long>)\n\
    \        Arrays.sort(arr);\n              ^\n    method Arrays.sort(int[]) is\
    \ not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to int[])\n    method Arrays.sort(long[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to long[])\n    method Arrays.sort(short[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to short[])\n    method Arrays.sort(char[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to char[])\n    method Arrays.sort(byte[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to byte[])\n    method Arrays.sort(float[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to float[])\n    method Arrays.sort(double[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to double[])\n    method Arrays.sort(Object[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<?\
    \ super T#1>) is not applicable\n      (cannot infer type-variable(s) T#1\n  \
    \      (actual and formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in method <T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>)\n/tmp/tmp4rznalb2.java:46: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollect"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphghqd5no.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = arr.get(0);\n        int smallestIndex = 0;\n        for (int i = 1; i < arr.size();\
    \ i++) {\n            if (arr.get(i) % 2 == 0) {\n                if (smallestEvenValue\
    \ > arr.get(i)) {\n                    smallestEvenValue = arr.get(i);\n     \
    \               smallestIndex = i;\n                }\n            } else {\n\
    \                if (smallestEvenValue == arr.get(i)) {\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnuvo_a7e.java:51: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdg5v60y2.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        res.add(smallestEven);\n        res.add(smallestIndex);\n  \
    \      return res;\n\n    }\n    public static void main(String[] args) {\n  \
    \  assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr7v6tv2o.java:47: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp94x79iqh.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smalest_value\
    \ = Long.MIN_VALUE;\n        int smalest_index = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n           \
    \     if (smalest_value == Long.MIN_VALUE) {\n                    smalest_value\
    \ = arr.get(i);\n                    smalest_index = i;\n                } else\
    \ if (smalest_value < arr.get(i)) {\n                    smalest_value = arr.get(i);\n\
    \                    smalest_index = i;\n                }\n            }\n  \
    \      }\n        if (smalest_index != -1) {\n            res.add(smalest_value);\n\
    \            res.add(smalest_index);\n        }\n        return res;\n\n    }\n\
    \    public static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9ypum1ad.java:51: error: no suitable method found for add(int)\n\
    \            res.add(smalest_index);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcr8hlc96.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if (value\
    \ % 2 == 0) {\n                if (value < smallestEven) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        res.add(smallestEven);\n        res.add(smallestIndex);\n\
    \        return res;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb5fln0nl.java:48: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(Long val : arr)\
    \ {\n            if(val % 2 == 0) {\n                smallestEven = Math.min(smallestEven,\
    \ val);\n                smallestIndex = arr.indexOf(val);\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeljzxqpf.java:45: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpig2c95dn.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjb4ratcv.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if (value\
    \ % 2 == 0) {\n                if (value < smallestEven) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        result.add(smallestEven);\n      \
    \  result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7qx4bxsu.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MIN_VALUE;\n        long smallestIndex = -1;\n        long smallestIndex2\
    \ = -1;\n        long smallestIndex3 = -1;\n        long smallestIndex4 = -1;\n\
    \        long smallestIndex5 = -1;\n        long smallestIndex6 = -1;\n      \
    \  long smallestIndex7 = -1;\n        long smallestIndex8 = -1;\n        long\
    \ smallestIndex9 = -1;\n        long smallestIndex10 = -1;\n        long smallestIndex11\
    \ = -1;\n        long smallestIndex12 = -1;\n        long smallestIndex13 = -1;\n\
    \        long smallestIndex14 = -1;\n        long smallestIndex15 = -1;\n    \
    \    long smallestIndex16 = -1;\n        long smallestIndex17 = -1;\n        long\
    \ smallestIndex18 = -1;\n        long smallestIndex19 = -1;\n        long smallestIndex20\
    \ = -1;\n        long smallestIndex21 = -1;\n        long smallestIndex22 = -1;\n\
    \        long smallestIndex23 = -1;\n        long smallestIndex24 = -1;\n    \
    \    long smallestIndex25 = -1;\n        long smallestIndex26 = -1;\n        long\
    \ smallestIndex27 = -1;\n        long smallestIndex28 = -1;\n        long smallestIndex29\
    \ = -1;\n        long smallestIndex30 = -1;\n        long smallestIndex31 = -1;\n\
    \        long smallestIndex32 = -1;\n        long smallestIndex33 = -1;\n    \
    \    long smallestIndex34 = -1;\n        long smallestIndex35 = -1;\n        long\
    \ smallestIndex36 = -1;\n        long smallestIndex37 = -1;\n        long smallestIndex38\
    \ = -1;\n        long smallestIndex39 = -1;\n        long smallestIndex40 = -1;\n\
    \        long smallestIndex41 = -1;\n        long smallestIndex42 = -1;\n    \
    \    long smallestIndex43 = -1;\n        long smallestIndex44 = -1;\n        long\
    \ smallestIndex45 = -1;\n        long smallestIndex46 = -1;\n        long smallestIndex47\
    \ = -1;\n        long smallestIndex48 = -1;\n        long smallestIndex49 = -1;\n\
    \        long smallestIndex50 = -1;\n        long smallestIndex51 = -1;\n    \
    \    long smallestIndex52 = -1;\n        long smallestIndex53 = -1;\n        long\
    \ smallestIndex54 = -1;\n        long smallestIndex55 = -1;\n        long smallestIndex56\
    \ = -1;\n\n    }\n    public static void main(String[] args) {\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpofilnrgy.java:94: error: missing return statement\n    }\n    ^\n\
    1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long val = arr.get(i);\n            if(val\
    \ % 2 == 0) {\n                if(val < smallestEven) {\n                    smallestEven\
    \ = val;\n                    smallestIndex = i;\n                }\n        \
    \    }\n        }\n        if(smallestEven != Long.MAX_VALUE) {\n            res.add(smallestEven);\n\
    \            res.add(smallestIndex);\n        }\n        return res;\n\n    }\n\
    \    public static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpufhdtugo.java:49: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpraq3byko.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpin4bumis.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            long value = arr.get(i);\n            if\
    \ (value % 2 == 0) {\n                if (smallestEven == Long.MAX_VALUE) {\n\
    \                    smallestEven = value;\n                    smallestIndex\
    \ = i;\n                } else {\n                    if (value < smallestEven)\
    \ {\n                        smallestEven = value;\n                        smallestIndex\
    \ = i;\n                    }\n                }\n            }\n        }\n \
    \       result.add(smallestEven);\n        result.add(smallestIndex);\n      \
    \  return result;\n\n    }\n    public static void main(String[] args) {\n   \
    \ assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4xds47uv.java:53: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1dfr4mas.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                smallestEven = Math.min(smallestEven, arr.get(i));\n    \
    \            smallestIndex = i;\n            }\n        }\n        if (smallestEven\
    \ != Long.MAX_VALUE) {\n            res.add(smallestEven);\n            res.add(smallestIndex);\n\
    \        }\n        return res;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1xd_ocxx.java:47: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmxfvfqxs.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphxs_514k.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for(int i = 0; i < size; i++) {\n            if(arr.get(i) % 2 == 0)\
    \ {\n                smallestEven = Math.min(smallestEven, arr.get(i));\n    \
    \            smallestIndex++;\n            }\n        }\n        if(smallestEven\
    \ != Long.MAX_VALUE) {\n            smallestEven = Math.min(smallestEven, arr.get(size\
    \ - 1));\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmps3o2gp2g.java:48: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv8oig1gb.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0odx6r2w.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  smallestEven = Math.min(smallestEven, arr.get(i));\n                smallestIndex\
    \ = i;\n            }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0ps879al.java:45: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw0cvbrpz.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MIN_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_gytxxx0.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoiz2oh1h.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe0c51zj4.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            res.add(smallestEven);\n            res.add(smallestIndex);\n\
    \        }\n        return res;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwtjwobj0.java:49: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp63e00919.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int index = 0;\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) %\
    \ 2 == 0) {\n                if (smallestEven > arr.get(i)) {\n              \
    \      smallestEven = arr.get(i);\n                    smallestIndex = i;\n  \
    \              }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsdqnbxx4.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplge8gmex.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz8fwfskg.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6xpp7hh_.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if (value\
    \ % 2 == 0) {\n                if (smallestEven > value) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        result.add(smallestEven);\n      \
    \  result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj6hbeo5t.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n           \
    \     if (smallestEven == Long.MAX_VALUE) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                } else\
    \ if (arr.get(i) < smallestEven) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        res.add(smallestEven);\n        res.add(smallestIndex);\n  \
    \      return res;\n\n    }\n    public static void main(String[] args) {\n  \
    \  assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphy8l0byk.java:50: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n           \
    \     if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7dg0jq6z.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for(int i = 0; i < size; i++) {\n            long value = arr.get(i);\n\
    \            if(value % 2 == 0) {\n                if(value < smallestEven) {\n\
    \                    smallestEven = value;\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp15lka5du.java:49: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven == Long.MAX_VALUE) {\n                    smallestEven =\
    \ arr.get(i);\n                    smallestIndex = i;\n                } else\
    \ {\n                    if (arr.get(i) < smallestEven) {\n                  \
    \      smallestEven = arr.get(i);\n                        smallestIndex = i;\n\
    \                    }\n                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyp0fks2l.java:52: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuwbe4786.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu37apv74.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx_26lyq9.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int index = 0;\n\
    \        for (Long val : arr) {\n            if (val % 2 == 0) {\n           \
    \     if (smallestEven > val) {\n                    smallestEven = val;\n   \
    \                 smallestIndex = index;\n                }\n                index++;\n\
    \            }\n        }\n        if (smallestEven != Long.MAX_VALUE) {\n   \
    \         res.add(smallestEven);\n            res.add(smallestIndex);\n      \
    \  }\n        return res;\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpylozq9ev.java:50: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr4_ppsmb.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf07uuv5j.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long value :\
    \ arr) {\n            if(value % 2 == 0) {\n                if(smallestEven >\
    \ value) {\n                    smallestEven = value;\n                    smallestIndex\
    \ = arr.indexOf(value);\n                }\n            }\n        }\n       \
    \ result.add(smallestEven);\n        result.add(smallestIndex);\n        return\
    \ result;\n\n    }\n    public static void main(String[] args) {\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr4t5ilbv.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            if (arr.get(i) % 2 == 0) {\n                if (smallestEvenValue\
    \ == 0) {\n                    smallestEvenValue = arr.get(i);\n             \
    \       smallestIndex = i;\n                } else {\n                    if (arr.get(i)\
    \ < smallestEvenValue) {\n                        smallestEvenValue = arr.get(i);\n\
    \                        smallestIndex = i;\n                    }\n         \
    \       }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn45ls580.java:52: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3meizc6g.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long min = Long.MAX_VALUE;\n\
    \        int minIndex = 0;\n        for (int i = 0; i < arr.size(); i++) {\n \
    \           long value = arr.get(i);\n            if (value % 2 == 0) {\n    \
    \            min = Math.min(min, value);\n                minIndex = i;\n    \
    \        }\n        }\n        if (min == Long.MAX_VALUE) {\n            return\
    \ res;\n        }\n        long smalest_value = min;\n        int smalest_index\
    \ = minIndex;\n        for (int i = 0; i < arr.size(); i++) {\n            long\
    \ value = arr.get(i);\n            if (value % 2 == 0) {\n                if (value\
    \ < smalest_value) {\n                    smalest_value = value;\n           \
    \         smalest_index = i;\n                }\n            }\n        }\n  \
    \      res.add(smalest_value);\n        res.add(smalest_index);\n        return\
    \ res;\n\n    }\n    public static void main(String[] args) {\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmptsj8k47u.java:60: error: no suitable method found for add(int)\n\
    \        res.add(smalest_index);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkfrg8_gd.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        res.add(smallestEven);\n        res.add(smallestIndex);\n  \
    \      return res;\n\n    }\n    public static void main(String[] args) {\n  \
    \  assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp01zz3in0.java:47: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long i : arr)\
    \ {\n            if(i%2 == 0) {\n                if(i<smallestEven) {\n      \
    \              smallestEven = i;\n                    smallestIndex = arr.indexOf(i);\n\
    \                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpekux35to.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MIN_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MIN_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp26_n68tx.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5i3kzpoc.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if (value\
    \ % 2 == 0) {\n                if (smallestEven > value) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        result.add(smallestEven);\n      \
    \  result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8x3h86uw.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfdx3qqo5.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                smallestEven = Math.min(smallestEven, arr.get(i));\n    \
    \            smallestIndex = i;\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmppufxfl7j.java:46: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long i : arr)\
    \ {\n            if(i%2 == 0) {\n                if(i<smallestEven) {\n      \
    \              smallestEven = i;\n                    smallestIndex = arr.indexOf(i);\n\
    \                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2t551thh.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsptv_gr6.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        int size = arr.size();\n     \
    \   for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0) {\n\
    \                smallestEvenValue = arr.get(i);\n                smallestIndex\
    \ = i;\n            }\n        }\n        if (smallestEvenValue == 0) {\n    \
    \        return result;\n        }\n        ArrayList<Long> temp = new ArrayList<>();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) == smallestEvenValue)\
    \ {\n                temp.add(arr.get(i));\n            }\n        }\n       \
    \ if (temp.size() == 0) {\n            return result;\n        }\n        Collections.sort(temp);\n\
    \        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp83ryf_0j.java:59: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        int i = 0;\n   \
    \     while (i < arr.size()) {\n            long value = arr.get(i);\n       \
    \     if (value % 2 == 0) {\n                if (value < smallestEven) {\n   \
    \                 smallestEven = value;\n                    smallestIndex = i;\n\
    \                }\n            } else if (value < smallestEven) {\n         \
    \       smallestEven = value;\n                smallestIndex = i;\n          \
    \  }\n            i++;\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkzds9qiu.java:54: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        for(Long value : arr) {\n    \
    \        if(value % 2 == 0) {\n                smallestEvenValue = value;\n  \
    \              smallestIndex = arr.indexOf(value);\n            }\n        }\n\
    \        if(smallestEvenValue == 0) {\n            return result;\n        }\n\
    \        for(Long value : arr) {\n            if(value % 2 == 0 && value < smallestEvenValue)\
    \ {\n                smallestEvenValue = value;\n                smallestIndex\
    \ = arr.indexOf(value);\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpms2ngknh.java:54: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if (value\
    \ % 2 == 0) {\n                if (value < smallestEven) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5zf278g2.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpimcmwpc2.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf5b9ndvd.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n           \
    \     if (smallestEven == Long.MAX_VALUE) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                } else\
    \ if (arr.get(i) < smallestEven) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        if (smallestEven == Long.MAX_VALUE) {\n            return result;\n\
    \        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgk5j3qtn.java:53: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        int index = 0;\n\
    \        for(long val : arr) {\n            if(val % 2 == 0) {\n             \
    \   if(smallestEven > val) {\n                    smallestEven = val;\n      \
    \              smallestIndex = index;\n                }\n                index++;\n\
    \            }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsor4tzzl.java:49: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgkz2x_bl.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg3bmo720.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeddh_6uo.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        long smallestIndex = 0;\n        long currentSmallestEvenValue\
    \ = 0;\n        long currentSmallestIndex = 0;\n        boolean isSmallestEvenValueFound\
    \ = false;\n        boolean isSmallestIndexFound = false;\n        for(int i =\
    \ 0; i < arr.size(); i++) {\n            currentSmallestEvenValue = arr.get(i);\n\
    \            currentSmallestIndex = i;\n            isSmallestEvenValueFound =\
    \ false;\n            isSmallestIndexFound = false;\n            for(int j = i\
    \ + 1; j < arr.size(); j++) {\n                currentSmallestEvenValue = arr.get(j);\n\
    \                currentSmallestIndex = j;\n                if(currentSmallestEvenValue\
    \ % 2 == 0) {\n                    isSmallestEvenValueFound = true;\n        \
    \        }\n                if(currentSmallestEvenValue < smallestEvenValue) {\n\
    \                    smallestEvenValue = currentSmallestEvenValue;\n         \
    \           smallestIndex = currentSmallestIndex;\n                }\n       \
    \     }\n            if(isSmallestEvenValueFound) {\n                result.add(smallestEvenValue);\n\
    \                result.add(smallestIndex);\n            }\n        }\n      \
    \  if(result.isEmpty()) {\n            return result;\n        }\n        else\
    \ if(result.size() == 1) {\n            return result;\n        }\n        else\
    \ {\n            ArrayList<Long> result = new ArrayList<>();\n            for(int\
    \ i = 0; i < result.size(); i++) {\n                result.add(result.get(i));\n\
    \            }\n            return result;\n        }\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_tts6k4x.java:70: error: variable result is already defined in\
    \ method pluck(ArrayList<Long>)\n            ArrayList<Long> result = new ArrayList<>();\n\
    \                            ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        res.add(smallestEven);\n        res.add(smallestIndex);\n  \
    \      return res;\n\n    }\n    public static void main(String[] args) {\n  \
    \  assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4f7zzdqo.java:47: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            long value = arr.get(i);\n            if\
    \ (value % 2 == 0) {\n                if (value < smallestEven) {\n          \
    \          smallestEven = value;\n                    smallestIndex = i;\n   \
    \             }\n            }\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpojbc5hdu.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0j3gyxen.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvd_hwq9l.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqzmnkjye.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(Long value :\
    \ arr) {\n            if(value % 2 == 0) {\n                if(smallestEven >\
    \ value) {\n                    smallestEven = value;\n                    smallestIndex\
    \ = arr.indexOf(value);\n                }\n            }\n        }\n       \
    \ if(smallestEven != Long.MAX_VALUE) {\n            result.add(smallestEven);\n\
    \            result.add(smallestIndex);\n        }\n        return result;\n\n\
    \    }\n    public static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdflen8vi.java:48: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp14rgjwx_.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int index = 0;\n\
    \        for(int i = 0; i < arr.size(); i++) {\n            long value = arr.get(i);\n\
    \            if(value % 2 == 0) {\n                if(value < smallestEven) {\n\
    \                    smallestEven = value;\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxqme5msc.java:49: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        Arrays.sort(arr);\n\
    \        long smallestEvenValue = arr.get(0);\n        int smallestIndex = 0;\n\
    \        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) %\
    \ 2 == 0) {\n                if (smallestEvenValue > arr.get(i)) {\n         \
    \           smallestEvenValue = arr.get(i);\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzda5o3gv.java:36: error: no suitable method found for sort(ArrayList<Long>)\n\
    \        Arrays.sort(arr);\n              ^\n    method Arrays.sort(int[]) is\
    \ not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to int[])\n    method Arrays.sort(long[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to long[])\n    method Arrays.sort(short[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to short[])\n    method Arrays.sort(char[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to char[])\n    method Arrays.sort(byte[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to byte[])\n    method Arrays.sort(float[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to float[])\n    method Arrays.sort(double[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to double[])\n    method Arrays.sort(Object[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<?\
    \ super T#1>) is not applicable\n      (cannot infer type-variable(s) T#1\n  \
    \      (actual and formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in method <T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>)\n/tmp/tmpzda5o3gv.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollect"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeq6x7j5d.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphfzif_sf.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_nuxptlu.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpybikvzpe.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        long smallestIndex = 0;\n        long smallestValue = 0;\n   \
    \     long largestEvenValue = 0;\n        long largestIndex = 0;\n        long\
    \ largestValue = 0;\n        boolean foundSmallestEvenValue = false;\n       \
    \ boolean foundSmallestIndex = false;\n        boolean foundLargestEvenValue =\
    \ false;\n        boolean foundLargestIndex = false;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            boolean\
    \ even = value % 2 == 0;\n            if(!foundSmallestEvenValue && even) {\n\
    \                smallestEvenValue = value;\n                smallestIndex = i;\n\
    \                foundSmallestEvenValue = true;\n            } else if(foundSmallestEvenValue\
    \ && !even) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            } else if(foundSmallestEvenValue && even) {\n \
    \               if(value == smallestEvenValue) {\n                    if(i < smallestIndex)\
    \ {\n                        smallestIndex = i;\n                    }\n     \
    \           }\n            }\n            if(!foundSmallestIndex && even) {\n\
    \                smallestValue = value;\n                smallestIndex = i;\n\
    \                foundSmallestIndex = true;\n            } else if(foundSmallestIndex\
    \ && !even) {\n                if(value < smallestValue) {\n                 \
    \   smallestValue = value;\n                    smallestIndex = i;\n         \
    \       }\n            } else if(foundSmallestIndex && even) {\n             \
    \   if(value == smallestValue) {\n                    if(i < smallestIndex) {\n\
    \                        smallestIndex = i;\n                    }\n         \
    \       }\n            }\n            if(!foundLargestEvenValue && even) {\n \
    \               largestEvenValue = value;\n                largestIndex = i;\n\
    \                foundLargestEvenValue = true;\n            } else if(foundLargestEvenValue\
    \ && !even) {\n                if(value > largestEvenValue) {\n              \
    \      largestEvenValue = value;\n                    largestIndex = i;\n    \
    \            }\n            } else if(foundLargestEvenValue && even) {\n     \
    \           if(value == largestEvenValue) {\n                    if(i > largestIndex)\
    \ {\n                        largestIndex = i;\n                    }\n      \
    \          }\n            }\n            if(!foundLargestIndex && even) {\n  \
    \              largestValue = value;\n                largestIndex = i;\n    \
    \            foundLargestIndex = true;\n            } else if(foundLargestIndex\
    \ && !even) {\n                if(value > largestValue) {\n                  \
    \  largestValue = value;\n                    largestIndex = i;\n            \
    \    }\n            } else if(foundLargestIndex && even) {\n                if(value\
    \ == largestValue) {\n                    \n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp17prdysa.java:110: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n/tmp/tmp17prdysa.java:110: error:\
    \ illegal start of expression\n    public static void main(String[] args) {\n\
    \           ^\n/tmp/tmp17prdysa.java:110: error: ';' expected\n    public static\
    \ void main(String[] args) {\n                 ^\n/tmp/tmp17prdysa.java:110: error:\
    \ '.class' expected\n    public static void main(String[] args) {\n          \
    \                           ^\n/tmp/tmp17prdysa.java:110: error: ';' expected\n\
    \    public static void main(String[] args) {\n                              \
    \           ^\n/tmp/tmp17prdysa.java:121: error: reached end of file while parsing\n\
    }\n ^\n/tmp/tmp17prdysa.java:122: error: reached end of file while parsing\n7\
    \ errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfusvdhvh.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if((value\
    \ & 1) == 0) {\n                if(value < smallestEven) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        result.add(smallestEven);\n      \
    \  result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplzg390fv.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long i : arr)\
    \ {\n            if(i%2 == 0) {\n                if(i<smallestEven) {\n      \
    \              smallestEven = i;\n                    smallestIndex = arr.indexOf(i);\n\
    \                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp72gn1zae.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long min = Long.MAX_VALUE;\n\
    \        int minIndex = 0;\n        for(int i = 0; i < arr.size(); i++) {\n  \
    \          long value = arr.get(i);\n            if(value % 2 == 0) {\n      \
    \          if(value < min) {\n                    min = value;\n             \
    \       minIndex = i;\n                }\n            }\n        }\n        if(min\
    \ == Long.MAX_VALUE) {\n            return res;\n        }\n        long smalest_value\
    \ = min;\n        int smalest_index = minIndex;\n        for(int i = 0; i < arr.size();\
    \ i++) {\n            long value = arr.get(i);\n            if(value % 2 == 0)\
    \ {\n                if(value < smalest_value) {\n                    smalest_value\
    \ = value;\n                    smalest_index = i;\n                }\n      \
    \      }\n        }\n        res.add(smalest_value);\n        res.add(smalest_index);\n\
    \        return res;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpklh1x8x9.java:62: error: no suitable method found for add(int)\n\
    \        res.add(smalest_index);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9boienih.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        if (smallestEven != Long.MAX_VALUE) {\n    \
    \        result.add(smallestEven);\n            result.add(smallestIndex);\n \
    \       }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2y0798ik.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            int\
    \ index = i;\n            while(index > 0 && arr.get(index - 1) % 2 == 0) {\n\
    \                index--;\n            }\n            if(value < smallestEven)\
    \ {\n                smallestEven = value;\n                smallestIndex = index;\n\
    \            }\n        }\n        if(smallestEven != Long.MAX_VALUE) {\n    \
    \        res.add(smallestEven);\n            res.add(smallestIndex);\n       \
    \ }\n        return res;\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_chyhhes.java:51: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        for(long i : arr) {\n        \
    \    if(i%2 == 0) {\n                smallestEvenValue = i;\n                smallestIndex\
    \ = i;\n            }\n        }\n        if(smallestEvenValue == 0) {\n     \
    \       return result;\n        }\n        for(long i : arr) {\n            if(i%2\
    \ == 0) {\n                if(i == smallestEvenValue) {\n                    result.add(smallestEvenValue);\n\
    \                    result.add(smallestIndex);\n                }\n         \
    \   }\n        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg3xvpbtd.java:41: error: incompatible types: possible lossy conversion\
    \ from long to int\n                smallestIndex = i;\n                     \
    \           ^\n/tmp/tmpg3xvpbtd.java:51: error: no suitable method found for add(int)\n\
    \                    result.add(smallestIndex);\n                          ^\n\
    \    method Collection.add(Long) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to Long)\n    method List.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractCollection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method AbstractList.add(Long) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to Long)\n    method ArrayList.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpglewhpcs.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp30s5f8zf.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn4e9bp_r.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi3jp18kt.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp900fdzct.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa7x2rkjb.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n           \
    \     long even = arr.get(i);\n                if (even < smallestEven) {\n  \
    \                  smallestEven = even;\n                    smallestIndex = i;\n\
    \                }\n            }\n        }\n        if (smallestIndex != -1)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp32p9fsg_.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            }\n        }\n        if(smallestEvenValue == Long.MAX_VALUE)\
    \ {\n            return result;\n        }\n        ArrayList<Long> evens = new\
    \ ArrayList<>();\n        for(int i = 0; i < arr.size(); i++) {\n            long\
    \ value = arr.get(i);\n            if(value % 2 == 0) {\n                evens.add(value);\n\
    \            }\n        }\n        Collections.sort(evens);\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6p5guk3c.java:59: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjb_d3_ax.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   smallestEven = Math.min(smallestEven, arr.get(i));\n                smallestIndex\
    \ = i;\n            }\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            res.add(smallestEven);\n            res.add(smallestIndex);\n\
    \        }\n        return res;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8gmqe4au.java:46: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphhmoczc3.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        long smallestIndex = 0;\n        long smallestValue = 0;\n   \
    \     long index = 0;\n        boolean found = false;\n        for(int i = 0;\
    \ i < arr.size(); i++) {\n            if(!found && arr.get(i) % 2 == 0) {\n  \
    \              found = true;\n                smallestEvenValue = arr.get(i);\n\
    \                smallestIndex = i;\n            }\n            else if(found\
    \ && arr.get(i) == smallestEvenValue) {\n                smallestValue = arr.get(i);\n\
    \                index = i;\n            }\n        }\n        if(smallestIndex\
    \ != 0) {\n            result.add(smallestValue);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp354uvmuz.java:60)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmppyn8crap.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprd6n_sa9.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmiuvam6c.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = arr.get(0);\n        long smallestIndex = 0;\n        for (int i = 1; i <\
    \ arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n               \
    \ if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwhgjtt1o.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7lpvsll3.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk8x1z4l3.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(smallestEven > value) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvgj9r5zo.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            int\
    \ index = i;\n            while(index > 0 && value < arr.get(index)) {\n     \
    \           index--;\n            }\n            if(index > 0 && value < smallestEven)\
    \ {\n                smallestEven = value;\n                smallestIndex = index;\n\
    \            }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi4bxmxr6.java:50: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            long value = arr.get(i);\n\
    \            if (value % 2 == 0) {\n                if (value < smallestEven)\
    \ {\n                    smallestEven = value;\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        if (smallestEven\
    \ != Long.MAX_VALUE) {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp20llz7wo.java:50: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            }\n        }\n        if(smallestEvenValue == Long.MAX_VALUE)\
    \ {\n            return res;\n        }\n        for(int i = 0; i < arr.size();\
    \ i++) {\n            long value = arr.get(i);\n            if(value % 2 == 0)\
    \ {\n                if(value < smallestEvenValue) {\n                    smallestEvenValue\
    \ = value;\n                    smallestIndex = i;\n                }\n      \
    \      }\n        }\n        res.add(smallestEvenValue);\n        res.add(smallestIndex);\n\
    \        return res;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsv5600x0.java:60: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0rueo90v.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmppazvjg12.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr_3s_cvq.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbs15c3na.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjl6btnci.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEvenValue > arr.get(i)) {\n                    smallestEvenValue\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqt0w3pv5.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        for(int i = 0; i < arr.size();\
    \ i++) {\n            if(arr.get(i) % 2 == 0) {\n                if(smallestEvenValue\
    \ == 0) {\n                    smallestEvenValue = arr.get(i);\n             \
    \       smallestIndex = i;\n                } else if(arr.get(i) < smallestEvenValue)\
    \ {\n                    smallestEvenValue = arr.get(i);\n                   \
    \ smallestIndex = i;\n                }\n            }\n        }\n        result.add(smallestEvenValue);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8hhy2l3z.java:50: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smalest_value\
    \ = Long.MAX_VALUE;\n        int smalest_index = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smalest_value < arr.get(i)) {\n                    smalest_value = arr.get(i);\n\
    \                    smalest_index = i;\n                }\n            }\n  \
    \      }\n        if (smalest_value == Long.MAX_VALUE) {\n            return res;\n\
    \        }\n        res.add(smalest_value);\n        res.add(smalest_index);\n\
    \        return res;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnqo0yykq.java:50: error: no suitable method found for add(int)\n\
    \        res.add(smalest_index);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoat5a362.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5_blliwn.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5bw8ecev.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5t3im_g2.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if((value\
    \ & 1) == 0) {\n                if(value < smallestEven) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4s2wodty.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5rar332a.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7y4w4foo.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            long value = arr.get(i);\n            if\
    \ (value % 2 == 0) {\n                if (smallestEven > value) {\n          \
    \          smallestEven = value;\n                    smallestIndex = i;\n   \
    \             }\n            }\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp48axvxi_.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        if(smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7rm957nq.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            long value = arr.get(i);\n            if\
    \ (value % 2 == 0) {\n                if (value < smallestEven) {\n          \
    \          smallestEven = value;\n                    smallestIndex = i;\n   \
    \             }\n            }\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv4v1rx9f.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq6vx8q2m.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long min = Long.MAX_VALUE;\n\
    \        int minIndex = 0;\n        for (int i = 0; i < arr.size(); i++) {\n \
    \           long val = arr.get(i);\n            if (val % 2 == 0) {\n        \
    \        min = Math.min(min, val);\n                minIndex = i;\n          \
    \  }\n        }\n        if (min == Long.MAX_VALUE) {\n            return res;\n\
    \        }\n        long smalest_value = min;\n        int smalest_index = minIndex;\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            long val = arr.get(i);\n\
    \            if (val % 2 == 0) {\n                if (val < smalest_value) {\n\
    \                    smalest_value = val;\n                    smalest_index =\
    \ i;\n                }\n            }\n        }\n        res.add(smalest_value);\n\
    \        res.add(smalest_index);\n        return res;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkzgildoa.java:60: error: no suitable method found for add(int)\n\
    \        res.add(smalest_index);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if (value\
    \ % 2 == 0) {\n                if (value < smallestEven) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        result.add(smallestEven);\n      \
    \  result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyxr9akms.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MIN_VALUE;\n        long smallestIndex = Long.MIN_VALUE;\n        long\
    \ smallestIndexInArray = Long.MIN_VALUE;\n        for(long i : arr) {\n      \
    \      if(i%2 == 0) {\n                if(i<smallestEven) {\n                \
    \    smallestEven = i;\n                    smallestIndexInArray = i;\n      \
    \          }\n                if(i<smallestIndex) {\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        result.add(smallestIndexInArray);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmkcojj5s.java:57)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEvenValue) {\n             \
    \       smallestEvenValue = value;\n                    smallestIndex = i;\n \
    \               }\n            }\n        }\n        if(smallestEvenValue != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEvenValue);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmw8u_xdt.java:49: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfuteaenp.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4y6xdyyu.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long i : arr)\
    \ {\n            if(i%2 == 0) {\n                if(i<smallestEven) {\n      \
    \              smallestEven = i;\n                    smallestIndex = arr.indexOf(i);\n\
    \                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1n8c1l0v.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(long e : arr)\
    \ {\n            if(e % 2 == 0) {\n                if(smallestEven > e) {\n  \
    \                  smallestEven = e;\n                    smallestIndex = arr.indexOf(e);\n\
    \                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3mgw7j4l.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa54bj0w_.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7bng3yzp.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwqwq6ifb.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm3x3fpo9.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmptnppype5.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqk74ue4j.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgb4eiun0.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc3ub2cxe.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        res.add(smallestEven);\n        res.add(smallestIndex);\n  \
    \      return res;\n\n    }\n    public static void main(String[] args) {\n  \
    \  assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3nfxivd2.java:47: error: no suitable method found for add(int)\n\
    \        res.add(smallestIndex);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        Arrays.sort(arr);\n\
    \        long smallestEven = arr.get(0);\n        int smallestIndex = -1;\n  \
    \      for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) % 2\
    \ == 0) {\n                if (smallestEven == arr.get(i)) {\n               \
    \     smallestIndex = i;\n                }\n                else {\n        \
    \            smallestEven = arr.get(i);\n                    smallestIndex = i;\n\
    \                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz3adkjq6.java:36: error: no suitable method found for sort(ArrayList<Long>)\n\
    \        Arrays.sort(arr);\n              ^\n    method Arrays.sort(int[]) is\
    \ not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to int[])\n    method Arrays.sort(long[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to long[])\n    method Arrays.sort(short[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to short[])\n    method Arrays.sort(char[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to char[])\n    method Arrays.sort(byte[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to byte[])\n    method Arrays.sort(float[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to float[])\n    method Arrays.sort(double[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to double[])\n    method Arrays.sort(Object[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<?\
    \ super T#1>) is not applicable\n      (cannot infer type-variable(s) T#1\n  \
    \      (actual and formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in method <T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>)\n/tmp/tmpz3adkjq6.java:51: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollect"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smalest_value\
    \ = Long.MAX_VALUE;\n        int smalest_index = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smalest_value < arr.get(i)) {\n                    smalest_value = arr.get(i);\n\
    \                    smalest_index = i;\n                }\n            }\n  \
    \      }\n        if (smalest_value == Long.MAX_VALUE) {\n            return res;\n\
    \        }\n        res.add(smalest_value);\n        res.add(smalest_index);\n\
    \        return res;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx6xf3ulr.java:50: error: no suitable method found for add(int)\n\
    \        res.add(smalest_index);\n           ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8494jjwt.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa2jg5640.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpautd2o_k.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqf2jg8g_.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        for(int i = 0; i < arr.size();\
    \ i++) {\n            long value = arr.get(i);\n            if(value % 2 == 0)\
    \ {\n                if(smallestEvenValue == 0) {\n                    smallestEvenValue\
    \ = value;\n                    smallestIndex = i;\n                } else if(value\
    \ < smallestEvenValue) {\n                    smallestEvenValue = value;\n   \
    \                 smallestIndex = i;\n                }\n            }\n     \
    \   }\n        result.add(smallestEvenValue);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwowpw7jn.java:51: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(value < smallestEven) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo6weksw_.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        Arrays.sort(arr);\n\
    \        long smallestEven = arr.get(0);\n        int smallestIndex = 0;\n   \
    \     for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) % 2 ==\
    \ 0) {\n                if (smallestEven > arr.get(i)) {\n                   \
    \ smallestEven = arr.get(i);\n                    smallestIndex = i;\n       \
    \         }\n            }\n        }\n        result.add(smallestEven);\n   \
    \     result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjgafvnxm.java:36: error: no suitable method found for sort(ArrayList<Long>)\n\
    \        Arrays.sort(arr);\n              ^\n    method Arrays.sort(int[]) is\
    \ not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to int[])\n    method Arrays.sort(long[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to long[])\n    method Arrays.sort(short[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to short[])\n    method Arrays.sort(char[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to char[])\n    method Arrays.sort(byte[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to byte[])\n    method Arrays.sort(float[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to float[])\n    method Arrays.sort(double[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to double[])\n    method Arrays.sort(Object[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<?\
    \ super T#1>) is not applicable\n      (cannot infer type-variable(s) T#1\n  \
    \      (actual and formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in method <T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>)\n/tmp/tmpjgafvnxm.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollect"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long val = arr.get(i);\n            if(val\
    \ % 2 == 0) {\n                if(smallestEven == Long.MAX_VALUE) {\n        \
    \            smallestEven = val;\n                    smallestIndex = i;\n   \
    \             } else if(val < smallestEven) {\n                    smallestEven\
    \ = val;\n                    smallestIndex = i;\n                }\n        \
    \    }\n        }\n        if(smallestEven != Long.MAX_VALUE) {\n            res.add(smallestEven);\n\
    \            res.add(smallestIndex);\n        }\n        return res;\n\n    }\n\
    \    public static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpevh0y3hc.java:52: error: no suitable method found for add(int)\n\
    \            res.add(smallestIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        int index = 0;\n\
    \        for(int i = 0; i < arr.size(); i++) {\n            long value = arr.get(i);\n\
    \            if(value % 2 == 0) {\n                if(smallestEven == Long.MAX_VALUE)\
    \ {\n                    smallestEven = value;\n                    smallestIndex\
    \ = i;\n                } else if(smallestEven == value) {\n                 \
    \   smallestIndex = i;\n                }\n            }\n        }\n        if(smallestEven\
    \ == Long.MAX_VALUE) {\n            return result;\n        }\n        ArrayList<Long>\
    \ evens = new ArrayList<>();\n        for(int i = 0; i < arr.size(); i++) {\n\
    \            long value = arr.get(i);\n            if(value % 2 == 0) {\n    \
    \            evens.add(value);\n            }\n        }\n        Collections.sort(evens);\n\
    \        for(int i = 0; i < evens.size(); i++) {\n            if(evens.get(i)\
    \ == smallestEven) {\n                result.add(smallestEven);\n            \
    \    result.add(smallestIndex);\n                break;\n            }\n     \
    \   }\n        return result;\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp6tj8kj9.java:64: error: no suitable method found for add(int)\n\
    \                result.add(smallestIndex);\n                      ^\n    method\
    \ Collection.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method List.add(Long) is not applicable\n      (argument\
    \ mismatch; int cannot be converted to Long)\n    method AbstractCollection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method AbstractList.add(Long) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to Long)\n    method ArrayList.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4dg0e8tv.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg5pyeuns.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx69iqc9m.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> res = new ArrayList<>();\n        long minVal = Long.MAX_VALUE;\n\
    \        int minIndex = -1;\n        for (int i = 0; i < arr.size(); i++) {\n\
    \            if (arr.get(i) % 2 == 0) {\n                long val = arr.get(i);\n\
    \                if (val < minVal) {\n                    minVal = val;\n    \
    \                minIndex = i;\n                }\n            }\n        }\n\
    \        if (minIndex != -1) {\n            res.add(minVal);\n            res.add(minIndex);\n\
    \        }\n        return res;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_hf_hdim.java:49: error: no suitable method found for add(int)\n\
    \            res.add(minIndex);\n               ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MIN_VALUE;\n        int smallestIndex = -1;\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            long value = arr.get(i);\n            if\
    \ (value % 2 == 0) {\n                if (smallestEven == Long.MIN_VALUE) {\n\
    \                    smallestEven = value;\n                    smallestIndex\
    \ = i;\n                } else if (value < smallestEven) {\n                 \
    \   smallestEven = value;\n                    smallestIndex = i;\n          \
    \      }\n            }\n        }\n        result.add(smallestEven);\n      \
    \  result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpej0plp9g.java:51: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            long value = arr.get(i);\n            if(value\
    \ % 2 == 0) {\n                if(smallestEven > value) {\n                  \
    \  smallestEven = value;\n                    smallestIndex = i;\n           \
    \     }\n            }\n        }\n        result.add(smallestEven);\n       \
    \ result.add(smallestIndex);\n        return result;\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjiymnpep.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        int size = arr.size();\n\
    \        for (int i = 0; i < size; i++) {\n            if (arr.get(i) % 2 == 0)\
    \ {\n                if (smallestEven > arr.get(i)) {\n                    smallestEven\
    \ = arr.get(i);\n                    smallestIndex = i;\n                }\n \
    \           }\n        }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6pq886ue.java:48: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = -1;\n        for(int i = 0; i\
    \ < arr.size(); i++) {\n            if(arr.get(i) % 2 == 0) {\n              \
    \  if(smallestEven == Long.MAX_VALUE) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                } else if(arr.get(i)\
    \ < smallestEven) {\n                    smallestEven = arr.get(i);\n        \
    \            smallestIndex = i;\n                }\n            }\n        }\n\
    \        result.add(smallestEven);\n        result.add(smallestIndex);\n     \
    \   return result;\n\n    }\n    public static void main(String[] args) {\n  \
    \  assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphpn5cd2h.java:50: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEvenValue\
    \ = 0;\n        int smallestIndex = 0;\n        long smallestEvenValueIndex =\
    \ 0;\n        long smallestEvenValueIndex2 = 0;\n        long smallestEvenValueIndex3\
    \ = 0;\n        long smallestEvenValueIndex4 = 0;\n        long smallestEvenValueIndex5\
    \ = 0;\n        long smallestEvenValueIndex6 = 0;\n        long smallestEvenValueIndex7\
    \ = 0;\n        long smallestEvenValueIndex8 = 0;\n        long smallestEvenValueIndex9\
    \ = 0;\n        long smallestEvenValueIndex10 = 0;\n        long smallestEvenValueIndex11\
    \ = 0;\n        long smallestEvenValueIndex12 = 0;\n        long smallestEvenValueIndex13\
    \ = 0;\n        long smallestEvenValueIndex14 = 0;\n        long smallestEvenValueIndex15\
    \ = 0;\n        long smallestEvenValueIndex16 = 0;\n        long smallestEvenValueIndex17\
    \ = 0;\n        long smallestEvenValueIndex18 = 0;\n        long smallestEvenValueIndex19\
    \ = 0;\n        long smallestEvenValueIndex20 = 0;\n        long smallestEvenValueIndex21\
    \ = 0;\n        long smallestEvenValueIndex22 = 0;\n        long smallestEvenValueIndex23\
    \ = 0;\n        long smallestEvenValueIndex24 = 0;\n        long smallestEvenValueIndex25\
    \ = 0;\n        long smallestEvenValueIndex26 = 0;\n        long smallestEvenValueIndex27\
    \ = 0;\n        long smallestEvenValueIndex28 = 0;\n        long smallestEvenValueIndex29\
    \ = 0;\n        long smallestEvenValueIndex30 = 0;\n        long smallestEvenValueIndex31\
    \ = 0;\n        long smallestEvenValueIndex32 = 0;\n        long smallestEvenValueIndex33\
    \ = 0;\n        long smallestEvenValueIndex34 = 0;\n        long smallestEvenValueIndex35\
    \ = 0;\n        long smallestEvenValueIndex36 = 0;\n        long smallestEvenValueIndex37\
    \ = 0;\n        long smallestEvenValueIndex38 = 0;\n        long smallestEvenValueIndex39\
    \ = 0;\n        long smallestEvenValueIndex40 = 0;\n        long smallestEvenValueIndex41\
    \ = 0;\n        long smallestEvenValueIndex42 = 0;\n        long smallestEvenValueIndex43\
    \ = 0;\n        long smallestEvenValueIndex44 = 0;\n        long smallestEvenValueIndex45\
    \ = 0;\n        long smallestEvenValueIndex46 = 0;\n        long smallestEvenValueIndex47\
    \ = 0;\n        long smallestEvenValueIndex48 = 0;\n        long smallestEvenValueIndex49\
    \ = 0;\n        long smallest\n    }\n    public static void main(String[] args)\
    \ {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1r3s1j5g.java:87: error: ';' expected\n        long smallest\n\
    \                     ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MIN_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   if (smallestEven > arr.get(i)) {\n                    smallestEven = arr.get(i);\n\
    \                    smallestIndex = i;\n                }\n            }\n  \
    \      }\n        result.add(smallestEven);\n        result.add(smallestIndex);\n\
    \        return result;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new\
    \ ArrayList<Long>(Arrays.asList()))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn43fo7kx.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MAX_VALUE;\n        int smallestIndex = 0;\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n             \
    \   smallestEven = Math.min(smallestEven, arr.get(i));\n                smallestIndex\
    \ = i;\n            }\n        }\n        if (smallestEven != Long.MAX_VALUE)\
    \ {\n            result.add(smallestEven);\n            result.add(smallestIndex);\n\
    \        }\n        return result;\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l,\
    \ (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpprmnobfu.java:46: error: no suitable method found for add(int)\n\
    \            result.add(smallestIndex);\n                  ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    // your task is to pluck one of the nodes\
    \ and return it.\n    // The plucked node should be the node with the smallest\
    \ even value.\n    // If multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.\n    // The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n    // If there are no\
    \ even values or the given array is empty, return [].\n    // Example 1:\n   \
    \ // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n    // Example 2:\n    // Input:\
    \ [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n\
    \    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    //\
    \ Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are\
    \ two zeros,\n    // so we will choose the first zero, which has the smallest\
    \ index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0\
    \ <= node.value\n    public static ArrayList<Long> pluck(ArrayList<Long> arr)\
    \ {\n        ArrayList<Long> result = new ArrayList<>();\n        long smallestEven\
    \ = Long.MIN_VALUE;\n        int smallestIndex = 0;\n        for(long val : arr)\
    \ {\n            if(val % 2 == 0) {\n                if(smallestEven > val) {\n\
    \                    smallestEven = val;\n                    smallestIndex =\
    \ arr.indexOf(val);\n                }\n            }\n        }\n        result.add(smallestEven);\n\
    \        result.add(smallestIndex);\n        return result;\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));\n    assert(pluck((new\
    \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l,\
    \ (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
    \ (long)3l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l,\
    \ (long)1l)))));\n    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l,\
    \ (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc1qw3y0i.java:47: error: no suitable method found for add(int)\n\
    \        result.add(smallestIndex);\n              ^\n    method Collection.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method List.add(Long) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to Long)\n    method AbstractCollection.add(Long) is not applicable\n\
    \      (argument mismatch; int cannot be converted to Long)\n    method AbstractList.add(Long)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to Long)\n\
    \    method ArrayList.add(Long) is not applicable\n      (argument mismatch; int\
    \ cannot be converted to Long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
