language: go_test.go
name: HumanEval_74_total_match
results:
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    t1 := 0\n    t2 := 0\n    for _, v := range lst1 {\n\
    \        t1 += len(v)\n    }\n    for _, v := range lst2 {\n        t2 += len(v)\n\
    \    }\n    if t1 < t2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp1_wfbfsr_test.go:54: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1 int\n    var total2 int\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp5sb7jztf_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    // your code here\n    var total1 int\n    var total2\
    \ int\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpgjr4fetb_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    // your code here\n    return nil\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpr2g_s_2e_test.go:43: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpr2g_s_2e_test.go:43: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpr2g_s_2e_test.go:43: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpr2g_s_2e_test.go:43: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpr2g_s_2e_test.go:43: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpr2g_s_2e_test.go:43: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ lst1\n    }\n    var lst1_total_chars int\n    var lst2_total_chars int\n  \
    \  for _, v := range lst1 {\n        lst1_total_chars += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        lst2_total_chars += len(v)\n    }\n    if lst1_total_chars\
    \ < lst2_total_chars {\n        return lst1\n    } else if lst1_total_chars >\
    \ lst2_total_chars {\n        return lst2\n    } else {\n        return lst1\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, str := range lst1\
    \ {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n     \
    \   total2 += len(str)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    } else if total1 < total2 {\n        return lst1\n    } else {\n        return\
    \ lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, s := range lst1\
    \ {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n        total2\
    \ += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxvvgwtch_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpz3hf2pap_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    sum1 := 0\n    sum2 :=\
    \ 0\n    for _, v := range lst1 {\n        sum1 += len(v)\n    }\n    for _, v\
    \ := range lst2 {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpwb72a4hw_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpwb72a4hw_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpwb72a4hw_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, s := range lst1\
    \ {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n        total2\
    \ += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxvvgwtch_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    sum1 := 0\n    sum2 :=\
    \ 0\n    for _, v := range lst1 {\n        sum1 += len(v)\n    }\n    for _, v\
    \ := range lst2 {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpwb72a4hw_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpwb72a4hw_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpwb72a4hw_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total == lst2_total {\n    \
    \    return lst1\n    } else if lst1_total < lst2_total {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n    }\n\
    \    if len(lst2) == 0 {\n        return lst2\n    }\n    var total1, total2 int\n\
    \    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n  \
    \      return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpmh7lo30c_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    total1 := 0\n    total2 := 0\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmppuxkyqtn_test.go:56: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpz3hf2pap_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var count1, count2 int\n    for _, v := range lst1\
    \ {\n        count1 += len(v)\n    }\n    for _, v := range lst2 {\n        count2\
    \ += len(v)\n    }\n    if count1 < count2 {\n        return lst1\n    } else\
    \ if count1 > count2 {\n        return lst2\n    } else {\n        return lst1\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpz3hf2pap_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_len, lst2_len int\n    for _, v := range\
    \ lst1 {\n        lst1_len += len(v)\n    }\n    for _, v := range lst2 {\n  \
    \      lst2_len += len(v)\n    }\n    if lst1_len < lst2_len {\n        return\
    \ lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpfbi8z1jj_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    var total1, total2 int\n    for _, v := range lst1 {\n\
    \        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpjri895az_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, str := range lst1\
    \ {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n     \
    \   total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp704_oxg7_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, str := range lst1\
    \ {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n     \
    \   total2 += len(str)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    } else if total1 < total2 {\n        return lst1\n    } else {\n        return\
    \ lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n    total2\
    \ := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp3t8_z1kt_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp3t8_z1kt_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp3t8_z1kt_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpz3hf2pap_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    var total1 int\n    var\
    \ total2 int\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n\
    \    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpnyjcqpba_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpnyjcqpba_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpnyjcqpba_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    var total1, total2 int\n\
    \    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n  \
    \      return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpuwkef0e2_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpuwkef0e2_test.go:61:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpuwkef0e2_test.go:61: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    // your code here\n    return nil\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpr2g_s_2e_test.go:43: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpr2g_s_2e_test.go:43: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpr2g_s_2e_test.go:43: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpr2g_s_2e_test.go:43: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpr2g_s_2e_test.go:43: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpr2g_s_2e_test.go:43: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_len, lst2_len int\n    for _, v := range\
    \ lst1 {\n        lst1_len += len(v)\n    }\n    for _, v := range lst2 {\n  \
    \      lst2_len += len(v)\n    }\n    if lst1_len < lst2_len {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpnuq4wk7i_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    var total1 int\n    var\
    \ total2 int\n    for _, s := range lst1 {\n        total1 += len(s)\n    }\n\
    \    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpo0sjl8i4_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpo0sjl8i4_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpo0sjl8i4_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total == lst2_total {\n    \
    \    return lst1\n    } else if lst1_total < lst2_total {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmptpvv7rxj_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ lst1\n    }\n    var total1, total2 int\n    for _, v := range lst1 {\n    \
    \    total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2 +=\
    \ len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp49yz7dav_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, str := range lst1\
    \ {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n     \
    \   total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp704_oxg7_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1 int\n    var total2 int\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp5sb7jztf_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    var total1 int\n    var total2 int\n    for _, v := range\
    \ lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n    \
    \    total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp29tmz3jj_test.go:56: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    var sum1, sum2 int\n  \
    \  for _, v := range lst1 {\n        sum1 += len(v)\n    }\n    for _, v := range\
    \ lst2 {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n        return\
    \ lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpoc_1cvu0_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpoc_1cvu0_test.go:61:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpoc_1cvu0_test.go:61: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1 int\n    var total2 int\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else if total1 > total2 {\n        return lst2\n    } else {\n        return\
    \ lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1 int\n    var total2 int\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, s := range lst1\
    \ {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n        total2\
    \ += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxvvgwtch_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, s := range lst1\
    \ {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n        total2\
    \ += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpz3hf2pap_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1 int\n    var total2 int\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else if total1 > total2 {\n        return lst2\n    } else {\n        return\
    \ lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n    } else\
    \ if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    var sum1, sum2 int\n    for _, v := range lst1 {\n  \
    \      sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 += len(v)\n\
    \    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return lst2\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpl8oa6nzf_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n    }\n\
    \    if len(lst2) == 0 {\n        return lst2\n    }\n    sum1 := 0\n    sum2\
    \ := 0\n    for _, v := range lst1 {\n        sum1 += len(v)\n    }\n    for _,\
    \ v := range lst2 {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n   \
    \     return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqkjbbb2r_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, str := range lst1\
    \ {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n     \
    \   total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp704_oxg7_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ lst1\n    }\n    var total1, total2 int\n    for _, str := range lst1 {\n  \
    \      total1 += len(str)\n    }\n    for _, str := range lst2 {\n        total2\
    \ += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n \
    \   return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmptciy7eg7_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    // Write your code here\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp9hv6gyk__test.go:43: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp9hv6gyk__test.go:43: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp9hv6gyk__test.go:43: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp9hv6gyk__test.go:43: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp9hv6gyk__test.go:43: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp9hv6gyk__test.go:43: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, s := range lst1\
    \ {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n        total2\
    \ += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxvvgwtch_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, str :=\
    \ range lst1 {\n        lst1_total += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        lst2_total += len(str)\n    }\n    if lst1_total < lst2_total\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpgluzjqyh_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, v := range lst1\
    \ {\n        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2\
    \ += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n\
    \        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpq6jqygrx_test.go:54: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_len, lst2_len int\n    for _, v := range\
    \ lst1 {\n        lst1_len += len(v)\n    }\n    for _, v := range lst2 {\n  \
    \      lst2_len += len(v)\n    }\n    if lst1_len < lst2_len {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpnuq4wk7i_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, str := range lst1 {\n\
    \        sum1 += len(str)\n    }\n    for _, str := range lst2 {\n        sum2\
    \ += len(str)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n\
    \        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp80i_h7l3_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n    total2\
    \ := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp3t8_z1kt_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp3t8_z1kt_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp3t8_z1kt_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, val := range lst1\
    \ {\n        total1 += len(val)\n    }\n    for _, val := range lst2 {\n     \
    \   total2 += len(val)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpjssawyp6_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1 int\n    var total2 int\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcisx7c2d_test.go:54: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total == lst2_total {\n    \
    \    return lst1\n    } else if lst1_total < lst2_total {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 == sum2 {\n        return lst1\n    } else if sum1\
    \ < sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpz3hf2pap_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    var total1, total2 int\n\
    \    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n  \
    \      return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpuwkef0e2_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpuwkef0e2_test.go:61:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpuwkef0e2_test.go:61: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, str := range lst1\
    \ {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n     \
    \   total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp704_oxg7_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n    }\n  \
    \  return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var count1, count2 int\n    for _, v := range lst1\
    \ {\n        count1 += len(v)\n    }\n    for _, v := range lst2 {\n        count2\
    \ += len(v)\n    }\n    if count1 == count2 {\n        return lst1\n    } else\
    \ if count1 < count2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    total1 := 0\n    total2 := 0\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmppuxkyqtn_test.go:56: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 <= sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    var total1, total2 int\n\
    \    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n  \
    \      return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpuwkef0e2_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpuwkef0e2_test.go:61:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpuwkef0e2_test.go:61: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 == sum2 {\n        return lst1\n    } else if sum1\
    \ < sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 == sum2 {\n        return lst1\n    } else if sum1\
    \ < sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    // Write your code here\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp9hv6gyk__test.go:43: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp9hv6gyk__test.go:43: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp9hv6gyk__test.go:43: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp9hv6gyk__test.go:43: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp9hv6gyk__test.go:43: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp9hv6gyk__test.go:43: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n    }\n\
    \    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n    total2\
    \ := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpf7ju2vkr_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074572
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n    }\n\
    \    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n    total2\
    \ := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n    }\n    for\
    \ _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpwm10ub0r_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074572
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    }\n   \
    \ return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxlpg9oxe_test.go:52: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, s := range lst1\
    \ {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n        total2\
    \ += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxvvgwtch_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n    total2\
    \ := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp3t8_z1kt_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp3t8_z1kt_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp3t8_z1kt_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var lst1_total, lst2_total int\n    for _, v := range\
    \ lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxo92xqbp_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1 {\n\
    \        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 +=\
    \ len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else {\n   \
    \     return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7k7cvwyx_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ lst1\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n    if len(lst2)\
    \ == 0 {\n        return lst1\n    }\n    var total1 int\n    var total2 int\n\
    \    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n  \
    \      return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp56j545w3_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp56j545w3_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp56j545w3_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074572
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n        return\
    \ []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n    }\n   \
    \ if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n    total2\
    \ := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp3t8_z1kt_test.go:62: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp3t8_z1kt_test.go:62:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp3t8_z1kt_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074568
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// total_match([], []) \u279E []\n// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1 []string, lst2\
    \ []string) []string {\n    var total1, total2 int\n    for _, v := range lst1\
    \ {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2\
    \ += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmph7d43m07_test.go:53: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074568
