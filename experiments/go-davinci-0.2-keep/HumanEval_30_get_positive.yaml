name: HumanEval_30_get_positive
language: go_test.go
prompt: "package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Return only positive numbers in the list.\n// >>> get_positive([-1, 2, -4, 5,\
  \ 6])\n// [2, 5, 6]\n// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
  // [5, 3, 2, 3, 9, 123, 1]\nfunc get_positive(l []int) []int {\n"
tests: "func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4,\
  \ 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}),\
  \ expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1,\
  \ -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{}\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var result []int\n    for _, v := range l {\n        if v > 0 {\n\
    \            result = append(result, v)\n        }\n    }\n    return result\n\
    }\n", "    var res []int\n    for _, v := range l {\n        if v > 0 {\n    \
    \        res = append(res, v)\n        }\n    }\n    return res\n}\n", "    var\
    \ result []int\n    for _, v := range l {\n        if v > 0 {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n", "    var result\
    \ []int\n    for _, v := range l {\n        if v > 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    var result []int\n    for\
    \ _, v := range l {\n        if v > 0 {\n            result = append(result, v)\n\
    \        }\n    }\n    return result\n}\n", "    var res []int\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            res = append(res, v)\n        }\n\
    \    }\n    return res\n}\n", "    var result []int\n    for _, v := range l {\n\
    \        if v > 0 {\n            result = append(result, v)\n        }\n    }\n\
    \    return result\n}\n", "    var res []int\n    for _, v := range l {\n    \
    \    if v > 0 {\n            res = append(res, v)\n        }\n    }\n    return\
    \ res\n}\n", "    var result []int\n    for _, i := range l {\n        if i >\
    \ 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n", "    var result []int\n    for _, v := range l {\n        if v > 0 {\n \
    \           result = append(result, v)\n        }\n    }\n    return result\n\
    }\n", "    var res []int\n    for _, v := range l {\n        if v > 0 {\n    \
    \        res = append(res, v)\n        }\n    }\n    return res\n}\n", "    var\
    \ result []int\n    for _, v := range l {\n        if v > 0 {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n", "    var r []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            r = append(r, v)\n\
    \        }\n    }\n    return r\n}\n", "    var result []int\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            result = append(result, v)\n    \
    \    }\n    }\n    return result\n}\n", "    var result []int\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            result = append(result, v)\n    \
    \    }\n    }\n    return result\n}\n", "    var result []int\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            result = append(result, v)\n    \
    \    }\n    }\n    return result\n}\n", "    var res []int\n    for _, v := range\
    \ l {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var result []int\n    for _, n := range l {\n    \
    \    if n > 0 {\n            result = append(result, n)\n        }\n    }\n  \
    \  return result\n}\n", "    var result []int\n    for _, v := range l {\n   \
    \     if v > 0 {\n            result = append(result, v)\n        }\n    }\n \
    \   return result\n}\n", "    var res []int\n    for _, v := range l {\n     \
    \   if v > 0 {\n            res = append(res, v)\n        }\n    }\n    return\
    \ res\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
