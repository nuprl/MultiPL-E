language: go_test.go
name: HumanEval_87_get_row
results:
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    res := make([][]interface{}, 0)\n   \
    \ for i, row := range lst {\n        for j, val := range row {\n            if\
    \ val == x {\n                res = append(res, []interface{}{i, j})\n       \
    \     }\n        }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ht_dlfu_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ht_dlfu_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6ht_dlfu_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ht_dlfu_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6ht_dlfu_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, el := range row {\n            if el == x\
    \ {\n                result = append(result, []interface{}{i, j})\n          \
    \  }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpow7yavv9_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpow7yavv9_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpow7yavv9_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, cell := range row {\n            if cell == x\
    \ {\n                res = append(res, []interface{}{i, j})\n            }\n \
    \       }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7wyi9jjf_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7wyi9jjf_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7wyi9jjf_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7wyi9jjf_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7wyi9jjf_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, el := range row {\n            if el == x\
    \ {\n                result = append(result, []interface{}{i, j})\n          \
    \  }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpow7yavv9_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpow7yavv9_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpow7yavv9_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, item := range row {\n            if item == x\
    \ {\n                res = append(res, []interface{}{i, j})\n            }\n \
    \       }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfpn8o0qh_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfpn8o0qh_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, cell := range row {\n            if cell\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1lvb0bnk_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1lvb0bnk_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, el := range row {\n            if el == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbslerbr2_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbslerbr2_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpbslerbr2_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbslerbr2_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpbslerbr2_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, item := range row {\n            if item == x\
    \ {\n                res = append(res, []interface{}{i, j})\n            }\n \
    \       }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfpn8o0qh_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfpn8o0qh_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // your code here\n    var res [][]interface{}\n\
    \    for i, row := range lst {\n        for j, col := range row {\n          \
    \  if col == x {\n                res = append(res, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18hshzcb_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp18hshzcb_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp18hshzcb_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp18hshzcb_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp18hshzcb_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, el := range row {\n            if el == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbslerbr2_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbslerbr2_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpbslerbr2_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbslerbr2_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpbslerbr2_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, elem := range row {\n            if elem == x\
    \ {\n                res = append(res, []interface{}{i, j})\n            }\n \
    \       }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphvmkig_9_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphvmkig_9_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphvmkig_9_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphvmkig_9_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmphvmkig_9_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, el := range row {\n            if el == x\
    \ {\n                result = append(result, []interface{}{i, j})\n          \
    \  }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpow7yavv9_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpow7yavv9_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpow7yavv9_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, el := range row {\n            if el == x\
    \ {\n                result = append(result, []interface{}{i, j})\n          \
    \  }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpow7yavv9_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpow7yavv9_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpow7yavv9_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpow7yavv9_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, cell := range row {\n            if cell\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1lvb0bnk_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1lvb0bnk_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, cell := range row {\n            if cell\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1lvb0bnk_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1lvb0bnk_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, el := range row {\n            if el == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbslerbr2_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbslerbr2_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpbslerbr2_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbslerbr2_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpbslerbr2_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, cell := range row {\n            if cell\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1lvb0bnk_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1lvb0bnk_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1lvb0bnk_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpem2f667p_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpem2f667p_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpem2f667p_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpem2f667p_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, item := range row {\n            if item == x\
    \ {\n                res = append(res, []interface{}{i, j})\n            }\n \
    \       }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfpn8o0qh_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfpn8o0qh_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, v := range row {\n            if v == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk12sll0d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk12sll0d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk12sll0d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk12sll0d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsc_sxfo0_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsc_sxfo0_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsc_sxfo0_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, val := range row {\n            if val ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2guvdyq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpa2guvdyq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpa2guvdyq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpa2guvdyq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcy0fktor_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcy0fktor_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcy0fktor_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcy0fktor_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, val := range row {\n            if val == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqkbbguz_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqkbbguz_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqkbbguz_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnqkbbguz_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5p5269mq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5p5269mq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5p5269mq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5p5269mq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, item := range row {\n            if item == x\
    \ {\n                res = append(res, []interface{}{i, j})\n            }\n \
    \       }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfpn8o0qh_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpn8o0qh_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfpn8o0qh_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n\
    // [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([],\
    \ 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i,\
    \ row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjjfd245_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfjjfd245_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfjjfd245_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfjjfd245_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075039
