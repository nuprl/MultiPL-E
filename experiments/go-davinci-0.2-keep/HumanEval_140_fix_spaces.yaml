name: HumanEval_140_fix_spaces
language: go_test.go
prompt: "package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given a string text, replace all spaces in it with underscores, \n// and if a\
  \ string has more than 2 consecutive spaces, \n// then replace all consecutive spaces\
  \ with - \n// fix_spaces(\"Example\") == \"Example\"\n// fix_spaces(\"Example 1\"\
  ) == \"Example_1\"\n// fix_spaces(\" Example 2\") == \"_Example_2\"\n// fix_spaces(\"\
  \ Example   3\") == \"_Example-3\"\nfunc fix_spaces(text string) string {\n"
tests: "func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n   \
  \  { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n  \
  \   { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\"\
  \ },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n    \
  \ { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var result string\n    var prev byte\n    var count int\n    for\
    \ _, c := range text {\n        if c == ' ' {\n            if prev == ' ' {\n\
    \                count++\n            } else {\n                count = 1\n  \
    \          }\n            if count == 2 {\n                result += \"-\"\n \
    \           }\n        } else {\n            if prev == ' ' {\n              \
    \  result += \"_\"\n            }\n            result += string(c)\n         \
    \   count = 0\n        }\n        prev = byte(c)\n    }\n    return result\n}\n",
  "    var result string\n    var prev_char byte\n    var prev_prev_char byte\n  \
    \  for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n           \
    \ if prev_char == ' ' && prev_prev_char == ' ' {\n                result += \"\
    -\"\n            } else {\n                result += \"_\"\n            }\n  \
    \      } else {\n            result += string(text[i])\n        }\n        prev_prev_char\
    \ = prev_char\n        prev_char = text[i]\n    }\n    return result\n}\n", " \
    \   return \"\"\n}\n", "    return \"\"\n}\n", "    return \"\"\n}\n", "    return\
    \ \"\"\n}\n", "    var result string\n    var prev_char rune\n    var curr_char\
    \ rune\n    var next_char rune\n    var prev_char_is_space bool\n    var curr_char_is_space\
    \ bool\n    var next_char_is_space bool\n    var prev_char_is_underscore bool\n\
    \    var curr_char_is_underscore bool\n    var next_char_is_underscore bool\n\
    \    var prev_char_is_hyphen bool\n    var curr_char_is_hyphen bool\n    var next_char_is_hyphen\
    \ bool\n    var prev_char_is_letter bool\n    var curr_char_is_letter bool\n \
    \   var next_char_is_letter bool\n    var prev_char_is_digit bool\n    var curr_char_is_digit\
    \ bool\n    var next_char_is_digit bool\n    var prev_char_is_special bool\n \
    \   var curr_char_is_special bool\n    var next_char_is_special bool\n    var\
    \ prev_char_is_whitespace bool\n    var curr_char_is_whitespace bool\n    var\
    \ next_char_is_whitespace bool\n    var prev_char_is_newline bool\n    var curr_char_is_newline\
    \ bool\n    var next_char_is_newline bool\n    var prev_char_is_tab bool\n   \
    \ var curr_char_is_tab bool\n    var next_char_is_tab bool\n    var prev_char_is_formfeed\
    \ bool\n    var curr_char_is_formfeed bool\n    var next_char_is_formfeed bool\n\
    \    var prev_char_is_carriage_return bool\n    var curr_char_is_carriage_return\
    \ bool\n    var next_char_is_carriage_return bool\n    var prev_char_is_unicode_space\
    \ bool\n    var curr_char_is_unicode_space bool\n    var next_char_is_unicode_space\
    \ bool\n    var prev_char_is_unicode_letter bool\n    var curr_char_is_unicode_letter\
    \ bool\n    var next_char_is_unicode_", "    return \"\"\n}\n", "    return \"\
    \"\n}\n", "    return \"\"\n}\n", "    return \"\"\n}\n", "    return \"\"\n}\n",
  "    var result string\n    var last_char byte\n    for i := 0; i < len(text); i++\
    \ {\n        if text[i] == ' ' {\n            if last_char == ' ' {\n        \
    \        result += \"-\"\n            } else {\n                result += \"_\"\
    \n            }\n        } else {\n            result += string(text[i])\n   \
    \     }\n        last_char = text[i]\n    }\n    return result\n}\n", "    return\
    \ \"\"\n}\n", "    var result string\n    var prev_space bool = false\n    var\
    \ consecutive_spaces int = 0\n    for _, c := range text {\n        if c == '\
    \ ' {\n            if prev_space {\n                consecutive_spaces++\n   \
    \         } else {\n                consecutive_spaces = 1\n            }\n  \
    \          prev_space = true\n        } else {\n            if consecutive_spaces\
    \ > 2 {\n                result += \"-\"\n            } else {\n             \
    \   for i := 0; i < consecutive_spaces; i++ {\n                    result += \"\
    _\"\n                }\n            }\n            consecutive_spaces = 0\n  \
    \          prev_space = false\n            result += string(c)\n        }\n  \
    \  }\n    if consecutive_spaces > 2 {\n        result += \"-\"\n    } else {\n\
    \        for i := 0; i < consecutive_spaces; i++ {\n            result += \"_\"\
    \n        }\n    }\n    return result\n}\n", "    var result string\n    var prev_space\
    \ bool = false\n    var space_count int = 0\n    for _, c := range text {\n  \
    \      if c == ' ' {\n            space_count++\n            if space_count >\
    \ 2 {\n                continue\n            }\n            if prev_space {\n\
    \                result += \"-\"\n            } else {\n                result\
    \ += \"_\"\n            }\n            prev_space = true\n        } else {\n \
    \           space_count = 0\n            result += string(c)\n            prev_space\
    \ = false\n        }\n    }\n    return result\n}\n", "    return \"\"\n}\n",
  "    return \"\"\n}\n", "    return \"\"\n}\n", "    return \"\"\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
