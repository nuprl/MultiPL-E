language: go_test.go
name: HumanEval_144_simplify
results:
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    if xn * nd == xd * nn {\n        return true\n  \
    \  }\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpauet0f41_test.go:17:15: undefined: parse

    /tmp/tmpauet0f41_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, _ := parse(x)\n\
    \    nn, _ := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvp_yyc8m_test.go:17:14: undefined: parse

    /tmp/tmpvp_yyc8m_test.go:18:14: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    x_numerator *= n_denominator\n    x_denominator *= n_numerator\n    return\
    \ x_numerator % x_denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu6e7gp3g_test.go:17:35: undefined: parseFraction

    /tmp/tmpu6e7gp3g_test.go:18:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum *\
    \ nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozk7d1a1_test.go:17:19: undefined: parseFraction

    /tmp/tmpozk7d1a1_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xNumerator,\
    \ xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"%d/%d\", &xNumerator,\
    \ &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator, &nDenominator)\n \
    \   return xNumerator * nDenominator % xDenominator == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpejc_pw8__test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpejc_pw8__test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpejc_pw8__test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpejc_pw8__test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\n\
    \    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := getNumeratorDenominator(x)\n    nNum, nDen := getNumeratorDenominator(n)\n\
    \    return (xNum * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp45y8j087_test.go:17:19: undefined: getNumeratorDenominator

    /tmp/tmp45y8j087_test.go:18:19: undefined: getNumeratorDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt66w9tuo_test.go:17:33: undefined: parseFraction

    /tmp/tmpt66w9tuo_test.go:18:33: undefined: parseFraction

    /tmp/tmpt66w9tuo_test.go:19:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, _ := parse(x)\n\
    \    nn, _ := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvp_yyc8m_test.go:17:14: undefined: parse

    /tmp/tmpvp_yyc8m_test.go:18:14: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_num, x_den\
    \ := parse(x)\n    n_num, n_den := parse(n)\n    return (x_num * n_den) % (x_den\
    \ * n_num) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp17dkyzyn_test.go:17:21: undefined: parse

    /tmp/tmp17dkyzyn_test.go:18:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := multiply(x,\
    \ n)\n    return isWhole(xn)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1ty3t_5b_test.go:17:11: undefined: multiply

    /tmp/tmp1ty3t_5b_test.go:18:12: undefined: isWhole

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return xNum * nDen\
    \ == xDen * nNum\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_8ucspfa_test.go:17:19: undefined: parseFraction

    /tmp/tmp_8ucspfa_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := x + \"\
    \ * \" + n\n    fmt.Println(xn)\n    return true\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "1/5 * 5/1\n1/6 * 2/1\n5/1 * 3/1\n7/10 * 10/2\n2/10 * 50/10\n7/2 * 4/2\n\
    11/6 * 6/1\n2/3 * 5/2\n5/2 * 3/5\n2/4 * 8/4\n2/4 * 4/2\n1/5 * 5/1\n1/5 * 1/5\n\
    --- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1 (0.00s)\n\
    \        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp2ul5rh8k_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp2ul5rh8k_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum *\
    \ nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozk7d1a1_test.go:17:19: undefined: parseFraction

    /tmp/tmpozk7d1a1_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvaocvg68_test.go:17:11: undefined: parse

    /tmp/tmpvaocvg68_test.go:18:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := toFraction(x)\n\
    \    nn := toFraction(n)\n    return xn.Multiply(nn).IsWhole()\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0g0su39t_test.go:17:11: undefined: toFraction

    /tmp/tmp0g0su39t_test.go:18:11: undefined: toFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn.numerator * nn.denominator % xn.denominator\
    \ == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwsl0ftca_test.go:22:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073199
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return xNum * nDen\
    \ * nNum * xDen % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqfvjr9h_test.go:17:19: undefined: parseFraction

    /tmp/tmpbqfvjr9h_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    return (xNumerator * nDenominator) % (xDenominator\
    \ * nNumerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqbp43oo_test.go:17:33: undefined: getNumeratorAndDenominator

    /tmp/tmpmqbp43oo_test.go:18:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator % (xDenominator * nNumerator) == 0\n}\n\n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_xdecc7p_test.go:17:33: undefined: parseFraction

    /tmp/tmp_xdecc7p_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpln5g5dso_test.go:17:33: undefined: parse

    /tmp/tmpln5g5dso_test.go:18:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return true\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn.numerator * nn.denominator % xn.denominator\
    \ == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwsl0ftca_test.go:22:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073199
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvaocvg68_test.go:17:11: undefined: parse

    /tmp/tmpvaocvg68_test.go:18:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\
    \ the function\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator * xDenominator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmwmlxov5_test.go:17:33: undefined: parseFraction

    /tmp/tmpmwmlxov5_test.go:18:33: undefined: parseFraction

    /tmp/tmpmwmlxov5_test.go:19:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpln5g5dso_test.go:17:33: undefined: parse

    /tmp/tmpln5g5dso_test.go:18:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: implement\n\
    \    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    if xn * nd == xd * nn {\n        return true\n  \
    \  }\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpauet0f41_test.go:17:15: undefined: parse

    /tmp/tmpauet0f41_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvaocvg68_test.go:17:11: undefined: parse

    /tmp/tmpvaocvg68_test.go:18:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_num, x_den\
    \ := parse(x)\n    n_num, n_den := parse(n)\n    return (x_num * n_den) % (x_den\
    \ * n_num) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp17dkyzyn_test.go:17:21: undefined: parse

    /tmp/tmp17dkyzyn_test.go:18:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := x + \"\
    \ * \" + n\n    fmt.Println(xn)\n    return true\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "1/5 * 5/1\n1/6 * 2/1\n5/1 * 3/1\n7/10 * 10/2\n2/10 * 50/10\n7/2 * 4/2\n\
    11/6 * 6/1\n2/3 * 5/2\n5/2 * 3/5\n2/4 * 8/4\n2/4 * 4/2\n1/5 * 5/1\n1/5 * 1/5\n\
    --- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1 (0.00s)\n\
    \        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp2ul5rh8k_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp2ul5rh8k_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_num, x_den\
    \ := parse(x)\n    n_num, n_den := parse(n)\n    return x_num * n_den * n_num\
    \ * x_den % (x_den * n_den) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4lftssuh_test.go:17:21: undefined: parse

    /tmp/tmp4lftssuh_test.go:18:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\n\
    \    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum *\
    \ nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozk7d1a1_test.go:17:19: undefined: parseFraction

    /tmp/tmpozk7d1a1_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn.numerator * nn.denominator % xn.denominator\
    \ == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwsl0ftca_test.go:22:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073199
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := getNumeratorAndDenominator(x)\n    n_numerator, n_denominator\
    \ := getNumeratorAndDenominator(n)\n    return (x_numerator * n_denominator) %\
    \ (x_denominator * n_numerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2ur32d48_test.go:17:35: undefined: getNumeratorAndDenominator

    /tmp/tmp2ur32d48_test.go:18:35: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xNumerator,\
    \ xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"%d/%d\", &xNumerator,\
    \ &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator, &nDenominator)\n \
    \   return xNumerator * nDenominator % xDenominator == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpejc_pw8__test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpejc_pw8__test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpejc_pw8__test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpejc_pw8__test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parseFraction(x)\n\
    \    nn := parseFraction(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpockv1onh_test.go:17:11: undefined: parseFraction

    /tmp/tmpockv1onh_test.go:18:11: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := getNumeratorAndDenominator(x)\n    nNum, nDen := getNumeratorAndDenominator(n)\n\
    \    return (xNum * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy17fmx73_test.go:17:19: undefined: getNumeratorAndDenominator

    /tmp/tmpy17fmx73_test.go:18:19: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, _ := parseFraction(x)\n\
    \    nn, _ := parseFraction(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp34ab19l_test.go:17:14: undefined: parseFraction

    /tmp/tmpp34ab19l_test.go:18:14: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator % (xDenominator * nNumerator) == 0\n}\n\n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_xdecc7p_test.go:17:33: undefined: parseFraction

    /tmp/tmp_xdecc7p_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    numerator := xNumerator * nDenominator\n    denominator := xDenominator *\
    \ nNumerator\n    return numerator % denominator == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprnqgdf4j_test.go:17:33: undefined: parseFraction

    /tmp/tmprnqgdf4j_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf9xd7nf_test.go:17:35: undefined: parseFraction

    /tmp/tmpbf9xd7nf_test.go:18:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return (xn.numerator * nn.denominator) % (xn.denominator\
    \ * nn.numerator) == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpehfx10gd_test.go:22:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\
    \ the function\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpwsyqikz__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpwsyqikz__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\
    \ me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpmt7ckres_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpmt7ckres_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpmt7ckres_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpmt7ckres_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpmt7ckres_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpmt7ckres_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpmt7ckres_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpmt7ckres_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return true\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum *\
    \ nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozk7d1a1_test.go:17:19: undefined: parseFraction

    /tmp/tmpozk7d1a1_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvaocvg68_test.go:17:11: undefined: parse

    /tmp/tmpvaocvg68_test.go:18:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return xNum * nDen * nNum * xDen\
    \ % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wiw85es_test.go:17:19: undefined: parse

    /tmp/tmp_wiw85es_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return false\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf9xd7nf_test.go:17:35: undefined: parseFraction

    /tmp/tmpbf9xd7nf_test.go:18:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_num, x_den\
    \ := parse(x)\n    n_num, n_den := parse(n)\n    return (x_num * n_den) % (x_den\
    \ * n_num) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp17dkyzyn_test.go:17:21: undefined: parse

    /tmp/tmp17dkyzyn_test.go:18:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\
    \ the solution\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum *\
    \ nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozk7d1a1_test.go:17:19: undefined: parseFraction

    /tmp/tmpozk7d1a1_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_num, x_den\
    \ := parse(x)\n    n_num, n_den := parse(n)\n    return x_num * n_den * n_num\
    \ * x_den % (x_den * n_den) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4lftssuh_test.go:17:21: undefined: parse

    /tmp/tmp4lftssuh_test.go:18:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator * nDenominator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4ijroamk_test.go:17:33: undefined: parse

    /tmp/tmp4ijroamk_test.go:18:33: undefined: parse

    /tmp/tmp4ijroamk_test.go:19:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_num, x_den\
    \ := parse(x)\n    n_num, n_den := parse(n)\n    num := x_num * n_num\n    den\
    \ := x_den * n_den\n    return num % den == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptihmp9_a_test.go:17:21: undefined: parse

    /tmp/tmptihmp9_a_test.go:18:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxoio5pu1_test.go:17:15: undefined: parse

    /tmp/tmpxoio5pu1_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvaocvg68_test.go:17:11: undefined: parse

    /tmp/tmpvaocvg68_test.go:18:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmueoh_x_test.go:17:15: undefined: parse

    /tmp/tmpxmueoh_x_test.go:18:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\
    \ the solution\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4soeejxw_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4soeejxw_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_num, x_den\
    \ := parse(x)\n    n_num, n_den := parse(n)\n    return isWhole(x_num * n_num,\
    \ x_den * n_den)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpparv2qpi_test.go:17:21: undefined: parse

    /tmp/tmpparv2qpi_test.go:18:21: undefined: parse

    /tmp/tmpparv2qpi_test.go:19:12: undefined: isWhole

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpbjp77ngg_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpbjp77ngg_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return false\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt66w9tuo_test.go:17:33: undefined: parseFraction

    /tmp/tmpt66w9tuo_test.go:18:33: undefined: parseFraction

    /tmp/tmpt66w9tuo_test.go:19:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return xNum * nDen * nNum * xDen\
    \ % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wiw85es_test.go:17:19: undefined: parse

    /tmp/tmp_wiw85es_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return x_numerator * n_denominator * n_numerator * x_denominator % (x_denominator\
    \ * n_denominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwhd5o0q_test.go:17:35: undefined: parseFraction

    /tmp/tmphwhd5o0q_test.go:18:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return true\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := x + \"\
    \ * \" + n\n    fmt.Println(xn)\n    return true\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "1/5 * 5/1\n1/6 * 2/1\n5/1 * 3/1\n7/10 * 10/2\n2/10 * 50/10\n7/2 * 4/2\n\
    11/6 * 6/1\n2/3 * 5/2\n5/2 * 3/5\n2/4 * 8/4\n2/4 * 4/2\n1/5 * 5/1\n1/5 * 1/5\n\
    --- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1 (0.00s)\n\
    \        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp2ul5rh8k_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp2ul5rh8k_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp2ul5rh8k_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt66w9tuo_test.go:17:33: undefined: parseFraction

    /tmp/tmpt66w9tuo_test.go:18:33: undefined: parseFraction

    /tmp/tmpt66w9tuo_test.go:19:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return true\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp67rk8gl5_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp67rk8gl5_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum *\
    \ nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozk7d1a1_test.go:17:19: undefined: parseFraction

    /tmp/tmpozk7d1a1_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return xNum * nDen\
    \ * nNum * xDen % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqfvjr9h_test.go:17:19: undefined: parseFraction

    /tmp/tmpbqfvjr9h_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum *\
    \ nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozk7d1a1_test.go:17:19: undefined: parseFraction

    /tmp/tmpozk7d1a1_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xNumerator,\
    \ xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"%d/%d\", &xNumerator,\
    \ &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator, &nDenominator)\n \
    \   return xNumerator * nDenominator % xDenominator == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpejc_pw8__test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpejc_pw8__test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpejc_pw8__test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpejc_pw8__test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen *\
    \ nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqusafvki_test.go:17:19: undefined: parse

    /tmp/tmpqusafvki_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\n\
    \    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvaocvg68_test.go:17:11: undefined: parse

    /tmp/tmpvaocvg68_test.go:18:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return false\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf9xd7nf_test.go:17:35: undefined: parseFraction

    /tmp/tmpbf9xd7nf_test.go:18:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // your code\
    \ here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpw2t4ccdo_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpw2t4ccdo_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd7dhqtuw_test.go:17:19: undefined: parse

    /tmp/tmpd7dhqtuw_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn, _ := parse(x)\n\
    \    nn, _ := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvp_yyc8m_test.go:17:14: undefined: parse

    /tmp/tmpvp_yyc8m_test.go:18:14: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\n\
    \    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    var xn, xd,\
    \ nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n, \"%d/%d\"\
    , &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3zueax3d_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3zueax3d_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return xNum * nDen\
    \ * nNum * xDen % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqfvjr9h_test.go:17:19: undefined: parseFraction

    /tmp/tmpbqfvjr9h_test.go:18:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf9xd7nf_test.go:17:35: undefined: parseFraction

    /tmp/tmpbf9xd7nf_test.go:18:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: implement\n\
    \    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp7jqr4whd_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp7jqr4whd_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := parse(x)\n\
    \    nn := parse(n)\n    return xn.numerator * nn.denominator % xn.denominator\
    \ == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwsl0ftca_test.go:22:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073199
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // TODO: Implement\n\
    \    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjrooih0p_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjrooih0p_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2l62a91_test.go:17:33: undefined: parseFraction

    /tmp/tmpo2l62a91_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    // Write your\
    \ code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp_5hvt2zb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp_5hvt2zb_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073201
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpln5g5dso_test.go:17:33: undefined: parse

    /tmp/tmpln5g5dso_test.go:18:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073202
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xn := x + \"\
    \ * \" + n\n    fmt.Println(xn)\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "1/5 * 5/1\n1/6 * 2/1\n5/1 * 3/1\n7/10 * 10/2\n2/10 * 50/10\n7/2 * 4/2\n\
    11/6 * 6/1\n2/3 * 5/2\n5/2 * 3/5\n2/4 * 8/4\n2/4 * 4/2\n1/5 * 5/1\n1/5 * 1/5\n\
    --- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0 (0.00s)\n\
    \        tmpk4glqbfy_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpk4glqbfy_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpk4glqbfy_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpk4glqbfy_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpk4glqbfy_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpk4glqbfy_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpk4glqbfy_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpk4glqbfy_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNum, xDen\
    \ := parse(x)\n    nNum, nDen := parse(n)\n    return xNum * nDen * nNum * xDen\
    \ % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wiw85es_test.go:17:19: undefined: parse

    /tmp/tmp_wiw85es_test.go:18:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073203
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa7vil0sj_test.go:17:33: undefined: parseFraction

    /tmp/tmpa7vil0sj_test.go:18:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073200
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\",\
    \ \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\"\
    , \"10/2\") = False\nfunc simplify(x string, n string) bool {\n    return false\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpi65zi3kt_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpi65zi3kt_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073203
