name: HumanEval_115_max_fill
language: go_test.go
prompt: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ You are given a rectangular grid of wells. Each row represents a single well,\n\
  // and each 1 in a row represents a single unit of water.\n// Each well has a corresponding\
  \ bucket that can be used to extract water from it, \n// and all buckets have the\
  \ same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output\
  \ the number of times you need to lower the buckets.\n// Example 1:\n// Input: \n\
  // grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity : 1\n// Output:\
  \ 6\n// Example 2:\n// Input: \n// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n\
  // bucket_capacity : 2\n// Output: 5\n// Example 3:\n// Input: \n// grid : [[0,0,0],\
  \ [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n// Constraints:\n// * all wells\
  \ have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length\
  \ <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunc max_fill(grid\
  \ [][]int, capacity int) int {\n"
tests: "func TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
  \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0, 1,\
  \ 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5\
  \ },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected:\
  \ 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}},\
  \ 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
  \ 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // TODO - Add your code here\n    return 0\n}\n", "    // Fill\
    \ this in.\n    return 0\n}\n", "    // Fill this in.\n    return 0\n}\n", " \
    \   // fill the wells with the buckets\n    // until all wells are empty\n   \
    \ // return the number of times the buckets were lowered\n    // solution:\n \
    \   // * find the maximum height of the wells\n    // * fill the wells with the\
    \ buckets\n    // * repeat until all wells are empty\n    // * return the number\
    \ of times the buckets were lowered\n    // complexity:\n    // * time complexity:\
    \ O(n^2)\n    // * space complexity: O(1)\n    if len(grid) == 0 {\n        return\
    \ 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n    // find the\
    \ maximum height of the wells\n    max_height := 0\n    for _, row := range grid\
    \ {\n        for _, cell := range row {\n            if cell > max_height {\n\
    \                max_height = cell\n            }\n        }\n    }\n    // fill\
    \ the wells with the buckets\n    // until all wells are empty\n    // return\
    \ the number of times the buckets were lowered\n    count := 0\n    for i := 0;\
    \ i < max_height; i++ {\n        for j := 0; j < len(grid); j++ {\n          \
    \  for k := 0; k < len(grid[j]); k++ {\n                if grid[j][k] > 0 {\n\
    \                    grid[j][k] -= capacity\n                    count++\n   \
    \             }\n            }\n        }\n    }\n    return count\n}\n", "  \
    \  // TODO - Add your code here\n    return 0\n}\n", "    // return max_fill_v1(grid,\
    \ capacity)\n    return max_fill_v2(grid, capacity)\n}\n", "    // Fill this in.\n\
    \    return 0\n}\n", "    // fill each well with the maximum amount of water\n\
    \    // and return the number of times you need to lower the buckets\n    // score:100(0ms)\n\
    \    // time:O(n^2)\n    // space:O(1)\n    count := 0\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ == 1 {\n                count += capacity\n                grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // fill each well with the maximum amount\
    \ of water\n    // and return the number of times you need to lower the buckets\n\
    \    // score:100(0ms)\n    // time:O(n^2)\n    // space:O(1)\n    for i := 0;\
    \ i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n        \
    \    if grid[i][j] == 0 {\n                // find the minimum of the wells above\
    \ and to the left\n                min := capacity\n                if i > 0 {\n\
    \                    min = grid[i-1][j]\n                }\n                if\
    \ j > 0 && grid[i][j-1] < min {\n                    min = grid[i][j-1]\n    \
    \            }\n                if min > 0 {\n                    count += min\n\
    \                    grid[i][j] = min\n                }\n            }\n    \
    \    }\n    }\n    return count\n}\n", "    // fill the wells\n    for i := 0;\
    \ i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n        \
    \    if grid[i][j] == 1 {\n                grid[i][j] = capacity\n           \
    \ }\n        }\n    }\n    // find the lowest well\n    lowest_well := make([]int,\
    \ len(grid[0]))\n    for i := 0; i < len(grid[0]); i++ {\n        lowest_well[i]\
    \ = -1\n    }\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if grid[i][j] > 0 {\n                lowest_well[j] = i\n\
    \            }\n        }\n    }\n    // fill the wells\n    count := 0\n    for\
    \ i := 0; i < len(lowest_well); i++ {\n        if lowest_well[i] >= 0 {\n    \
    \        for j := lowest_well[i]; j >= 0; j-- {\n                if grid[j][i]\
    \ > 0 {\n                    count++\n                    grid[j][i]--\n     \
    \           }\n            }\n        }\n    }\n    return count\n}\n", "    //\
    \ TODO - Add your code here\n    return 0\n}\n", "    // TODO - Add your code\
    \ here\n    return 0\n}\n", "    // TODO - Add your code here\n    return 0\n\
    }\n", "    // Fill this in.\n    return 0\n}\n", "    // TODO - Add your code\
    \ here\n    return 0\n}\n", "    // fill each row to capacity\n    // return the\
    \ number of times we fill\n    //\n    // fill each row to capacity\n    // return\
    \ the number of times we fill\n    //\n    // fill each row to capacity\n    //\
    \ return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity\n\
    \    // return the number of times we fill\n    //\n    // fill each row to capacity",
  "    // fill the wells from the bottom up\n    // if a well is full, fill the next\
    \ well\n    // if a well is empty, skip it\n    // if a well is partially full,\
    \ fill it to capacity\n    // return the number of times the bucket was lowered\n\
    \    //\n    // for each row, starting from the bottom\n    //   for each well,\
    \ starting from the left\n    //     if the well is full\n    //       skip it\n\
    \    //     if the well is empty\n    //       skip it\n    //     if the well\
    \ is partially full\n    //       fill it to capacity\n    //       increment\
    \ the bucket count\n    // return the bucket count\n    bucket_count := 0\n  \
    \  for row := len(grid) - 1; row >= 0; row-- {\n        for col := 0; col < len(grid[row]);\
    \ col++ {\n            if grid[row][col] == 1 {\n                continue\n  \
    \          }\n            if grid[row][col] == 0 {\n                continue\n\
    \            }\n            if grid[row][col] < capacity {\n                bucket_count++\n\
    \                grid[row][col] = capacity\n            }\n        }\n    }\n\
    \    return bucket_count\n}\n", "    if len(grid) == 0 {\n        return 0\n \
    \   }\n    // find the max height\n    max_height := 0\n    for _, row := range\
    \ grid {\n        for _, cell := range row {\n            if cell > max_height\
    \ {\n                max_height = cell\n            }\n        }\n    }\n    //\
    \ fill the wells\n    count := 0\n    for height := 0; height < max_height; height++\
    \ {\n        for _, row := range grid {\n            for _, cell := range row\
    \ {\n                if cell > height {\n                    count++\n       \
    \         }\n            }\n        }\n    }\n    return count\n}\n", "    //\
    \ fill the first row\n    for i := 0; i < len(grid[0]); i++ {\n        if grid[0][i]\
    \ == 1 {\n            grid[0][i] = capacity\n        }\n    }\n    // fill the\
    \ rest of the rows\n    for i := 1; i < len(grid); i++ {\n        for j := 0;\
    \ j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n                grid[i][j]\
    \ = grid[i-1][j] - 1\n            } else {\n                grid[i][j] = grid[i-1][j]\n\
    \            }\n        }\n    }\n    // count the number of times we had to fill\n\
    \    count := 0\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j <\
    \ len(grid[i]); j++ {\n            if grid[i][j] == capacity {\n             \
    \   count++\n            }\n        }\n    }\n    return count\n}\n", "    //\
    \ return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n\
    }\n", "    if len(grid) == 0 {\n        return 0\n    }\n    // find the max height\
    \ of the grid\n    max_height := 0\n    for _, row := range grid {\n        for\
    \ _, cell := range row {\n            if cell > max_height {\n               \
    \ max_height = cell\n            }\n        }\n    }\n    // fill the grid from\
    \ the max height down to 0\n    // each time we fill the grid, we count the number\
    \ of times we fill a cell\n    num_fills := 0\n    for height := max_height; height\
    \ >= 0; height-- {\n        for _, row := range grid {\n            for _, cell\
    \ := range row {\n                if cell >= height {\n                    num_fills++\n\
    \                }\n            }\n        }\n    }\n    // divide the number\
    \ of fills by the capacity to get the number of times we need to lower the buckets\n\
    \    return num_fills / capacity\n}\n", "    // fill the wells from bottom to\
    \ top\n    // for each row, fill the wells from left to right\n    // for each\
    \ well, fill it with the minimum of the capacity and the number of units of water\n\
    \    // return the number of times the buckets are lowered\n    // T: O(n^2)\n\
    \    // S: O(1)\n    var count int\n    for i := len(grid) - 1; i >= 0; i-- {\n\
    \        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n\
    \                count += min(capacity, grid[i][j])\n                grid[i][j]\
    \ -= min(capacity, grid[i][j])\n            }\n        }\n    }\n    return count\n\
    }\n", "    // return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid,\
    \ capacity)\n}\n", "    // fill the first row\n    var count int\n    for i :=\
    \ 0; i < len(grid[0]); i++ {\n        if grid[0][i] == 1 {\n            count++\n\
    \        }\n    }\n    // fill the other rows\n    for i := 1; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ == 1 {\n                if grid[i-1][j] == 0 {\n                    count++\n\
    \                }\n            } else {\n                if grid[i-1][j] == 1\
    \ {\n                    count++\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n", "    // TODO - Add your code here\n    return\
    \ 0\n}\n", "    // fill each well with water\n    for i := 0; i < len(grid); i++\
    \ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] ==\
    \ 1 {\n                grid[i][j] = capacity\n            }\n        }\n    }\n\
    \    // fill each well with water from the previous well\n    for i := 1; i <\
    \ len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if\
    \ grid[i][j] > 0 {\n                grid[i][j] += grid[i-1][j]\n            }\n\
    \        }\n    }\n    // find the maximum water in the last row\n    max := 0\n\
    \    for i := 0; i < len(grid[len(grid)-1]); i++ {\n        if grid[len(grid)-1][i]\
    \ > max {\n            max = grid[len(grid)-1][i]\n        }\n    }\n    return\
    \ max\n}\n", "    // TODO - Add your code here\n    return 0\n}\n", "    // TODO\
    \ - Add your code here\n    return 0\n}\n", "    // return max_fill_v1(grid, capacity)\n\
    \    return max_fill_v2(grid, capacity)\n}\n", "    // Fill this in.\n    return\
    \ 0\n}\n", "    // TODO - Add your code here\n    return 0\n}\n", "    // TODO\
    \ - Add your code here\n    return 0\n}\n", "    // Fill this in.\n    return\
    \ 0\n}\n", "    // TODO - Add your code here\n    return 0\n}\n", "    // Fill\
    \ this in.\n    return 0\n}\n", "    // Fill this in.\n    return 0\n}\n", " \
    \   // fill the wells with the buckets\n    // return the number of times you\
    \ need to lower the buckets\n    // score: 100(0ms)\n    // time: O(n)\n    //\
    \ space: O(1)\n    count := 0\n    for i := 0; i < len(grid); i++ {\n        for\
    \ j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n        \
    \        count++\n                grid[i][j] = 0\n                for k := i +\
    \ 1; k < len(grid); k++ {\n                    if grid[k][j] == 1 {\n        \
    \                grid[k][j] = 0\n                        count++\n           \
    \         } else {\n                        break\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return count\n}\n", "  \
    \  // TODO - Add your code here\n    return 0\n}\n", "    // fill each row\n \
    \   var count int\n    for i := 0; i < len(grid); i++ {\n        // find the first\
    \ 1\n        var j int\n        for j = 0; j < len(grid[i]); j++ {\n         \
    \   if grid[i][j] == 1 {\n                break\n            }\n        }\n  \
    \      if j == len(grid[i]) {\n            continue\n        }\n        // fill\
    \ the row\n        count += fill_row(grid[i], j, capacity)\n    }\n    return\
    \ count\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // Fill this in.\n\
    \    return 0\n}\n", "    // fill the buckets\n    // for each row, find the first\
    \ 1, then fill the bucket\n    // if the bucket is full, then empty the bucket\n\
    \    // repeat until all wells are empty\n    // return the number of times the\
    \ bucket is lowered\n    //\n    // fill the bucket\n    // for each row, find\
    \ the first 1, then fill the bucket\n    // if the bucket is full, then empty\
    \ the bucket\n    // repeat until all wells are empty\n    // return the number\
    \ of times the bucket is lowered\n    //\n    // fill the bucket\n    // for each\
    \ row, find the first 1, then fill the bucket\n    // if the bucket is full, then\
    \ empty the bucket\n    // repeat until all wells are empty\n    // return the\
    \ number of times the bucket is lowered\n    //\n    // fill the bucket\n    //\
    \ for each row, find the first 1, then fill the bucket\n    // if the bucket is\
    \ full, then empty the bucket\n    // repeat until all wells are empty\n    //\
    \ return the number of times the bucket is lowered\n    //\n    // fill the bucket\n\
    \    // for each row, find the first 1, then fill the bucket\n    // if the bucket\
    \ is full, then empty the bucket\n    // repeat until all wells are empty\n  \
    \  // return the number of times the bucket is lowered\n    //\n    // fill the\
    \ bucket\n    // for each row, find the first 1, then fill the bucket\n    //\
    \ if the bucket is full, then empty the bucket\n    // repeat until all wells\
    \ are empty\n    // return the number of times the bucket is lowered\n    //\n\
    \    // fill the bucket\n    // for each row, find the first 1, then fill the\
    \ bucket\n    // if the bucket is full, then empty the bucket\n    // repeat until\
    \ all wells are empty\n    // return the number of times the bucket is lowered\n\
    \    //\n    // fill the bucket\n    // for each row, find the first 1, then fill\
    \ the bucket\n    // if the bucket is full, then empty the bucket\n    // repeat\
    \ until all wells are empty\n    // return the number of times the bucket is lowered\n\
    \    //\n    // fill the bucket\n    // for each row, find the first 1, then fill\
    \ the bucket\n    // if the bucket is full, then empty the bucket\n    // repeat\
    \ until", "    // fill the wells\n    // return the number of times you need to\
    \ lower the buckets\n    return 0\n}\n", "    // return max_fill_v1(grid, capacity)\n\
    \    return max_fill_v2(grid, capacity)\n}\n", "    // fill the wells from the\
    \ bottom up\n    // if a well is already full, skip it\n    // if a well is not\
    \ full, fill it with the capacity\n    // if a well is overfilled, fill the next\
    \ well with the remaining capacity\n    // if the next well is full, skip it\n\
    \    // if the next well is not full, fill it with the remaining capacity\n  \
    \  // if the next well is overfilled, fill the next well with the remaining capacity\n\
    \    // ...\n    // if there is no next well, return the number of times the bucket\
    \ was lowered\n    //\n    // Example 1:\n    // Input: \n    // grid : [[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]]\n    // bucket_capacity : 1\n    // Output: 6\n    //\n\
    \    // Example 2:\n    // Input: \n    // grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]]\n    // bucket_capacity : 2\n    // Output: 5\n    //\n    // Example\
    \ 3:\n    // Input: \n    // grid : [[0,0,0], [0,0,0]]\n    // bucket_capacity\
    \ : 5\n    // Output: 0\n    //\n    // Example 4:\n    // Input: \n    // grid\
    \ : [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    // bucket_capacity : 5\n\
    \    // Output: 0\n    //\n    // Example 5:\n    // Input: \n    // grid : [[1,1,1,1],\
    \ [1,1,1,1], [1,1,1,1], [1,1,1,1]]\n    // bucket_capacity : 5\n    // Output:\
    \ 0\n    //\n    // Example 6:\n    // Input: \n    // grid : [[1,1,1,1], [1,1,1,1],\
    \ [1,1,1,1], [1,1,1,1]]\n    // bucket_capacity : 1\n    //", "    // fill all\
    \ wells with capacity\n    for i := 0; i < len(grid); i++ {\n        for j :=\
    \ 0; j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n             \
    \   grid[i][j] = capacity\n            }\n        }\n    }\n    // find the max\
    \ fill\n    max_fill := 0\n    for i := 0; i < len(grid); i++ {\n        for j\
    \ := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > max_fill {\n    \
    \            max_fill = grid[i][j]\n            }\n        }\n    }\n    // fill\
    \ all wells with max fill\n    for i := 0; i < len(grid); i++ {\n        for j\
    \ := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n           \
    \     grid[i][j] = max_fill\n            }\n        }\n    }\n    // count the\
    \ number of fills\n    count := 0\n    for i := 0; i < len(grid); i++ {\n    \
    \    for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n  \
    \              count += 1\n            }\n        }\n    }\n    return count\n\
    }\n", "    // Fill this in.\n    return 0\n}\n", "    // fill the wells from top\
    \ to bottom\n    // for each row, fill the wells from left to right\n    // for\
    \ each well, fill it with the minimum of the capacity and the remaining water\n\
    \    // return the total number of times the bucket was lowered\n    var count\
    \ int\n    for _, row := range grid {\n        for _, well := range row {\n  \
    \          if well > 0 {\n                if well > capacity {\n             \
    \       count += capacity\n                } else {\n                    count\
    \ += well\n                }\n            }\n        }\n    }\n    return count\n\
    }\n", "    // TODO - Add your code here\n    return 0\n}\n", "    // Fill this\
    \ in.\n    return 0\n}\n", "    // fill the wells from the bottom up\n    // if\
    \ the well is full, fill the next well\n    // if the well is not full, fill the\
    \ well\n    // if the well is empty, skip the well\n    // return the number of\
    \ times the bucket was lowered\n    //\n    // [0,0,1,0]\n    // [0,1,0,0]\n \
    \   // [1,1,1,1]\n    //\n    // [0,0,1,0]\n    // [0,1,0,0]\n    // [1,1,1,1]\n\
    \    //\n    // [0,0,1,0]\n    // [0,1,0,0]\n    // [1,1,1,1]\n    //\n    //\
    \ [0,0,1,0]\n    // [0,1,0,0]\n    // [1,1,1,1]\n    //\n    // [0,0,1,0]\n  \
    \  // [0,1,0,0]\n    // [1,1,1,1]\n    //\n    // [0,0,1,0]\n    // [0,1,0,0]\n\
    \    // [1,1,1,1]\n    //\n    // [0,0,1,0]\n    // [0,1,0,0]\n    // [1,1,1,1]\n\
    \    //\n    // [0,0,1,0]\n    // [0,1,0,0]\n    // [1,1,1,1]\n    //\n    //\
    \ [0,0,1,0]\n    // [0,1,0,0]\n    // [1,1,1,1]\n    //\n    // [0,0,1,0]\n  \
    \  // [0,1,0,0]\n    // [1,1,1,1]\n    //\n    // [0,0,1,0]\n    // [0,1,0,0]\n\
    \    // [1,1,1,1]\n    //\n    // [0,0,1,0]\n    // [0,1,", "    // TODO - Add\
    \ your code here\n    return 0\n}\n", "    // fill the wells from left to right\n\
    \    // and from top to bottom\n    // until all wells are empty\n    // or the\
    \ bucket is empty\n    // return the number of times the bucket was lowered\n\
    \    //\n    // Example:\n    // grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n  \
    \  // bucket_capacity : 1\n    //\n    // 1. fill the first well\n    // [[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]]\n    //  ^\n    // 2. fill the second well\n    // [[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]]\n    //     ^\n    // 3. fill the third well\n    // [[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]]\n    //        ^\n    // 4. fill the fourth well\n   \
    \ // [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    //           ^\n    // 5. fill the\
    \ fifth well\n    // [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    //              ^\n\
    \    // 6. fill the sixth well\n    // [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n   \
    \ //                 ^\n    //\n    // return 6\n    //\n    // Example:\n   \
    \ // grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n    // bucket_capacity\
    \ : 2\n    //\n    // 1. fill the first well\n    // [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]]\n    //  ^\n    // 2. fill the second well\n    // [[0,0,1,1], [0,0,0,0],",
  "    // fill the wells with the buckets\n    // return the number of times the buckets\
    \ are lowered\n    // score: 100(0ms)\n    // time:O(n)\n    // space:O(1)\n \
    \   count := 0\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j <\
    \ len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n                count\
    \ += capacity\n            } else {\n                count += 1\n            }\n\
    \        }\n    }\n    return count\n}\n", "    // TODO - Add your code here\n\
    \    return 0\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // return\
    \ max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n}\n", " \
    \   // Fill this in.\n    return 0\n}\n", "    // Fill this in.\n    return 0\n\
    }\n", "    // fill the wells\n    // return the number of times you need to lower\
    \ the buckets\n    // score: 100(0ms)\n    // time: O(n^2)\n    // space: O(1)\n\
    \    count := 0\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j <\
    \ len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n                count\
    \ += capacity\n                grid[i][j] = capacity\n            }\n        }\n\
    \    }\n    // fmt.Println(grid)\n    // fill the wells\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ > 0 {\n                if i > 0 && grid[i-1][j] > 0 {\n                    if\
    \ grid[i][j] > grid[i-1][j] {\n                        count -= grid[i][j] - grid[i-1][j]\n\
    \                        grid[i][j] = grid[i-1][j]\n                    } else\
    \ {\n                        count -= grid[i-1][j] - grid[i][j]\n            \
    \            grid[i-1][j] = grid[i][j]\n                    }\n              \
    \  }\n                if j > 0 && grid[i][j-1] > 0 {\n                    if grid[i][j]\
    \ > grid[i][j-1] {\n                        count -= grid[i][j] - grid[i][j-1]\n\
    \                        grid[i][j] = grid[i][j-1]\n                    } else\
    \ {\n                        count -= grid[i][j-1] - grid[i][j]\n            \
    \            grid[i][j-1] = grid[i][j]\n                    }\n              \
    \  }\n            }\n        }\n    }\n    // fmt.Println(grid)\n    return count\n\
    }\n", "    // TODO - Add your code here\n    return 0\n}\n", "    // fill the\
    \ first row\n    var count int\n    for i := 0; i < len(grid[0]); i++ {\n    \
    \    if grid[0][i] == 1 {\n            count++\n        }\n    }\n    // fill\
    \ the rest of the rows\n    for i := 1; i < len(grid); i++ {\n        for j :=\
    \ 0; j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n             \
    \   if grid[i-1][j] == 0 {\n                    count++\n                }\n \
    \           } else {\n                if grid[i-1][j] == 1 {\n               \
    \     count++\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n", "    // return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid,\
    \ capacity)\n}\n", "    // fill the wells from the bottom up\n    // if the well\
    \ is full, fill the next well\n    // if the well is not full, fill the well and\
    \ the next well\n    // if the well is empty, fill the next well\n    // if the\
    \ well is empty, and the next well is empty, fill the next well\n    // if the\
    \ well is empty, and the next well is full, fill the next well\n    // if the\
    \ well is empty, and the next well is not full, fill the well and the next well\n\
    \    // if the well is not full, and the next well is empty, fill the well and\
    \ the next well\n    // if the well is not full, and the next well is full, fill\
    \ the next well\n    // if the well is not full, and the next well is not full,\
    \ fill the well and the next well\n    // if the well is full, and the next well\
    \ is empty, fill the next well\n    // if the well is full, and the next well\
    \ is full, fill the next well\n    // if the well is full, and the next well is\
    \ not full, fill the well and the next well\n    // if the well is not full, and\
    \ the next well is not full, fill the well and the next well\n    // if the well\
    \ is not full, and the next well is not full, fill the well and the next well\n\
    \    // if the well is not full, and the next well is not full, fill the well\
    \ and the next well\n    // if the well is not full, and the next well is not\
    \ full, fill the well and the next well\n    // if the well is not full, and the\
    \ next well is not full, fill the well and the next well\n    // if the well is\
    \ not full, and the next well is not full, fill the well and the next well\n \
    \   // if the well is not full, and the next well is not full, fill the well and\
    \ the next well\n    // if the well is not full, and the next well is not full,\
    \ fill the well and the next well\n    // if the well is not full, and the next\
    \ well is not full, fill the well and the next well\n    // if the well is not\
    \ full, and the next well is not full, fill the well and the next well\n    //\
    \ if the well is not full, and", "    // fill the wells\n    var count int\n \
    \   for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                count += capacity\n   \
    \         }\n        }\n    }\n    // lower the buckets\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ == 1 {\n                // lower the bucket\n                count--\n     \
    \           // fill the wells\n                for k := i; k < len(grid); k++\
    \ {\n                    for l := 0; l < len(grid[k]); l++ {\n               \
    \         if grid[k][l] == 1 {\n                            grid[k][l] = 0\n \
    \                       }\n                    }\n                }\n        \
    \        // lower the bucket\n                count--\n                // fill\
    \ the wells\n                for k := i; k >= 0; k-- {\n                    for\
    \ l := 0; l < len(grid[k]); l++ {\n                        if grid[k][l] == 1\
    \ {\n                            grid[k][l] = 0\n                        }\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  return count\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // fill\
    \ each well to capacity\n    // return the number of times we need to lower the\
    \ bucket\n    //\n    // we can fill each well to capacity in one pass\n    //\
    \ we can fill each row to capacity in one pass\n    // we can fill each column\
    \ to capacity in one pass\n    //\n    // we can fill each well to capacity in\
    \ one pass\n    // we can fill each row to capacity in one pass\n    // we can\
    \ fill each column to capacity in one pass\n    //\n    // we can fill each well\
    \ to capacity in one pass\n    // we can fill each row to capacity in one pass\n\
    \    // we can fill each column to capacity in one pass\n    //\n    // we can\
    \ fill each well to capacity in one pass\n    // we can fill each row to capacity\
    \ in one pass\n    // we can fill each column to capacity in one pass\n    //\n\
    \    // we can fill each well to capacity in one pass\n    // we can fill each\
    \ row to capacity in one pass\n    // we can fill each column to capacity in one\
    \ pass\n    //\n    // we can fill each well to capacity in one pass\n    // we\
    \ can fill each row to capacity in one pass\n    // we can fill each column to\
    \ capacity in one pass\n    //\n    // we can fill each well to capacity in one\
    \ pass\n    // we can fill each row to capacity in one pass\n    // we can fill\
    \ each column to capacity in one pass\n    //\n    // we can fill each well to\
    \ capacity in one pass\n    // we can fill each row to capacity in one pass\n\
    \    // we can fill each column to capacity in one pass\n    //\n    // we can\
    \ fill each well to capacity in one pass\n    // we can fill each row to capacity\
    \ in one pass\n    // we can fill each column to capacity in one pass\n    //\n\
    \    // we can fill each well to capacity in one pass\n    // we can fill each\
    \ row to capacity in one pass\n    // we can fill each column to capacity in one\
    \ pass\n    //\n    // we can fill each well to capacity in one pass\n    // we\
    \ can fill each row to capacity in one pass\n    // we can fill each column to\
    \ capacity in one pass\n    //\n    // we can fill each well to capacity in one\
    \ pass\n    // we can fill each row to capacity in one", "    // Fill this in.\n\
    \    return 0\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // return\
    \ max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n}\n", " \
    \   // fill each row until it is full\n    // then fill the next row\n    // if\
    \ the next row is full, then fill the next row\n    // if the next row is not\
    \ full, then fill the previous row\n    // until all rows are full\n    // then\
    \ repeat the process until all rows are empty\n    // the number of times we fill\
    \ the rows is the answer\n    //\n    // we can use a stack to keep track of the\
    \ rows that are not full\n    // we can use a queue to keep track of the rows\
    \ that are full\n    //\n    // we can also use a queue to keep track of the rows\
    \ that are not full\n    // we can use a stack to keep track of the rows that\
    \ are full\n    //\n    // we can also use a queue to keep track of the rows that\
    \ are not full\n    // we can use a queue to keep track of the rows that are full\n\
    \    //\n    // we can also use a stack to keep track of the rows that are not\
    \ full\n    // we can use a stack to keep track of the rows that are full\n  \
    \  //\n    // we can also use a stack to keep track of the rows that are not full\n\
    \    // we can use a queue to keep track of the rows that are full\n    //\n \
    \   // we can also use a queue to keep track of the rows that are not full\n \
    \   // we can use a stack to keep track of the rows that are full\n    //\n  \
    \  // we can also use a stack to keep track of the rows that are not full\n  \
    \  // we can use a stack to keep track of the rows that are full\n    //\n   \
    \ // we can also use a queue to keep track of the rows that are not full\n   \
    \ // we can use a queue to keep track of the rows that are full\n    //\n    //\
    \ we can also use a stack to keep track of the rows that are not full\n    //\
    \ we can use a queue to keep track of the rows that are full\n    //\n    // we\
    \ can also use a queue to keep track of the rows that are not full\n    // we\
    \ can use a stack to keep track of the rows that are full\n    //\n    // we can\
    \ also use a stack to keep track of the rows that are not full\n    // we can\
    \ use a stack to keep track of the rows that are full\n", "    // fill the first\
    \ row\n    var count int\n    for i := 0; i < len(grid[0]); i++ {\n        if\
    \ grid[0][i] == 1 {\n            grid[0][i] = 0\n            count++\n       \
    \ }\n    }\n    // fill the rest of the rows\n    for i := 1; i < len(grid); i++\
    \ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] ==\
    \ 1 {\n                if grid[i-1][j] > 0 {\n                    grid[i][j] =\
    \ 0\n                    grid[i-1][j]--\n                } else {\n          \
    \          grid[i][j] = 0\n                    count++\n                }\n  \
    \          }\n        }\n    }\n    return count\n}\n", "    // Fill this in.\n\
    \    return 0\n}\n", "    // TODO - Add your code here\n    return 0\n}\n", " \
    \   // Fill this in.\n    return 0\n}\n", "    // fill all wells with capacity\n\
    \    // return the number of times you need to lower the buckets\n    // score:\
    \ 100(0ms)\n    // time: O(n)\n    // space: O(1)\n    count := 0\n    for i :=\
    \ 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n     \
    \       if grid[i][j] == 1 {\n                count += capacity\n            }\n\
    \        }\n    }\n    return count\n}\n", "    // Fill this in.\n    return 0\n\
    }\n", "    // TODO - Add your code here\n    return 0\n}\n", "    // TODO - Add\
    \ your code here\n    return 0\n}\n", "    // TODO - Add your code here\n    return\
    \ 0\n}\n", "    // fill the wells\n    // return the number of times you need\
    \ to lower the buckets\n    return 0\n}\n", "    // fill the first row\n    var\
    \ count int\n    for i := 0; i < len(grid[0]); i++ {\n        if grid[0][i] ==\
    \ 1 {\n            count++\n        }\n    }\n    // fill the rest of the rows\n\
    \    for i := 1; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                if grid[i-1][j] < capacity\
    \ {\n                    grid[i-1][j]++\n                    count++\n       \
    \         }\n            }\n        }\n    }\n    return count\n}\n", "    //\
    \ Fill this in.\n    return 0\n}\n", "    // fill the wells\n    // return the\
    \ number of times you need to lower the buckets\n    // score: 100(0ms)\n    //\
    \ time: O(n^2)\n    // space: O(1)\n    count := 0\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                grid[i][j] = 0\n       \
    \         if i > 0 && grid[i-1][j] == 1 {\n                    grid[i-1][j] =\
    \ 0\n                    count += 1\n                }\n                if j >\
    \ 0 && grid[i][j-1] == 1 {\n                    grid[i][j-1] = 0\n           \
    \         count += 1\n                }\n            }\n        }\n    }\n   \
    \ return count\n}\n", "    // fill the wells\n    fill_count := 0\n    for i :=\
    \ 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n     \
    \       if grid[i][j] == 1 {\n                fill_count++\n            }\n  \
    \      }\n    }\n    // empty the wells\n    empty_count := 0\n    for i := 0;\
    \ i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n        \
    \    if grid[i][j] == 1 {\n                empty_count++\n                if empty_count\
    \ % capacity == 0 {\n                    fill_count++\n                }\n   \
    \         }\n        }\n    }\n    return fill_count\n}\n", "    if len(grid)\
    \ == 0 {\n        return 0\n    }\n    if len(grid[0]) == 0 {\n        return\
    \ 0\n    }\n    // fill the first row\n    count := 0\n    for i := 0; i < len(grid[0]);\
    \ i++ {\n        if grid[0][i] == 1 {\n            count++\n        }\n    }\n\
    \    // fill the rest\n    for i := 1; i < len(grid); i++ {\n        for j :=\
    \ 0; j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n             \
    \   if grid[i-1][j] == 0 {\n                    count++\n                }\n \
    \           }\n        }\n    }\n    return count * capacity\n}\n", "    // TODO\
    \ - Add your code here\n    return 0\n}\n", "    // fill the wells from the bottom\
    \ up\n    // fill each well with the maximum amount of water it can hold\n   \
    \ // return the number of times the bucket was lowered\n    var lowered int\n\
    \    for i := len(grid) - 1; i >= 0; i-- {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if grid[i][j] == 1 {\n                lowered += capacity\
    \ - grid[i][j]\n                grid[i][j] = capacity\n            }\n       \
    \ }\n    }\n    return lowered\n}\n", "    // fill the wells\n    for i := 0;\
    \ i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n        \
    \    if grid[i][j] == 1 {\n                grid[i][j] = capacity\n           \
    \ }\n        }\n    }\n    // fill the buckets\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ > 0 {\n                if i > 0 && grid[i-1][j] > 0 {\n                    grid[i][j]\
    \ = min(grid[i][j], grid[i-1][j] + 1)\n                }\n                if j\
    \ > 0 && grid[i][j-1] > 0 {\n                    grid[i][j] = min(grid[i][j],\
    \ grid[i][j-1] + 1)\n                }\n            }\n        }\n    }\n    //\
    \ count the buckets\n    count := 0\n    for i := len(grid) - 1; i >= 0; i-- {\n\
    \        for j := len(grid[i]) - 1; j >= 0; j-- {\n            if grid[i][j] >\
    \ 0 {\n                count += grid[i][j]\n            }\n        }\n    }\n\
    \    return count\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // Fill\
    \ this in.\n    return 0\n}\n", "    // fill the wells from the bottom up\n  \
    \  // if the well is full, fill the next well\n    // if the well is not full,\
    \ fill the well and the next well\n    // if the well is empty, fill the next\
    \ well\n    // if the well is empty and the next well is empty, do nothing\n \
    \   // if the well is empty and the next well is full, fill the next well\n  \
    \  // if the well is full and the next well is empty, do nothing\n    // if the\
    \ well is full and the next well is full, fill the next well\n    // if the well\
    \ is not full and the next well is empty, fill the well and the next well\n  \
    \  // if the well is not full and the next well is full, fill the well and the\
    \ next well\n    // if the well is empty and the next well is not full, fill the\
    \ next well\n    // if the well is full and the next well is not full, fill the\
    \ next well\n    // if the well is not full and the next well is not full, fill\
    \ the well and the next well\n    // if the well is not full and the next well\
    \ is not full and the next well is not full, fill the well and the next well and\
    \ the next well\n    // if the well is not full and the next well is not full\
    \ and the next well is full, fill the well and the next well and the next well\n\
    \    // if the well is not full and the next well is full and the next well is\
    \ not full, fill the well and the next well and the next well\n    // if the well\
    \ is not full and the next well is full and the next well is full, fill the well\
    \ and the next well and the next well\n    // if the well is full and the next\
    \ well is not full and the next well is not full, fill the next well and the next\
    \ well\n    // if the well is full and the next well is not full and the next\
    \ well is full, fill the next well and the next well\n    // if the well is full\
    \ and the next well is full and the next well is not full, fill the next well\
    \ and the next well\n    // if the well is full and the next well is full and\
    \ the next well is full, fill the next well and the next well\n    // if the well\
    \ is empty and the next well is not full and the next well is not", "    // return\
    \ max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n}\n", " \
    \   // Fill this in.\n    return 0\n}\n", "    // TODO - Add your code here\n\
    \    return 0\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // return\
    \ max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n}\n", " \
    \   // Fill this in.\n    return 0\n}\n", "    // fill each well\n    for i :=\
    \ 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n     \
    \       if grid[i][j] == 1 {\n                grid[i][j] = capacity\n        \
    \    }\n        }\n    }\n    // fill each row\n    for i := 0; i < len(grid);\
    \ i++ {\n        // find the max value in the row\n        max := 0\n        for\
    \ j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > max {\n       \
    \         max = grid[i][j]\n            }\n        }\n        // fill the row\n\
    \        for j := 0; j < len(grid[i]); j++ {\n            grid[i][j] = max\n \
    \       }\n    }\n    // fill each column\n    for j := 0; j < len(grid[0]); j++\
    \ {\n        // find the max value in the column\n        max := 0\n        for\
    \ i := 0; i < len(grid); i++ {\n            if grid[i][j] > max {\n          \
    \      max = grid[i][j]\n            }\n        }\n        // fill the column\n\
    \        for i := 0; i < len(grid); i++ {\n            grid[i][j] = max\n    \
    \    }\n    }\n    // count the number of times we filled\n    count := 0\n  \
    \  for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            count += capacity - grid[i][j]\n        }\n    }\n    return\
    \ count\n}\n", "    // fill the wells from the bottom up\n    // if the well is\
    \ full, fill the next well\n    // if the well is not full, fill the well\n  \
    \  // if the well is empty, skip the well\n    // return the number of times the\
    \ bucket is lowered\n    //\n    // Example 1:\n    // Input: \n    // grid :\
    \ [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    // bucket_capacity : 1\n    // Output:\
    \ 6\n    //\n    // Example 2:\n    // Input: \n    // grid : [[0,0,1,1], [0,0,0,0],\
    \ [1,1,1,1], [0,1,1,1]]\n    // bucket_capacity : 2\n    // Output: 5\n    //\n\
    \    // Example 3:\n    // Input: \n    // grid : [[0,0,0], [0,0,0]]\n    // bucket_capacity\
    \ : 5\n    // Output: 0\n    //\n    // Example 4:\n    // Input: \n    // grid\
    \ : [[0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],\
    \ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],\
    \ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0]]\n    // bucket_capacity : 5\n\
    \    // Output: 0\n    //\n    // Example 5:\n    // Input: \n    // grid : [[0,0,0,0,",
  "    // fill the wells\n    // return the number of times you need to lower the\
    \ buckets\n    return 0\n}\n", "    // fill the wells from left to right\n   \
    \ // if a well is full, fill the next well\n    // if a well is not full, fill\
    \ the well to capacity\n    // if a well is empty, skip the well\n    // return\
    \ the number of times the bucket is lowered\n    //\n    // example 1:\n    //\
    \ 0 0 1 0\n    // 0 1 0 0\n    // 1 1 1 1\n    //\n    // 0 0 1 0\n    // 0 1\
    \ 1 0\n    // 1 1 1 1\n    //\n    // 0 0 1 0\n    // 0 1 1 1\n    // 1 1 1 1\n\
    \    //\n    // 0 0 1 1\n    // 0 1 1 1\n    // 1 1 1 1\n    //\n    // 0 0 1\
    \ 1\n    // 0 1 1 1\n    // 1 1 1 1\n    //\n    // 0 0 1 1\n    // 0 1 1 1\n\
    \    // 1 1 1 1\n    //\n    // example 2:\n    // 0 0 1 1\n    // 0 0 0 0\n \
    \   // 1 1 1 1\n    // 0 1 1 1\n    //\n    // 0 0 1 1\n    // 0 0 1 0\n    //\
    \ 1 1 1 1\n    // 0 1 1 1\n    //\n    // 0 0 1 1\n    // 0 0 1 1\n    // 1 1\
    \ 1 1\n    // 0 1 1 1\n    //\n    // 0 0 1 1\n    // 0 0 1 1\n    // 1 1 1 1\n\
    \    // 0 1 1 1\n    //\n    // 0 0 1 1\n    // 0 0 1 1\n    // 1 1 1 1\n    //\
    \ 0 1 1 1\n    //\n    // example 3:\n    // 0 0 0\n    // 0 0 0\n    //\n   \
    \ // 0 0 0\n    // 0 0 0\n    //\n    // 0 0 0\n    // 0 0 0\n    //\n    // 0\
    \ 0 0\n    // 0 0 0\n    //\n    // 0 0 0\n    // 0 0 0\n    //\n    // 0 0 0\n\
    \    // 0 0 0\n    //\n    // 0 0 0\n    // 0 0 0\n    //\n    // 0 0 0\n    //\
    \ 0 0 0\n    //\n    // 0 0 0\n    // 0", "    // TODO - Add your code here\n\
    \    return 0\n}\n", "    // fill each well with water\n    // return the number\
    \ of times you need to lower the buckets\n    // score: 100(0ms)\n    // time:\
    \ O(n)\n    // space: O(1)\n    var count int\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ == 0 {\n                continue\n            }\n            if grid[i][j] <\
    \ capacity {\n                count += capacity - grid[i][j]\n            }\n\
    \        }\n    }\n    return count\n}\n", "    if len(grid) == 0 {\n        return\
    \ 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n    // fill the\
    \ first row\n    for i := 0; i < len(grid[0]); i++ {\n        if grid[0][i] ==\
    \ 1 {\n            grid[0][i] = capacity\n        }\n    }\n    // fill the rest\
    \ of the rows\n    for i := 1; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if grid[i][j] == 1 {\n                grid[i][j] = grid[i-1][j]\
    \ - 1\n            }\n        }\n    }\n    // count the number of times we need\
    \ to fill the buckets\n    count := 0\n    for i := 0; i < len(grid); i++ {\n\
    \        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n\
    \                count += capacity - grid[i][j]\n            }\n        }\n  \
    \  }\n    return count\n}\n", "    // Fill this in.\n    return 0\n}\n", "   \
    \ // return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n\
    }\n", "    // fill the wells\n    // return the number of times you need to lower\
    \ the buckets\n    // score: 100(0ms)\n    // time: O(n^2)\n    // space: O(1)\n\
    \    count := 0\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j <\
    \ len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n                count\
    \ += 1\n                grid[i][j] = 0\n                for k := i + 1; k < len(grid);\
    \ k++ {\n                    if grid[k][j] == 1 {\n                        grid[k][j]\
    \ = 0\n                        count += 1\n                    } else {\n    \
    \                    break\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return count\n}\n", "    // TODO - Add your code\
    \ here\n    return 0\n}\n", "    if len(grid) == 0 {\n        return 0\n    }\n\
    \    if len(grid[0]) == 0 {\n        return 0\n    }\n    // find the max in each\
    \ row\n    max_in_row := make([]int, len(grid))\n    for i := 0; i < len(grid);\
    \ i++ {\n        max_in_row[i] = 0\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] > max_in_row[i] {\n                max_in_row[i]\
    \ = grid[i][j]\n            }\n        }\n    }\n    // find the max in each column\n\
    \    max_in_col := make([]int, len(grid[0]))\n    for j := 0; j < len(grid[0]);\
    \ j++ {\n        max_in_col[j] = 0\n        for i := 0; i < len(grid); i++ {\n\
    \            if grid[i][j] > max_in_col[j] {\n                max_in_col[j] =\
    \ grid[i][j]\n            }\n        }\n    }\n    // find the max in each row\
    \ and column\n    max_in_row_col := make([]int, len(grid))\n    for i := 0; i\
    \ < len(grid); i++ {\n        max_in_row_col[i] = 0\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if max_in_row[i] > max_in_row_col[i] {\n                max_in_row_col[i]\
    \ = max_in_row[i]\n            }\n            if max_in_col[j] > max_in_row_col[i]\
    \ {\n                max_in_row_col[i] = max_in_col[j]\n            }\n      \
    \  }\n    }\n    // find the max in each row and column\n    max_in_col_row :=\
    \ make([]int, len(grid[0]))\n    for j := 0; j < len(grid[0]); j++ {\n       \
    \ max_in_col_row[", "    // Fill this in.\n    return 0\n}\n", "    // fill the\
    \ wells\n    // return the number of times you need to lower the buckets\n   \
    \ return 0\n}\n", "    // fill the wells from the bottom up\n    // the number\
    \ of times we need to fill is the number of rows\n    // the number of times we\
    \ need to lower the buckets is the number of rows\n    // the number of times\
    \ we need to fill each bucket is the number of wells\n    // the number of times\
    \ we need to lower each bucket is the number of wells\n    // the number of times\
    \ we need to fill each well is the number of units of water\n    // the number\
    \ of times we need to lower each well is the number of units of water\n    //\
    \ the number of times we need to fill each unit of water is the capacity\n   \
    \ // the number of times we need to lower each unit of water is the capacity\n\
    \    // the number of times we need to fill each bucket is the sum of the number\
    \ of units of water in each well\n    // the number of times we need to lower\
    \ each bucket is the sum of the number of units of water in each well\n    //\
    \ the number of times we need to fill each well is the sum of the number of units\
    \ of water in each well\n    // the number of times we need to lower each well\
    \ is the sum of the number of units of water in each well\n    // the number of\
    \ times we need to fill is the sum of the number of units of water in each well\n\
    \    // the number of times we need to lower the buckets is the sum of the number\
    \ of units of water in each well\n    // the number of times we need to fill is\
    \ the sum of the number of units of water in each row\n    // the number of times\
    \ we need to lower the buckets is the sum of the number of units of water in each\
    \ row\n    // the number of times we need to fill is the sum of the number of\
    \ 1s in each row\n    // the number of times we need to lower the buckets is the\
    \ sum of the number of 1s in each row\n    // the number of times we need to fill\
    \ is the sum of the number of 1s in the grid\n    // the number of times we need\
    \ to lower the buckets is the sum of the number of 1s in the grid\n    // the\
    \ number of times we need to fill is the sum of the number of 1s in the grid\n\
    \    // the number of times we need to lower the buckets is the sum of the number\
    \ of 1s in the grid\n    // the number of times we", "    // return max_fill_v1(grid,\
    \ capacity)\n    return max_fill_v2(grid, capacity)\n}\n", "    // fill the wells\n\
    \    // return the number of times you need to lower the buckets\n    // score:\
    \ 100(0ms)\n    // time: O(n)\n    // space: O(1)\n    count := 0\n    for i :=\
    \ 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n     \
    \       if grid[i][j] == 1 {\n                count++\n                grid[i][j]\
    \ = 0\n                for k := i + 1; k < len(grid); k++ {\n                \
    \    if grid[k][j] == 1 {\n                        grid[k][j] = 0\n          \
    \              count++\n                    } else {\n                       \
    \ break\n                    }\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n", "    // fill each well with the bucket\n    //\
    \ until all wells are empty\n    // return the number of times the bucket was\
    \ lowered\n    // grid[i][j] -> 0 | 1\n    // capacity -> 1..10\n    // grid.length\
    \ -> 1..100\n    // grid[i].length -> 1..100\n    //\n    // 1. fill each well\
    \ with the bucket\n    // 2. until all wells are empty\n    // 3. return the number\
    \ of times the bucket was lowered\n    //\n    // 1. fill each well with the bucket\n\
    \    //   1.1. for each well\n    //     1.1.1. fill the well with the bucket\n\
    \    //       1.1.1.1. for each unit of water in the well\n    //         1.1.1.1.1.\
    \ fill the unit with the bucket\n    //   1.2. return the number of times the\
    \ bucket was lowered\n    //\n    // 1. fill each well with the bucket\n    //\
    \   1.1. for each well\n    //     1.1.1. fill the well with the bucket\n    //\
    \       1.1.1.1. for each unit of water in the well\n    //         1.1.1.1.1.\
    \ fill the unit with the bucket\n    //   1.2. return the number of times the\
    \ bucket was lowered\n    //\n    // 1. fill each well with the bucket\n    //\
    \   1.1. for each well\n    //     1.1.1. fill the well with the bucket\n    //\
    \       1.1.1.1. for each unit of water in the well\n    //         1.1.1.1.1.\
    \ fill the unit with the bucket\n    //   1.2. return the number of times the\
    \ bucket was lowered\n    //\n    // 1. fill each well with the bucket\n    //\
    \   1.1. for each well\n    //     1.1.1. fill the well with the bucket\n    //\
    \       1.1.1.1. for each unit of water in the well\n    //         1.1.1.1.1.\
    \ fill the unit with the bucket\n    //   1.2. return the number of times the\
    \ bucket was lowered\n    //\n    // 1. fill each", "    // Fill this in.\n  \
    \  return 0\n}\n", "    // TODO - Add your code here\n    return 0\n}\n", "  \
    \  if len(grid) == 0 {\n        return 0\n    }\n    if len(grid[0]) == 0 {\n\
    \        return 0\n    }\n    // count the number of wells\n    wells := 0\n \
    \   for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                wells++\n            }\n\
    \        }\n    }\n    // if all wells are empty, return 0\n    if wells == 0\
    \ {\n        return 0\n    }\n    // if all wells are full, return the number\
    \ of wells\n    if wells == len(grid) * len(grid[0]) {\n        return wells\n\
    \    }\n    // if the capacity is 1, return the number of wells\n    if capacity\
    \ == 1 {\n        return wells\n    }\n    // if the capacity is greater than\
    \ the number of wells, return the number of wells\n    if capacity >= wells {\n\
    \        return wells\n    }\n    // if the capacity is less than the number of\
    \ wells, return the number of wells\n    // minus the number of wells that can\
    \ be filled by the capacity\n    return wells - (wells % capacity)\n}\n", "  \
    \  // Fill this in.\n    return 0\n}\n", "    if len(grid) == 0 {\n        return\
    \ 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n    // find max\
    \ height\n    max_height := 0\n    for _, row := range grid {\n        for _,\
    \ cell := range row {\n            if cell > max_height {\n                max_height\
    \ = cell\n            }\n        }\n    }\n    // fill each level\n    count :=\
    \ 0\n    for level := 0; level < max_height; level++ {\n        for _, row :=\
    \ range grid {\n            for _, cell := range row {\n                if cell\
    \ > level {\n                    count += capacity\n                }\n      \
    \      }\n        }\n    }\n    return count\n}\n", "    // fill the wells\n \
    \   // return the number of times you need to lower the buckets\n    // score:\
    \ 100(0ms)\n    // time: O(n^2)\n    // space: O(1)\n    count := 0\n    for i\
    \ := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n  \
    \          if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                for k := 1; k <= capacity; k++ {\n                    if\
    \ i + k < len(grid) && grid[i + k][j] == 1 {\n                        grid[i +\
    \ k][j] = 0\n                    }\n                    if j + k < len(grid[i])\
    \ && grid[i][j + k] == 1 {\n                        grid[i][j + k] = 0\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // fill each well\
    \ with the capacity\n    // then count the number of 1's\n    // return that number\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // now we need to fill the wells with the\
    \ overflow from the previous wells\n    // we need to fill the wells from left\
    \ to right\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if grid[i][j] > 0 {\n                // we have water in\
    \ this well\n                // we need to check if the well to the right has\
    \ water\n                if j + 1 < len(grid[i]) && grid[i][j+1] > 0 {\n     \
    \               // we have water in the well to the right\n                  \
    \  // we need to see how much water we can move\n                    // we can\
    \ move the minimum of the two wells\n                    if grid[i][j] < grid[i][j+1]\
    \ {\n                        // we can move all of the water in the current well\n\
    \                        grid[i][j+1] += grid[i][j]\n                        grid[i][j]\
    \ = 0\n                    } else {\n                        // we can only move\
    \ some of the water in the current well\n                        grid[i][j] -=\
    \ grid[i][j+1]\n                        grid[i][j+1] = capacity\n            \
    \        }\n                }\n            }\n        }\n    }\n    // now we\
    \ need to fill the wells with the overflow from the previous wells\n    // we\
    \ need to fill the wells from right to left\n    for i := 0; i < len(grid); i++\
    \ {\n        for j := len(grid[i]) - 1; j >= 0; j-- {\n            if grid[i][j]\
    \ > 0 {\n                // we have water in this well\n                // we\
    \ need to check if the well to the left has water\n                if j - 1 >=\
    \ 0 && grid[i][j-1] > 0 {\n                    // we have water in the well to\
    \ the left\n", "    // fill the wells\n    for i := 0; i < len(grid); i++ {\n\
    \        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = capacity\n            }\n        }\n    }\n    //\
    \ fill the buckets\n    for i := 0; i < len(grid); i++ {\n        for j := 0;\
    \ j < len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n                //\
    \ fill the bucket\n                for k := i + 1; k < len(grid); k++ {\n    \
    \                if grid[k][j] > 0 {\n                        // fill the well\n\
    \                        if grid[k][j] > grid[i][j] {\n                      \
    \      grid[k][j] -= grid[i][j]\n                            grid[i][j] = 0\n\
    \                        } else {\n                            grid[i][j] -= grid[k][j]\n\
    \                            grid[k][j] = 0\n                        }\n     \
    \               }\n                }\n            }\n        }\n    }\n    //\
    \ count the number of times we need to lower the buckets\n    count := 0\n   \
    \ for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] > 0 {\n                count++\n            }\n\
    \        }\n    }\n    return count\n}\n", "    // Fill this in.\n    return 0\n\
    }\n", "    // Fill this in.\n    return 0\n}\n", "    // fill the wells from left\
    \ to right\n    // if a well is filled, then the next well is filled with the\
    \ remaining water\n    // if a well is not filled, then the next well is filled\
    \ with the full capacity\n    // if a well is filled with the full capacity, then\
    \ the next well is filled with the remaining water\n    // if a well is filled\
    \ with the remaining water, then the next well is filled with the full capacity\n\
    \    // if a well is filled with the remaining water, then the next well is filled\
    \ with the remaining water\n    // if a well is filled with the full capacity,\
    \ then the next well is filled with the full capacity\n    // if a well is filled\
    \ with the remaining water, then the next well is filled with the remaining water\n\
    \    // if a well is filled with the full capacity, then the next well is filled\
    \ with the full capacity\n    // if a well is filled with the remaining water,\
    \ then the next well is filled with the remaining water\n    // if a well is filled\
    \ with the full capacity, then the next well is filled with the full capacity\n\
    \    // if a well is filled with the remaining water, then the next well is filled\
    \ with the remaining water\n    // if a well is filled with the full capacity,\
    \ then the next well is filled with the full capacity\n    // if a well is filled\
    \ with the remaining water, then the next well is filled with the remaining water\n\
    \    // if a well is filled with the full capacity, then the next well is filled\
    \ with the full capacity\n    // if a well is filled with the remaining water,\
    \ then the next well is filled with the remaining water\n    // if a well is filled\
    \ with the full capacity, then the next well is filled with the full capacity\n\
    \    // if a well is filled with the remaining water, then the next well is filled\
    \ with the remaining water\n    // if a well is filled with the full capacity,\
    \ then the next well is filled with the full capacity\n    // if a well is filled\
    \ with the remaining water, then the next well is filled with the remaining water\n\
    \    // if a well is filled with the full capacity, then the next well is filled\
    \ with the full capacity\n    // if a well is filled with the remaining water,\
    \ then the next well is filled with the remaining water\n    // if a well is filled\
    \ with the full capacity, then the next well is filled with the full capacity\n\
    \    //", "    // Fill this in.\n    return 0\n}\n", "    // fill the wells from\
    \ the bottom\n    // if the well is already full, skip it\n    // if the well\
    \ is not full, fill it with the capacity\n    // if the well is overfilled, fill\
    \ it with the capacity and fill the next well with the remaining water\n    //\
    \ repeat until all wells are full\n    // return the number of times you need\
    \ to lower the buckets\n    // T: O(n^2)\n    // S: O(1)\n    var count int\n\
    \    for i := len(grid) - 1; i >= 0; i-- {\n        for j := len(grid[0]) - 1;\
    \ j >= 0; j-- {\n            if grid[i][j] == 0 {\n                count += capacity\n\
    \                grid[i][j] = capacity\n            }\n            if i > 0 {\n\
    \                if grid[i][j] > grid[i-1][j] {\n                    grid[i-1][j]\
    \ += grid[i][j] - grid[i-1][j]\n                    grid[i][j] = grid[i-1][j]\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n", " \
    \   // TODO - Add your code here\n    return 0\n}\n", "    // fill the wells\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // find the max fill\n    max_fill := 0\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] > max_fill {\n                max_fill = grid[i][j]\n\
    \            }\n        }\n    }\n    // count the number of times we need to\
    \ lower the buckets\n    count := 0\n    for i := 0; i < len(grid); i++ {\n  \
    \      for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] < max_fill\
    \ {\n                count += max_fill - grid[i][j]\n            }\n        }\n\
    \    }\n    return count\n}\n", "    // TODO - Add your code here\n    return\
    \ 0\n}\n", "    // TODO - Add your code here\n    return 0\n}\n", "    // fill\
    \ each row to capacity\n    // return the number of times we filled the bucket\n\
    \    var count int\n    for _, row := range grid {\n        count += fill_row(row,\
    \ capacity)\n    }\n    return count\n}\n", "    // return max_fill_v1(grid, capacity)\n\
    \    return max_fill_v2(grid, capacity)\n}\n", "    // fill the wells from the\
    \ bottom up\n    // fill the wells from left to right\n    // if a well is full,\
    \ fill the next well\n    // if a well is empty, fill the previous well\n    //\
    \ if a well is full and the next well is empty, fill the next well\n    // if\
    \ a well is empty and the previous well is full, fill the previous well\n    //\
    \ if a well is full and the next well is full, fill the next well\n    // if a\
    \ well is empty and the previous well is empty, fill the previous well\n    //\
    \ if a well is full and the next well is empty, fill the next well\n    // if\
    \ a well is empty and the previous well is full, fill the previous well\n    //\
    \ if a well is full and the next well is full, fill the next well\n    // if a\
    \ well is empty and the previous well is empty, fill the previous well\n    //\
    \ if a well is full and the next well is empty, fill the next well\n    // if\
    \ a well is empty and the previous well is full, fill the previous well\n    //\
    \ if a well is full and the next well is full, fill the next well\n    // if a\
    \ well is empty and the previous well is empty, fill the previous well\n    //\
    \ if a well is full and the next well is empty, fill the next well\n    // if\
    \ a well is empty and the previous well is full, fill the previous well\n    //\
    \ if a well is full and the next well is full, fill the next well\n    // if a\
    \ well is empty and the previous well is empty, fill the previous well\n    //\
    \ if a well is full and the next well is empty, fill the next well\n    // if\
    \ a well is empty and the previous well is full, fill the previous well\n    //\
    \ if a well is full and the next well is full, fill the next well\n    // if a\
    \ well is empty and the previous well is empty, fill the previous well\n    //\
    \ if a well is full and the next well is empty, fill the next well\n    // if\
    \ a well is empty and the previous well is full, fill the previous well\n    //\
    \ if a well is full and the next well is full, fill the next well\n    // if a\
    \ well is empty and the previous well is empty, fill the previous well\n    //\
    \ if a well is full and the", "    // fill the wells from the bottom up\n    //\
    \ when a well is filled, it is removed from the grid\n    // when a well is filled,\
    \ the wells above it are filled\n    // when a well is filled, the wells to the\
    \ left and right of it are filled\n    // when a well is filled, the wells above\
    \ it are filled\n    // when a well is filled, the wells to the left and right\
    \ of it are filled\n    // when a well is filled, the wells above it are filled\n\
    \    // when a well is filled, the wells to the left and right of it are filled\n\
    \    // when a well is filled, the wells above it are filled\n    // when a well\
    \ is filled, the wells to the left and right of it are filled\n    // when a well\
    \ is filled, the wells above it are filled\n    // when a well is filled, the\
    \ wells to the left and right of it are filled\n    // when a well is filled,\
    \ the wells above it are filled\n    // when a well is filled, the wells to the\
    \ left and right of it are filled\n    // when a well is filled, the wells above\
    \ it are filled\n    // when a well is filled, the wells to the left and right\
    \ of it are filled\n    // when a well is filled, the wells above it are filled\n\
    \    // when a well is filled, the wells to the left and right of it are filled\n\
    \    // when a well is filled, the wells above it are filled\n    // when a well\
    \ is filled, the wells to the left and right of it are filled\n    // when a well\
    \ is filled, the wells above it are filled\n    // when a well is filled, the\
    \ wells to the left and right of it are filled\n    // when a well is filled,\
    \ the wells above it are filled\n    // when a well is filled, the wells to the\
    \ left and right of it are filled\n    // when a well is filled, the wells above\
    \ it are filled\n    // when a well is filled, the wells to the left and right\
    \ of it are filled\n    // when a well is filled, the wells above it are filled\n\
    \    // when a well is filled, the wells to the left and right of it are filled\n\
    \    // when a well is filled, the wells above it are filled\n    // when a well\
    \ is filled, the wells to the left and right of", "    // fill the wells\n   \
    \ for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // fill the buckets\n    for i := 0; i <\
    \ len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if\
    \ grid[i][j] > 0 {\n                // fill the bucket\n                grid[i][j]\
    \ -= 1\n                // fill the wells\n                if i > 0 {\n      \
    \              grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n              \
    \  }\n                if i < len(grid) - 1 {\n                    grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                }\n                if j >\
    \ 0 {\n                    grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n  \
    \              }\n                if j < len(grid[i]) - 1 {\n                \
    \    grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n                }\n     \
    \       }\n        }\n    }\n    // count the buckets\n    count := 0\n    for\
    \ i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n\
    \            if grid[i][j] > 0 {\n                count += 1\n            }\n\
    \        }\n    }\n    return count\n}\n", "    // Fill this in.\n    return 0\n\
    }\n", "    // return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid,\
    \ capacity)\n}\n", "    // TODO - Add your code here\n    return 0\n}\n", "  \
    \  // return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n\
    }\n", "    // fill the wells\n    for i := 0; i < len(grid); i++ {\n        for\
    \ j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n        \
    \        grid[i][j] = capacity\n            }\n        }\n    }\n    // fill the\
    \ buckets\n    var buckets []int\n    for i := 0; i < len(grid[0]); i++ {\n  \
    \      buckets = append(buckets, capacity)\n    }\n    // fill the wells\n   \
    \ var count int\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j <\
    \ len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n                if buckets[j]\
    \ > 0 {\n                    if buckets[j] >= grid[i][j] {\n                 \
    \       buckets[j] -= grid[i][j]\n                        grid[i][j] = 0\n   \
    \                 } else {\n                        grid[i][j] -= buckets[j]\n\
    \                        buckets[j] = 0\n                    }\n             \
    \       count++\n                }\n            }\n        }\n    }\n    // fill\
    \ the buckets\n    for i := 0; i < len(buckets); i++ {\n        if buckets[i]\
    \ > 0 {\n            count++\n        }\n    }\n    return count\n}\n", "    //\
    \ fill the first row\n    var count int\n    for i := 0; i < len(grid[0]); i++\
    \ {\n        if grid[0][i] == 1 {\n            count++\n        }\n    }\n   \
    \ // fill the rest of the rows\n    for i := 1; i < len(grid); i++ {\n       \
    \ for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n    \
    \            if grid[i-1][j] < capacity {\n                    grid[i-1][j]++\n\
    \                    count++\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n", "    // fill the first row\n    count := 0\n   \
    \ for i := 0; i < len(grid[0]); i++ {\n        if grid[0][i] == 1 {\n        \
    \    count++\n        }\n    }\n    // fill the rest rows\n    for i := 1; i <\
    \ len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if\
    \ grid[i][j] == 1 {\n                if grid[i-1][j] == 0 {\n                \
    \    count++\n                }\n            } else {\n                if grid[i-1][j]\
    \ == 1 {\n                    count++\n                }\n            }\n    \
    \    }\n    }\n    return count\n}\n", "    // TODO - Add your code here\n   \
    \ return 0\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // fill the\
    \ wells\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if grid[i][j] == 1 {\n                grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // find the max fill\n    max_fill := 0\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] > max_fill {\n                max_fill = grid[i][j]\n\
    \            }\n        }\n    }\n    // find the min fill\n    min_fill := max_fill\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] < min_fill {\n                min_fill = grid[i][j]\n\
    \            }\n        }\n    }\n    // find the number of times to lower the\
    \ buckets\n    return max_fill - min_fill\n}\n", "    // TODO - Add your code\
    \ here\n    return 0\n}\n", "    // fill the wells from the bottom up\n    //\
    \ for each row, fill the wells that are not filled\n    // if the well is filled,\
    \ then move to the next well\n    // if the well is not filled, then fill it\n\
    \    // if the well is not filled, but the bucket is empty, then move to the next\
    \ well\n    // if the well is not filled, but the bucket is not empty, then fill\
    \ the well\n    // if the well is not filled, but the bucket is not empty, and\
    \ the well is full, then move to the next well\n    // if the well is not filled,\
    \ but the bucket is not empty, and the well is not full, then fill the well\n\
    \    // if the well is not filled, but the bucket is not empty, and the well is\
    \ not full, and the bucket is full, then move to the next well\n    // if the\
    \ well is not filled, but the bucket is not empty, and the well is not full, and\
    \ the bucket is not full, then fill the well\n    // if the well is not filled,\
    \ but the bucket is not empty, and the well is not full, and the bucket is not\
    \ full, and the well is full, then move to the next well\n    // if the well is\
    \ not filled, but the bucket is not empty, and the well is not full, and the bucket\
    \ is not full, and the well is not full, then fill the well\n    // if the well\
    \ is not filled, but the bucket is not empty, and the well is not full, and the\
    \ bucket is not full, and the well is not full, and the bucket is full, then move\
    \ to the next well\n    // if the well is not filled, but the bucket is not empty,\
    \ and the well is not full, and the bucket is not full, and the well is not full,\
    \ and the bucket is not full, then fill the well\n    // if the well is not filled,\
    \ but the bucket is not empty, and the well is not full, and the bucket is not\
    \ full, and the well is not full, and the bucket is not full, and the well is\
    \ full, then move to the next well\n    // if the well is not filled, but the\
    \ bucket is not empty, and the well is not full, and the bucket is not full, and\
    \ the well is not full, and the bucket is not full, and the well", "    // return\
    \ max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n}\n", " \
    \   // fill the wells\n    // return the number of times you need to lower the\
    \ buckets\n    // score: 100(0ms)\n    // time: O(n^2)\n    // space: O(1)\n \
    \   count := 0\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j <\
    \ len(grid[i]); j++ {\n            if grid[i][j] == 1 {\n                count\
    \ += 1\n                grid[i][j] = 0\n                for k := i + 1; k < len(grid);\
    \ k++ {\n                    if grid[k][j] == 1 {\n                        grid[k][j]\
    \ = 0\n                        count += 1\n                    } else {\n    \
    \                    break\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return count\n}\n", "    // fill each well with\
    \ capacity\n    // return the number of times you need to lower the buckets\n\
    \    // score: 100(0ms)\n    // time: O(n)\n    // space: O(1)\n    count := 0\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 0 {\n                continue\n            }\n\
    \            count += capacity - grid[i][j]\n            grid[i][j] = capacity\n\
    \        }\n    }\n    return count\n}\n", "    // fill the wells from the bottom\
    \ up\n    // if a well is full, fill the next well\n    // if the next well is\
    \ full, fill the well above it\n    // if the well above it is full, fill the\
    \ well above it\n    // if the well above it is full, fill the well above it\n\
    \    // if the well above it is full, fill the well above it\n    // if the well\
    \ above it is full, fill the well above it\n    // if the well above it is full,\
    \ fill the well above it\n    // if the well above it is full, fill the well above\
    \ it\n    // if the well above it is full, fill the well above it\n    // if the\
    \ well above it is full, fill the well above it\n    // if the well above it is\
    \ full, fill the well above it\n    // if the well above it is full, fill the\
    \ well above it\n    // if the well above it is full, fill the well above it\n\
    \    // if the well above it is full, fill the well above it\n    // if the well\
    \ above it is full, fill the well above it\n    // if the well above it is full,\
    \ fill the well above it\n    // if the well above it is full, fill the well above\
    \ it\n    // if the well above it is full, fill the well above it\n    // if the\
    \ well above it is full, fill the well above it\n    // if the well above it is\
    \ full, fill the well above it\n    // if the well above it is full, fill the\
    \ well above it\n    // if the well above it is full, fill the well above it\n\
    \    // if the well above it is full, fill the well above it\n    // if the well\
    \ above it is full, fill the well above it\n    // if the well above it is full,\
    \ fill the well above it\n    // if the well above it is full, fill the well above\
    \ it\n    // if the well above it is full, fill the well above it\n    // if the\
    \ well above it is full, fill the well above it\n    // if the well above it is\
    \ full, fill the well above it\n    // if the well above it is full, fill the\
    \ well above it\n    // if the well above it is full, fill the well above it\n\
    \    // if the well above it is full", "    // fill the wells\n    for i := 0;\
    \ i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n        \
    \    if grid[i][j] == 1 {\n                grid[i][j] = capacity\n           \
    \ }\n        }\n    }\n    // fill the buckets\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ > 0 {\n                // fill the bucket\n                for k := 0; k < capacity;\
    \ k++ {\n                    // fill the wells\n                    for l := 0;\
    \ l < len(grid); l++ {\n                        if grid[l][j] > 0 {\n        \
    \                    grid[l][j]--\n                        }\n               \
    \     }\n                }\n            }\n        }\n    }\n    // count the\
    \ number of times we filled the wells\n    count := 0\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ > 0 {\n                count++\n            }\n        }\n    }\n    return\
    \ count\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // fill the wells\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // empty the wells\n    var count int\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] > 0 {\n                count += grid[i][j]\n  \
    \              // empty the well\n                grid[i][j] = 0\n           \
    \     // fill the wells below\n                for k := i + 1; k < len(grid);\
    \ k++ {\n                    if grid[k][j] > 0 {\n                        grid[k][j]\
    \ = capacity\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return count\n}\n", "    // Fill this in.\n    return 0\n}\n",
  "    // return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n\
    }\n", "    // Fill this in.\n    return 0\n}\n", "    // fill the wells from the\
    \ bottom\n    // if the well is full, fill the next well\n    // if the well is\
    \ not full, fill the well and the next well\n    // if the well is empty, fill\
    \ the next well\n    // if the next well is empty, fill the next well\n    //\
    \ if the next well is full, fill the well and the next well\n    // if the next\
    \ well is not full, fill the well and the next well\n    // if the next well is\
    \ full, fill the well and the next well\n    // if the next well is not full,\
    \ fill the well and the next well\n    // if the next well is full, fill the well\
    \ and the next well\n    // if the next well is not full, fill the well and the\
    \ next well\n    // if the next well is full, fill the well and the next well\n\
    \    // if the next well is not full, fill the well and the next well\n    //\
    \ if the next well is full, fill the well and the next well\n    // if the next\
    \ well is not full, fill the well and the next well\n    // if the next well is\
    \ full, fill the well and the next well\n    // if the next well is not full,\
    \ fill the well and the next well\n    // if the next well is full, fill the well\
    \ and the next well\n    // if the next well is not full, fill the well and the\
    \ next well\n    // if the next well is full, fill the well and the next well\n\
    \    // if the next well is not full, fill the well and the next well\n    //\
    \ if the next well is full, fill the well and the next well\n    // if the next\
    \ well is not full, fill the well and the next well\n    // if the next well is\
    \ full, fill the well and the next well\n    // if the next well is not full,\
    \ fill the well and the next well\n    // if the next well is full, fill the well\
    \ and the next well\n    // if the next well is not full, fill the well and the\
    \ next well\n    // if the next well is full, fill the well and the next well\n\
    \    // if the next well is not full, fill the well and the next well\n    //\
    \ if the next well is full, fill the well and the next well\n    // if the next\
    \ well is not", "    // Fill this in.\n    return 0\n}\n", "    // TODO - Add\
    \ your code here\n    return 0\n}\n", "    // return max_fill_v1(grid, capacity)\n\
    \    return max_fill_v2(grid, capacity)\n}\n", "    // Fill this in.\n    return\
    \ 0\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // TODO - Add your\
    \ code here\n    return 0\n}\n", "    // TODO - Add your code here\n    return\
    \ 0\n}\n", "    // fill the first row\n    var count int\n    for j := 0; j <\
    \ len(grid[0]); j++ {\n        if grid[0][j] == 1 {\n            count++\n   \
    \     }\n    }\n    // fill the rest rows\n    for i := 1; i < len(grid); i++\
    \ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] ==\
    \ 1 {\n                if grid[i-1][j] == 0 {\n                    count++\n \
    \               }\n            } else {\n                if grid[i-1][j] == 1\
    \ {\n                    count++\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n", "    // TODO - Add your code here\n    return\
    \ 0\n}\n", "    // fill the first row\n    var count int\n    for i := 0; i <\
    \ len(grid[0]); i++ {\n        if grid[0][i] == 1 {\n            grid[0][i] =\
    \ 0\n            count++\n        }\n    }\n    // fill the other rows\n    for\
    \ i := 1; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n\
    \            if grid[i][j] == 1 {\n                grid[i][j] = 0\n          \
    \      count++\n                for k := 0; k < capacity; k++ {\n            \
    \        if j - k >= 0 && grid[i - 1][j - k] == 1 {\n                        grid[i\
    \ - 1][j - k] = 0\n                        count++\n                    }\n  \
    \                  if j + k < len(grid[i]) && grid[i - 1][j + k] == 1 {\n    \
    \                    grid[i - 1][j + k] = 0\n                        count++\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // TODO\
    \ - Add your code here\n    return 0\n}\n", "    // fill the first row\n    var\
    \ fill_count int\n    for j := 0; j < len(grid[0]); j++ {\n        if grid[0][j]\
    \ == 1 {\n            fill_count++\n        }\n    }\n    // fill the rest of\
    \ the rows\n    for i := 1; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if grid[i][j] == 1 {\n                if grid[i-1][j] ==\
    \ 0 {\n                    fill_count++\n                }\n            } else\
    \ {\n                if grid[i-1][j] == 1 {\n                    fill_count++\n\
    \                }\n            }\n        }\n    }\n    return fill_count\n}\n",
  "    // TODO - Add your code here\n    return 0\n}\n", "    // return max_fill_v1(grid,\
    \ capacity)\n    return max_fill_v2(grid, capacity)\n}\n", "    // Fill this in.\n\
    \    return 0\n}\n", "    // fill each well with the bucket\n    // until the\
    \ well is full\n    // or the bucket is empty\n    // return the number of times\
    \ we lowered the bucket\n    // to fill the wells\n    //\n    // we can fill\
    \ the wells from left to right\n    // and from top to bottom\n    //\n    //\
    \ we can fill the wells in a single pass\n    //\n    // we can fill the wells\
    \ in a single pass\n    // by keeping track of the number of units of water\n\
    \    // in the bucket\n    //\n    // we can fill the wells in a single pass\n\
    \    // by keeping track of the number of units of water\n    // in the bucket\n\
    \    //\n    // we can fill the wells in a single pass\n    // by keeping track\
    \ of the number of units of water\n    // in the bucket\n    //\n    // we can\
    \ fill the wells in a single pass\n    // by keeping track of the number of units\
    \ of water\n    // in the bucket\n    //\n    // we can fill the wells in a single\
    \ pass\n    // by keeping track of the number of units of water\n    // in the\
    \ bucket\n    //\n    // we can fill the wells in a single pass\n    // by keeping\
    \ track of the number of units of water\n    // in the bucket\n    //\n    //\
    \ we can fill the wells in a single pass\n    // by keeping track of the number\
    \ of units of water\n    // in the bucket\n    //\n    // we can fill the wells\
    \ in a single pass\n    // by keeping track of the number of units of water\n\
    \    // in the bucket\n    //\n    // we can fill the wells in a single pass\n\
    \    // by keeping track of the number of units of water\n    // in the bucket\n\
    \    //\n    // we can fill the wells in a single pass\n    // by keeping track\
    \ of the number of units of water\n    // in the bucket\n    //\n    // we can\
    \ fill the wells in a single pass\n    // by keeping track of the number of units\
    \ of water\n    // in the bucket\n    //\n    // we can fill the wells in a single\
    \ pass\n    // by keeping track of the number of units of water\n    // in the\
    \ bucket\n    //\n    // we can fill the wells in a single pass\n    // by keeping\
    \ track of", "    // Fill this in.\n    return 0\n}\n", "    // Fill this in.\n\
    \    return 0\n}\n", "    // fill the wells from the bottom up\n    // if a well\
    \ is empty, fill it with water from the well above it\n    // if the well above\
    \ is empty, fill it with water from the well above it\n    // if the well above\
    \ is full, fill it with water from the well above it\n    // if the well above\
    \ is full and the well above it is empty, fill it with water from the well above\
    \ it\n    // if the well above is full and the well above it is full, fill it\
    \ with water from the well above it\n    // if the well above is full and the\
    \ well above it is full and the well above it is empty, fill it with water from\
    \ the well above it\n    // if the well above is full and the well above it is\
    \ full and the well above it is full, fill it with water from the well above it\n\
    \    // if the well above is full and the well above it is full and the well above\
    \ it is full and the well above it is empty, fill it with water from the well\
    \ above it\n    // if the well above is full and the well above it is full and\
    \ the well above it is full and the well above it is full, fill it with water\
    \ from the well above it\n    // if the well above is full and the well above\
    \ it is full and the well above it is full and the well above it is full and the\
    \ well above it is empty, fill it with water from the well above it\n    // if\
    \ the well above is full and the well above it is full and the well above it is\
    \ full and the well above it is full and the well above it is full, fill it with\
    \ water from the well above it\n    // if the well above is full and the well\
    \ above it is full and the well above it is full and the well above it is full\
    \ and the well above it is full and the well above it is empty, fill it with water\
    \ from the well above it\n    // if the well above is full and the well above\
    \ it is full and the well above it is full and the well above it is full and the\
    \ well above it is full and the well above it is full, fill it with water from\
    \ the well above it\n    // if the well above is full and the well above it is\
    \ full and the well above it is full and the well above it is full and the well\
    \ above it is full and the well above it is full and the", "    // Fill this in.\n\
    \    return 0\n}\n", "    // Fill this in.\n    return 0\n}\n", "    // fill all\
    \ wells with water\n    for i := 0; i < len(grid); i++ {\n        for j := 0;\
    \ j < len(grid[i]); j++ {\n            grid[i][j] = 1\n        }\n    }\n    //\
    \ fill all wells with water\n    for i := 0; i < len(grid); i++ {\n        for\
    \ j := 0; j < len(grid[i]); j++ {\n            grid[i][j] = 1\n        }\n   \
    \ }\n    // fill all wells with water\n    for i := 0; i < len(grid); i++ {\n\
    \        for j := 0; j < len(grid[i]); j++ {\n            grid[i][j] = 1\n   \
    \     }\n    }\n    // fill all wells with water\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            grid[i][j] =\
    \ 1\n        }\n    }\n    // fill all wells with water\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            grid[i][j] =\
    \ 1\n        }\n    }\n    // fill all wells with water\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            grid[i][j] =\
    \ 1\n        }\n    }\n    // fill all wells with water\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            grid[i][j] =\
    \ 1\n        }\n    }\n    // fill all wells with water\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            grid[i][j] =\
    \ 1\n        }\n    }\n    // fill all wells with water\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            grid[i][", " \
    \   // return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n\
    }\n", "    // Fill this in.\n    return 0\n}\n", "    // TODO - Add your code\
    \ here\n    return 0\n}\n", "    // TODO - Add your code here\n    return 0\n\
    }\n", "    // Fill this in.\n    return 0\n}\n", "    // fill the wells\n    //\
    \ return the number of times we lowered the bucket\n    //\n    // we can fill\
    \ the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single pass\n    // we can fill the wells in a single pass\n\
    \    // we can fill the wells in a single pass\n    // we can fill the wells in\
    \ a single pass\n    // we can fill the wells in a single pass\n    // we can\
    \ fill the wells in a single", "    // TODO - Add your code here\n    return 0\n\
    }\n", "    // fill the wells from the bottom up\n    // if a well is already full,\
    \ skip it\n    // if a well is not full, fill it with the capacity\n    // if\
    \ a well is overfilled, fill the next well with the remaining capacity\n    //\
    \ repeat until all wells are full\n    // return the number of times you lowered\
    \ the bucket\n    //\n    // Example 1:\n    // Input: \n    // grid : [[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]]\n    // bucket_capacity : 1\n    // Output: 6\n    //\n\
    \    // Example 2:\n    // Input: \n    // grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]]\n    // bucket_capacity : 2\n    // Output: 5\n    //\n    // Example\
    \ 3:\n    // Input: \n    // grid : [[0,0,0], [0,0,0]]\n    // bucket_capacity\
    \ : 5\n    // Output: 0\n    //\n    // Example 4:\n    // Input: \n    // grid\
    \ : [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,",
  "    // Fill this in.\n    return 0\n}\n", "    // TODO - Add your code here\n \
    \   return 0\n}\n", "    // fill the wells\n    for i := 0; i < len(grid); i++\
    \ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] ==\
    \ 1 {\n                grid[i][j] = capacity\n            }\n        }\n    }\n\
    \    // fill the buckets\n    for i := 0; i < len(grid); i++ {\n        for j\
    \ := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n           \
    \     if i > 0 && grid[i-1][j] > 0 {\n                    grid[i][j] = min(grid[i][j],\
    \ grid[i-1][j])\n                }\n                if j > 0 && grid[i][j-1] >\
    \ 0 {\n                    grid[i][j] = min(grid[i][j], grid[i][j-1])\n      \
    \          }\n            }\n        }\n    }\n    // count the buckets\n    count\
    \ := 0\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if grid[i][j] > 0 {\n                count += capacity -\
    \ grid[i][j]\n            }\n        }\n    }\n    return count\n}\n", "    //\
    \ return max_fill_v1(grid, capacity)\n    return max_fill_v2(grid, capacity)\n\
    }\n", "    // Fill this in.\n    return 0\n}\n", "    // TODO - Add your code\
    \ here\n    return 0\n}\n", "    // TODO - Add your code here\n    return 0\n\
    }\n", "    // fill the wells from the bottom up\n    // fill the wells from the\
    \ left to the right\n    // fill the wells from the right to the left\n    //\
    \ fill the wells from the top down\n    // fill the wells from the left to the\
    \ right\n    // fill the wells from the right to the left\n    // return the number\
    \ of times the wells were filled\n    return 0\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
