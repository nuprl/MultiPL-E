name: HumanEval_59_largest_prime_factor
language: go_test.go
prompt: "package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  // >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n//\
  \ 2\nfunc largest_prime_factor(n int) int {\n"
tests: "func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual:\
  \ candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n\
  \     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195),\
  \ expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // TODO: implement\n    return 0\n}\n", "    var largest int\n\
    \    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            largest =\
    \ i\n            n /= i\n            i--\n        }\n    }\n    return largest\n\
    }\n", "    // Start with the smallest prime number, 2.\n    // If n is divisible\
    \ by 2, then n is even.\n    // In that case, divide n by 2 and continue.\n  \
    \  // If n is not divisible by 2, then n is odd.\n    // In that case, try the\
    \ next prime number, 3.\n    // If n is divisible by 3, then divide n by 3 and\
    \ continue.\n    // If n is not divisible by 3, then try the next prime number,\
    \ 5.\n    // If n is divisible by 5, then divide n by 5 and continue.\n    //\
    \ If n is not divisible by 5, then try the next prime number, 7.\n    // If n\
    \ is divisible by 7, then divide n by 7 and continue.\n    // If n is not divisible\
    \ by 7, then try the next prime number, 11.\n    // If n is divisible by 11, then\
    \ divide n by 11 and continue.\n    // If n is not divisible by 11, then try the\
    \ next prime number, 13.\n    // If n is divisible by 13, then divide n by 13\
    \ and continue.\n    // If n is not divisible by 13, then try the next prime number,\
    \ 17.\n    // If n is divisible by 17, then divide n by 17 and continue.\n   \
    \ // If n is not divisible by 17, then try the next prime number, 19.\n    //\
    \ If n is divisible by 19, then divide n by 19 and continue.\n    // If n is not\
    \ divisible by 19, then try the next prime number, 23.\n    // If n is divisible\
    \ by 23, then divide n by 23 and continue.\n    // If n is not divisible by 23,\
    \ then try the next prime number, 29.\n    // If n is divisible by 29, then divide\
    \ n by 29 and continue.\n    // If n is not divisible by 29, then try the next\
    \ prime number, 31.\n    // If n is divisible by 31, then divide n by 31 and continue.\n\
    \    // If n is not divisible by 31, then try the next prime number, 37.\n   \
    \ // If n is divisible by 37, then divide n by 37 and continue.\n    // If n is\
    \ not divisible by 37, then try the next prime number,", "    // TODO: implement\n\
    \    return 0\n}\n", "    var i int\n    for i = 2; i < n; i++ {\n        if n\
    \ % i == 0 {\n            return largest_prime_factor(n / i)\n        }\n    }\n\
    \    return n\n}\n", "    // TODO: implement\n    return 0\n}\n", "    // Start\
    \ with the smallest prime factor, 2.\n    factor := 2\n    for n > 1 {\n     \
    \   for n % factor == 0 {\n            n /= factor\n        }\n        factor\
    \ += 1\n    }\n    return factor - 1\n}\n", "    for i := 2; i < n; i++ {\n  \
    \      if n % i == 0 {\n            return largest_prime_factor(n / i)\n     \
    \   }\n    }\n    return n\n}\n", "    // TODO: Implement me!\n    return 0\n\
    }\n", "    // TODO: implement\n    return 0\n}\n", "    var largest_prime int\
    \ = 1\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n = n / i\n            i = 1\n        }\n    }\n    return\
    \ largest_prime\n}\n", "    // Find the largest prime factor of n.\n    //\n \
    \   // We start with the largest possible prime factor, which is n/2.\n    //\
    \ If n/2 is a factor, then we are done.\n    // If n/2 is not a factor, then we\
    \ can reduce the search space by\n    // half.\n    //\n    // We can continue\
    \ to reduce the search space by half until we find\n    // a factor.\n    //\n\
    \    // We can stop the search when we reach the square root of n.\n    //\n \
    \   // We can skip even numbers, since all even numbers are divisible by 2.\n\
    \    //\n    // We can skip numbers that are not prime.\n    //\n    // We can\
    \ skip numbers that are not factors.\n    //\n    // We can skip numbers that\
    \ are not prime factors.\n    //\n    // We can skip numbers that are not prime\
    \ factors of n.\n    //\n    // We can skip numbers that are not prime factors\
    \ of n and are not\n    // less than the square root of n.\n    //\n    // We\
    \ can skip numbers that are not prime factors of n and are not\n    // less than\
    \ the square root of n and are not odd.\n    //\n    // We can skip numbers that\
    \ are not prime factors of n and are not\n    // less than the square root of\
    \ n and are not odd and are not prime.\n    //\n    // We can skip numbers that\
    \ are not prime factors of n and are not\n    // less than the square root of\
    \ n and are not odd and are not prime\n    // and are not factors of n.\n    //\n\
    \    // We can skip numbers that are not prime factors of n and are not\n    //\
    \ less than the square root of n and are not odd and are not prime\n    // and\
    \ are not factors of n and are not prime factors of n.\n    //\n    // We can\
    \ skip numbers that are not prime factors of n and are not\n    // less than the\
    \ square root of n and are not odd and are not prime\n    // and are not factors\
    \ of n and are not prime factors of n and are\n    // not less than the square\
    \ root of n.\n    //\n    // We can skip numbers that are not prime factors of\
    \ n and are not\n    // less than the square root of n and are", "    var i int\n\
    \    for i = 2; i < n; i++ {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i)\n        }\n    }\n    return n\n}\n", "    // Start with the smallest\
    \ prime factor, 2.\n    factor := 2\n    for n > 1 {\n        // If n is divisible\
    \ by factor, divide it out.\n        for n % factor == 0 {\n            n /= factor\n\
    \        }\n        // The next smallest prime factor is the next odd number.\n\
    \        factor += 2\n    }\n    return factor\n}\n", "    var largest_prime int\n\
    \    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n            i--\n        }\n    }\n    return largest_prime\n\
    }\n", "    // Start with the smallest prime factor, 2.\n    factor := 2\n    //\
    \ Keep going until we have no more factors.\n    for n > 1 {\n        // If factor\
    \ is a factor of n, divide n by factor and keep going.\n        for n % factor\
    \ == 0 {\n            n /= factor\n        }\n        // Otherwise, increment\
    \ factor by 1 and try again.\n        factor += 1\n    }\n    // The last factor\
    \ is the largest prime factor.\n    return factor\n}\n", "    // TODO: implement\n\
    \    return 0\n}\n", "    // TODO: implement\n    return 0\n}\n", "    var largest\
    \ int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            largest\
    \ = i\n            n /= i\n            i--\n        }\n    }\n    return largest\n\
    }\n", "    var i int = 2\n    for ; i < n; i++ {\n        if n % i == 0 {\n  \
    \          n /= i\n            i--\n        }\n    }\n    return i\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
