language: go_test.go
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf9dxwp2w_test.go:37: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpf9dxwp2w_test.go:37: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpg_z1219i_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf9dxwp2w_test.go:37: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpf9dxwp2w_test.go:37: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var bin string = \"db\"\n    for decimal > 0 {\n        bin\
    \ += fmt.Sprintf(\"%d\", decimal % 2)\n        decimal /= 2\n    }\n    bin +=\
    \ \"db\"\n    return bin\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3nf5tg8h_test.go:42: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3nf5tg8h_test.go:42:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp3nf5tg8h_test.go:42: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var result string\n    for decimal > 0 {\n        result\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, result)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpc9pqcxkg_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2vqpxlg2_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string = \"db\"\n    for decimal > 0 {\n     \
    \   binary += fmt.Sprintf(\"%d\", decimal % 2)\n        decimal /= 2\n    }\n\
    \    binary += \"db\"\n    return Reverse(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp4rj3h7u_test.go:23:12: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2vqpxlg2_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf9dxwp2w_test.go:37: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpf9dxwp2w_test.go:37: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2vqpxlg2_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%v%v\", decimal % 2, binary)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%vdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvax84egs_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string = \"db\"\n    for decimal > 0 {\n     \
    \   binary += fmt.Sprintf(\"%d\", decimal % 2)\n        decimal /= 2\n    }\n\
    \    binary += \"db\"\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp300j670c_test.go:42: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp300j670c_test.go:42:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp300j670c_test.go:42: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf9dxwp2w_test.go:37: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpf9dxwp2w_test.go:37: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf9dxwp2w_test.go:37: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpf9dxwp2w_test.go:37: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        if decimal\
    \ % 2 == 0 {\n            binary = \"0\" + binary\n        } else {\n        \
    \    binary = \"1\" + binary\n        }\n        decimal /= 2\n    }\n    return\
    \ \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpea8j18v2_test.go:45: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"db\"\n    for decimal > 0 {\n        if decimal\
    \ % 2 == 0 {\n            binary = \"0\" + binary\n        } else {\n        \
    \    binary = \"1\" + binary\n        }\n        decimal /= 2\n    }\n    return\
    \ binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpv368ssvs_test.go:45: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpv368ssvs_test.go:45:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpv368ssvs_test.go:45: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpv368ssvs_test.go:45:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf9dxwp2w_test.go:37: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpf9dxwp2w_test.go:37: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var result string\n    for decimal > 0 {\n        result\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, result)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpc9pqcxkg_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2vqpxlg2_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var result string = \"db\"\n    for decimal > 0 {\n     \
    \   result = fmt.Sprintf(\"%s%d\", result, decimal % 2)\n        decimal /= 2\n\
    \    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_olv59y4_test.go:42: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_olv59y4_test.go:42:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp_olv59y4_test.go:42: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n\n  \
    \  result := \"db\"\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%s%d\"\
    , result, decimal % 2)\n        decimal /= 2\n    }\n    result += \"db\"\n\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpw638k1n__test.go:47: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpw638k1n__test.go:47:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf9dxwp2w_test.go:37: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpf9dxwp2w_test.go:37: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf9dxwp2w_test.go:37: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2vqpxlg2_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    var binary string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n\
    \    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2vqpxlg2_test.go:41: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074228
