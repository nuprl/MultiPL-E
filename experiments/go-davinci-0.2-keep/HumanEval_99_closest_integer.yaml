name: HumanEval_99_closest_integer
language: go_test.go
prompt: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunc closest_integer(value string) int {\n"
tests: "func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     {\
  \ actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"\
  ), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     {\
  \ actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\
  \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var result int\n    var floatValue float64\n    var err error\n\
    \    if floatValue, err = strconv.ParseFloat(value, 64); err != nil {\n      \
    \  fmt.Println(\"Error:\", err)\n        return 0\n    }\n    result = int(floatValue)\n\
    \    if floatValue - float64(result) >= 0.5 {\n        result++\n    }\n    return\
    \ result\n}\n", "    var result int\n    var floatValue float64\n    var err error\n\
    \    if floatValue, err = strconv.ParseFloat(value, 64); err != nil {\n      \
    \  panic(err)\n    }\n    if floatValue < 0 {\n        result = int(floatValue\
    \ - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n", "    var result int\n    var decimal float64\n    fmt.Sscanf(value,\
    \ \"%d.%f\", &result, &decimal)\n    if decimal >= 0.5 {\n        result++\n \
    \   }\n    return result\n}\n", "    var result int\n    var floatValue float64\n\
    \    fmt.Sscanf(value, \"%f\", &floatValue)\n    if floatValue < 0 {\n       \
    \ result = int(floatValue - 0.5)\n    } else {\n        result = int(floatValue\
    \ + 0.5)\n    }\n    return result\n}\n", "    return 0\n}\n", "    var result\
    \ int\n    var floatValue float64\n    var err error\n    if floatValue, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n   \
    \ if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n", "   \
    \ var result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if float_value < 0 {\n        result = int(float_value\
    \ - 0.5)\n    } else {\n        result = int(float_value + 0.5)\n    }\n    return\
    \ result\n}\n", "    var result int\n    var err error\n    var f float64\n  \
    \  if f, err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n\
    \    }\n    if f < 0 {\n        f = -f\n    }\n    if f - math.Floor(f) >= 0.5\
    \ {\n        result = int(math.Ceil(f))\n    } else {\n        result = int(math.Floor(f))\n\
    \    }\n    if value[0] == '-' {\n        result = -result\n    }\n    return\
    \ result\n}\n", "    return 0\n}\n", "    var result int\n    var err error\n\
    \    var float_value float64\n    if float_value, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if float_value < 0 {\n   \
    \     result = int(float_value - 0.5)\n    } else {\n        result = int(float_value\
    \ + 0.5)\n    }\n    return result\n}\n", "    var result int\n    var floatValue\
    \ float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n    if floatValue < 0 {\n\
    \        result = int(floatValue - 0.5)\n    } else {\n        result = int(floatValue\
    \ + 0.5)\n    }\n    return result\n}\n", "    return 0\n}\n", "    return 0\n\
    }\n", "    var result int\n    var floatValue float64\n    fmt.Sscanf(value, \"\
    %f\", &floatValue)\n    if floatValue < 0 {\n        result = int(floatValue -\
    \ 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n", "    // TODO: implement me\n    return 0\n}\n", "    return 0\n\
    }\n", "    var result int\n    var decimal float64\n    var err error\n    if\
    \ decimal, err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n\
    \    }\n    if decimal < 0 {\n        decimal = -decimal\n    }\n    result =\
    \ int(decimal)\n    if decimal - float64(result) >= 0.5 {\n        result++\n\
    \    }\n    if value[0] == '-' {\n        result = -result\n    }\n    return\
    \ result\n}\n", "    var result int\n    var number float64\n    fmt.Sscanf(value,\
    \ \"%f\", &number)\n    if number < 0 {\n        result = int(number) - 1\n  \
    \  } else {\n        result = int(number)\n    }\n    return result\n}\n", " \
    \   return 0\n}\n", "    var result int\n    var f float64\n    var err error\n\
    \    if f, err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n\
    \    }\n    if f < 0 {\n        f = -f\n    }\n    if f - float64(int(f)) >= 0.5\
    \ {\n        result = int(f) + 1\n    } else {\n        result = int(f)\n    }\n\
    \    if value[0] == '-' {\n        result = -result\n    }\n    return result\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
