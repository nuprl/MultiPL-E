name: HumanEval_119_match_parens
language: go_test.go
prompt: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // You are given a list of two strings, both strings consist of open\n// parentheses\
  \ '(' or close parentheses ')' only.\n// Your job is to check if it is possible\
  \ to concatenate the two strings in\n// some order, that the resulting string will\
  \ be good.\n// A string S is considered to be good if and only if all parentheses\
  \ in S\n// are balanced. For example: the string '(())()' is good, while the string\n\
  // '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n// Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')',\
  \ ')']) == 'No'\nfunc match_parens(lst []string) string {\n"
tests: "func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\"\
  \ },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n  \
  \   { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n\
  \     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n\
  \     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\"\
  \ },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n\
  \     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n\
  \     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n\
  \     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n \
  \    { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     {\
  \ actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual:\
  \ candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc :=\
  \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    var left, right int\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                left++\n        \
    \    } else {\n                right++\n            }\n        }\n    }\n    if\
    \ left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n", " \
    \   var open, close int\n    for _, s := range lst {\n        for _, c := range\
    \ s {\n            if c == '(' {\n                open++\n            } else {\n\
    \                close++\n            }\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n", "    if len(lst)\
    \ != 2 {\n        return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1)\
    \ == 0 {\n        return check_parens(s2)\n    }\n    if len(s2) == 0 {\n    \
    \    return check_parens(s1)\n    }\n    if check_parens(s1) == \"Yes\" {\n  \
    \      return \"Yes\"\n    }\n    if check_parens(s2) == \"Yes\" {\n        return\
    \ \"Yes\"\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n        return \"\
    Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n", "    var open, close int\n    for _, s := range\
    \ lst {\n        for _, c := range s {\n            if c == '(' {\n          \
    \      open++\n            } else {\n                close++\n            }\n\
    \        }\n    }\n    if open == close {\n        return \"Yes\"\n    }\n   \
    \ return \"No\"\n}\n", "    var result string\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        result = \"Yes\"\
    \n    } else {\n        result = \"No\"\n    }\n    return result\n}\n", "   \
    \ if len(lst) != 2 {\n        return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n\
    \    if len(s1) == 0 && len(s2) == 0 {\n        return \"Yes\"\n    }\n    if\
    \ len(s1) == 0 {\n        return \"No\"\n    }\n    if len(s2) == 0 {\n      \
    \  return \"No\"\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n        return\
    \ match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] == ')' && s2[0]\
    \ == '(' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n   \
    \ if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n", "    // TODO - Add your code here\n  \
    \  return \"\"\n}\n", "    var s string\n    for _, v := range lst {\n       \
    \ s += v\n    }\n    fmt.Println(s)\n    var c int\n    for _, v := range s {\n\
    \        if v == '(' {\n            c++\n        } else {\n            c--\n \
    \       }\n        if c < 0 {\n            return \"No\"\n        }\n    }\n \
    \   if c == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n", "   \
    \ if len(lst) != 2 {\n        return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n\
    \    if len(s1) == 0 {\n        return \"Yes\"\n    }\n    if len(s2) == 0 {\n\
    \        return \"Yes\"\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n      \
    \  return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] == ')' &&\
    \ s2[0] == '(' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n\
    \    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n", "    var s string\n    for _, v := range\
    \ lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n", "   \
    \ // TODO: implement\n    return \"\"\n}\n", "    var (\n        open, close int\n\
    \        s string\n    )\n    for _, s = range lst {\n        for _, c := range\
    \ s {\n            if c == '(' {\n                open++\n            } else {\n\
    \                close++\n            }\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n", "    var s string\n\
    \    for _, v := range lst {\n        s += v\n    }\n    var stack []byte\n  \
    \  for _, v := range s {\n        if v == '(' {\n            stack = append(stack,\
    \ byte(v))\n        } else {\n            if len(stack) == 0 {\n             \
    \   return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n \
    \       }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n  \
    \  return \"No\"\n}\n", "    var (\n        open int\n        close int\n    )\n\
    \    for _, s := range lst {\n        for _, c := range s {\n            if c\
    \ == '(' {\n                open++\n            } else {\n                close++\n\
    \            }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n", "    var open, close int\n    for _, s := range\
    \ lst {\n        for _, c := range s {\n            if c == '(' {\n          \
    \      open++\n            } else {\n                close++\n            }\n\
    \        }\n    }\n    if open == close {\n        return \"Yes\"\n    }\n   \
    \ return \"No\"\n}\n", "    var open, close int\n    for _, s := range lst {\n\
    \        for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n", "    // TODO: Implement\n    return \"\"\n}\n", "    // TODO: implement\
    \ this function\n    return \"\"\n}\n", "    return \"Yes\"\n}\n", "    var (\n\
    \        open int\n        close int\n    )\n    for _, s := range lst {\n   \
    \     for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
