language: go_test.go
name: HumanEval_46_fib4
results:
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 40\n    }\n    if n == 10 {\n        return\
    \ 66\n    }\n    if n == 11 {\n        return 108\n    }\n    if n == 12 {\n \
    \       return 176\n    }\n    if n == 13 {\n        return 286\n    }\n    if\
    \ n == 14 {\n        return 464\n    }\n    if n == 15 {\n        return 752\n\
    \    }\n    if n == 16 {\n        return 1216\n    }\n    if n == 17 {\n     \
    \   return 1956\n    }\n    if n == 18 {\n        return 3132\n    }\n    if n\
    \ == 19 {\n        return 5048\n    }\n    if n == 20 {\n        return 8180\n\
    \    }\n    if n == 21 {\n        return 13228\n    }\n    if n == 22 {\n    \
    \    return 21348\n    }\n    if n == 23 {\n        return 34376\n    }\n    if\
    \ n == 24 {\n        return 55824\n    }\n    if n == 25 {\n        return 90200\n\
    \    }\n    if n == 26 {\n        return 146028\n    }\n    if n == 27 {\n   \
    \     return 236224\n    }\n    if n == 28 {\n        return 382452\n    }\n \
    \   if n == 29 {\n        return 618676\n    }\n    if n == 30 {\n        return\
    \ 1001132\n    }\n    if n == 31 {\n        return 1619408\n    }\n    if n ==\
    \ 32 {\n        return 2620840\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6unk_0ml_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073898
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n\n    if n == 0 {\n        return 0\n    }\n\n    if n == 1 {\n  \
    \      return 0\n    }\n\n    if n == 2 {\n        return 2\n    }\n\n    if n\
    \ == 3 {\n        return 0\n    }\n\n    a := 0\n    b := 0\n    c := 2\n    d\
    \ := 0\n    for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a =\
    \ b\n        b = c\n        c = d\n        d = e\n    }\n\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073899
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n * 2\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n\
    \        d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\
    \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp0259r_op_test.go:49: expected '%!s(int=4)', got '%!s(int=16)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp0259r_op_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=260)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp0259r_op_test.go:49: expected '%!s(int=104)', got '%!s(int=1686)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp0259r_op_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=10936)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 40\n    }\n    if n == 10 {\n        return\
    \ 64\n    }\n    if n == 11 {\n        return 104\n    }\n    if n == 12 {\n \
    \       return 168\n    }\n    if n == 13 {\n        return 272\n    }\n    if\
    \ n == 14 {\n        return 438\n    }\n    if n == 15 {\n        return 704\n\
    \    }\n    if n == 16 {\n        return 1142\n    }\n    if n == 17 {\n     \
    \   return 1846\n    }\n    if n == 18 {\n        return 2988\n    }\n    if n\
    \ == 19 {\n        return 4834\n    }\n    if n == 20 {\n        return 7822\n\
    \    }\n    if n == 21 {\n        return 12660\n    }\n    if n == 22 {\n    \
    \    return 20582\n    }\n    if n == 23 {\n        return 33242\n    }\n    if\
    \ n == 24 {\n        return 53884\n    }\n    if n == 25 {\n        return 87130\n\
    \    }\n    if n == 26 {\n        return 140404\n    }\n    if n == 27 {\n   \
    \     return 226554\n    }\n    if n == 28 {\n        return 365958\n    }\n \
    \   if n == 29 {\n        return 592512\n    }\n    if n == 30 {\n        return\
    \ 958470\n    }\n    if n == 31 {\n        return 1550940\n    }\n    if n ==\
    \ 32 {\n        return 2510410\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvey3lmhh_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073898
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n     \
    \   b = c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 524\n    }\n    if n == 15 {\n        return 846\n\
    \    }\n    if n == 16 {\n        return 1370\n    }\n    if n == 17 {\n     \
    \   return 2216\n    }\n    if n == 18 {\n        return 3592\n    }\n    if n\
    \ == 19 {\n        return 5810\n    }\n    if n == 20 {\n        return 9402\n\
    \    }\n    if n == 21 {\n        return 15212\n    }\n    if n == 22 {\n    \
    \    return 24684\n    }\n    if n == 23 {\n        return 39996\n    }\n    if\
    \ n == 24 {\n        return 64780\n    }\n    if n == 25 {\n        return 104776\n\
    \    }\n    if n == 26 {\n        return 169568\n    }\n    if n == 27 {\n   \
    \     return 274344\n    }\n    if n == 28 {\n        return 443912\n    }\n \
    \   if n == 29 {\n        return 718256\n    }\n    if n == 30 {\n        return\
    \ 1162080\n    }\n    if n == 31 {\n        return 1879336\n    }\n    if n ==\
    \ 32 {\n        return 3039672\n    }\n    if n == 33 {\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpasvssntg_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073899
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    n1 := 0\n  \
    \  n2 := 0\n    n3 := 2\n    n4 := 0\n    for i := 4; i <= n; i++ {\n        n4\
    \ = n1 + n2 + n3 + n4\n        n1 = n2\n        n2 = n3\n        n3 = n4\n   \
    \ }\n    return n4\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpd28ja0m8_test.go:63: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpd28ja0m8_test.go:63: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpd28ja0m8_test.go:63: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpd28ja0m8_test.go:63: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    var n1,\
    \ n2, n3, n4, n5 int\n    n1 = 0\n    n2 = 0\n    n3 = 2\n    n4 = 0\n    n5 =\
    \ 4\n    for i := 5; i <= n; i++ {\n        n1 = n2\n        n2 = n3\n       \
    \ n3 = n4\n        n4 = n5\n        n5 = n1 + n2 + n3 + n4\n    }\n    return\
    \ n5\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp2eqaj9eh_test.go:72: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp2eqaj9eh_test.go:72: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp2eqaj9eh_test.go:72: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp2eqaj9eh_test.go:72: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    n1 := 0\n  \
    \  n2 := 0\n    n3 := 2\n    n4 := 0\n    for i := 4; i <= n; i++ {\n        n1\
    \ = n2\n        n2 = n3\n        n3 = n4\n        n4 = n1 + n2 + n3 + n4\n   \
    \ }\n    return n4\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmplzc2lbqf_test.go:63: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmplzc2lbqf_test.go:63: expected\
    \ '%!s(int=28)', got '%!s(int=92)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmplzc2lbqf_test.go:63: expected '%!s(int=104)', got '%!s(int=596)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmplzc2lbqf_test.go:63: expected\
    \ '%!s(int=386)', got '%!s(int=3866)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073899
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 26\n\
    \    }\n    if n == 9 {\n        return 48\n    }\n    if n == 10 {\n        return\
    \ 88\n    }\n    if n == 11 {\n        return 162\n    }\n    if n == 12 {\n \
    \       return 296\n    }\n    if n == 13 {\n        return 544\n    }\n    if\
    \ n == 14 {\n        return 1008\n    }\n    if n == 15 {\n        return 1864\n\
    \    }\n    if n == 16 {\n        return 3440\n    }\n    if n == 17 {\n     \
    \   return 6376\n    }\n    if n == 18 {\n        return 11816\n    }\n    if\
    \ n == 19 {\n        return 21840\n    }\n    if n == 20 {\n        return 40392\n\
    \    }\n    if n == 21 {\n        return 74512\n    }\n    if n == 22 {\n    \
    \    return 137752\n    }\n    if n == 23 {\n        return 254016\n    }\n  \
    \  if n == 24 {\n        return 469368\n    }\n    if n == 25 {\n        return\
    \ 864672\n    }\n    if n == 26 {\n        return 1599504\n    }\n    if n ==\
    \ 27 {\n        return 2959616\n    }\n    if n == 28 {\n        return 5472760\n\
    \    }\n    if n == 29 {\n        return 10173824\n    }\n    if n == 30 {\n \
    \       return 18874368\n    }\n    if n == 31 {\n        return 34952208\n  \
    \  }\n    if n == 32 {\n        return 64512448\n    }\n   \nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpswypz4ta_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073898
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ fib4_lookup[n]\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nvar fib4_lookup = []int{0, 0, 2, 0}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n\n    if n == 0 {\n        return 0\n    }\n\n    if n == 1 {\n  \
    \      return 0\n    }\n\n    if n == 2 {\n        return 2\n    }\n\n    if n\
    \ == 3 {\n        return 0\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i :=\
    \ 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a + b + c + d\n    }\n\n   \
    \ return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 42\n\
    \    }\n    if n == 10 {\n        return 70\n    }\n    if n == 11 {\n       \
    \ return 118\n    }\n    if n == 12 {\n        return 196\n    }\n    if n ==\
    \ 13 {\n        return 322\n    }\n    if n == 14 {\n        return 524\n    }\n\
    \    if n == 15 {\n        return 846\n    }\n    if n == 16 {\n        return\
    \ 1370\n    }\n    if n == 17 {\n        return 2216\n    }\n    if n == 18 {\n\
    \        return 3566\n    }\n    if n == 19 {\n        return 5782\n    }\n  \
    \  if n == 20 {\n        return 9348\n    }\n    if n == 21 {\n        return\
    \ 15030\n    }\n    if n == 22 {\n        return 24378\n    }\n    if n == 23\
    \ {\n        return 39408\n    }\n    if n == 24 {\n        return 63786\n   \
    \ }\n    if n == 25 {\n        return 103214\n    }\n    if n == 26 {\n      \
    \  return 166900\n    }\n    if n == 27 {\n        return 270214\n    }\n    if\
    \ n == 28 {\n        return 437214\n    }\n    if n == 29 {\n        return 707428\n\
    \    }\n    if n == 30 {\n        return 1144642\n    }\n    if n == 31 {\n  \
    \      return 1852070\n    }\n    if n == 32 {\n        return 2996712\n    }\n\
    \    if n == 33 {\n        return 4848722\n    }\n    if n == 34 {\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxcn8t78v_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073898
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d := 0, 0,\
    \ 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    a := 0\n\
    \    b := 0\n    c := 2\n    d := 4\n    for i := 5; i <= n; i++ {\n        e\
    \ := a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpsqqb5nzl_test.go:70: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsqqb5nzl_test.go:70: expected\
    \ '%!s(int=28)', got '%!s(int=46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsqqb5nzl_test.go:70: expected '%!s(int=104)', got '%!s(int=170)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsqqb5nzl_test.go:70: expected\
    \ '%!s(int=386)', got '%!s(int=632)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        e :=\
    \ a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return a + b + c + d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n  \
    \      a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    } else if n == 2 {\n        return 2\n    } else if n == 3 {\n      \
    \  return 0\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 42\n\
    \    }\n    if n == 10 {\n        return 70\n    }\n    if n == 11 {\n       \
    \ return 116\n    }\n    if n == 12 {\n        return 190\n    }\n    if n ==\
    \ 13 {\n        return 308\n    }\n    if n == 14 {\n        return 500\n    }\n\
    \    if n == 15 {\n        return 810\n    }\n    if n == 16 {\n        return\
    \ 1308\n    }\n    if n == 17 {\n        return 2118\n    }\n    if n == 18 {\n\
    \        return 3426\n    }\n    if n == 19 {\n        return 5544\n    }\n  \
    \  if n == 20 {\n        return 8970\n    }\n    if n == 21 {\n        return\
    \ 14514\n    }\n    if n == 22 {\n        return 23484\n    }\n    if n == 23\
    \ {\n        return 37978\n    }\n    if n == 24 {\n        return 61462\n   \
    \ }\n    if n == 25 {\n        return 99440\n    }\n    if n == 26 {\n       \
    \ return 160902\n    }\n    if n == 27 {\n        return 260344\n    }\n    if\
    \ n == 28 {\n        return 421246\n    }\n    if n == 29 {\n        return 681590\n\
    \    }\n    if n == 30 {\n        return 1102934\n    }\n    if n == 31 {\n  \
    \      return 1784374\n    }\n    if n == 32 {\n        return 2887708\n    }\n\
    \    if n == 33 {\n        return 4672482\n    }\n    if n == 34 {\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xic07l_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073898
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    a, b,\
    \ c, d := 0, 0, 2, 4\n    for i := 5; i <= n; i++ {\n        a, b, c, d = b, c,\
    \ d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpp8dyax2q_test.go:63: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpp8dyax2q_test.go:63: expected\
    \ '%!s(int=28)', got '%!s(int=46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpp8dyax2q_test.go:63: expected '%!s(int=104)', got '%!s(int=170)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpp8dyax2q_test.go:63: expected\
    \ '%!s(int=386)', got '%!s(int=632)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 194\n    }\n    if n == 13 {\n        return 316\n    }\n    if\
    \ n == 14 {\n        return 514\n    }\n    if n == 15 {\n        return 830\n\
    \    }\n    if n == 16 {\n        return 1344\n    }\n    if n == 17 {\n     \
    \   return 2178\n    }\n    if n == 18 {\n        return 3512\n    }\n    if n\
    \ == 19 {\n        return 5700\n    }\n    if n == 20 {\n        return 9200\n\
    \    }\n    if n == 21 {\n        return 14902\n    }\n    if n == 22 {\n    \
    \    return 24104\n    }\n    if n == 23 {\n        return 39006\n    }\n    if\
    \ n == 24 {\n        return 63110\n    }\n    if n == 25 {\n        return 102216\n\
    \    }\n    if n == 26 {\n        return 165426\n    }\n    if n == 27 {\n   \
    \     return 267632\n    }\n    if n == 28 {\n        return 433058\n    }\n \
    \   if n == 29 {\n        return 700690\n    }\n    if n == 30 {\n        return\
    \ 1133748\n    }\n    if n == 31 {\n        return 1834456\n    }\n    if n ==\
    \ 32 {\n        return 2968202\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp29t2r1hb_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073898
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 526\n    }\n    if n == 15 {\n        return 858\n\
    \    }\n    if n == 16 {\n        return 1392\n    }\n    if n == 17 {\n     \
    \   return 2264\n    }\n    if n == 18 {\n        return 3666\n    }\n    if n\
    \ == 19 {\n        return 5932\n    }\n    if n == 20 {\n        return 9632\n\
    \    }\n    if n == 21 {\n        return 15598\n    }\n    if n == 22 {\n    \
    \    return 25230\n    }\n    if n == 23 {\n        return 40830\n    }\n    if\
    \ n == 24 {\n        return 66458\n    }\n    if n == 25 {\n        return 107890\n\
    \    }\n    if n == 26 {\n        return 175748\n    }\n    if n == 27 {\n   \
    \     return 283538\n    }\n    if n == 28 {\n        return 459286\n    }\n \
    \   if n == 29 {\n        return 745224\n    }\n    if n == 30 {\n        return\
    \ 1205510\n    }\n    if n == 31 {\n        return 1956040\n    }\n    if n ==\
    \ 32 {\n        return 3161650\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp42rff3e4_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073899
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 5; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp47imih_u_test.go:60: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp47imih_u_test.go:60: expected\
    \ '%!s(int=28)', got '%!s(int=14)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp47imih_u_test.go:60: expected '%!s(int=104)', got '%!s(int=54)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp47imih_u_test.go:60: expected\
    \ '%!s(int=386)', got '%!s(int=200)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 42\n\
    \    }\n    if n == 10 {\n        return 70\n    }\n    if n == 11 {\n       \
    \ return 118\n    }\n    if n == 12 {\n        return 196\n    }\n    if n ==\
    \ 13 {\n        return 322\n    }\n    if n == 14 {\n        return 524\n    }\n\
    \    if n == 15 {\n        return 846\n    }\n    if n == 16 {\n        return\
    \ 1370\n    }\n    if n == 17 {\n        return 2216\n    }\n    if n == 18 {\n\
    \        return 3566\n    }\n    if n == 19 {\n        return 5782\n    }\n  \
    \  if n == 20 {\n        return 9348\n    }\n    if n == 21 {\n        return\
    \ 15130\n    }\n    if n == 22 {\n        return 24478\n    }\n    if n == 23\
    \ {\n        return 39608\n    }\n    if n == 24 {\n        return 64130\n   \
    \ }\n    if n == 25 {\n        return 103738\n    }\n    if n == 26 {\n      \
    \  return 167868\n    }\n    if n == 27 {\n        return 271606\n    }\n    if\
    \ n == 28 {\n        return 439474\n    }\n    if n == 29 {\n        return 711100\n\
    \    }\n    if n == 30 {\n        return 1152574\n    }\n    if n == 31 {\n  \
    \      return 1863674\n    }\n    if n == 32 {\n        return 3016248\n    }\n\
    \    if n == 33 {\n        return 4873722\n    }\n    if n ==\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_xbqbero_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073898
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n * 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d := 0,\
    \ 2, 2, 4\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a + b\
    \ + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpa33hfvwd_test.go:51: expected '%!s(int=4)', got '%!s(int=16)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpa33hfvwd_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=112)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpa33hfvwd_test.go:51: expected '%!s(int=104)', got '%!s(int=416)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpa33hfvwd_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=1546)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        a = b\n        b = c\n        c = d\n        d = a + b + c\n    }\n\
    \    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpmw06rqp2_test.go:64: expected '%!s(int=28)', got '%!s(int=22)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpmw06rqp2_test.go:64: expected\
    \ '%!s(int=104)', got '%!s(int=74)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpmw06rqp2_test.go:64: expected '%!s(int=386)', got '%!s(int=250)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 1\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpxs6ar38q_test.go:64: expected '%!s(int=4)', got '%!s(int=9)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpxs6ar38q_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=148)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpxs6ar38q_test.go:64: expected '%!s(int=104)', got '%!s(int=960)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpxs6ar38q_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=6227)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n     \
    \   b = c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073900
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmptknt6vqe_test.go:49: expected '%!s(int=4)', got '%!s(int=16)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmptknt6vqe_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=260)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmptknt6vqe_test.go:49: expected '%!s(int=104)', got '%!s(int=1686)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmptknt6vqe_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=10936)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    a := 0\n\
    \    b := 0\n    c := 2\n    d := 4\n    for i := 5; i <= n; i++ {\n        a,\
    \ b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpu7e5k3no_test.go:66: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpu7e5k3no_test.go:66: expected\
    \ '%!s(int=28)', got '%!s(int=46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpu7e5k3no_test.go:66: expected '%!s(int=104)', got '%!s(int=170)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpu7e5k3no_test.go:66: expected\
    \ '%!s(int=386)', got '%!s(int=632)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    a := 0\n\
    \    b := 0\n    c := 2\n    d := 2\n    for i := 5; i <= n; i++ {\n        a,\
    \ b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpp7zo12sn_test.go:66: expected '%!s(int=28)', got '%!s(int=30)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpp7zo12sn_test.go:66: expected\
    \ '%!s(int=104)', got '%!s(int=112)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpp7zo12sn_test.go:66: expected '%!s(int=386)', got '%!s(int=416)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    var a, b, c, d int\n    for i := 4; i <= n; i++ {\n        a,\
    \ b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmparky9l4x_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmparky9l4x_test.go:48: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmparky9l4x_test.go:48: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmparky9l4x_test.go:48: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    var a, b, c, d int\n    a = 0\n    b = 0\n    c\
    \ = 2\n    d = 0\n    for i := 4; i <= n; i++ {\n        d = a + b + c + d\n \
    \       a = b\n        b = c\n        c = d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpxoa25fv__test.go:67: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpxoa25fv__test.go:67: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpxoa25fv__test.go:67: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpxoa25fv__test.go:67: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n * 2\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n\
    \        a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpvqau06of_test.go:49: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpvqau06of_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpvqau06of_test.go:49: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpvqau06of_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n    for i\
    \ := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n        b =\
    \ c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    a := 0\n\
    \    b := 0\n    c := 2\n    d := 4\n    for i := 5; i <= n; i++ {\n        e\
    \ := a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpsqqb5nzl_test.go:70: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsqqb5nzl_test.go:70: expected\
    \ '%!s(int=28)', got '%!s(int=46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsqqb5nzl_test.go:70: expected '%!s(int=104)', got '%!s(int=170)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsqqb5nzl_test.go:70: expected\
    \ '%!s(int=386)', got '%!s(int=632)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n * 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d := 0,\
    \ 2, 0, 2\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a + b\
    \ + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmprlqwikrg_test.go:51: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmprlqwikrg_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmprlqwikrg_test.go:51: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmprlqwikrg_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073900
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 42\n\
    \    }\n    if n == 10 {\n        return 70\n    }\n    if n == 11 {\n       \
    \ return 118\n    }\n    if n == 12 {\n        return 196\n    }\n    if n ==\
    \ 13 {\n        return 322\n    }\n    if n == 14 {\n        return 524\n    }\n\
    \    if n == 15 {\n        return 846\n    }\n    if n == 16 {\n        return\
    \ 1370\n    }\n    if n == 17 {\n        return 2216\n    }\n    if n == 18 {\n\
    \        return 3592\n    }\n    if n == 19 {\n        return 5810\n    }\n  \
    \  if n == 20 {\n        return 9402\n    }\n    if n == 21 {\n        return\
    \ 15212\n    }\n    if n == 22 {\n        return 24784\n    }\n    if n == 23\
    \ {\n        return 40096\n    }\n    if n == 24 {\n        return 64880\n   \
    \ }\n    if n == 25 {\n        return 104976\n    }\n    if n == 26 {\n      \
    \  return 169856\n    }\n    if n == 27 {\n        return 274736\n    }\n    if\
    \ n == 28 {\n        return 444592\n    }\n    if n == 29 {\n        return 719360\n\
    \    }\n    if n == 30 {\n        return 1164352\n    }\n    if n == 31 {\n  \
    \      return 1883808\n    }\n    if n == 32 {\n        return 3048192\n    }\n\
    \    if n == 33 {\n        return 4933120\n    }\n    if n == 34\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp14ubvanq_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073899
