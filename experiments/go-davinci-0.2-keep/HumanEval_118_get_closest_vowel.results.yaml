language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if !is_vowel(word[i-1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rdamgwh_test.go:19:5: vowels declared but not used

    /tmp/tmp_rdamgwh_test.go:21:12: undefined: is_vowel

    /tmp/tmp_rdamgwh_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_consonant(word[i]) {\n\
    \            continue\n        }\n        for j := i - 1; j >= 0; j-- {\n    \
    \        if is_consonant(word[j]) {\n                continue\n            }\n\
    \            for _, v := range vowels {\n                if string(word[j]) ==\
    \ v {\n                    return v\n                }\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6z_fevjt_test.go:21:13: undefined: is_consonant

    /tmp/tmp6z_fevjt_test.go:25:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if v == string(word[i-1]) {\n                    return v\n         \
    \       }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i8excjs_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    last_vowel := \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            last_vowel\
    \ = string(word[i])\n            break\n        }\n    }\n    if last_vowel ==\
    \ \"\" {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if !vowels[string(word[i])] {\n            if i == len(word) - 1\
    \ {\n                return \"\"\n            }\n            if vowels[string(word[i\
    \ + 1])] {\n                return string(word[i + 1])\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpp501pjjh_test.go:68: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpp501pjjh_test.go:68: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpp501pjjh_test.go:68: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpp501pjjh_test.go:68: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpp501pjjh_test.go:68: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpp501pjjh_test.go:68: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpp501pjjh_test.go:68: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpp501pjjh_test.go:68:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpp501pjjh_test.go:68: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !isVowel(word[i]) && isVowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwf24b5h__test.go:21:13: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var index int\n    var found\
    \ bool\n    for i := len(word) - 1; i > 0; i-- {\n        for _, v := range vowels\
    \ {\n            if word[i] == v[0] {\n                found = true\n        \
    \        index = i\n                break\n            }\n        }\n        if\
    \ found {\n            break\n        }\n    }\n    if !found {\n        return\
    \ result\n    }\n    for i := index - 1; i >= 0; i-- {\n        for _, c := range\
    \ consonants {\n            if word[i] == c[0] {\n                return string(word[index])\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp5bs_3dyg_test.go:74: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp5bs_3dyg_test.go:74: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp5bs_3dyg_test.go:74: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp5bs_3dyg_test.go:74: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp5bs_3dyg_test.go:74:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp5bs_3dyg_test.go:74: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant string\n    var last_vowel string\n   \
    \ for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            last_vowel = string(word[i])\n            if last_consonant\
    \ != \"\" {\n                return last_vowel\n            }\n        } else\
    \ {\n            last_consonant = string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp324rbj58_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp324rbj58_test.go:66: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp324rbj58_test.go:66: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp324rbj58_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp324rbj58_test.go:66: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] != -1 {\n \
    \           if vowels[strings.Index(vowels, string(word[i-1]))] == -1 {\n    \
    \            return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnat3dlge_test.go:21:19: undefined: strings

    /tmp/tmpnat3dlge_test.go:21:62: -1 (untyped int constant) overflows byte

    /tmp/tmpnat3dlge_test.go:22:23: undefined: strings

    /tmp/tmpnat3dlge_test.go:22:68: -1 (untyped int constant) overflows byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if vowels[string(word[i + 1])] {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp4r29vtuv_test.go:65: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp4r29vtuv_test.go:65: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp4r29vtuv_test.go:65: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp4r29vtuv_test.go:65: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp4r29vtuv_test.go:65:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp4r29vtuv_test.go:65: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var closest_vowel string\n    var closest_vowel_index int\n    var closest_vowel_distance\
    \ int\n    for i, c := range word {\n        if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            for j, v := range vowels {\n        \
    \        if string(c) == v {\n                    if closest_vowel_index == 0\
    \ {\n                        closest_vowel_index = j\n                       \
    \ closest_vowel_distance = i\n                        closest_vowel = string(c)\n\
    \                    } else if j < closest_vowel_index {\n                   \
    \     closest_vowel_index = j\n                        closest_vowel_distance\
    \ = i\n                        closest_vowel = string(c)\n                   \
    \ } else if j == closest_vowel_index && i < closest_vowel_distance {\n       \
    \                 closest_vowel_index = j\n                        closest_vowel_distance\
    \ = i\n                        closest_vowel = string(c)\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpicw2563__test.go:72: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpicw2563__test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpicw2563__test.go:72: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpicw2563__test.go:72: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpicw2563__test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpicw2563__test.go:72: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpicw2563__test.go:72: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpicw2563__test.go:72:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpicw2563__test.go:72: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpicw2563__test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var prev_vowel string\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n       \
    \     prev_vowel = string(word[i])\n            continue\n        }\n        if\
    \ prev_vowel != \"\" {\n            return prev_vowel\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpdjnznjpn_test.go:58: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpdjnznjpn_test.go:58: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpdjnznjpn_test.go:58: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpdjnznjpn_test.go:58: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpdjnznjpn_test.go:58:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpdjnznjpn_test.go:58: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if word[i-1] == v[0] {\n                    return v\n              \
    \  }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsom5065y_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_vowel rune\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[rune(word[i])] {\n            last_vowel =\
    \ rune(word[i])\n            break\n        }\n    }\n    if last_vowel == 0 {\n\
    \        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   if !vowels[rune(word[i])] {\n            if i == len(word) - 1 {\n       \
    \         return string(last_vowel)\n            }\n            if vowels[rune(word[i\
    \ + 1])] {\n                return string(last_vowel)\n            }\n       \
    \ }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpc5nefc6q_test.go:68: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpc5nefc6q_test.go:68: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpc5nefc6q_test.go:68: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpc5nefc6q_test.go:68: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpc5nefc6q_test.go:68: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpc5nefc6q_test.go:68: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpc5nefc6q_test.go:68: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpc5nefc6q_test.go:68:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpc5nefc6q_test.go:68: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var vowel_index int\n  \
    \  var consonant_index int\n    var vowel_found bool\n    var consonant_found\
    \ bool\n    var vowel_index_found bool\n    var consonant_index_found bool\n \
    \   var vowel_index_found_before bool\n    var consonant_index_found_before bool\n\
    \    var vowel_index_found_after bool\n    var consonant_index_found_after bool\n\
    \    var vowel_index_found_before_index int\n    var consonant_index_found_before_index\
    \ int\n    var vowel_index_found_after_index int\n    var consonant_index_found_after_index\
    \ int\n    var vowel_index_found_before_distance int\n    var consonant_index_found_before_distance\
    \ int\n    var vowel_index_found_after_distance int\n    var consonant_index_found_after_distance\
    \ int\n    var vowel_index_found_before_distance_min int\n    var consonant_index_found_before_distance_min\
    \ int\n    var vowel_index_found_after_distance_min int\n    var consonant_index_found_after_distance_min\
    \ int\n    var vowel_index_found_before_distance_min_index int\n    var consonant_index_found_before_distance_min_index\
    \ int\n    var vowel_index_found_after_distance_min_index int\n    var consonant_index_found_after_distance_min_index\
    \ int\n    var vowel_index_found_before_distance_min_index_value string\n    var\
    \ consonant_index_found_before_distance_min_index_value string\n    var vowel_index_found_after_distance_min_index_value\
    \ string\n    var consonant_index_found_after_distance_min_index_value string\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpug_esos__test.go:52:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074388
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ strings.Contains(vowels, string(word[i-1])) {\n                continue\n  \
    \          }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpom0mjmcf_test.go:21:12: undefined: strings

    /tmp/tmpom0mjmcf_test.go:22:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if string(word[i-1])\
    \ == v {\n                    return v\n                }\n            }\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppolha9hi_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !isVowel(word[i]) && isVowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwf24b5h__test.go:21:13: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels[string(word[i+1])]\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp5lx_a3zp_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp5lx_a3zp_test.go:58: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp5lx_a3zp_test.go:58: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp5lx_a3zp_test.go:58: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp5lx_a3zp_test.go:58:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp5lx_a3zp_test.go:58: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] != \"\" {\n\
    \            if vowels[strings.Index(vowels, string(word[i-1]))] == \"\" {\n \
    \               return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppogsq7qh_test.go:21:19: undefined: strings

    /tmp/tmppogsq7qh_test.go:21:62: invalid operation: vowels[strings.Index(vowels,
    string(word[i]))] != "" (mismatched types byte and untyped string)

    /tmp/tmppogsq7qh_test.go:22:23: undefined: strings

    /tmp/tmppogsq7qh_test.go:22:68: invalid operation: vowels[strings.Index(vowels,
    string(word[i - 1]))] == "" (mismatched types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    last_consonant := \"\"\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if vowels[string(word[i])] {\n            if last_consonant !=\
    \ \"\" {\n                return string(word[i])\n            }\n        } else\
    \ {\n            last_consonant = string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmppo82i26x_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmppo82i26x_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmppo82i26x_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmppo82i26x_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmppo82i26x_test.go:64: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_vowel string\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if vowels[string(word[i])] {\n            last_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if last_vowel != string(word[i])\
    \ {\n                return string(word[i])\n            }\n        } else {\n\
    \            if last_vowel != \"\" {\n                return last_vowel\n    \
    \        }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp0z901wl1_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp0z901wl1_test.go:72: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp0z901wl1_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp0z901wl1_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp0z901wl1_test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp0z901wl1_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp0z901wl1_test.go:72: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp0z901wl1_test.go:72:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp0z901wl1_test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !isConsonant(word[i]) {\n\
    \            continue\n        }\n        for j := i - 1; j >= 0; j-- {\n    \
    \        if isConsonant(word[j]) {\n                continue\n            }\n\
    \            for _, v := range vowels {\n                if v == string(word[j])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt_5_y958_test.go:21:13: undefined: isConsonant

    /tmp/tmpt_5_y958_test.go:25:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_consonant rune\n    var last_vowel rune\n\
    \    for _, c := range word {\n        if vowels[c] {\n            last_vowel\
    \ = c\n        } else {\n            if last_vowel != 0 {\n                return\
    \ string(last_vowel)\n            }\n            last_consonant = c\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1b12no8w_test.go:20:9: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var closest_vowel string\n    var closest_distance int\n    for i, c := range\
    \ word {\n        if is_vowel(string(c), vowels) {\n            if is_consonant(string(word[i-1]),\
    \ vowels) && is_consonant(string(word[i+1]), vowels) {\n                distance\
    \ := i\n                if closest_distance == 0 || distance < closest_distance\
    \ {\n                    closest_distance = distance\n                    closest_vowel\
    \ = string(c)\n                }\n            }\n        }\n    }\n    return\
    \ closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk74t9m2j_test.go:23:12: undefined: is_vowel

    /tmp/tmpk74t9m2j_test.go:24:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ strings.Contains(vowels, string(word[i-1])) {\n                continue\n  \
    \          }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpom0mjmcf_test.go:21:12: undefined: strings

    /tmp/tmpom0mjmcf_test.go:22:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if string(word[i-1])\
    \ == v {\n                    return v\n                }\n            }\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppolha9hi_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if word[i-1] == v[0] {\n                    return v\n              \
    \  }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsom5065y_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_vowel_index int\n\
    \    var last_consonant_index int\n    var last_vowel string\n    var last_consonant\
    \ string\n    var last_vowel_distance int\n    var last_consonant_distance int\n\
    \    var distance int\n    var found_vowel bool\n    var found_consonant bool\n\
    \    var found_vowel_distance bool\n    var found_consonant_distance bool\n  \
    \  var found_result bool\n    for i := len(word) - 1; i >= 0; i-- {\n        for\
    \ _, v := range vowels {\n            if word[i:i+1] == v {\n                last_vowel_index\
    \ = i\n                last_vowel = v\n                found_vowel = true\n  \
    \              break\n            }\n        }\n        if found_vowel {\n   \
    \         break\n        }\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        for _, c := range consonants {\n            if word[i:i+1] == c {\n \
    \               last_consonant_index = i\n                last_consonant = c\n\
    \                found_consonant = true\n                break\n            }\n\
    \        }\n        if found_consonant {\n            break\n        }\n    }\n\
    \    if found_vowel && found_consonant {\n        last_vowel_distance = last_consonant_index\
    \ - last_vowel_index\n        last_consonant_distance = last_consonant_index -\
    \ last_vowel_index\n        found_vowel_distance = true\n        found_consonant_distance\
    \ = true\n    }\n    for i := len(word)\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoi3j3llh_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_vowel rune\n    var last_consonant rune\n\
    \    for _, c := range word {\n        if vowels[c] {\n            last_vowel\
    \ = c\n        } else {\n            if last_vowel != 0 {\n                return\
    \ string(last_vowel)\n            }\n            last_consonant = c\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwul5j3ux_test.go:21:9: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !isVowel(word[i], vowels)\
    \ && isVowel(word[i-1], vowels) {\n            return string(word[i-1])\n    \
    \    }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu9p66msg_test.go:21:13: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i - 1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt7_gigv__test.go:21:12: undefined: strings

    /tmp/tmpt7_gigv__test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var vowel_index int\n  \
    \  var consonant_index int\n    var vowel_found bool\n    var consonant_found\
    \ bool\n    var vowel_found_index int\n    var consonant_found_index int\n   \
    \ var found bool\n    var distance int\n    var min_distance int\n    var min_distance_index\
    \ int\n    var min_distance_found bool\n    var i int\n    var j int\n    var\
    \ k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p\
    \ int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n\
    \    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n \
    \   var a int\n    var b int\n    var c int\n    var d int\n    var e int\n  \
    \  var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n \
    \   var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n\
    \    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n\
    \    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n\
    \    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n\
    \    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n\
    \    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn\
    \ int\n    var ooo int\n    var ppp int\n    var qqq\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyyrxx2_o_test.go:93:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ strings.Contains(vowels, string(word[i-1])) {\n                continue\n  \
    \          }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpom0mjmcf_test.go:21:12: undefined: strings

    /tmp/tmpom0mjmcf_test.go:22:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if vowels[strings.IndexRune(vowels, rune(word[i]))] != 0 {\n\
    \            if vowels[strings.IndexRune(vowels, rune(word[i-1]))] == 0 {\n  \
    \              return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbsxa7qy_test.go:21:19: undefined: strings

    /tmp/tmphbsxa7qy_test.go:22:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var last_consonant string\n    var last_vowel string\n\
    \    for _, char := range word {\n        if vowels[string(char)] {\n        \
    \    last_vowel = string(char)\n        } else {\n            last_consonant =\
    \ string(char)\n        }\n        if last_consonant != \"\" && last_vowel !=\
    \ \"\" {\n            return last_vowel\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpq92luh07_test.go:66: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpq92luh07_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpq92luh07_test.go:66: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpq92luh07_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpq92luh07_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpq92luh07_test.go:66: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpq92luh07_test.go:66: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpq92luh07_test.go:66:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpq92luh07_test.go:66: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if vowels[string(word[i\
    \ + 1])] {\n                continue\n            }\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpqje46thy_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpqje46thy_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpqje46thy_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpqje46thy_test.go:59: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpqje46thy_test.go:59:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpqje46thy_test.go:59: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !isVowel(word[i]) && isVowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwf24b5h__test.go:21:13: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i > 0; i-- {\n        if !vowels[string(word[i])]\
    \ && vowels[string(word[i-1])] {\n            return string(word[i-1])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp_oidyovu_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp_oidyovu_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp_oidyovu_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp_oidyovu_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp_oidyovu_test.go:59: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_vowel_index int\n\
    \    var last_consonant_index int\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if contains(vowels, string(word[i])) {\n            last_vowel_index\
    \ = i\n            break\n        }\n    }\n    for i := last_vowel_index - 1;\
    \ i >= 0; i-- {\n        if contains(consonants, string(word[i])) {\n        \
    \    last_consonant_index = i\n            break\n        }\n    }\n    if last_vowel_index\
    \ > last_consonant_index {\n        result = string(word[last_vowel_index])\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv3s4ruz1_test.go:25:12: undefined: contains

    /tmp/tmpv3s4ruz1_test.go:31:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i - 1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt7_gigv__test.go:21:12: undefined: strings

    /tmp/tmpt7_gigv__test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if v == string(word[i-1]) {\n                    return v\n         \
    \       }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i8excjs_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if string(word[i-1])\
    \ == v {\n                    return v\n                }\n            }\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppolha9hi_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i])\
    \ && !isVowel(word[i-1]) {\n            return string(word[i])\n        }\n  \
    \  }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg7euj747_test.go:20:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if v == string(word[i-1]) {\n                    return v\n         \
    \       }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i8excjs_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var result string\n    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i])\
    \ && is_vowel(word[i-1]) {\n            result = string(word[i-1])\n         \
    \   break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpepnb38ly_test.go:19:5: vowels declared but not used

    /tmp/tmpepnb38ly_test.go:22:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i > 0 && !vowels[string(word[i-1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp5zyoyd3f_test.go:61: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp5zyoyd3f_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp5zyoyd3f_test.go:61: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp5zyoyd3f_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp5zyoyd3f_test.go:61:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp5zyoyd3f_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if v == string(word[i-1]) {\n                    return v\n         \
    \       }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i8excjs_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closestVowel string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            closestVowel = string(word[i])\n\
    \            break\n        }\n    }\n    return closestVowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp0hw01_xm_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp0hw01_xm_test.go:61: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp0hw01_xm_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp0hw01_xm_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp0hw01_xm_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp0hw01_xm_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp0hw01_xm_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp0hw01_xm_test.go:61:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp0hw01_xm_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var consonants = map[string]bool{\n        \"b\": true,\n\
    \        \"c\": true,\n        \"d\": true,\n        \"f\": true,\n        \"\
    g\": true,\n        \"h\": true,\n        \"j\": true,\n        \"k\": true,\n\
    \        \"l\": true,\n        \"m\": true,\n        \"n\": true,\n        \"\
    p\": true,\n        \"q\": true,\n        \"r\": true,\n        \"s\": true,\n\
    \        \"t\": true,\n        \"v\": true,\n        \"w\": true,\n        \"\
    x\": true,\n        \"y\": true,\n        \"z\": true,\n    }\n    var last_consonant_index\
    \ int\n    var last_vowel_index int\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if _, ok := consonants[string(word[i])]; ok {\n            last_consonant_index\
    \ = i\n            break\n        }\n    }\n    for i := last_consonant_index\
    \ - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])]; ok {\n    \
    \        last_vowel_index = i\n            break\n        }\n    }\n    if last_vowel_index\
    \ == 0 {\n        return \"\"\n    }\n    return string(word[last_vowel_index])\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpqdxb4bvu_test.go:94: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpqdxb4bvu_test.go:94: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_consonant_index\
    \ int\n    var last_vowel_index int\n    var last_consonant_char string\n    var\
    \ last_vowel_char string\n    var last_char string\n    var last_index int\n \
    \   var last_char_index int\n    var last_char_is_consonant bool\n    var last_char_is_vowel\
    \ bool\n    var last_char_is_valid bool\n    var last_char_is_invalid bool\n \
    \   var last_char_is_valid_vowel bool\n    var last_char_is_valid_consonant bool\n\
    \    var last_char_is_invalid_vowel bool\n    var last_char_is_invalid_consonant\
    \ bool\n    var last_char_is_invalid_vowel_or_consonant bool\n    var last_char_is_valid_vowel_or_consonant\
    \ bool\n    var last_char_is_invalid_vowel_or_consonant_or_valid_vowel bool\n\
    \    var last_char_is_invalid_vowel_or_consonant_or_valid_consonant bool\n   \
    \ var last_char_is_invalid_vowel_or_consonant_or_valid_vowel_or_consonant bool\n\
    \    var last_char_is_invalid_vowel_or_consonant_or_valid_vowel_or_consonant_or_valid_vowel\
    \ bool\n    var last_char_is_invalid_vowel_or_consonant_or_valid_vowel_or_consonant_or_valid_consonant\
    \ bool\n    var last_char_is\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxk5cikv1_test.go:44:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if !is_vowel(word[i-1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rdamgwh_test.go:19:5: vowels declared but not used

    /tmp/tmp_rdamgwh_test.go:21:12: undefined: is_vowel

    /tmp/tmp_rdamgwh_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    last_vowel := \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            last_vowel\
    \ = string(word[i])\n            break\n        }\n    }\n    if last_vowel ==\
    \ \"\" {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if !vowels[string(word[i])] {\n            if i == len(word) - 1\
    \ {\n                return \"\"\n            }\n            if vowels[string(word[i\
    \ + 1])] {\n                return string(word[i + 1])\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpp501pjjh_test.go:68: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpp501pjjh_test.go:68: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpp501pjjh_test.go:68: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpp501pjjh_test.go:68: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpp501pjjh_test.go:68: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpp501pjjh_test.go:68: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpp501pjjh_test.go:68: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpp501pjjh_test.go:68:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpp501pjjh_test.go:68: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i > 0; i-- {\n        if is_consonant(word[i]) && is_consonant(word[i-1]) {\n\
    \            for _, v := range vowels {\n                if word[i-1] == v[0]\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbln6qieb_test.go:24:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var prev_vowel string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            prev_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if prev_vowel != string(word[i])\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp677wmz7v_test.go:68: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp677wmz7v_test.go:68: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n     \
    \   tmp677wmz7v_test.go:68: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp677wmz7v_test.go:68: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmp677wmz7v_test.go:68: expected\
    \ 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n     \
    \   tmp677wmz7v_test.go:68: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp677wmz7v_test.go:68: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp677wmz7v_test.go:68:\
    \ expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] != 0 {\n  \
    \          if vowels[strings.Index(vowels, string(word[i-1]))] == 0 {\n      \
    \          return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4d2hsplk_test.go:21:19: undefined: strings

    /tmp/tmp4d2hsplk_test.go:22:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_vowel string\n\
    \    var last_consonant string\n    var last_vowel_index int\n    var last_consonant_index\
    \ int\n    var last_vowel_found bool\n    var last_consonant_found bool\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            last_vowel = string(word[i])\n            last_vowel_index =\
    \ i\n            last_vowel_found = true\n        }\n        if contains(consonants,\
    \ string(word[i])) {\n            last_consonant = string(word[i])\n         \
    \   last_consonant_index = i\n            last_consonant_found = true\n      \
    \  }\n        if last_vowel_found && last_consonant_found {\n            if last_vowel_index\
    \ > last_consonant_index {\n                result = last_vowel\n            }\n\
    \            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc8g1px6y_test.go:23:9: last_consonant declared but not used

    /tmp/tmpc8g1px6y_test.go:29:12: undefined: contains

    /tmp/tmpc8g1px6y_test.go:34:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_vowel rune\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[rune(word[i])] {\n            last_vowel =\
    \ rune(word[i])\n            break\n        }\n    }\n    if last_vowel == 0 {\n\
    \        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   if !vowels[rune(word[i])] {\n            return string(last_vowel)\n     \
    \   }\n        last_vowel = rune(word[i])\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpfgg46ced_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpfgg46ced_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpfgg46ced_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpfgg46ced_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpfgg46ced_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpfgg46ced_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpfgg46ced_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpfgg46ced_test.go:64:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpfgg46ced_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074393
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var index int\n    var found\
    \ bool\n    var found_vowel bool\n    var found_consonant bool\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i:i+1]\
    \ == v {\n                found_vowel = true\n                break\n        \
    \    }\n        }\n        for _, c := range consonants {\n            if word[i:i+1]\
    \ == c {\n                found_consonant = true\n                break\n    \
    \        }\n        }\n        if found_vowel && found_consonant {\n         \
    \   index = i\n            found = true\n            break\n        }\n      \
    \  found_vowel = false\n        found_consonant = false\n    }\n    if found {\n\
    \        result = word[index:index+1]\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpqc666tbz_test.go:78: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpqc666tbz_test.go:78: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpqc666tbz_test.go:78: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpqc666tbz_test.go:78: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpqc666tbz_test.go:78:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpqc666tbz_test.go:78: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if is_vowel(word[i-1]) {\n                continue\n            } else\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe2uq9i2d_test.go:19:5: vowels declared but not used

    /tmp/tmpe2uq9i2d_test.go:21:12: undefined: is_vowel

    /tmp/tmpe2uq9i2d_test.go:22:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var result string\n    var last_consonant string\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n  \
    \          if last_consonant != \"\" {\n                result = string(word[i])\n\
    \                break\n            }\n        } else {\n            last_consonant\
    \ = string(word[i])\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp4draswni_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp4draswni_test.go:66: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp4draswni_test.go:66: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp4draswni_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp4draswni_test.go:66: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            return string(word[i-1])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw7pb9342_test.go:19:5: vowels declared but not used

    /tmp/tmpw7pb9342_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            if !contains(vowels, string(word[i-1])) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5qvlba3_test.go:21:12: undefined: contains

    /tmp/tmpt5qvlba3_test.go:22:17: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    consonants\
    \ := []rune{'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'}\n    var vowel rune\n    var consonant rune\n\
    \    var closest_vowel rune\n    var closest_consonant rune\n    var closest_distance\
    \ int\n    var distance int\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   for _, v := range vowels {\n            if word[i] == byte(v) {\n        \
    \        vowel = v\n                break\n            }\n        }\n        if\
    \ vowel != 0 {\n            for j := i - 1; j >= 0; j-- {\n                for\
    \ _, c := range consonants {\n                    if word[j] == byte(c) {\n  \
    \                      consonant = c\n                        break\n        \
    \            }\n                }\n                if consonant != 0 {\n     \
    \               distance = i - j\n                    if closest_distance == 0\
    \ || distance < closest_distance {\n                        closest_distance =\
    \ distance\n                        closest_vowel = vowel\n                  \
    \      closest_consonant = consonant\n                    }\n                \
    \    break\n                }\n            }\n        }\n    }\n    if closest_vowel\
    \ != 0 {\n        return string(closest_vowel)\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpza49_pc0_test.go:24:9: closest_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if !is_vowel(word[i-1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rdamgwh_test.go:19:5: vowels declared but not used

    /tmp/tmp_rdamgwh_test.go:21:12: undefined: is_vowel

    /tmp/tmp_rdamgwh_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1,\
    \ \"o\": 1, \"u\": 1}\n    for i := len(word) - 1; i >= 0; i-- {\n        if _,\
    \ ok := vowels[string(word[i])]; ok {\n            if i > 0 && i < len(word) -\
    \ 1 {\n                if _, ok := vowels[string(word[i - 1])]; !ok && _, ok :=\
    \ vowels[string(word[i + 1])]; !ok {\n                    return string(word[i])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm9wsw6jc_test.go:23:58: expected identifier on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if stringInSlice(string(word[i]),\
    \ vowels) {\n            if !stringInSlice(string(word[i-1]), vowels) {\n    \
    \            return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwhx6hjr7_test.go:21:12: undefined: stringInSlice

    /tmp/tmpwhx6hjr7_test.go:22:17: undefined: stringInSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    consonants := []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"}\n    var vowel string\n    var consonant string\n    var result\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels,\
    \ string(word[i])) {\n            vowel = string(word[i])\n            break\n\
    \        }\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if contains(consonants,\
    \ string(word[i])) {\n            consonant = string(word[i])\n            break\n\
    \        }\n    }\n    if vowel != \"\" && consonant != \"\" {\n        for i\
    \ := len(word) - 1; i >= 0; i-- {\n            if string(word[i]) == vowel {\n\
    \                result = vowel\n                break\n            }\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsq1f27uk_test.go:25:12: undefined: contains

    /tmp/tmpsq1f27uk_test.go:31:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074394
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if string(word[i-1])\
    \ == v {\n                    return v\n                }\n            }\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppolha9hi_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var result string\n    var last_vowel_index int\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            last_vowel_index = i\n            break\n        }\n    }\n\
    \    for i := last_vowel_index - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ !ok {\n            result = string(word[last_vowel_index])\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpa3fai_j__test.go:68: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpa3fai_j__test.go:68: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpa3fai_j__test.go:68: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpa3fai_j__test.go:68: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpa3fai_j__test.go:68:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpa3fai_j__test.go:68: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i > 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n     \
    \       if !strings.Contains(vowels, string(word[i-1])) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz2i__nyi_test.go:21:12: undefined: strings

    /tmp/tmpz2i__nyi_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074394
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closestVowel string\n    var closestVowelIndex int\n \
    \   for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            closestVowel = string(word[i])\n            closestVowelIndex\
    \ = i\n            break\n        }\n    }\n    if closestVowelIndex == 0 {\n\
    \        return \"\"\n    }\n    for i := closestVowelIndex - 1; i >= 0; i-- {\n\
    \        if _, ok := vowels[string(word[i])]; !ok {\n            return closestVowel\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp8spj4pjf_test.go:71: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp8spj4pjf_test.go:71: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp8spj4pjf_test.go:71: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp8spj4pjf_test.go:71: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp8spj4pjf_test.go:71:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp8spj4pjf_test.go:71: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if word[i-1] == v[0] {\n                    return v\n              \
    \  }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsom5065y_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels[string(word[i+1])]\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp5lx_a3zp_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp5lx_a3zp_test.go:58: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp5lx_a3zp_test.go:58: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp5lx_a3zp_test.go:58: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp5lx_a3zp_test.go:58:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp5lx_a3zp_test.go:58: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if isVowel(word[i], vowels)\
    \ && !isVowel(word[i-1], vowels) {\n            return string(word[i])\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjuh619p7_test.go:21:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels[string(word[i\
    \ + 1])] {\n                return string(word[i])\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpfoeccl14_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpfoeccl14_test.go:58: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpfoeccl14_test.go:58: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpfoeccl14_test.go:58: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpfoeccl14_test.go:58:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpfoeccl14_test.go:58: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if v == string(word[i-1]) {\n                    return v\n         \
    \       }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i8excjs_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if !is_vowel(word[i-1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rdamgwh_test.go:19:5: vowels declared but not used

    /tmp/tmp_rdamgwh_test.go:21:12: undefined: is_vowel

    /tmp/tmp_rdamgwh_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            closest_vowel =\
    \ string(word[i])\n            break\n        }\n    }\n    if closest_vowel ==\
    \ \"\" {\n        return closest_vowel\n    }\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if !vowels[string(word[i])] {\n            if i == 0 {\n \
    \               return \"\"\n            }\n            if vowels[string(word[i-1])]\
    \ {\n                return closest_vowel\n            }\n        }\n    }\n \
    \   return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmph3a6vs9y_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmph3a6vs9y_test.go:74: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmph3a6vs9y_test.go:74: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmph3a6vs9y_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmph3a6vs9y_test.go:74: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmph3a6vs9y_test.go:74: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmph3a6vs9y_test.go:74: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if vowels[string(word[i\
    \ + 1])] {\n                continue\n            }\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpqje46thy_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpqje46thy_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpqje46thy_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpqje46thy_test.go:59: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpqje46thy_test.go:59:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpqje46thy_test.go:59: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074392
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var last_vowel string\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n       \
    \     last_vowel = string(word[i])\n            break\n        }\n    }\n    if\
    \ last_vowel == \"\" {\n        return \"\"\n    }\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if !vowels[string(word[i])] {\n            return last_vowel\n\
    \        }\n        last_vowel = string(word[i])\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp9j6ivytc_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp9j6ivytc_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp9j6ivytc_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp9j6ivytc_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp9j6ivytc_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp9j6ivytc_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp9j6ivytc_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp9j6ivytc_test.go:64:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp9j6ivytc_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !isConsonant(word[i]) {\n\
    \            continue\n        }\n        for j := i - 1; j >= 0; j-- {\n    \
    \        if isConsonant(word[j]) {\n                continue\n            }\n\
    \            for _, v := range vowels {\n                if v == string(word[j])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt_5_y958_test.go:21:13: undefined: isConsonant

    /tmp/tmpt_5_y958_test.go:25:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\"a\": true, \"e\": true,\
    \ \"i\": true, \"o\": true, \"u\": true}\n    var last_vowel string\n    var last_consonant\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            last_vowel = string(word[i])\n        } else {\n            last_consonant\
    \ = string(word[i])\n            break\n        }\n    }\n    if last_vowel !=\
    \ \"\" && last_consonant != \"\" {\n        return last_vowel\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp7k55jbac_test.go:61: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp7k55jbac_test.go:61: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp7k55jbac_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmp7k55jbac_test.go:61: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmp7k55jbac_test.go:61: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp7k55jbac_test.go:61: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp7k55jbac_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp7k55jbac_test.go:61:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp7k55jbac_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if !is_vowel(word[i-1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rdamgwh_test.go:19:5: vowels declared but not used

    /tmp/tmp_rdamgwh_test.go:21:12: undefined: is_vowel

    /tmp/tmp_rdamgwh_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i - 1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt7_gigv__test.go:21:12: undefined: strings

    /tmp/tmpt7_gigv__test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var prev_char string\n    var prev_vowel string\n    for _,\
    \ char := range word {\n        if vowels[string(char)] {\n            if prev_char\
    \ != \"\" && !vowels[prev_char] {\n                return string(char)\n     \
    \       }\n            prev_vowel = string(char)\n        }\n        prev_char\
    \ = string(char)\n    }\n    return prev_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp026zfys6_test.go:65: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp026zfys6_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmp026zfys6_test.go:65: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp026zfys6_test.go:65: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp026zfys6_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp026zfys6_test.go:65: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp026zfys6_test.go:65: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp026zfys6_test.go:65:\
    \ expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074394
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if !is_vowel(word[i-1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rdamgwh_test.go:19:5: vowels declared but not used

    /tmp/tmp_rdamgwh_test.go:21:12: undefined: is_vowel

    /tmp/tmp_rdamgwh_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i > 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n     \
    \       if strings.Contains(vowels, string(word[i-1])) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y2wko2a_test.go:21:12: undefined: strings

    /tmp/tmp6y2wko2a_test.go:22:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_consonant(word[i]) {\n\
    \            continue\n        }\n        for j := i - 1; j >= 0; j-- {\n    \
    \        if is_consonant(word[j]) {\n                continue\n            }\n\
    \            for _, v := range vowels {\n                if string(word[j]) ==\
    \ v {\n                    return v\n                }\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6z_fevjt_test.go:21:13: undefined: is_consonant

    /tmp/tmp6z_fevjt_test.go:25:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_consonant(word[i]) &&\
    \ is_consonant(word[i-1]) {\n            for _, v := range vowels {\n        \
    \        if v == string(word[i-1]) {\n                    return v\n         \
    \       }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i8excjs_test.go:21:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if !is_vowel(word[i-1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rdamgwh_test.go:19:5: vowels declared but not used

    /tmp/tmp_rdamgwh_test.go:21:12: undefined: is_vowel

    /tmp/tmp_rdamgwh_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n  \
    \          if is_vowel(word[i-1]) {\n                continue\n            } else\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe2uq9i2d_test.go:19:5: vowels declared but not used

    /tmp/tmpe2uq9i2d_test.go:21:12: undefined: is_vowel

    /tmp/tmpe2uq9i2d_test.go:22:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1])\
    \ {\n            for _, v := range vowels {\n                if v == string(word[i-1])\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoockfbc5_test.go:21:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyid4o_nu_test.go:21:12: undefined: is_vowel

    /tmp/tmpyid4o_nu_test.go:22:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i > 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            if !contains(vowels, string(word[i-1])) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5qvlba3_test.go:21:12: undefined: contains

    /tmp/tmpt5qvlba3_test.go:22:17: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074393
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ !strings.Contains(vowels, string(word[i-1])) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfexubvl2_test.go:21:12: undefined: strings

    /tmp/tmpfexubvl2_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i > 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n     \
    \       if strings.Contains(vowels, string(word[i-1])) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y2wko2a_test.go:21:12: undefined: strings

    /tmp/tmp6y2wko2a_test.go:22:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074394
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if vowels[strings.IndexRune(vowels, rune(word[i]))] != 0 {\n\
    \            if vowels[strings.IndexRune(vowels, rune(word[i-1]))] == 0 {\n  \
    \              return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbsxa7qy_test.go:21:19: undefined: strings

    /tmp/tmphbsxa7qy_test.go:22:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074392
