name: HumanEval_20_find_closest_elements
language: go_test.go
prompt: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  // (2.0, 2.2)\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n//\
  \ (2.0, 2.0)\nfunc find_closest_elements(numbers []float64) []interface{} {\n"
tests: "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
  \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
  \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
  \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
  \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\
    \    var closest_diff float64 = numbers[1] - numbers[0]\n    var closest_pair\
    \ []float64 = []float64{numbers[0], numbers[1]}\n    for i := 0; i < len(numbers)\
    \ - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff\
    \ := numbers[j] - numbers[i]\n            if diff < closest_diff {\n         \
    \       closest_diff = diff\n                closest_pair = []float64{numbers[i],\
    \ numbers[j]}\n            }\n        }\n    }\n    return []interface{}{closest_pair[0],\
    \ closest_pair[1]}\n}\n", "    var closest_elements []interface{}\n    var closest_distance\
    \ float64\n    var distance float64\n    var distance_1 float64\n    var distance_2\
    \ float64\n    var distance_3 float64\n    var distance_4 float64\n    var distance_5\
    \ float64\n    var distance_6 float64\n    var distance_7 float64\n    var distance_8\
    \ float64\n    var distance_9 float64\n    var distance_10 float64\n    var distance_11\
    \ float64\n    var distance_12 float64\n    var distance_13 float64\n    var distance_14\
    \ float64\n    var distance_15 float64\n    var distance_16 float64\n    var distance_17\
    \ float64\n    var distance_18 float64\n    var distance_19 float64\n    var distance_20\
    \ float64\n    var distance_21 float64\n    var distance_22 float64\n    var distance_23\
    \ float64\n    var distance_24 float64\n    var distance_25 float64\n    var distance_26\
    \ float64\n    var distance_27 float64\n    var distance_28 float64\n    var distance_29\
    \ float64\n    var distance_30 float64\n    var distance_31 float64\n    var distance_32\
    \ float64\n    var distance_33 float64\n    var distance_34 float64\n    var distance_35\
    \ float64\n    var distance_36 float64\n    var distance_37 float64\n    var distance_38\
    \ float64\n    var distance_39 float64\n    var distance_40 float64\n    var distance_41\
    \ float64\n    var distance_42 float64\n    var distance_43 float64\n    var distance_44\
    \ float64\n    var distance_45 float64\n    var distance_46 float64\n    var distance_47\
    \ float64\n    var distance_48 float64\n    var distance_49 float64\n    var distance_50\
    \ float64\n    var distance_51 float64\n    var distance_52 float64\n    var distance_53\
    \ float64\n    var distance_54 float64\n    var distance_55 float64\n    var distance_56\
    \ float64\n    var distance_57 float64\n    var distance_58 float64\n    var distance_59\
    \ float64\n    var distance_60 float64\n    var distance_61 float", "    var closest_elements\
    \ []interface{}\n    var closest_diff float64\n    for i, number := range numbers\
    \ {\n        if i == 0 {\n            closest_elements = []interface{}{number,\
    \ number}\n            closest_diff = numbers[i+1] - number\n        } else if\
    \ i == len(numbers) - 1 {\n            break\n        } else {\n            diff\
    \ := numbers[i+1] - number\n            if diff < closest_diff {\n           \
    \     closest_elements = []interface{}{number, numbers[i+1]}\n               \
    \ closest_diff = diff\n            }\n        }\n    }\n    return closest_elements\n\
    }\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    var\
    \ closest_diff float64 = numbers[1] - numbers[0]\n    var closest_pair []float64\
    \ = []float64{numbers[0], numbers[1]}\n    for i := 0; i < len(numbers) - 1; i++\
    \ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[j]\
    \ - numbers[i]\n            if diff < closest_diff {\n                closest_diff\
    \ = diff\n                closest_pair = []float64{numbers[i], numbers[j]}\n \
    \           }\n        }\n    }\n    return []interface{}{closest_pair[0], closest_pair[1]}\n\
    }\n", "    var closest_elements []interface{}\n    var closest_difference float64\
    \ = numbers[1] - numbers[0]\n    var current_difference float64\n\n    for i :=\
    \ 0; i < len(numbers) - 1; i++ {\n        current_difference = numbers[i + 1]\
    \ - numbers[i]\n        if current_difference < closest_difference {\n       \
    \     closest_difference = current_difference\n            closest_elements =\
    \ []interface{}{numbers[i], numbers[i + 1]}\n        }\n    }\n\n    return closest_elements\n\
    }\n", "    var closest_pair []interface{}\n    var closest_distance float64 =\
    \ 0.0\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            distance := numbers[j] - numbers[i]\n            if closest_distance\
    \ == 0.0 || distance < closest_distance {\n                closest_distance =\
    \ distance\n                closest_pair = []interface{}{numbers[i], numbers[j]}\n\
    \            }\n        }\n    }\n    return closest_pair\n}\n", "    var closest_elements\
    \ []interface{}\n    var closest_diff float64\n    for i := 0; i < len(numbers);\
    \ i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff :=\
    \ numbers[j] - numbers[i]\n            if closest_diff == 0 || diff < closest_diff\
    \ {\n                closest_elements = []interface{}{numbers[i], numbers[j]}\n\
    \                closest_diff = diff\n            }\n        }\n    }\n    return\
    \ closest_elements\n}\n", "    var closest_elements []interface{}\n    var closest_diff\
    \ float64\n    var diff float64\n    var prev_num float64\n    var curr_num float64\n\
    \n    if len(numbers) > 1 {\n        closest_diff = numbers[1] - numbers[0]\n\
    \        closest_elements = []interface{}{numbers[0], numbers[1]}\n        prev_num\
    \ = numbers[0]\n        for _, curr_num = range numbers[1:] {\n            diff\
    \ = curr_num - prev_num\n            if diff < closest_diff {\n              \
    \  closest_diff = diff\n                closest_elements = []interface{}{prev_num,\
    \ curr_num}\n            }\n            prev_num = curr_num\n        }\n    }\n\
    \    return closest_elements\n}\n", "    var closest_elements []interface{}\n\
    \    var closest_distance float64\n    var distance float64\n    var distance_1\
    \ float64\n    var distance_2 float64\n    var number_1 float64\n    var number_2\
    \ float64\n\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1;\
    \ j < len(numbers); j++ {\n            distance_1 = numbers[i] - numbers[j]\n\
    \            distance_2 = numbers[j] - numbers[i]\n            if distance_1 <\
    \ 0 {\n                distance = distance_1 * -1\n            } else {\n    \
    \            distance = distance_2\n            }\n            if closest_distance\
    \ == 0 || distance < closest_distance {\n                closest_distance = distance\n\
    \                if distance_1 < 0 {\n                    number_1 = numbers[j]\n\
    \                    number_2 = numbers[i]\n                } else {\n       \
    \             number_1 = numbers[i]\n                    number_2 = numbers[j]\n\
    \                }\n            }\n        }\n    }\n    closest_elements = append(closest_elements,\
    \ number_1)\n    closest_elements = append(closest_elements, number_2)\n    return\
    \ closest_elements\n}\n", "    var closest_elements []interface{}\n    var closest_distance\
    \ float64\n    var distance float64\n    var current_element float64\n    var\
    \ next_element float64\n\n    for i := 0; i < len(numbers) - 1; i++ {\n      \
    \  current_element = numbers[i]\n        next_element = numbers[i + 1]\n     \
    \   distance = next_element - current_element\n        if i == 0 {\n         \
    \   closest_distance = distance\n            closest_elements = []interface{}{current_element,\
    \ next_element}\n        } else if distance < closest_distance {\n           \
    \ closest_distance = distance\n            closest_elements = []interface{}{current_element,\
    \ next_element}\n        }\n    }\n\n    return closest_elements\n}\n", "    var\
    \ closest_elements []interface{}\n    var closest_difference float64 = numbers[1]\
    \ - numbers[0]\n    var closest_index int = 0\n    for i := 1; i < len(numbers)\
    \ - 1; i++ {\n        difference := numbers[i + 1] - numbers[i]\n        if difference\
    \ < closest_difference {\n            closest_difference = difference\n      \
    \      closest_index = i\n        }\n    }\n    closest_elements = append(closest_elements,\
    \ numbers[closest_index])\n    closest_elements = append(closest_elements, numbers[closest_index\
    \ + 1])\n    return closest_elements\n}\n", "    var closest_difference float64\
    \ = numbers[1] - numbers[0]\n    var closest_elements []interface{} = []interface{}{numbers[0],\
    \ numbers[1]}\n    for i := 0; i < len(numbers) - 1; i++ {\n        for j := i\
    \ + 1; j < len(numbers); j++ {\n            if numbers[j] - numbers[i] < closest_difference\
    \ {\n                closest_difference = numbers[j] - numbers[i]\n          \
    \      closest_elements = []interface{}{numbers[i], numbers[j]}\n            }\n\
    \        }\n    }\n    return closest_elements\n}\n", "    var closest_elements\
    \ []interface{}\n    var closest_difference float64\n    var current_difference\
    \ float64\n    var current_elements []interface{}\n\n    for i := 0; i < len(numbers)\
    \ - 1; i++ {\n        current_elements = []interface{}{numbers[i], numbers[i +\
    \ 1]}\n        current_difference = numbers[i + 1] - numbers[i]\n        if closest_difference\
    \ == 0 || current_difference < closest_difference {\n            closest_difference\
    \ = current_difference\n            closest_elements = current_elements\n    \
    \    }\n    }\n\n    return closest_elements\n}\n", "    var closest []interface{}\n\
    \    var closest_diff float64\n    for i := 0; i < len(numbers); i++ {\n     \
    \   for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[j] -\
    \ numbers[i]\n            if closest_diff == 0 || diff < closest_diff {\n    \
    \            closest_diff = diff\n                closest = []interface{}{numbers[i],\
    \ numbers[j]}\n            }\n        }\n    }\n    return closest\n}\n", "  \
    \  var closest_elements []interface{}\n    var closest_diff float64\n    for i,\
    \ number := range numbers {\n        if i == 0 {\n            closest_elements\
    \ = []interface{}{number, number}\n            closest_diff = numbers[i+1] - number\n\
    \        } else if i == len(numbers) - 1 {\n            break\n        } else\
    \ {\n            diff := numbers[i+1] - number\n            if diff < closest_diff\
    \ {\n                closest_elements = []interface{}{number, numbers[i+1]}\n\
    \                closest_diff = diff\n            }\n        }\n    }\n    return\
    \ closest_elements\n}\n", "    var closest_elements []interface{}\n    var smallest_difference\
    \ float64\n    var difference float64\n    var smaller_number float64\n    var\
    \ larger_number float64\n\n    for i := 0; i < len(numbers); i++ {\n        for\
    \ j := i + 1; j < len(numbers); j++ {\n            difference = numbers[j] - numbers[i]\n\
    \            if i == 0 && j == 1 {\n                smallest_difference = difference\n\
    \                smaller_number = numbers[i]\n                larger_number =\
    \ numbers[j]\n            } else if difference < smallest_difference {\n     \
    \           smallest_difference = difference\n                smaller_number =\
    \ numbers[i]\n                larger_number = numbers[j]\n            }\n    \
    \    }\n    }\n\n    closest_elements = append(closest_elements, smaller_number,\
    \ larger_number)\n    return closest_elements\n}\n", "    var closest_elements\
    \ []interface{}\n    var closest_difference float64 = numbers[1] - numbers[0]\n\
    \    var closest_elements_indexes []int = []int{0, 1}\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            difference\
    \ := numbers[j] - numbers[i]\n            if difference < closest_difference {\n\
    \                closest_difference = difference\n                closest_elements_indexes\
    \ = []int{i, j}\n            }\n        }\n    }\n\n    closest_elements = append(closest_elements,\
    \ numbers[closest_elements_indexes[0]])\n    closest_elements = append(closest_elements,\
    \ numbers[closest_elements_indexes[1]])\n\n    return closest_elements\n}\n",
  "    var closest_elements []interface{}\n    var closest_diff float64\n    for i\
    \ := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++\
    \ {\n            diff := numbers[j] - numbers[i]\n            if closest_diff\
    \ == 0 || diff < closest_diff {\n                closest_elements = []interface{}{numbers[i],\
    \ numbers[j]}\n                closest_diff = diff\n            }\n        }\n\
    \    }\n    return closest_elements\n}\n", "    var closest []interface{}\n  \
    \  var smallestDifference float64\n    var currentDifference float64\n    var\
    \ previousNumber float64\n    var currentNumber float64\n\n    for i, number :=\
    \ range numbers {\n        if i == 0 {\n            previousNumber = number\n\
    \            continue\n        }\n\n        currentNumber = number\n        currentDifference\
    \ = currentNumber - previousNumber\n\n        if i == 1 {\n            smallestDifference\
    \ = currentDifference\n            closest = []interface{}{previousNumber, currentNumber}\n\
    \        } else if currentDifference < smallestDifference {\n            smallestDifference\
    \ = currentDifference\n            closest = []interface{}{previousNumber, currentNumber}\n\
    \        }\n\n        previousNumber = currentNumber\n    }\n\n    return closest\n\
    }\n", "    var closest_elements []interface{}\n    var closest_difference float64\n\
    \    var current_difference float64\n    var current_elements []interface{}\n\n\
    \    for i := 0; i < len(numbers) - 1; i++ {\n        current_elements = []interface{}{numbers[i],\
    \ numbers[i + 1]}\n        current_difference = numbers[i + 1] - numbers[i]\n\
    \        if closest_difference == 0 || current_difference < closest_difference\
    \ {\n            closest_difference = current_difference\n            closest_elements\
    \ = current_elements\n        }\n    }\n\n    return closest_elements\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
