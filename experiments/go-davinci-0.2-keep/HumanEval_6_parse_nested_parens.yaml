name: HumanEval_6_parse_nested_parens
language: go_test.go
prompt: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  // [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string string) []int {\n"
tests: "func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"),\
  \ expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
  ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"),\
  \ expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n", "    var max_depth int\n    var depth int\n    var result []int\n    for\
    \ _, c := range paren_string {\n        if c == '(' {\n            depth += 1\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if c == ')' {\n            depth -= 1\n        } else\
    \ if c == ' ' {\n            result = append(result, max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n", "    var result []int\n    var max_depth int\n    var\
    \ depth int\n    for _, char := range paren_string {\n        if char == '(' {\n\
    \            depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n", "    var result []int\n\
    \    var current_level int\n    var max_level int\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            current_level += 1\n            if\
    \ current_level > max_level {\n                max_level = current_level\n   \
    \         }\n        } else if char == ')' {\n            current_level -= 1\n\
    \        } else if char == ' ' {\n            result = append(result, max_level)\n\
    \            current_level = 0\n            max_level = 0\n        }\n    }\n\
    \    result = append(result, max_level)\n    return result\n}\n", "    var result\
    \ []int\n    var depth int\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            depth += 1\n        } else if char == ')' {\n   \
    \         depth -= 1\n        } else if char == ' ' {\n            result = append(result,\
    \ depth)\n        }\n    }\n    return result\n}\n", "    var result []int\n \
    \   var max_level int\n    var level int\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            level += 1\n            if level >\
    \ max_level {\n                max_level = level\n            }\n        } else\
    \ if char == ')' {\n            level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n", "    var result []int\n    var current_level int\n \
    \   var max_level int\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            current_level++\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if c\
    \ == ')' {\n            if current_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n            }\n\
    \            current_level--\n        } else if c == ' ' {\n            if current_level\
    \ == max_level {\n                result = append(result, max_level)\n       \
    \         max_level = 0\n            }\n            current_level = 0\n      \
    \  }\n    }\n    return result\n}\n", "    var max_level int = 0\n    var level\
    \ int = 0\n    var max_levels []int\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            level += 1\n            if level > max_level\
    \ {\n                max_level = level\n            }\n        } else if char\
    \ == ')' {\n            level -= 1\n            if level == 0 {\n            \
    \    max_levels = append(max_levels, max_level)\n                max_level = 0\n\
    \            }\n        }\n    }\n    return max_levels\n}\n", "    var result\
    \ []int\n    var paren_stack []rune\n    var max_level int\n    var level int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            level\
    \ += 1\n            if level > max_level {\n                max_level = level\n\
    \            }\n            paren_stack = append(paren_stack, c)\n        } else\
    \ if c == ')' {\n            level -= 1\n            if level < 0 {\n        \
    \        panic(\"Unmatched parentheses\")\n            }\n            paren_stack\
    \ = paren_stack[:len(paren_stack)-1]\n        } else if c == ' ' {\n         \
    \   if len(paren_stack) != 0 {\n                panic(\"Unmatched parentheses\"\
    )\n            }\n            result = append(result, max_level)\n           \
    \ max_level = 0\n            level = 0\n        } else {\n            panic(\"\
    Invalid character\")\n        }\n    }\n    if len(paren_stack) != 0 {\n     \
    \   panic(\"Unmatched parentheses\")\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n", "    var result []int\n    var current_level int\n \
    \   var max_level int\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            current_level++\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if c\
    \ == ')' {\n            if current_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n            }\n\
    \            current_level--\n        } else if c == ' ' {\n            if current_level\
    \ == max_level {\n                result = append(result, max_level)\n       \
    \         max_level = 0\n            }\n            current_level = 0\n      \
    \  }\n    }\n    return result\n}\n", "    var result []int\n    var level int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            level++\n\
    \        } else if c == ')' {\n            level--\n        } else if c == ' '\
    \ {\n            result = append(result, level)\n        }\n    }\n    return\
    \ result\n}\n", "    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n        } else if\
    \ c == ')' {\n            level--\n        } else if c == ' ' {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n", "    var\
    \ result []int\n    var level int\n    var max_level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n            if level\
    \ > max_level {\n                max_level = level\n            }\n        } else\
    \ if c == ')' {\n            level--\n        } else if c == ' ' {\n         \
    \   result = append(result, max_level)\n            max_level = 0\n          \
    \  level = 0\n        }\n    }\n    result = append(result, max_level)\n    return\
    \ result\n}\n", "    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n", "    var result []int\n    var current_level int\n    var max_level int\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if char == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level--\n\
    \        }\n    }\n    return result\n}\n", "    var result []int\n    var current_level\
    \ int\n    var current_max int\n    for _, char := range paren_string {\n    \
    \    if char == '(' {\n            current_level += 1\n            if current_level\
    \ > current_max {\n                current_max = current_level\n            }\n\
    \        } else if char == ')' {\n            current_level -= 1\n        } else\
    \ if char == ' ' {\n            result = append(result, current_max)\n       \
    \     current_level = 0\n            current_max = 0\n        }\n    }\n    result\
    \ = append(result, current_max)\n    return result\n}\n", "    var result []int\n\
    \    var current_level int\n    for _, paren := range paren_string {\n       \
    \ if paren == '(' {\n            current_level += 1\n        } else if paren ==\
    \ ')' {\n            result = append(result, current_level)\n            current_level\
    \ -= 1\n        }\n    }\n    return result\n}\n", "    var result []int\n   \
    \ var current_level int\n    var max_level int\n    for _, c := range paren_string\
    \ {\n        if c == '(' {\n            current_level++\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      } else if c == ')' {\n            current_level--\n        } else if c\
    \ == ' ' {\n            result = append(result, max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result = append(result,\
    \ max_level)\n    return result\n}\n", "    var result []int\n    var paren_stack\
    \ []int\n    var max_depth int\n    var current_depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            current_depth++\n       \
    \     if current_depth > max_depth {\n                max_depth = current_depth\n\
    \            }\n        } else if c == ')' {\n            current_depth--\n  \
    \      } else if c == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        }\n    }\n\
    \    return result\n}\n", "    var result []int\n    var current_level int\n \
    \   var max_level int\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if c == ')' {\n            current_level -= 1\n        } else if c == ' ' {\n\
    \            result = append(result, max_level)\n            current_level = 0\n\
    \            max_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
