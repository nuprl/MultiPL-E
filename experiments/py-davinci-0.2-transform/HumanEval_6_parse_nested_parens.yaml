name: HumanEval_6_parse_nested_parens
language: py
prompt: "from typing import List\n\ndef parse_nested_parens(paren_string: str) ->\
  \ List[int]:\n    \"\"\" Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n    For each of the group,\
  \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
  \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
  \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
  \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
  \ntest_check()\n"
completions: ["    paren_groups = paren_string.split(' ')\n    max_nesting = []\n\
    \    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n", "    result = []\n    for paren_group in paren_string.split('\
    \ '):\n        max_depth = 0\n        current_depth = 0\n        for char in paren_group:\n\
    \            if char == '(':\n                current_depth += 1\n           \
    \     max_depth = max(max_depth, current_depth)\n            elif char == ')':\n\
    \                current_depth -= 1\n        result.append(max_depth)\n    return\
    \ result\n", "    result = []\n    for paren_group in paren_string.split(' '):\n\
    \        max_depth = 0\n        current_depth = 0\n        for paren in paren_group:\n\
    \            if paren == '(':\n                current_depth += 1\n          \
    \      max_depth = max(max_depth, current_depth)\n            elif paren == ')':\n\
    \                current_depth -= 1\n        result.append(max_depth)\n    return\
    \ result\n", "    result = []\n    for paren_group in paren_string.split(' '):\n\
    \        max_depth = 0\n        current_depth = 0\n        for paren in paren_group:\n\
    \            if paren == '(':\n                current_depth += 1\n          \
    \      max_depth = max(max_depth, current_depth)\n            elif paren == ')':\n\
    \                current_depth -= 1\n        result.append(max_depth)\n    return\
    \ result\n", "    max_depth = 0\n    current_depth = 0\n    result = []\n    for\
    \ c in paren_string:\n        if c == '(':\n            current_depth += 1\n \
    \           max_depth = max(max_depth, current_depth)\n        elif c == ')':\n\
    \            current_depth -= 1\n        elif c == ' ':\n            result.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n    result.append(max_depth)\n\
    \    return result\n", "    max_depth = 0\n    current_depth = 0\n    max_depths\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            current_depth\
    \ += 1\n            max_depth = max(max_depth, current_depth)\n        elif char\
    \ == ')':\n            current_depth -= 1\n        elif char == ' ':\n       \
    \     max_depths.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n    return max_depths", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n", "    max_depth = 0\n    curr_depth = 0\n    result\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            curr_depth\
    \ += 1\n            max_depth = max(max_depth, curr_depth)\n        elif char\
    \ == ')':\n            curr_depth -= 1\n        elif char == ' ':\n          \
    \  result.append(max_depth)\n            max_depth = 0\n            curr_depth\
    \ = 0\n    result.append(max_depth)\n    return result\n", "    paren_groups =\
    \ paren_string.split(' ')\n    return [max_nested_parens(group) for group in paren_groups]\n",
  "    paren_groups = paren_string.split(' ')\n    return [max_nested_parens(group)\
    \ for group in paren_groups]\n", "    result = []\n    for paren_group in paren_string.split('\
    \ '):\n        max_level = 0\n        level = 0\n        for paren in paren_group:\n\
    \            if paren == '(':\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            elif paren == ')':\n                level\
    \ -= 1\n        result.append(max_level)\n    return result\n", "    result =\
    \ []\n    for group in paren_string.split(' '):\n        max_depth = 0\n     \
    \   depth = 0\n        for char in group:\n            if char == '(':\n     \
    \           depth += 1\n                max_depth = max(max_depth, depth)\n  \
    \          elif char == ')':\n                depth -= 1\n        result.append(max_depth)\n\
    \    return result\n", "    paren_groups = paren_string.split(' ')\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(get_max_nesting(group))\n\
    \    return max_nesting\n", "    result = []\n    for paren_group in paren_string.split('\
    \ '):\n        max_depth = 0\n        current_depth = 0\n        for paren in\
    \ paren_group:\n            if paren == '(':\n                current_depth +=\
    \ 1\n                max_depth = max(max_depth, current_depth)\n            elif\
    \ paren == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\n", "    max_nesting_levels = []\n    for paren_group in paren_string.split('\
    \ '):\n        max_nesting_levels.append(find_max_nesting_level(paren_group))\n\
    \    return max_nesting_levels\n", "    max_depth = 0\n    current_depth = 0\n\
    \    result = []\n    for char in paren_string:\n        if char == '(':\n   \
    \         current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif char == ')':\n            current_depth -= 1\n        elif char\
    \ == ' ':\n            result.append(max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n    result.append(max_depth)\n    return result\n",
  "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for paren_group\
    \ in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n", "    max_depth = 0\n    curr_depth = 0\n    depths\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            curr_depth\
    \ += 1\n            max_depth = max(max_depth, curr_depth)\n        elif char\
    \ == ')':\n            curr_depth -= 1\n        elif char == ' ':\n          \
    \  depths.append(max_depth)\n            max_depth = 0\n            curr_depth\
    \ = 0\n    depths.append(max_depth)\n    return depths\n", "    paren_groups =\
    \ paren_string.split(' ')\n    return [max_nested_parens(group) for group in paren_groups]\n",
  "    result = []\n    for paren_group in paren_string.split():\n        depth =\
    \ 0\n        max_depth = 0\n        for paren in paren_group:\n            if\
    \ paren == '(':\n                depth += 1\n                max_depth = max(max_depth,\
    \ depth)\n            elif paren == ')':\n                depth -= 1\n       \
    \ result.append(max_depth)\n    return result\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
