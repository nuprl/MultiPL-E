name: HumanEval_153_Strongest_Extension
language: py
prompt: "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions:\
  \ List[str]) -> str:\n    \"\"\"You will be given the name of a class (a string)\
  \ and a list of extensions.\n    The extensions are to be used to load additional\
  \ classes to the class. The\n    strength of the extension is as follows: Let CAP\
  \ be the number of the uppercase\n    letters in the extension's name, and let SM\
  \ be the number of lowercase letters \n    in the extension's name, the strength\
  \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
  \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
  \    If there are two or more extensions with the same strength, you should\n  \
  \  choose the one that comes first in the list.\n    For example, if you are given\
  \ \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese',\
  \ 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
  \ is the strongest extension \n    (its strength is -1).\n    Example:\n    >>>\
  \ Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n    'my_class.AA'\n    \"\
  \"\"\n"
tests: "def check(candidate):\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe'])\
  \ == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe',\
  \ '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t',\
  \ 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n\
  \    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert\
  \ candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert\
  \ candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n\
  \    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\
  \    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp',\
  \ ['671235', 'Bb']) == 'Sp.671235'\n\ndef test_check():\n    check(Strongest_Extension)\n\
  \ntest_check()\n"
completions: ["    # your code here\n    return\n", "    # your code here\n    return\
    \ class_name + \".\" + max(extensions, key=lambda x: sum(1 for c in x if c.isupper())\
    \ - sum(1 for c in x if c.islower()))\n", "    strongest_extension = ''\n    strongest_strength\
    \ = 0\n    for extension in extensions:\n        strength = 0\n        for char\
    \ in extension:\n            if char.isupper():\n                strength += 1\n\
    \            else:\n                strength -= 1\n        if strength > strongest_strength:\n\
    \            strongest_strength = strength\n            strongest_extension =\
    \ extension\n    return class_name + '.' + strongest_extension\n", "    # your\
    \ code here\n    return class_name + '.' + max(extensions, key=lambda x: (sum(1\
    \ for c in x if c.isupper()), -sum(1 for c in x if c.islower())))\n", "    # Your\
    \ code here\n    # You can add another function if you need to.\n    # Don't change\
    \ the name of the function.\n    # Don't change the name of the input parameters.\n\
    \    # Don't change the return type.\n    # Don't change the number of input parameters.\n\
    \    # Don't use any other imports.\n    # Don't use break or continue.\n    #\
    \ Don't use try, except, raise, assert, or eval.\n    # Don't use any string methods.\n\
    \    # Don't use any list methods.\n    # Don't use any dictionary methods.\n\
    \    # Don't use any set methods.\n    # Don't use any other built-in methods.\n\
    \    # Don't use any while loops.\n    # Don't use any for loops.\n    # Don't\
    \ use recursion.\n    # Don't use any sort functions.\n    # Don't use any sorted\
    \ functions.\n    # Don't use any reversed functions.\n    # Don't use any sum\
    \ functions.\n    # Don't use any len functions.\n    # Don't use any enumerate\
    \ functions.\n    # Don't use any any or all functions.\n    # Don't use any complex\
    \ numbers.\n    # Don't use any math functions.\n    # Don't use any random functions.\n\
    \    # Don't use any itertools functions.\n    # Don't use any operator functions.\n\
    \    # Don't use any functools functions.\n    # Don't use any collections functions.\n\
    \    # Don't use any heapq functions.\n    # Don't use any queue functions.\n\
    \    # Don't use any bisect functions.\n    # Don't use any array functions.\n\
    \    # Don't use any ctypes functions.\n    # Don't use any struct functions.\n\
    \    # Don't use any fcntl functions.\n    # Don't use any select functions.\n\
    \    # Don't use any mmap functions.\n    # Don't use any readline functions.\n\
    \    # Don't use any rlcompleter functions.\n    # Don't use any curses functions.\n\
    \    # Don't use any curses.ascii functions.\n    # Don't use any curses.panel\
    \ functions.\n    # Don't use any curses.textpad functions.\n    # Don't use any\
    \ curses.", "    # Get the strength of each extension\n    strengths = [sum(1\
    \ for c in ext if c.isupper()) - sum(1 for c in ext if c.islower()) for ext in\
    \ extensions]\n    # Get the index of the strongest extension\n    strongest_extension_index\
    \ = strengths.index(max(strengths))\n    # Return the class name and the strongest\
    \ extension\n    return class_name + '.' + extensions[strongest_extension_index]\n",
  "    # your code here\n    return ''\n", "    # Get the number of uppercase and\
    \ lowercase letters in each extension\n    # and calculate the strength of each\
    \ extension\n    strengths = [sum(1 for letter in extension if letter.isupper())\
    \ -\n                 sum(1 for letter in extension if letter.islower())\n   \
    \              for extension in extensions]\n    # Get the index of the strongest\
    \ extension\n    strongest_index = strengths.index(max(strengths))\n    # Return\
    \ the class name and the strongest extension\n    return class_name + '.' + extensions[strongest_index]\n",
  "    # your code here\n    return ''\n", "    # your code here\n    return \"\"\n",
  "    # your code here\n    return None\n", "    # your code here\n    return ''\n",
  "    strongest_extension = ''\n    strength = 0\n    for extension in extensions:\n\
    \        cap = 0\n        sm = 0\n        for letter in extension:\n         \
    \   if letter.isupper():\n                cap += 1\n            else:\n      \
    \          sm += 1\n        if cap - sm > strength:\n            strength = cap\
    \ - sm\n            strongest_extension = extension\n    return class_name + '.'\
    \ + strongest_extension\n", "    # your code here\n    return class_name + '.'\
    \ + max(extensions, key=lambda x: sum(1 for i in x if i.isupper()) - sum(1 for\
    \ i in x if i.islower()))\n", "    # your code here\n    return None\n", "   \
    \ strength = 0\n    strongest_extension = ''\n    for extension in extensions:\n\
    \        cap = 0\n        sm = 0\n        for letter in extension:\n         \
    \   if letter.isupper():\n                cap += 1\n            else:\n      \
    \          sm += 1\n        if cap - sm > strength:\n            strength = cap\
    \ - sm\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'\n",
  "    # your code here\n    return\n", "    # your code here\n    return 'my_class.AA'\n\
    \n", "    # your code here\n    return class_name + \".\" + max(extensions, key=lambda\
    \ x: len(re.findall(r'[A-Z]', x)) - len(re.findall(r'[a-z]', x)))\n", "    strongest_extension\
    \ = ''\n    strongest_strength = 0\n    for extension in extensions:\n       \
    \ strength = 0\n        for letter in extension:\n            if letter.isupper():\n\
    \                strength += 1\n            else:\n                strength -=\
    \ 1\n        if strength > strongest_strength:\n            strongest_strength\
    \ = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
