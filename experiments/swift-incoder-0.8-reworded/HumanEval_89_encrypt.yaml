name: HumanEval_89_encrypt
language: swift
prompt: "\n/// Create a function encrypt that takes a string as an argument and\n\
  /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
  \ should be rotated in a manner such that the letters \n/// shift down by two multiplied\
  \ to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n/// \"lm\"\n///\
  \ >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s: \"gf\")\n\
  /// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s: String) -> String\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
  \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
  \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
  )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
  \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  )\nassert(encrypt(s: \"a\") == \"e\")"
completions: ["    \n    var result = \"\"\n    var i = 0\n    while i < len(s) {\n\
    \        let index = ((i>>1) + 1) * 2\n        if index < s.count {\n        \
    \    result += alphabet[index]\n        }\n        i += 2\n    }\n    return result",
  "    if s == \"\" {\n        return \"\"\n    }\n\n    let r = rotate(s.characters,\
    \ -2)\n    switch s.characters {\n    case r where !r.isEmpty {\n        let lc\
    \ = len(s)\n        let l = append(s.characters, s.characters.last!)\n       \
    \ let r = rotate(s.characters, -2)\n        return append(append(append(r, append(append(append(append(append(append(r,\
    \ s.characters.first!), append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(append(",
  '    return applyLetterTransform("rot13", s)', "    var alphabet: [String] = []\n\
    \    \n    for _ in 1..<26 {\n        let num = alphabet.count\n        alphabet.append(\"\
    abcdefghijklmnopqrstuvwxyz\".characters[num - 1])\n    }\n    \n    return s.characters.map\
    \ { alphabet[alphabet.index(of: $0)! + 2] }", "\tlet alphabet: [Character] = ['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n\tlet rotation: Int = alphabet.count\
    \ / 2\n\tlet result = \"\"\n\tfor char in s.characters {\n\t\tresult += alphabet.element(char\
    \ + rotation)\n\t}\n\treturn result", "    if s == \"\" {\n        return \"\\\
    0\"\n    }\n    \n    var a = \"abcdefghijklmnopqrstuvwxyz\"\n    var b = \"nopqrstuvwxyzabcdefghijklm\"\
    \n    var c = \"jklmpqrstuvwxyzabcdefghijk\"\n    var d = \"pqrstuvwxyzabcdefghijklmnop\"\
    \n    var e = \"uvwxyzabcdefghijklmnopqrst\"\n    var f = \"ghijklmnopqrstuvwxyzabcdef\"\
    \n    var g = \"klmnopqrstuvwxyzabcdefghi\"\n    var h = \"nopqrstuvwxyzabcdefghijkl\"\
    \n    var i = \"uvwxyzabcdefghijklmnopqr\"\n    var j = \"pqrstuvwxyzabcdefghijklmn\"\
    \n    var k = \"rstuvwxyzabcdefghijklmnop\"\n    var l = \"uvwxyzabcdefghijklmnopq\"\
    \n    var m = \"ghijklmnopqrstuvwxyzabcde\"\n    var n = \"klmnopqrstuvwxyzabcdefghi\"\
    \n    var o = \"nopqrstuvwxyzabcdefghijkl\"\n    var p = \"uvwxyzabcdefghijklmnop\"\
    \n    var q = \"pqrstuvwxyzabcdefghijklmn\"\n    var r = \"rstuvwxyzabcdefghijklmno\"\
    \n    var s = \"uvwxyzabcdefghijklmnop\"\n    var t = \"ghijklmnopqrstuvwxyzabcde\"\
    \n    var u = \"klmnopqrstuvwxyzabcdefghi\"\n    var v = \"nopqrstuvwxyzabcdefghijkl\"\
    \n    var w = \"uvwxyzabcdefghijklmnop\"\n    var x = \"pqrstuvwxyzabcdefghijklmn\"\
    \n    var y = \"rstuvwxyzabcdefghijklmno\"\n    var z = \"uvwxyzabcdefghijklmnop\"\
    \n    \n    var len = s.length\n    var key = [UInt8](repeatElement(a[len/2],\
    \ len/2))\n    var result = [UInt8](repeatElement(0, len))\n    \n    var i =\
    \ 0\n    for char in s {\n        result[i] = char\n        key[i] = char\n  \
    \      key[len-i-1] = char\n        i += 1\n    }\n    \n    for i from len-1\
    \ downto 0 {\n        var index = i % len\n        var tmp = a[index]\n      \
    \  a[index] = a[len-index-1]\n", '    return rotateByTwo(rotateByTwo(s))', " \
    \   if s != \"\" {\n        var alphabet = [Character : Character]()\n       \
    \ let characterSet = NSCharacterSet(charactersInString: \"abcdefghijklmnopqrstuvwxyz\"\
    ).invertedSet\n        for character in characterSet.unicodeScalars {\n      \
    \      alphabet[character] = Character(character)\n        }\n        let strings\
    \ = Array(s.characters)\n        var result = \"\"\n        for string in strings\
    \ {\n            let key = alphabet[string]\n            for char in string {\n\
    \                if char != key {\n                    result += char\n      \
    \          }\n            }\n        }\n        return result\n    }\n    return\
    \ \"\"", "    var letters = [Character]()\n    for char in s.characters {\n  \
    \      letters.append(char)\n    }\n    rotate(letters)\n    let encryptedLetters\
    \ = letters.map({ $0.toInt() })\n    return String(encryptedLetters)", "\tlet\
    \ alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\tvar i = 0\n\tvar j = 0\n\tvar string\
    \ = \"\"\n\tfor ch in s {\n\t\tlet index = (ch - 97) * 10 + alphabet.index(alphabet.subscript((alphabet.index(alphabet.startIndex,\
    \ offsetBy: -2)) + 2))\n\t\tstring = String(alphabet[index % 26])\n\t\tstring\
    \ += string\n\t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\
    \t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring =\
    \ String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index\
    \ % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index % 26])\n\t\t\
    string += string\n\t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\
    \t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring =\
    \ String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index\
    \ % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index % 26])\n\t\t\
    string += string\n\t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\
    \t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring =\
    \ String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index\
    \ % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index % 26])\n\t\t\
    string += string\n\t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\
    \t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring =\
    \ String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index\
    \ % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index % 26])\n\t\t\
    string += string\n\t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\
    \t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring =\
    \ String(alphabet[index % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index\
    \ % 26])\n\t\tstring += string\n\t\tstring = String(alphabet[index % 26])\n\t\t\
    string += string\n\t\tstring = String(alphabet[index % 26])\n\t\tstring += string\n\
    \t\tstring = String(alphabet[index % 26])\n\t\t", "\treturn rotate(s, alphabetRotation:\
    \ 2)", "    var alphabet [Int: String] = [\n        \"\": \"\", \"\": \"\", \"\
    \": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n      \
    \  \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\"\
    : \"\", \"\": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\
    \": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\": \"\"\
    , \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n  \
    \      \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\"\
    , \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\
    \", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\"\
    : \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\"\
    ,\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\
    \", \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\"\
    : \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\
    \": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\
    \",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\"\
    : \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\
    \": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\"\
    , \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\"\
    : \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\
    \": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\"\
    , \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\
    \", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\
    \": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\"\
    , \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\
    \", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\"\
    : \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\"\
    , \"\": \"\",\n        \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\", \"\": \"\
    \", \"\": \"\", \"\": \"\", \"\": \"\",\n        \"\": \"\", ", '    return encrypt(s,
    "")', "    let alphabet = s.characters\n    let characters = rotation(alphabet.count).map\
    \ { alphabet[$0] }\n    return String(characters.joinWithSeparator(\"\"))", " \
    \   if s == \"\" {\n        return \"\"\n    }\n\n    alphabet = [\n        \"\
    a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"\
    n\",\n        \"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\"\
    ,\"z\"\n    ]\n    if alphabet.isEmpty() {\n        return \"\"\n    }\n\n   \
    \ var cipherText = \"\"\n    for c in s {\n        let index = alphabet.index(of:\
    \ c)!\n        let result = alphabet.index(before: index)!\n        cipherText\
    \ += alphabet[result]\n    }\n\n    return cipherText", "\tvar result = \"\"\n\
    \tfor _, c in s.characters {\n\t\tvar c2 = c + 2\n\t\tif c2 >= 97 && c2 <= 122\
    \ {\n\t\t\tc2 += 32\n\t\t}\n\t\tresult += c2\n\t}\n\treturn result", "    var\
    \ letters: [String] = []\n    s.characters().forEach {\n        let x = $0.unicodeScalarValue\n\
    \        let offset = ((x * 2) - 1) // offset needs to be multiplied by 2 because\
    \ we rotate by two places.\n        letters.append(letters[offset])\n        letters[offset]\
    \ = String(UnicodeScalar(x))\n    }\n    return String(letters)", "    let n =\
    \ s.count\n    var e = \"\"\n    for _i in 0..<n {\n        let d = n % 26\n \
    \       e += alphabet[d]\n        n -= d\n    }\n    e += alphabet[(n - 1) % 26]\n\
    \    return e", "    n := len(s)\n    var alphabet = [Character]()\n    for i\
    \ := 0; i < n; i++ {\n        alphabet += alphabet.rotate(2)\n    }\n    var c\
    \ = s[0]\n    for i := 1; i < n; i++ {\n        var d = s[i] - c\n        var\
    \ r = alphabet.find(d)\n        if r == -1 {\n            d = d.rotateLeft()\n\
    \        } else {\n            d = d.rotateRight()\n        }\n        c = (c\
    \ - d) + c\n    }\n    return c", "    if s.isEmpty {\n        return s\n    }\n\
    \    if s.count < 4 { \n        return String(s.characters.map { letterToCode($0)\
    \ })\n    }\n    if s.count < 6 { \n        let firstLetter = s.characters.first!\n\
    \        let lastLetter = s.characters.last!\n        var s = \"\"\n        var\
    \ i = 0\n        for letter in s.characters {\n            let code = (letterToCode(letter)\
    \ + firstLetter.characters.count + lastLetter.characters.count) % 26\n       \
    \     s += letterToCode(letter)\n            s[i] = letter\n            s[i] =\
    \ Character(UnicodeScalar(UnicodeScalar(code + 65).value).value)\n           \
    \ i += 1\n        }\n        return s.characters.prefix(1) + s.characters.dropLast()\n\
    \    }\n    return String(s.characters.map { letterToCode($0) })", '    return
    s.rotate()', "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let letterCount\
    \ = alphabet.count\n    let rotationCount = letterCount / 2\n    let rotationFactor\
    \ = 2.0\n\n    var str = [Character]()\n\n    for char in s {\n        str.append(char)\n\
    \    }\n\n    for index in 0..<str.count {\n        let c = str[index]\n     \
    \   str[index] = alphabet[Int(index * rotationFactor) % letterCount]\n    }\n\n\
    \    return String(str)", "    var out = \"\"\n    for c in s {\n        out +=\
    \ rotateAlphabet(getChar(c, alphabet))\n    }\n    return out", "\tlet alphabet\
    \ = s.characters.map { String($0) }\n\tlet alphabetIndex = alphabet.indices\n\t\
    var newAlphabet = String()\n\tvar newAlphabetIndex = 0\n\tfor i in 0..<alphabet.count\
    \ {\n\t\tlet currentChar = alphabet[alphabetIndex[i]]\n\t\tnewAlphabet.append(currentChar)\n\
    \t\tnewAlphabet.append(currentChar)\n\t\tnewAlphabetIndex += 2\n\t}\n\treturn\
    \ newAlphabet", "\tswitch len(s) {\n\tcase 0: return \"\"\n\tcase 1: return s[0]\
    \ + encrypt(s[1...])\n\tcase 2: return s[0] + encrypt(s[1...]+s[2...])\n\tcase\
    \ 3: return s[0] + encrypt(s[1...]+s[2...]+s[3...])\n\tdefault: return s[0] +\
    \ encrypt(s[1...]+s[2...]+s[3...]+s[4...])\n\t}", "\treturn crypt(s, alphabet[alphabet.index(s.first!)..<alphabet.index(s.last!)])",
  "\tvar i = 0\n\tvar n = 0\n\tvar out: String = s\n\twhile i < out.characters.count\
    \ {\n\t\tn = i % 2\n\t\tif n == 0 {\n\t\t\tout.append(alphabet.characters[Int(arc4random_uniform(UInt32(alphabet.characters.count)))])\n\
    \t\t} else {\n\t\t\tout.append(alphabet.characters[Int(arc4random_uniform(UInt32(alphabet.characters.count)))+2])\n\
    \t\t}\n\t\ti += 1\n\t}\n\treturn out", "    var alphabet = Array(s.characters)\n\
    \    var alphabetCopy = alphabet\n    for i in 0..<s.characters.count {\n    \
    \    alphabet[i] = alphabet[s.characters.count - i - 1]\n        alphabet[s.characters.count\
    \ - i - 1] = alphabet[i]\n    }\n    var alphabetCopy2 = alphabet\n    for i in\
    \  alphabetCopy {\n        if alphabetCopy.index(of: i) != alphabetCopy2.index(of:\
    \ i) {\n            let index = alphabetCopy.index(of: i)!\n            let index\
    \ = alphabetCopy2.index(of: i)!\n            alphabetCopy[index] = alphabetCopy2[index]\n\
    \            alphabetCopy2[index] = alphabetCopy[index]\n        }\n    }\n  \
    \  var resultString = \"\"\n    for i in 0..<s.characters.count {\n        let\
    \ index = alphabetCopy.index(of: s[i])!\n        resultString += alphabetCopy2[index]\n\
    \    }\n    return resultString", "  var r = \"\"\n  for char in s {\n    r +=\
    \ (char + shift(char))\n  }\n  return r", "    var l = len(s)\n    var w = make([]rune,\
    \ l)\n    var j = l - 1\n    \n    for i := 0; i < l; i++ {\n        w[i] = s[i]\n\
    \    }\n    for i := 0; i < l; i++ {\n        w[i] = w[i]\n        w[i+1] = w[i+1]\n\
    \        j--\n        w[j+1] = w[j]\n    }\n    var k = l\n    \n    var r string\
    \ = make([]rune, l)\n    for i := 0; i < l; i++ {\n        r[i] = s[k]\n     \
    \   k--\n    }\n    for i := 0; i < k; i++ {\n        r[i] = w[i]\n        r[i+1]\
    \ = w[i+1]\n        j--\n        r[j+1] = w[j]\n    }\n    \n    return r", " \
    \ var newS = []rune(s)\n  \n  for _ in 0..<s.characters.count {\n    var c1 =\
    \ Int(random(25))\n    var c2 = Int(random(25))\n    newS.append(s.characters[c1+c2])\n\
    \  }\n  \n  return string(newS)", "    var alphabet: Alphabet = [97 ... 122]\n\
    \    let alphabetSize = alphabet.count\n    var alphabetShift: Alphabet = [0 ...\
    \ alphabetSize - 1]\n    var index = 0\n    var cipherString = \"\"\n    for letter\
    \ in s {\n        if alphabetShift[index] >= alphabetSize {\n            index\
    \ = (index + 1) % alphabetSize\n        }\n        cipherString += alphabet[alphabetShift[index]]\n\
    \        alphabetShift[index] += 1\n    }\n    return cipherString", "    let\
    \ len = s.length\n    var c = \"\"\n    repeat {\n        let x = s.index(of:\
    \ c)\n        let y = s.index(of: s.characters.last!)\n        if x > 0 && y <\
    \ x + len {\n            c += s.characters.first!\n        } else {\n        \
    \    c += s.characters.last!\n        }\n    }\n    return c", "    if s == \"\
    \" {\n        return s\n    }\n    let alphabet = [\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ]\n    var rotatedAlphabet = [String]()\n    var index = 0\n    for letter in\
    \ alphabet {\n        if letter == \"a\" {\n            rotatedAlphabet.append(alphabet[index+1])\n\
    \            index += 1\n        } else {\n            rotatedAlphabet.append(letter)\n\
    \        }\n    }\n    let len = rotatedAlphabet.count\n    var resultString =\
    \ \"\"\n    var idx = 0\n    for letter in s {\n        if letter in rotatedAlphabet\
    \ {\n            resultString += alphabet[rotatedAlphabet.index(of: letter)+1]\n\
    \        } else {\n            resultString += letter\n        }\n        if idx\
    \ < len {\n            resultString += \" \"\n        } else {\n            resultString\
    \ += \"\\n\"\n        }\n        idx += 1\n    }\n    return resultString", " \
    \   // Rotate alphabet by 2 to make the alphabet shift down by two.\n    return\
    \ encrypt(s, alphabet.rotated(2))", "    guard s.count % 2 == 0 else {\n     \
    \   return \"\"\n    }\n    let alphabet = rotate(s.characters.map {\n       \
    \ Character($0)!\n    }, 1)\n    return alphabet.reduce(\"\") { $0 + String($1)\
    \ + String($2) }", "    let alphabet = rotate(alphabet.letters)\n    return s.fold(alphabet,\
    \ _shift)", "\tresult := \"\"\n\tcurrentPosition := 0\n\tcurrentRotation := 0\n\
    \trotation := make([]int, len(alphabet))\n\tfor _, letter := range alphabet {\n\
    \t\trotation[letter] = currentRotation\n\t\tcurrentRotation += 2\n\t}\n\tfor _,\
    \ letter := range s {\n\t\tcurrentPosition = letterToIndex[letter]\n\t\tresult\
    \ += shifts[rotation[currentPosition]]\n\t}\n\treturn result", "    if s == \"\
    \" {\n        return s\n    }\n\n    // \"abcdefghijklmnopqrstuvwxyz\"\n    let\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var out = [String]()\n\n    for\
    \ c in s.characters {\n        var pos = alphabet.index(c)!\n        var npos\
    \ = pos + 1\n        \n        while pos < alphabet.characters.count {\n     \
    \       let letter = alphabet[pos]\n            let next = alphabet[npos]\n  \
    \          \n            if letter == next {\n                out.append(letter)\n\
    \                pos += 1\n                npos += 1\n            } else if letter\
    \ == alphabet[npos - 1] {\n                out.append(letter)\n              \
    \  npos -= 1\n            } else {\n                out.append(letter)\n     \
    \           pos += 1\n                npos += 1\n            }\n        }\n  \
    \  }\n    return String(out)", "\tenc.init()\n\n\tr := []rune(s)\n\n\tvar i int\n\
    \n\tfor i = 0; i < len(r); i++ {\n\t\tr[i] = enc.encode(r[i])\n\t}\n\n\treturn\
    \ string(r)", "    var c = [String]()\n    for letter in s {\n        c.append(letter)\n\
    \    }\n    for i := 0; i < len(c); i++ {\n        c[i] = rotateLetter(c[i], 2)\n\
    \    }\n    return joinLetters(c)", "    var alphabet = [Character : [Character,\
    \ Character]](\n        a: [Character : [Character, Character]](),\n        b:\
    \ [Character : [Character, Character]](),\n        c: [Character : [Character,\
    \ Character]](),\n        d: [Character : [Character, Character]](),\n       \
    \ e: [Character : [Character, Character]](),\n        f: [Character : [Character,\
    \ Character]](),\n        g: [Character : [Character, Character]](),\n       \
    \ h: [Character : [Character, Character]](),\n        i: [Character : [Character,\
    \ Character]](),\n        j: [Character : [Character, Character]](),\n       \
    \ k: [Character : [Character, Character]](),\n        l: [Character : [Character,\
    \ Character]](),\n        m: [Character : [Character, Character]](),\n       \
    \ n: [Character : [Character, Character]](),\n        o: [Character : [Character,\
    \ Character]](),\n        p: [Character : [Character, Character]](),\n       \
    \ q: [Character : [Character, Character]](),\n        r: [Character : [Character,\
    \ Character]](),\n        s: [Character : [Character, Character]](),\n       \
    \ t: [Character : [Character, Character]](),\n        u: [Character : [Character,\
    \ Character]](),\n        v: [Character : [Character, Character]](),\n       \
    \ w: [Character : [Character, Character]](),\n        x: [Character : [Character,\
    \ Character]](),\n        y: [Character : [Character, Character]](),\n       \
    \ z: [Character : [Character, Character]](),\n        blank: [Character : [Character,\
    \ Character]](),\n    )\n    for c in s.characters {\n        alphabet[a]![c]\
    \ = c\n        alphabet[b]![c] = c\n        alphabet[c]![c] = c\n        alphabet[d]![c]\
    \ = c\n        alphabet[e]![c] = c\n        alphabet[f]![c] = c\n        alphabet[g]![c]\
    \ = c\n        alphabet[h]![c] = c\n        alphabet[i]![c] = c\n        alphabet[j]![c]\
    \ = c\n        alphabet[k]![c] = c\n        alphabet[l]![c] = c\n        alphabet[m]![c]\
    \ = c\n        alphabet[n]![c] = c\n        alphabet[o]![c] = c\n        alphabet[p]![c]\
    \ = c\n        alphabet[q]![c] = c\n        alphabet[r]![c] = c\n        alphabet[s]![c]\
    \ = c\n        alphabet[t]![c] = c\n        alphabet[u]![c] = c\n        alphabet[v]![c",
  "    \n    if let sArr = s.charArray {\n        var newArr = [Int](count: sArr.count,\
    \ repeatedValue: 0)\n        \n        // Get the size of the alphabet and loop\
    \ through \n        // the string and add the letters two places to the right.\n\
    \        for index in 0..<sArr.count {\n            let val = sArr[index]\n  \
    \          newArr[index] = val + 2\n        }\n        \n        // Rotate the\
    \ array to the left by two places.\n        var index = 0\n        var carry =\
    \ 0\n        for (index, val) in newArr.enumerated() {\n            let carryVal\
    \ = carry + val // val is now the carry value\n            \n            // If\
    \ we need to add one, add the one to carry and shift it down.\n            if\
    \ carryVal > 0 {\n                let newVal = carryVal - 2\n                newArr[index]\
    \ = newVal\n                carry = 0\n            } else {\n                //\
    \ Otherwise just add the carry value.\n                newArr[index] = carryVal\n\
    \                carry = val\n            }\n        }\n        \n        // Convert\
    \ back to string\n        return String(newArr)\n    }\n    \n    return \"\"",
  "    var s = s\n    var t = [String]()\n    for cs in s {\n        if cs < 'a' ||\
    \ cs > 'z' {\n            return \"\"\n        }\n        t += [cs.lowercaseString]\n\
    \    }\n    var i = 0\n    for x in t {\n        if i == 0 {\n            i +=\
    \ 1\n            continue\n        }\n        var y = [x]\n        for _ in 0..<i\
    \ {\n            if i > 0 {\n                y += [Character(t[i-1])]\n      \
    \      }\n        }\n        y += [Character(x.lowercaseString)]\n        t =\
    \ y\n    }\n    return t.joinWithSeparator(\"\")", "\tlet n = 26 // number of\
    \ letters in the alphabet\n\tlet alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\t\
    \n\t// create lookup table\n\tvar lut = [Character : [String]]()\n\tfor c in alphabet{\n\
    \t\tlet l = [c]\n\t\tlut[c] = l\n\t\tfor c in alphabet{\n\t\t\tl.append(c + c\
    \ + c)\n\t\t}\n\t}\n\t\n\t// go through each letter in the string\n\tvar s = s\n\
    \tvar e = s\n\t\n\tfor k in 0..<n {\n\t\t\n\t\te[0] = alphabet[(alphabet.index(e[0])\
    \ + k + n) % alphabet.count]\n\t\t\n\t\tvar p = 0\n\t\t\n\t\tfor i = 0; i<e.count-1{\n\
    \t\t\tif p.isEqualTo(lut[e[i]]) == false{\n\t\t\t\te = e.replacingOccurrences(of:\
    \ e[i], with: lut[e[i]][p])\n\t\t\t\tp = p + 1\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn\
    \ e", "    \n    var encryptedString = \"\"\n    var rotation = 0\n    var lastChar\
    \ = \"\"\n    \n    for _ in s.characters {\n        lastChar = lastChar + String(rotation)\n\
    \        \n        if (rotation > 26) {\n            rotation = rotation - 26\n\
    \        } else {\n            rotation = rotation + 2\n        }\n        \n\
    \        encryptedString = encryptedString + lastChar\n    }\n    \n    return\
    \ encryptedString", '    return Strings.rotate(s, 2, 2)', "    defer { puts(s)\
    \ }\n    var result: String = \"\"\n    for c in s.characters {\n        result\
    \ = c + String(alphabet.rot13(c))\n    }\n    return result", '    return s.rotate().rotate().rotate()',
  "    if s.length%2 == 1 {\n        fmt.Println(s)\n        panic(\"encrypted string\
    \ must have an even number of characters\")\n    }\n    var t = \"\"\n    for\
    \ i := 0; i < len(s); i++ {\n        if i > 0 && s[i-1] == 'z' {\n           \
    \ t = t.append(\"z\")\n        } else {\n            t = t.append(alphabet.lookup(s[i]))\n\
    \        }\n    }\n    return t", "    var r = \"\"\n    var a = alphabet.characters\n\
    \n    for i in s {\n        r += (a[(s.characters.indexOf(i) + a.count - 1) %\
    \ a.count])\n    }\n    return r", "\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\n\
    \trs := make([]rune, len(s)*2)\n\ta := make([]rune, bigLetters)\n\tb := make([]rune,\
    \ len(s)*2)\n\tc := make([]rune, len(s)*2)\n\tfor i := range rs {\n\t\trs[i*2]\
    \ = rune(i)\n\t\trs[i*2+1] = rune(i)\n\t\ta[i] = 'a' + i\n\t}\n\n\tm := len(s)\n\
    \tfor i := 0; i < m; i++ {\n\t\tb[i] = rune(i)\n\t}\n\tb[m*2] = rune(m)\n\tb[m*2+1]\
    \ = rune(m)\n\n\tk := len(b)\n\tj := 0\n\tfor i := range rs {\n\t\trs[i*2] = b[k]\n\
    \t\trs[i*2+1] = b[k+1]\n\t\tb[k] ^= a[j]\n\t\tb[k+1] ^= a[j+1]\n\t\tj += 1\n\t\
    \tif j >= len(a) {\n\t\t\tj = 0\n\t\t}\n\t}\n\ts := string(rs)\n\n\treturn s[len(s):]",
  "    let result = (s.uppercaseString.characters).map({\n        switch $0 {\n  \
    \      case $0:\n            return Character($1)\n        default:\n        \
    \    return Character($0)\n        }\n    })\n    .sorted()\n    .map{Character($0)}\n\
    \    .joinWithSeparator(\"\")\n    .characters.map{Character($0)}\n    return\
    \ result.joinWithSeparator(\"\")", '    cipherText(s)', "    if s != \"\" {\n\
    \        var t = s[0]\n        for c in s[1:] {\n            if c == 'z' {\n \
    \               c = 'a'\n            } else if c == 'a' {\n                c =\
    \ 'z'\n            }\n            t = t + c\n        }\n        if t == \"z\"\
    \ {\n            t = \"a\"\n        } else if t == \"a\" {\n            t = \"\
    z\"\n        }\n    }\n    return t", "    var result = \"\"\n    for letter in\
    \ s {\n        result = append(append(result, reverse(letter)), result)\n    }\n\
    \    return result", "\tlet alphabet = Array(s)\n\tlet newAlphabet = Array(alphabet.prefix(1))\n\
    \tnewAlphabet.append(alphabet.suffix(1))\n\tlet newAlphabet2 = Array(newAlphabet.prefix(2))\n\
    \tnewAlphabet2.append(newAlphabet.suffix(2))\n\tnewAlphabet2.append(newAlphabet)\n\
    \treturn String(newAlphabet2.flatMap{ $0.join() })", '    return rotate(rotate(s,
    alphabet.count-1), alphabet.count-2)', "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let length = alphabet.count\n    let news = StringBuilder(s)\n    var i\
    \ = 0\n    for c in news.characters {\n        var offset = alphabet.index(alphabet,\
    \ from: c)\n        offset = offset + 2\n        offset = offset % length\n  \
    \      news.append(alphabet[offset])\n    }\n    return news.string", '    return
    alphabet[s].rotateLeft()', "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    return s.map { alphabet.index(of: $0)! + 2 }", "    let alphabet: [Character.Element]\
    \ = [Character(s.characters[s.startIndex]!), Character(s.characters[s.endIndex]!)]\n\
    \    let shifted = alphabet\n    shifted.append(Character(s.characters[s.endIndex-1]))\n\
    \    shifted.append(Character(s.characters[s.startIndex+1]))\n\n    let res =\
    \ s.characters.map { (char) -> Character in\n        let index = alphabet.indexOf(char.unicodeScalars.first!)!\n\
    \        let value = alphabet[index]\n        return Character(value)\n    }.joined()\n\
    \n    return res", "    let alphabet = alphabet\n    return s.map {\n        alphabet.index(of:\
    \ $0) ?? alphabet.index(of: String($0))\n    }.joined(separator: \"\")", "\treturn\
    \ rotate(s, alphabet, 2, 0)", "    var result: String = String()\n\n    for c\
    \ in s {\n        let alpha = String(c) - \"a\"\n        result += \"a\" + (alpha\
    \ / 2)\n        result += \"b\" + (alpha / 2)\n        result += \"c\" + (alpha\
    \ / 2)\n        result += \"d\" + (alpha / 2)\n        result += \"e\" + (alpha\
    \ / 2)\n        result += \"f\" + (alpha / 2)\n        result += \"g\" + (alpha\
    \ / 2)\n        result += \"h\" + (alpha / 2)\n    }\n\n    return result", " \
    \   var alphabet = [Character]()\n    alphabet.append(Character(s.characters.first!))\n\
    \    for i in s.characters[1..] {\n        alphabet.append(Character(alphabet.last!))\n\
    \        alphabet.append(Character(alphabet.last!))\n    }\n    alphabet.append(Character(alphabet.last!))\n\
    \    return String.fromCString(strangeROT13(s))", "\tresult := []rune(s)\n\trotate(result)\n\
    \treturn String(result)", "\tvar result [String] = [\"a\",\"b\",\"c\",\"d\",\"\
    e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"\
    r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\tvar index [String] = [\"\
    a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"\
    n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\
    \tvar temp [String] = [String]()\n\n\tvar shift [Int] = [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,",
  '    return s.rotateBy(2)', "\treturn s.rotate().lower()", "  var s = s\n  for index\
    \ in 0..<s.length {\n    switch s.characters[index] {\n    case 'a':\n      s\
    \ += 'n'\n    case 'b':\n      s += 'o'\n    case 'c':\n      s += 't'\n    case\
    \ 'd':\n      s += 'p'\n    case 'e':\n      s += 'g'\n    case 'f':\n      s\
    \ += 'h'\n    case 'g':\n      s += 'j'\n    case 'h':\n      s += 'k'\n    case\
    \ 'i':\n      s += 'i'\n    case 'j':\n      s += 'x'\n    case 'k':\n      s\
    \ += 'l'\n    case 'l':\n      s += 'n'\n    case 'm':\n      s += 'q'\n    case\
    \ 'n':\n      s += 'q'\n    case 'o':\n      s += 'r'\n    case 'p':\n      s\
    \ += 'z'\n    case 'q':\n      s += 'y'\n    case 'r':\n      s += 'z'\n    case\
    \ 's':\n      s += 'z'\n    case 't':\n      s += 'u'\n    case 'u':\n      s\
    \ += 'z'\n    case 'v':\n      s += 'z'\n    case 'w':\n      s += 'z'\n    case\
    \ 'x':\n      s += 'z'\n    case 'y':\n      s += 'z'\n    case 'z':\n      s\
    \ += 'z'\n    }\n  }\n  return s", '    return encryptString(s, cipherAlphabet(s))',
  '    return s.rotations(&Alphabet.rotation)', "\ts = String(s.characters.map { $0\
    \ ^ 2 })\n\ts = String(s.characters.map { $0 - 2 })\n\treturn s", "\t\n\tlet alphabet\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"\
    G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"\
    R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n\tvar cipher = \"\
    \"\n\tfor i in s.characters {\n\t\tlet index = alphabet.index(of: i)!\n\t\tcipher\
    \ += alphabet[index + 1] + alphabet[index + 2]\n\t}\n\treturn cipher", "    var\
    \ sb = \"\"\n    for c in s {\n        var tmp = alphabet.index(c)\n        if\
    \ tmp > 0 {\n            tmp = tmp + 2\n        } else {\n            tmp = tmp\
    \ - 2\n        }\n        sb += alphabet[tmp]\n    }\n    return sb", "    switch\
    \ s {\n    case \"q\":\n        return \"m\"\n    case \"e\":\n        return\
    \ \"t\"\n    case \"r\":\n        return \"s\"\n    case \"v\":\n        return\
    \ \"v\"\n    case \"m\":\n        return \"i\"\n    case \"t\":\n        return\
    \ \"x\"\n    case \"w\":\n        return \"w\"\n    case \"g\":\n        return\
    \ \"a\"\n    case \"x\":\n        return \"g\"\n    case \"h\":\n        return\
    \ \"j\"\n    case \"k\":\n        return \"f\"\n    case \"l\":\n        return\
    \ \"d\"\n    case \"o\":\n        return \"b\"\n    case \"j\":\n        return\
    \ \"hk\"\n    case \"n\":\n        return \"n\"\n    case \"s\":\n        return\
    \ \"p\"\n    case \"i\":\n        return \"l\"\n    case \"p\":\n        return\
    \ \"o\"\n    case \"v\":\n        return \"rs\"\n    case \"b\":\n        return\
    \ \"v\"\n    case \"o\":\n        return \"k\"\n    case \"d\":\n        return\
    \ \"s\"\n    case \"l\":\n        return \"m\"\n    case \"f\":\n        return\
    \ \"t\"\n    case \"k\":\n        return \"x\"\n    case \"j\":\n        return\
    \ \"e\"\n    case \"x\":\n        return \"kj\"\n    case \"s\":\n        return\
    \ \"ks\"\n    case \"w\":\n        return \"w\"\n    case \"x\":\n        return\
    \ \"rw\"\n    case \"h\":\n        return \"v\"\n    case \"l\":\n        return\
    \ \"v\"\n    case \"n\":\n        return \"r\"\n    case \"i\":\n        return\
    \ \"r\"\n    case \"s\":\n        return \"k\"\n    case \"x\":\n        return\
    \ \"y\"\n    case \"g\":\n        return \"h\"\n    case \"y\":\n        return\
    \ \"b\"\n    case \"r\":\n        return \"z\"\n    case \"v\":\n        return\
    \ \"m\"\n    case \"b\":\n        return \"z\"\n    case \"j\":\n        return\
    \ \"h\"\n    case \"o\":\n        return \"w\"\n    case \"w\":\n        return\
    \ \"s\"\n    case \"a\":\n        return \"x\"\n    case \"z\":\n        return\
    \ \"v\"\n    case \"m\":\n        return \"b\"\n    case \"r\":\n        return\
    \ \"y\"\n    case \"e\":\n        return \"m\"\n    case \"t\":\n        return\
    \ \"s\"\n    case \"p\":\n        return \"b\"\n    case \"l\":\n        return\
    \ \"x\"\n    case \"i\":\n        return \"r\"\n    default:\n        return \"\
    q\"\n    }", "    if s == \"\" {\n        return s\n    }\n    \n    var res =\
    \ \"\"\n    \n    for i := 0; i < len(s); i++ {\n        let x = s[i]\n      \
    \  if x >= 'a' && x <= 'z' {\n            res += string(x - 97 + 2)\n        }\
    \ else {\n            res += string(x+2)\n        }\n    }\n    return res", " \
    \   guard s.characters.count > 0 else {\n        return \"\"\n    }\n    var result\
    \ = \"\"\n    \n    for char in s {\n        guard let index = alphabet.index(of:\
    \ char) else {\n            result += char\n            continue\n        }\n\
    \        \n        let shiftAmount = alphabet.count - index - 2\n        result\
    \ += alphabet[index] + alphabet[index + shiftAmount]\n    }\n    \n    return\
    \ result", "    var rotation = { a, b -> String in\n        var s = \"\"\n   \
    \     var index = 0\n        while (index < a.count) {\n            s += String(a.characters.dropFirst(index).first!)\
    \ + String(b.characters.dropFirst(index).first!)\n            index += 1\n   \
    \     }\n        return s\n    }\n    return rotation(\"abcdefghijklmnopqrstuvwxyz\"\
    .characters, \"zyxwvutsrqponmlkjihgfedcba\".characters)(s)", "\t\n\t// Convert\
    \ string into char array.\n\tchars := s.ToCharArray()\n\t\n\t// Rotate each char\
    \ in string by two and add one to each index\n\t// to shift the letters down by\
    \ two multiplied to two places.\n\tvar newString = \"\"\n\tfor i, val := range\
    \ chars {\n\t\tnewString += stringRotate(string(val) + string(chars[i]), 2)\n\t\
    }\n\treturn newString", "    var res = \"\"\n    var l = len(s)\n    for _ in\
    \ 0..l {\n        res += s[len(s)-1] + s[len(s)-2] + s[len(s)-3] + s[len(s)-4]\n\
    \    }\n    return res", "    if s == \"\" {\n        return \"\"\n    }\n   \
    \ var result = [Character]()\n    for c in s {\n        result.append(Character((c\
    \ << 1) | 1))\n    }\n    return String(result)", "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    var encrypted = \"\"\n    for letter in s {\n        if alphabet.characters.contains(letter)\
    \ {\n            var index = 0\n            while index < alphabet.characters.count\
    \ && alphabet.characters[index] != letter\n            {\n                index\
    \ += 1\n            }\n            let rotate = index + 2\n            encrypted\
    \ += alphabet.characters.rotate(rotate).last\n        } else {\n            encrypted\
    \ += letter\n        }\n    }\n    return encrypted", "\treturn s.rotateByCharacter(1)",
  "    var result = \"\"\n    var shiftMultiplier = -1\n\n    for i := 0; i < len(s);\
    \ i++ {\n        var letter = s[i]\n\n        var index = (alphabet.index(letter)\
    \ + shiftMultiplier) % 26\n        result += alphabet[index] + letter\n      \
    \  shiftMultiplier = -shiftMultiplier\n    }\n\n    return result", "\ts := s[1...]\
    \ + s[0]\n\ts = s[2...] + s[1]\n\ts = s[4...] + s[2]\n\ts = s[6...] + s[3]\n\t\
    return s", "    if s.isEmpty {\n        return s\n    }\n    \n    // Create an\
    \ array that holds all of the letters in the alphabet.\n    // Use a for loop\
    \ to go through each character in s and append \n    // each letter to the array.\n\
    \    var alphabet: [Character]\n    for letter in alphabets {\n        alphabet.append(letter)\n\
    \    }\n    \n    // Create an array that holds all of the letters in the string.\n\
    \    // Use a for loop to go through each character in s and append \n    // each\
    \ letter to the array.\n    var string: [Character]\n    for letter in s.characters\
    \ {\n        string.append(letter)\n    }\n    \n    // Start looping through\
    \ the string array and making sure the \n    // character is less than or equal\
    \ to the length of the \n    // alphabet.\n    for i in 0..<string.count {\n \
    \       if string[i] <= alphabet.count {\n            // Get the index of the\
    \ character in the alphabet array \n            // that is equal to the character\
    \ in the string.\n            var index: Int = alphabet[string[i]]\n         \
    \   // Append the index from the alphabet to the end of the string.\n        \
    \    string.append(index)\n        }\n    }\n    return String(string)", "   \
    \ \n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\".characters)\n    \n\
    \    var result = \"\"\n    var shiftDown = False\n    \n    for character in\
    \ s {\n        if character == \"z\" {\n            if shiftDown == true {\n \
    \               shiftDown = false\n                result += alphabet[0]\n   \
    \         } else {\n                result += alphabet[1]\n                shiftDown\
    \ = true\n            }\n        } else {\n            if shiftDown == true {\n\
    \                result += alphabet[alphabet.index(of: character)!]\n        \
    \    } else {\n                result += alphabet[alphabet.index(of: character)!\
    \ + 2]\n                shiftDown = true\n            }\n        }\n    }\n  \
    \  \n    return result", "\tif s.isEmpty() {\n\t\treturn \"\"\n\t}\n\t\n\tvar\
    \ i = 0\n\t\n\tvar result = \"\"\n\tfor ; i < len(s); i++ {\n\t\tresult = result\
    \ + alphabet[(s.charCodeAt(i)-97 + rot) % (alphabet.count-1)]\n\t}\n\t\n\treturn\
    \ result", "\trs := \"\"\n\tfor i := len(s) - 1; i >= 0; i -= 2 {\n\t\trs += stringToChar(s[i\
    \ : i+1])\n\t}\n\treturn rs", "    var b = rotator(s.characters[s.characters.count\
    \ - 1], 2)\n    for _ in s.characters {\n        b = rotator(b, 2)\n    }\n  \
    \  return String(b)", "    var n = s.count\n    var k = s.count/2\n    var r =\
    \ \"\"\n    while n > 0 {\n        r = rotate(s, k, r).substring(0,k) + r + rotate(s,\
    \ k+2, r).substring(k,k+k+2)\n        n -= 1\n        k += 2\n    }\n    return\
    \ r", "    if s.isEmpty {\n        return s\n    }\n\n    let mut encrypt = rotateAsciiArr(s.characters().map(|c|\
    \ c ^ 0x20).collect::<String>())\n    let mut reverseEncrypt = rotateAsciiArr(encrypt.chars().map(|c|\
    \ c ^ 0x20).collect::<String>())\n\n    return reverseEncrypt.append(s).to_string();",
  "    let alphabet = makeAlphabet()\n    let result = \"\"\n    var offset = 0\n\
    \    for letter in s {\n        offset += alphabet.distance(letter)\n        let\
    \ i = alphabet.indexOf(letter)\n        let newLetter = alphabet[alphabet.index(alphabet.startIndex,\
    \ offset..<alphabet.endIndex) % (alphabet.endIndex - alphabet.startIndex)]\n \
    \       result += newLetter\n        offset = alphabet.distance(letter)\n    }\n\
    \    return result", '    return ""', "    var c = \"\"\n    for letter in s {\n\
    \        switch letter {\n        case \"a\":\n            c += \"b\"\n      \
    \  case \"b\":\n            c += \"a\"\n        case \"c\":\n            c +=\
    \ \"d\"\n        case \"d\":\n            c += \"c\"\n        case \"e\":\n  \
    \          c += \"f\"\n        case \"f\":\n            c += \"e\"\n        case\
    \ \"g\":\n            c += \"h\"\n        case \"h\":\n            c += \"g\"\n\
    \        case \"i\":\n            c += \"j\"\n        case \"j\":\n          \
    \  c += \"i\"\n        case \"k\":\n            c += \"l\"\n        case \"l\"\
    :\n            c += \"k\"\n        case \"m\":\n            c += \"n\"\n     \
    \   case \"n\":\n            c += \"m\"\n        case \"o\":\n            c +=\
    \ \"p\"\n        case \"p\":\n            c += \"o\"\n        case \"q\":\n  \
    \          c += \"q\"\n        case \"r\":\n            c += \"s\"\n        case\
    \ \"s\":\n            c += \"r\"\n        case \"t\":\n            c += \"v\"\n\
    \        case \"v\":\n            c += \"t\"\n        case \"w\":\n          \
    \  c += \"x\"\n        case \"x\":\n            c += \"w\"\n        case \"y\"\
    :\n            c += \"z\"\n        case \"z\":\n            c += \"y\"\n     \
    \   default:\n            c += letter\n        }\n    }\n    return c", "    if\
    \ let n = s.count {\n        return encrypt(s: s, n: n)\n    } else {\n      \
    \  return \"\"\n    }", '    return encrypt(s, alphabet)', '    return encrypt(s,
    alphabet.rotate())', '    return encrypt(s: s, alphabet: alphabet)', "\tresult\
    \ = \"\"\n\tfor i in 0..<s.count {\n\t\tresult += encrypt(s[i] - 97)\n\t}\n\t\
    return result", "    // Rotate the alphabet by two places for each char\n    var\
    \ r = s.characters\n    r.advanced(by: 2).forEach { $0.advanced(by: 2) }\n   \
    \ return String(r)", '    return s.rotateBy(26)', "\talphabet := make([]rune,\
    \ 26)\n\tfor i := 0; i < len(alphabet); i++ {\n\t\talphabet[i] = 'a'\n\t}\n\t\
    for i := 0; i < len(s); i++ {\n\t\talphabet[i] = 'z' - 2*(i%26)\n\t}\n\tvar result\
    \ []rune\n\tfor _, r := range s {\n\t\tresult = append(result, alphabet[r])\n\t\
    }\n\treturn string(result)", "    \n    if s.isEmpty {\n        return s\n   \
    \ }\n    \n    letters := make([]rune, len(s))\n    for i := range letters {\n\
    \        letters[i] = s[i]\n    }\n    letters[len(letters)-1] = letters[len(letters)-1]\
    \ + 2\n    letters[len(letters)-2] = letters[len(letters)-2] + 2\n    \n    return\
    \ String(letters)", "\tc := make([]rune, len(s))\n\tfor i := range s {\n\t\tc[i]\
    \ = s[len(s)-i-1]\n\t}\n\tp = rcipher.Encrypt(c, alphabet.Rotate(alphabet.GetEncryptAlphabet()))\n\
    \ts = make([]rune, len(s))\n\tfor i := range s {\n\t\ts[i] = c[p[i]]\n\t}\n\t\
    return string(s)", "\treturn s.rotateRight(2)", "    cipherString := \"\"\n  \
    \  for i in s { cipherString += encryptChar(cipherString.lastIndex, i); }\n  \
    \  return cipherString", "    return s.withCStringNoCopy(nil, func(s *uint8, a,\
    \ b uintptr) int {\n        var slen, schar\n        slen = C.strlen(s)\n    \
    \    schar = C.CString(s)\n        for i := 0; i < slen; i++ {\n            a\
    \ += int(schar[i]) + 2\n            a %= 26\n            b += int(schar[slen-i-1])\
    \ - int(schar[i]) + 2\n            b %= 26\n        }\n        return C.int(a\
    \ % 26) + C.int(b % 26)\n    })", "    if s == \"\" {\n        return \"\"\n \
    \   }\n\n    count := 0\n    var result String = \"\"\n    \n    for i in s {\n\
    \        result += \"\\(c[i])\"\n        count += 1\n\n        if count == 2 {\n\
    \            count = 0\n            c[count] = c[0]\n            c[count+1] =\
    \ c[1]\n        }\n    }\n\n    return result", '    return rotate(s, 0, 2)',
  "    var result = \"\"\n    for c in s {\n        result += \"abcdefghijklmnopqrstuvwxyz\"\
    .charAt((c - 'a' + 1) >> 1) + \"abcdefghijklmnopqrstuvwxyz\".charAt((c - 'a' +\
    \ 1) & 1)\n    }\n    return result", "    return s.chars().map(rotate).fold(\"\
    \") {\n        String($0)\n    }", "\treturn s.chars().flatMap(rotate).joinWithSeparator(\"\
    \")", "    if let b = try? encode(s) {\n        return try! encode(b).map({ $0.rot13()\
    \ })\n    }\n    throw CryptoError.decryptError()", "    var result = \"\"\n \
    \   var i = 0\n    for x in s {\n        result += alphabet.charAt((alphabet.indexOf(x)\
    \ + i + 2) % alphabet.length)\n        i++\n    }\n    return result", "    var\
    \ rotation = ROTATIONS[s.characters.count]\n    var index = 0\n    return \"\"\
    \n\n    // Rotate each character in the string and add it to the output\n    //\
    \ string\n    for char in s.characters {\n        if index == 0 {\n          \
    \  output = char + output\n            index++\n        } else {\n           \
    \ output += char + output\n        }\n    }\n\n    // Rotate each character in\
    \ the output string\n    for char in output.characters {\n        if char == \"\
    \ \" {\n            output = rotation(output)\n        } else {\n            output\
    \ += char\n        }\n    }\n\n    return output", '    return rotate(s, alphabet,
    false, 2)', "    let length = s.count\n    let result = String()\n    for i in\
    \ 0..<length {\n        let index = String(i).characters.first!\n        let c\
    \ = chars.firstIndex(of: index)!\n        result.appending(chars[c])\n       \
    \ result.appending(chars[c + 1])\n        result.appending(chars[c + 2])\n   \
    \     result.appending(chars[c + 3])\n    }\n    return result", "\tvar cipherText\
    \ = s\n\tfor i := 0; i < len(cipherText); i += 2 {\n\t\tcipherText = append(cipherText,\
    \ cipherText[i+1])\n\t}\n\treturn string(cipherText)", "    var result = \"\"\n\
    \    for c in s {\n        let index = alphabet.index(of: c)!\n        let newIndex\
    \ = (index + 2) % alphabet.count\n        result += alphabet[newIndex]\n    }\n\
    \    return result", "    \n    if s == \"\" {\n        return s\n    }\n    \n\
    \    var alphabet = [Character]()\n    for c in s.unicodeScalars {\n        alphabet.append(c)\n\
    \    }\n    \n    // Rotate each letter in alphabet two places to the right.\n\
    \    var result = \"\"\n    for letter in alphabet {\n        var index = alphabet.indexOf(letter)\n\
    \        index += 2\n        index = index % alphabet.count\n        result +=\
    \ alphabet[index]\n    }\n    \n    return result", "  var i = 0\n  for ch in\
    \ s {\n    i = i * 26 + ch.ordinal()\n  }\n  var ret = \"\"\n  for ch in s {\n\
    \    ret += alphabet.stringAtIndex(i % 26)\n    i /= 26\n  }\n  return ret", "\t\
    var c = 0\n\tvar alphabet = Array(s.characters)\n\tfor i in 0 ..< alphabet.count\
    \ {\n\t\tif alphabet[i] == ' ' {\n\t\t\talphabet.removeAtIndex(i - 1)\n\t\t\t\
    alphabet.removeAtIndex(i)\n\t\t\talphabet = alphabet.sortInPlace()\n\t\t\talphabet\
    \ = alphabet.map(String.init)\n\t\t\tbreak\n\t\t}\n\t\tc += ((i + 2) * 2)\n\t\
    }\n\tfor i in 0 ..< alphabet.count {\n\t\talphabet[i] = alphabet[c] + alphabet[i]\n\
    \t}\n\talphabet = alphabet.sortInPlace()\n\talphabet = alphabet.map(String.init)\n\
    \tvar i = 0\n\tvar resultString = String()\n\tfor char in s {\n\t\tif i < alphabet.count\
    \ {\n\t\t\tresultString.appendString(alphabet[i])\n\t\t\ti += 1\n\t\t} else if\
    \ i == alphabet.count {\n\t\t\ti = 0\n\t\t\tresultString.appendString(alphabet[i])\n\
    \t\t}\n\t}\n\treturn resultString", '    return alphabet.rotate(s.chars().map{Character($0)})',
  "    let alphabet = String(s.characters.reversed())\n    let newAlphabet = alphabet.chars().map\
    \ {\n        charArray[$0] + charArray[$1] * 2\n    }.joined()\n    return newAlphabet",
  "\tvar ret String = \"\"\n\tfor i := 0; i < len(s); i++ {\n\t\tif i >= len(alphabet)-1\
    \ {\n\t\t\tbreak\n\t\t}\n\t\tret += alphabet[alphabet.index(alphabet.startIndex,\
    \ i)+2] + alphabet[i]\n\t}\n\treturn ret", "    var r = \"\"\n    for i in s.characters\
    \ {\n        var c = i\n        c = c - 'a' // convert to int to shift by 2\n\
    \        c = c + 2\n        c = c - 'a' // convert to int to shift by 2\n    \
    \    r = r + alphabet[c]\n    }\n    return r", "  let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  let n = alphabet.count\n\n  var encrypted: [Int] = []\n  for b in s.characters\
    \ {\n    let index = (alphabet.characters.index(of: b) + n) % n\n    encrypted.append(index)\n\
    \  }\n\n  return String(encrypted)", "\tlet letters = Array(s.characters)\n\t\
    let ciphers = Array(Alphabet[letters.map({ $0 })])\n\treturn String(ciphers)",
  "    var alphabet = [Character]()\n    alphabet.insert(contentsOf: Array(\"a\",\
    \ \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"))\n    alphabet.insert(contentsOf: Array(\"B\", \"C\", \"\
    D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"\
    O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"\
    Z\"))\n    alphabet.insert(contentsOf: Array(\"a\", \"b\", \"c\", \"d\", \"e\"\
    , \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"))\n   \
    \ alphabet.insert(contentsOf: Array(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\",\
    \ \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\"\
    , \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"))\n    alphabet.insert(contentsOf:\
    \ Array(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\
    \ \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"))\n    alphabet.insert(contentsOf: Array(\"\
    0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"))\n    alphabet.insert(contentsOf:\
    \ Array(\"!\", \"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"*\", \"(\", \")\"))\n\
    \    alphabet.insert(contentsOf: Array(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"\
    , \"6\", \"7\", \"8\", \"9\"))\n    alphabet.insert(contentsOf: Array(\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"))\n    alphabet.insert(contentsOf: Array(\"A\", \"B\", \"C\"\
    , \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\"\
    , \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\"\
    , \"Z\"))\n    alphabet.insert(contentsOf: Array(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t", '    return s.rotate(s.count(), by: 2).rotate(s.count(),
    by: 4)', '    return encrypt2(s, s.characters)', "    var t = \"\"\n    for i\
    \ := 0; i < len(s); i++ {\n        t += alphabet.index(s[i]) << (i * 2)\n    }\n\
    \    return t", '    return rotate(s, false)', "\tlet alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tvar c = \"\"\n\tfor i in s.characters.reverse() {\n\t\tc += alpha[(alpha.index(of:\
    \ i)! + alpha.index(of: i)!) % 26]\n\t}\n\treturn c", "    var rs = \"\"\n   \
    \ var i = 0\n    for _, b in s.bytes() {\n        // Find out the index of the\
    \ rotated character\n        r := (i + b - 2) % len(Alphabet)\n        rs = String.fromCharCode(r)\
    \ + rs\n        i += 1\n    }\n    return rs", "  let r = makeAlphabetRotation(Alphabet.uppercase,\
    \ 2)\n  return s.map{r[it]}", "    if s == \"\" {\n        return \"\"\n    }\n\
    \n    var result = \"\"\n    for idx, letter := range s {\n        var newLetter\
    \ = chr(letter + ALPHABET[(idx+ALPHABET_ROTATION)%len(ALPHABET)])\n        result\
    \ += newLetter\n    }\n\n    return result", "\ts = \"\" + s + \"\"\n\t\n\trotatedAlphabet\
    \ := rotate(s)\n\t\n\treturn strings.Map(func(c rune) rune {\n\t\ti := rotatedAlphabet.indexOf(c)\n\
    \t\treturn rotatedAlphabet[(i + 2) % len(rotatedAlphabet)]\n\t}, s)", "    var\
    \ alphabet: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var result: String\
    \ = s\n    for i in s.characters {\n        result[i] = alphabet[(result[i] -\
    \ 'a') + 2]\n    }\n    return result", "\treturn encrypt([]rune(s), \"\", \"\"\
    , s.Len(), 0)", "    let rec = Array(s.characters)\n    var alphabet = [Character\
    \ : [Character]](repeating: [Character : [Character]], count: 256)\n    for c\
    \ in alphabet {\n        for r in rec {\n            c[r] = r\n        }\n   \
    \ }\n    \n    var i = alphabet.count\n    var j = 0\n    \n    var result: String\
    \ = \"\"\n    for c in rec {\n        if i == 0 {\n            if alphabet[j][c.0]\
    \ != 0 {\n                i = i + 1\n                j = j + 1\n            }\n\
    \        } else {\n            if alphabet[j][c.0] != 0 {\n                if\
    \ alphabet[j-1][c.0] == 0 {\n                    alphabet[j-1][c.0] = alphabet[j][c.0]\n\
    \                    alphabet[j][c.0] = 0\n                    i = i - 1\n   \
    \                 j = j - 1\n                }\n                \n           \
    \ }\n        }\n        result = result + c.0\n    }\n    return result", "  \
    \  var result = \"\"\n\n    for letter in s.characters {\n        if letter ==\
    \ \"a\" {\n            result.append(rotateRight(letter, \"a\"))\n        } else\
    \ if letter == \"b\" {\n            result.append(rotateRight(letter, \"b\"))\n\
    \        } else if letter == \"c\" {\n            result.append(rotateRight(letter,\
    \ \"c\"))\n        } else if letter == \"d\" {\n            result.append(rotateRight(letter,\
    \ \"d\"))\n        } else if letter == \"e\" {\n            result.append(rotateRight(letter,\
    \ \"e\"))\n        } else if letter == \"f\" {\n            result.append(rotateRight(letter,\
    \ \"f\"))\n        } else if letter == \"g\" {\n            result.append(rotateRight(letter,\
    \ \"g\"))\n        } else if letter == \"h\" {\n            result.append(rotateRight(letter,\
    \ \"h\"))\n        } else if letter == \"i\" {\n            result.append(rotateRight(letter,\
    \ \"i\"))\n        } else if letter == \"j\" {\n            result.append(rotateRight(letter,\
    \ \"j\"))\n        } else if letter == \"k\" {\n            result.append(rotateRight(letter,\
    \ \"k\"))\n        } else if letter == \"l\" {\n            result.append(rotateRight(letter,\
    \ \"l\"))\n        } else if letter == \"m\" {\n            result.append(rotateRight(letter,\
    \ \"m\"))\n        } else if letter == \"n\" {\n            result.append(rotateRight(letter,\
    \ \"n\"))\n        } else if letter == \"o\" {\n            result.append(rotateRight(letter,\
    \ \"o\"))\n        } else if letter == \"p\" {\n            result.append(rotateRight(letter,\
    \ \"p\"))\n        } else if letter == \"q\" {\n            result.append(rotateRight(letter,\
    \ \"q\"))\n        } else if letter == \"r\" {\n            result.append(rotateRight(letter,\
    \ \"r\"))\n        } else if letter == \"s\" {\n            result.append(rotateRight(letter,\
    \ \"s\"))\n        } else if letter == \"t\" {\n            result.append(rotateRight(letter,\
    \ \"t\"))\n        } else if letter == \"u\" {\n            result.append(rotateRight(letter,\
    \ \"u\"))\n        } else if letter == \"v\" {\n            result.append(rotateRight(letter,\
    \ \"v\"))\n        } else if letter == \"w\" {\n            result.append(rotateRight(letter,\
    \ \"w\"))\n        } else if letter == \"x\" {\n            result.append(rotateRight(letter,\
    \ \"x\"))\n        } else if letter == \"y\" {\n            result.append(rotateRight(letter,\
    \ \"y\"))\n        } else if letter == \"z\" {\n            result.append(rotateRight(letter,\
    \ \"z\"))\n        }\n    }\n\n    return result", "    var c = [Character]()\n\
    \    \n    for i in s {\n        if i == ' ' {\n            continue\n       \
    \ }\n        \n        if i < 'a' || i > 'z' {\n            c.append(i)\n    \
    \        continue\n        }\n        \n        if i == ('a' || 'b' || 'c' ||\
    \ 'd' || 'e' || 'f' || 'g' || 'h' || 'i' || 'j' || 'k' || 'l' || 'm' || 'n' ||\
    \ 'o' || 'p' || 'q' || 'r' || 's' || 't' || 'u' || 'v' || 'w' || 'x' || 'y' ||\
    \ 'z') {\n            if i == ('a' || 'b' || 'c' || 'd' || 'e' || 'f' || 'g' ||\
    \ 'h' || 'i' || 'j' || 'k' || 'l' || 'm' || 'n' || 'o' || 'p' || 'q' || 'r' ||\
    \ 's' || 't' || 'u' || 'v' || 'w' || 'x' || 'y' || 'z') {\n                i =\
    \ i - 'z' + 'a'\n            } else {\n                i = i - 'z' + 'a'\n   \
    \         }\n        }\n        \n        if i == ('a' || 'b' || 'c' || 'd' ||\
    \ 'e' || 'f' || 'g' || 'h' || 'i' || 'j' || 'k' || 'l' || 'm' || 'n' || 'o' ||\
    \ 'p' || 'q' || 'r' || 's' || 't' || 'u' || 'v' || 'w' || 'x' || 'y' || 'z') {\n\
    \            c.append(i + 'm')\n        } else {\n            c.append(i + 'a')\n\
    \        }\n    }\n    \n    return String(c)", "\tlet mut out = \"\"\n\tfor ch\
    \ in s {\n\t\tlet i = alphabet.find(ch as Char);\n\t\tlet j = alphabet.rfind(ch\
    \ as Char);\n\t\tout += alphabet[i + 2 as Int];\n\t\tout += alphabet[(i + 2) %\
    \ len(alphabet) as Int];\n\t}\n\treturn out", "    var result = \"\"\n    for\
    \ char in s {\n        let index = alphabet.index(of: char.lowercased() )!\n \
    \       result += alphabet[(index * 2)..<((index + 1) * 2) - 1]\n    }\n    return\
    \ result", "    let mut alphabet = makeAlphabet()\n    let mut encoded = \"\"\n\
    \    let length = s.count\n    for i in 0..<length {\n        encoded.append(alphabet[s[i]\
    \ - alphabet[0]])\n    }\n    return encoded", '    return rotate(s, 2)', "  \
    \  var a = makeAlphabet(s.count)\n    var result = \"\"\n    var index = 0\n \
    \   for char := range a {\n        result += a[char] + s[index++]\n    }\n   \
    \ return result", "\tr := alphabet.NewRot13()\n\tstr := []rune(s)\n\t\n\tnewStr\
    \ := make([]rune, len(str))\n\tfor i, v := range str {\n\t\tnewStr[i] = r.Rot13(v)\n\
    \t}\n\treturn string(newStr)", "\tc := s.characters\n\tn := len(s) / 2\n\tc[n]\
    \ = c[n] + 2\n\tc[n+1] = c[n+1] + 2\n\treturn String(c)", "    let length = s.count\n\
    \    let alphabet = alphabet.map { Character($0) }\n    var result = \"\"\n  \
    \  for i in 0..<length {\n        let index = alphabet.index(alphabet.startIndex,\
    \ offsetBy: i*2)\n        result += String(alphabet[index])\n    }\n    return\
    \ result", "\tif s.isEmpty {\n\t\treturn \"\"\n\t}\n\t\n\tvar a = alphabet\n\t\
    \n\tswitch len(a) {\n\tcase 2:\n\t\ta = append(a, a[0])\n\tcase 3:\n\t\ta = append(a,\
    \ a[1], a[0])\n\tcase 4:\n\t\ta = append(a, a[1], a[2], a[0])\n\tcase 5:\n\t\t\
    a = append(a, a[1], a[2], a[3], a[0])\n\tdefault:\n\t\tlog.Panicf(\"unsupported\
    \ alphabet %v\", a)\n\t}\n\t\n\tvar c strings.Builder\n\tc.Grow(len(s))\n\tfor\
    \ _, c := range s {\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is\
    \ needed\n\t\taVal, ok := a[len(a) - c.Len()]\n\t\tif !ok {\n\t\t\tlog.Panicf(\"\
    unsupported character %v\", c)\n\t\t}\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO:\
    \ verify this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this\
    \ is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\
    \t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\t\tc.ToUpper()\n\
    \t\tc.ToLower() // TODO: verify this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower()\
    \ // TODO: verify this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify\
    \ this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\
    \t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\t\tc.ToUpper()\n\
    \t\tc.ToLower() // TODO: verify this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower()\
    \ // TODO: verify this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify\
    \ this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\
    \t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\t\tc.ToUpper()\n\
    \t\tc.ToLower() // TODO: verify this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower()\
    \ // TODO: verify this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify\
    \ this is needed\n\t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\
    \t\tc.ToUpper()\n\t\tc.ToLower() // TODO: verify this is needed\n\t\tc.ToUpper()\n\
    \t\tc.ToLower() // TODO: verify this is needed\n\t\t", "    // TODO: Implement\
    \ here\n    return \"\"", "    if s.isEmpty {\n        return s\n    }\n    let\
    \ alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    return s.map { alphabet[$0][$1.intValue()*2%26]\
    \ }", '    return s.rotate(alphabet.count())', "    let alphabet = Alphabet()\n\
    \    return s.map(String.init).map(alphabet.rotate).map(alphabet.toChar).joinWithSeparator(\"\
    \")", "    var result = \"\"\n    \n    for letter in s {\n        let index =\
    \ alphabet.index(of: letter)!\n        let newIndex = index + 2\n        \n  \
    \      if newIndex < 26 {\n            result += alphabet[newIndex]\n        }\n\
    \        else {\n            result += alphabet[newIndex - 26]\n        }\n  \
    \  }\n    \n    return result", "    var res = [Character]()\n    for i in s {\n\
    \        res.append(Character(i))\n    }\n    return String.fromCString(encrypt(res.as_C_CHARP()))",
  "    switch rotation(len(s)) {\n    default:\n        fatalError(\"Unexpectedly\
    \ invalid rotation of alphabet\")\n    case 0:\n        return append(s, s[0])\n\
    \    case 1:\n        return append(s, s[1])\n    case 2:\n        return append(append(s,\
    \ s[0]), s[1])\n    case 3:\n        return append(append(append(s, s[0]), s[1]),\
    \ s[2])\n    case 4:\n        return append(append(append(append(s, s[0]), s[1]),\
    \ s[2]), s[3])\n    case 5:\n        return append(append(append(append(append(s,\
    \ s[0]), s[1]), s[2]), s[3]), s[4])\n    case 6:\n        return append(append(append(append(append(append(s,\
    \ s[0]), s[1]), s[2]), s[3]), s[4]), s[5])\n    case 7:\n        return append(append(append(append(append(append(append(s,\
    \ s[0]), s[1]), s[2]), s[3]), s[4]), s[5]), s[6])\n    case 8:\n        return\
    \ append(append(append(append(append(append(append(s, s[0]), s[1]), s[2]), s[3]),\
    \ s[4]), s[5]), s[6]), s[7])\n    case 9:\n        return append(append(append(append(append(append(append(s,\
    \ s[0]), s[1]), s[2]), s[3]), s[4]), s[5]), s[6]), s[7]), s[8])\n    case 10:\n\
    \        return append(append(append(append(append(append(append(s, s[0]), s[1]),\
    \ s[2]), s[3]), s[4]), s[5]), s[6]), s[7]), s[8]), s[9])\n    case 11:\n     \
    \   return append(append(append(append(append(append(append(s, s[0]), s[1]), s[2]),\
    \ s[3]), s[4]), s[5]), s[6]), s[7]), s[8]), s[9]), s[10])\n    case 12:\n    \
    \    return append(append(append(append(append(append(append(s, s[0]), s[1]),\
    \ s[2]), s[3]), s[4]), s[5]), s[6]), s[7]), s[8]), s[9]), s[10]), s[11])\n   \
    \ case 13:\n        return append(append(append(append(append(append(append(s,\
    \ s[0]), s[1]), s[2]), s[3]), s[4]), s[5]), s[6]), s[7]), s[8]), s[9]), s[10]),\
    \ s[11]), s[12])\n    case 14:\n        return append(append(append(append(append(append(append(append(s,\
    \ s[0]), s[1]), s[2]), s[3]), s[4]), s[5]), s[6]), s[7]), s[8]), s[9]), s[10]),\
    \ s[11]), s[12]), s[13])\n    case 15:\n        return append(append(append(append(append(append(append(append(s,\
    \ s[0]), s[1]), s[2]), s[3]), s[4]), s[5]), s[6]), s[7]), s[8]), s[9]), s[10]),\
    \ s[11]), s[12]), s[13]), s[14])\n    case 16:\n        return append(append(append(",
  "    var result = \"\"\n    for letter in s.chars() {\n        let index = alphabet.index(letter)\n\
    \        result = result+alphabet[alphabet.index(alphabet[index], index: index)+2]\n\
    \    }\n    return result", "    var n = s.count\n    var r = 0\n    var alpha\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = [Character]()\n    for c\
    \ in s {\n        result[r] = alpha[(n + r + r + r - r - r + r + r + r) % alpha.count]\n\
    \        r++\n    }\n    return String(result)", "\treturn s.chars().map{String($0\
    \ + 1)}.joinWithSeparator(\"\").reversed().joinWithSeparator(\"\").reversed()",
  "    let alphabet = s.characters\n    let newAlphabet = alphabet.map { $0 + 2 }.map\
    \ { $0 - 2 }\n    return String(newAlphabet.map { alphabet[$0] }) + String(alphabet.map\
    \ { alphabet[$0] })", "    let result = \"\"\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .characters\n    for c in s {\n        result = result + alphabet[(alphabet.index(alphabet.startIndex,\
    \ offsetBy: 2)) + alphabet.index(alphabet.startIndex, offsetBy: 2) + alphabet.index(alphabet.startIndex,\
    \ offsetBy: 3)]\n    }\n    return result", "\t\n\tlet length = s.characters.count\n\
    \tlet alphabet = [\"\"]\n\t\n\tfor i in 0..<length {\n\t\tlet letter = s.character(at:\
    \ i)\n\t\t\n\t\tlet index = alphabet.index(of: letter)\n\t\t\n\t\tif index !=\
    \ nil {\n\t\t\talphabet[index!] = alphabet[index!] + letter\n\t\t} else {\n\t\t\
    \talphabet.append(letter)\n\t\t}\n\t}\n\t\n\tlet resultingString = String()\n\t\
    \n\tfor letter in alphabet {\n\t\tlet index = alphabet.index(of: letter)\n\t\t\
    \n\t\tif let index = index {\n\t\t\tlet shiftIndex = index! + 2\n\t\t\t\n\t\t\t\
    if shiftIndex < alphabet.count {\n\t\t\t\tlet shiftLetter = alphabet[shiftIndex]\n\
    \t\t\t\t\n\t\t\t\talphabet[index!] = shiftLetter\n\t\t\t\t\n\t\t\t\tresultingString\
    \ = resultingString + letter + shiftLetter\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn\
    \ resultingString", "    var result : String = s.characters.map { charToInt($0)\
    \ }\n\n    rotateLeft(result: &result)\n    rotateRight(result: &result)\n\n \
    \   return result", "    let res = s[0]\n    for char in s.characters.dropFirst().reversed()\
    \ {\n        res += char.rotateRight(by: 1)\n        res += char.rotateLeft(by:\
    \ 1)\n    }\n    return res", '  return alphabet.rotate(s)', "  var res = \"\"\
    \n  for c in s {\n    if c >= \"a\" && c <= \"z\" {\n      c -= \"z\" - (c % \"\
    z\" >= \"a\" ? (c % \"z\" - \"a\" + 1) : 0)\n    }\n    res = res + c\n  }\n \
    \ return res", "    let alphabet = Array(s.characters)\n    let rotatedAlphabet\
    \ = rotatedAlphabet(alphabet)\n\n    var resultString = \"\"\n    var index =\
    \ 0\n    for character in s {\n        resultString += rotatedAlphabet[index++]\n\
    \    }\n    return resultString", "\tcipherText := make([]rune, len(s))\n\tfor\
    \ index, value := range s {\n\t\tcipherText[index] = alphabet.lookup(alphabet.lookup_index(alphabet.lookup(alphabet.lookup(alphabet.lookup_index(value))\
    \ + 2))) * 2\n\t}\n\treturn string(cipherText)", "    let alphabet = alphabet_rot13()\n\
    \    return alphabet.map{ alphabet[$0] }.map{ s.replace($0, \"\") }.joined()",
  "    var result = \"\"\n    for letter in s {\n        var rotation = letter\n \
    \       for _ in 0..<2 {\n            rotation = alphabet[rotation.ordinal() -\
    \ rotation.ordinal() % len(alphabet)]\n        }\n        result += rotation\n\
    \    }\n    return result", "    let alphabet = s.characters\n    var result =\
    \ \"\"\n    for letter in alphabet {\n        let idx = alphabet.index(of: letter)\n\
    \        if idx % 2 == 0 {\n            result = result + alphabet[alphabet.index(of:\
    \ alphabet[idx/2]) + 1] + alphabet[alphabet.index(of: alphabet[idx/2])]\n    \
    \    } else {\n            result = result + alphabet[alphabet.index(of: alphabet[idx/2])\
    \ + 1] + alphabet[alphabet.index(of: alphabet[idx/2])-1]\n        }\n    }\n \
    \   return result", "    var result: String = s\n    var j = 0\n    for c in s.characters\
    \ {\n        result[j] = chr(rxor(c, 32))\n        j += 1\n    }\n    return result",
  "    switch s.Characters {\n    case s.Characters().characters.count/2:\n      \
    \  return s.Rotate()\n    default:\n        return s \n    }", "\treturn crypt(s,\
    \ ALPHA)", '  return s(0).rotatedString(2)', "\tresult := \"\"\n\tfor i := 0;\
    \ i < len(s); i++ {\n\t\tresult += alphabet.rotateLeft(s.charAt(i)) + alphabet.rotateLeft(s.charAt(i+1))\n\
    \t}\n\treturn result", "    if s == \"\" {\n        return \"\"\n    }\n\n   \
    \ // TODO: make an exception handling here\n    return s[0] + s.substring(1) +\
    \ s.substring(2)", "\tlet alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\t\n\tvar\
    \ result = \"\"\n\tfor char in s.characters {\n\t\tlet index = alphabet.characters.indexOf(char)\
    \ ?? 0\n\t\tresult += alphabet.characters[index..<alphabet.characters.index(index,\
    \ offsetBy: 2)].last!\n\t}\n\t\n\treturn result", "\treturn s.rotate(Alphabet.rotate())",
  "    result := \"\"\n    for _, letter := range s {\n        result += shift(letter)\n\
    \    }\n    return result", "\tvar len = s.Length()\n\tvar rotation = len(s)\n\
    \tfor {\n\t\trotation -= 2\n\t\tif rotation < 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\t\
    return s[:rotation] + s[rotation+1:]", "    var alphabet = [\"a\",\"b\",\"c\"\
    ,\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"\
    ,\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    alphabet.shuffle()\n\
    \    alphabet.sort(by: { $0 < $1 })\n    var alphaCount = [0,0,0,0,0,0,0,0]\n\
    \    var c = 0\n    for letter in alphabet {\n        if letter == s.characters[c]\
    \ {\n            alphaCount[c] += 1\n        } else {\n            c++\n     \
    \   }\n    }\n    var newChars = Array(alphabet)\n    var newAlphaCount = Array(alphabet)\n\
    \    for indexChar in 0 ..< s.characters.count {\n        let char = s.characters[indexChar]\n\
    \        let indexNew = alphabet[(indexChar + c) % alphabet.length]\n        newChars[indexNew]\
    \ = char\n        newAlphaCount[indexNew] = alphaCount[indexNew] + 1\n    }\n\
    \    return String(newChars)", "    if s.isEmpty {\n        return \"\"\n    }\n\
    \n    var len = s.count\n    var cipherString = [Character](repeating: 0, count:\
    \ len/2)\n    cipherString.append(s.characters)\n    cipherString.append(cipherString[len-2],\
    \ cipherString[len-1])\n    let index = cipher(cipherString, key: alphabet)\n\
    \    return string(cipherString[index..<(index+len/2)])", "\treturn rotate(s,\
    \ true)", "    return s.chars().enumerate().map { (i, c) in\n        switch i\
    \ {\n        case 0, 2, 4, 6:\n            return c.toUppercase()\n        default:\n\
    \            return c.toLowercase()\n        }\n    }.map { String($0) }.joinWithSeparator(\"\
    \").lowercased()", "    if s == \"\" {\n        return \"\"\n    }\n\n    var\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var index = alphabet.IndexOf(s[0])\n\
    \    var result = \"\"\n    for i := 1; i < len(s); i++ {\n        index = alphabet.IndexOf(s[i],\
    \ index)\n        result += alphabet[(index + (index / 2)) % 26]\n    }\n\n  \
    \  return result", "    var result = \"\"\n    for _ in s.characters {\n     \
    \   result = result + (s.characters[s.characters.characters.count - 1] + s.characters[s.characters.characters.count\
    \ - 1])\n    }\n    return result", "  \n  // Rotate the alphabet by multiplying\
    \ the letters by two and then adding two\n  // to each letter, then rotate the\
    \ alphabet by two to start at the beginning\n  let alphabet = s.chars.map { c\
    \ -> String in\n    let i = c - 'a'\n    return String.init(\"a\".utf8.prefix(1)\
    \ + i.multiply_by(2).add_by(2).utf8.repeated())\n  }\n  \n  let res = alphabet.map\
    \ { c in\n    let i = s.indexOf(c)\n    return String(s.dropLast(1) + s.dropFirst(i))\n\
    \  }\n  \n  return res", "\tlet alphabet = StringRotation(s.characters)\n\treturn\
    \ s.characters(using: alphabet)", "    \n    var n = s.length\n    var m = len(alphabet)\n\
    \    var l = len(s)\n    var newString = \"\"\n    \n    for i in 0..<l {\n  \
    \      var c = s[i]\n        c = c & ^(1 << 63)\n        c = alphabet.subst[c]\
    \ & ^(1 << 63)\n        newString += alphabet.subst[c]\n    }\n    return newString",
  "    var s = s\n    for _ in 1...alphabet.count {\n        s = alphabet.first! +\
    \ alphabet.last! + s\n    }\n    return s.characters.map { alphabet[$0] }", " \
    \   var index = alphabet.count-1\n    var newString = \"\"\n    while index >=\
    \ 0 {\n        newString = newString + alphabet[(index+2)%alphabet.count]\n  \
    \      index = index-1\n    }\n    return newString + s", "    let alphabet =\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var result = \"\"\n    for char in s {\n\
    \        result += alphabet.indexOf(char)\n    }\n    return result", "    guard\
    \ let alphabet = Alphabet[s] else {\n        throw Error.invalidArgument(message:\
    \ \"Cannot encrypt \" + s + \" as it is not in the alphabet\")\n    }\n    \n\
    \    var result = \"\"\n    for i in 0 ..< s.count {\n        let charIndex =\
    \ alphabet.index(s.character(at: i))\n        let charNextIndex = alphabet.index(s.character(at:\
    \ i + 1))\n        let multiplier = charIndex - charNextIndex\n        result\
    \ += Alphabet[s.character(at: i)].character(at: charIndex + multiplier)\n    }\n\
    \    \n    return result"]
stop_tokens:
- "\n}"
