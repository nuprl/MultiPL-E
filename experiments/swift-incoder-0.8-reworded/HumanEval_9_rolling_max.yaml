name: HumanEval_9_rolling_max
language: swift
prompt: "\n/// From a given array of integers, generate an array of rolling maximum\
  \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
  \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == []\
  \ as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
  \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
  \ == [3, 3, 3, 100, 100])"
completions: ["    var max = numbers[0]\n    var maxIndex = 0\n    var index = 0\n\
    \    var sum = 0\n    while index < numbers.count {\n        sum += numbers[index]\n\
    \        if sum > max {\n            max = sum\n            maxIndex = index\n\
    \        }\n        index += 1\n    }\n    return numbers[maxIndex]", "    \n\
    \    let result = Array(repeating: numbers[0], count: numbers.count)\n    \n \
    \   for value in numbers {\n        let min = min(result, value)\n        let\
    \ max = max(result, value)\n        \n        result[min...max] += 1\n    }\n\
    \    \n    return result", "    var max = [Int]()\n    var max = numbers[0]\n\
    \    for i in numbers {\n        if i > max {\n            max = i\n        }\n\
    \    }\n    for i in numbers {\n        if i > max {\n            max = i\n  \
    \      }\n    }\n    return max", "    var max = numbers[0]\n    var max_indexes\
    \ = [Int]()\n    var min_indexes = [Int]()\n    for index in 0..<numbers.count\
    \ {\n        if max < numbers[index] {\n            max = numbers[index]\n   \
    \     }\n        if max < numbers[index] {\n            max_indexes.append(index)\n\
    \        }\n    }\n    for index in 0..<numbers.count {\n        if min > numbers[index]\
    \ {\n            min = numbers[index]\n        }\n        if min > numbers[index]\
    \ {\n            min_indexes.append(index)\n        }\n    }\n    var indexes:\
    \ [Int] = []\n    for index in max_indexes {\n        indexes.append(index)\n\
    \    }\n    for index in min_indexes {\n        indexes.append(index)\n    }\n\
    \    return indexes", '    return rolling_max(numbers, 0)', "    var max = [Int]()\n\
    \    var index = 0\n    for number in numbers {\n        if index == 0 {\n   \
    \         max = number\n        } else {\n            if number > max[index-1]\
    \ {\n                max = number\n            }\n        }\n        index +=\
    \ 1\n    }\n    return max", '  return rolling_max(numbers: numbers, n: 1)', " \
    \   var maxs = [Int]()\n    for n in numbers {\n        maxs.append(n)\n     \
    \   if maxs.count > 1 {\n            if maxs[maxs.count - 2] > maxs[maxs.count\
    \ - 1] {\n                maxs.swapLast(2)\n            }\n        }\n    }\n\
    \    return maxs", "    return Array(\n        stride(from: numbers.count - 1,\
    \ through: 0, by: 1)\n            .enumerated()\n            .flatMap { i, number\
    \ in\n                if number == numbers[0] {\n                    return [number]\n\
    \                } else if number > numbers[0] {\n                    let rolling_max\
    \ = [numbers[0]]\n                    rolling_max.append(number)\n           \
    \         rolling_max.append(numbers[i + 1])\n                    return rolling_max\n\
    \                }\n                return []\n            })", "    let maxes\
    \ = [Int]()\n    var maxIndex = 0\n    for number in numbers {\n        maxIndex\
    \ += 1\n        if maxIndex == numbers.count {\n            maxIndex = 0\n   \
    \     }\n        maxes.append(max(maxes[maxIndex - 1], number))\n    }\n    return\
    \ maxes", '    return rolling_max(numbers, 0)', "    if numbers.isEmpty {\n  \
    \      return []\n    }\n    numbers.sort()\n    var maxValue: Int = 0\n    var\
    \ maxIndex = 0\n    var currentIndex = 0\n    for num in numbers {\n        while\
    \ currentIndex < maxIndex {\n            if num == maxValue {\n              \
    \  currentIndex += 1\n            } else {\n                break\n          \
    \  }\n        }\n        if currentIndex == maxIndex {\n            maxValue =\
    \ num\n            maxIndex = currentIndex + 1\n        }\n    }\n    return Array(numbers[0..<maxIndex])",
  '    return rolling_max(numbers, .init())', "    return numbers.reduce(into: [Int]())\
    \ { accumulatorValue, currentValue in\n        if accumulatorValue.count > 0 &&\
    \ accumulatorValue.last < currentValue {\n            accumulatorValue.append(currentValue)\n\
    \        }\n        else if accumulatorValue.last == currentValue {\n        \
    \    accumulatorValue.append(accumulatorValue.last)\n        }\n        else if\
    \ accumulatorValue.last > currentValue {\n            accumulatorValue.insert(currentValue)\n\
    \        }\n    }", "    if numbers.isEmpty {\n        return []\n    }\n    \n\
    \    var rolling_max = numbers[0]\n    for i in 1...numbers.count {\n        if\
    \ numbers[i] > rolling_max {\n            rolling_max = numbers[i]\n        }\n\
    \    }\n    return rolling_max", "    var maxElements = [0]\n    for i in numbers\
    \ {\n        if maxElements[0] < i {\n            maxElements = [i]\n        }\
    \ else if maxElements[0] == i {\n            if maxElements[1] < i {\n       \
    \         maxElements = [i, maxElements[1]]\n            } else {\n          \
    \      maxElements = [i, maxElements[1], maxElements[2]]\n            }\n    \
    \    } else {\n            if maxElements[2] < i {\n                maxElements\
    \ = [maxElements[0], i, maxElements[2]]\n            } else {\n              \
    \  maxElements = [maxElements[0], i, maxElements[1], maxElements[2]]\n       \
    \     }\n        }\n    }\n    return maxElements", "    var max = numbers[0]\n\
    \    var maxIndex = 0\n    for num in numbers {\n        if num > max {\n    \
    \        max = num\n            maxIndex = numbers.indexOf(num)\n        }\n \
    \   }\n    let maxIndex = maxIndex + numbers.count\n    let maxValue = numbers[maxIndex]\n\
    \    let maxCount = numbers.count\n    var result = Array<Int>()\n    for i in\
    \ 0..<maxCount {\n        let sum: Int\n        if i == maxIndex {\n         \
    \   sum = maxValue\n        } else {\n            sum = maxValue - numbers[maxIndex\
    \ - i] + numbers[i]\n        }\n        if sum < 0 {\n            result.append\
    \ (sum)\n        } else {\n            result.append (maxValue)\n        }\n \
    \   }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        var max = result[0]\n        var remaining = number\n   \
    \     if number > max {\n            remaining = number\n        }\n        if\
    \ number > remaining {\n            max = 0\n        }\n        result.append(max)\n\
    \    })", "    var rolling_max = [Int]()\n    rolling_max.removeAll()\n    for\
    \ number in numbers {\n        rolling_max = rolling_max.filter { $0 != number\
    \ }\n        rolling_max.append(number)\n    }\n    return rolling_max", '  return
    _recursive(numbers, numbers, 0)', "    numbers.sort()\n    var rolling_max = numbers.first!\n\
    \    for i in 1..<numbers.count {\n        if numbers[i-1] < rolling_max {\n \
    \           rolling_max = numbers[i]\n        }\n    }\n    return rolling_max",
  "    return numbers.reduce(into: [Int](), { result, number in\n        if result.count\
    \ < 1 {\n            result.append(number)\n        } else {\n            if number\
    \ > result[result.count - 1] {\n                result.append(number)\n      \
    \      }\n        }\n    })", '    return rolling_max_(numbers, numbers)', " \
    \   var rollingMax = [Int]()\n\n    var maxNumber = Int(numbers[0])\n    for number\
    \ in numbers {\n        if number > maxNumber {\n            maxNumber = number\n\
    \        }\n    }\n\n    for number in numbers {\n        if number == maxNumber\
    \ {\n            rollingMax.append(number)\n        }\n    }\n    return rollingMax",
  "    var max = numbers[0]\n    for number in numbers {\n        if number > max\
    \ {\n            max = number\n        }\n    }\n    return Array(max..<numbers.last!)",
  "    let length = numbers.count\n    var rollingMax = 0\n    var lastRollingMax\
    \ = -1\n    for idx in stride(from: 0, to: length, by: 1) {\n        if numbers[idx]\
    \ > rollingMax {\n            rollingMax = numbers[idx]\n            lastRollingMax\
    \ = idx\n        }\n    }\n    return [rollingMax, lastRollingMax]", "    // Add\
    \ extra element for end\n    numbers.append(Int64(1))\n\n    var largest = numbers[0]\n\
    \    var rolling_max = [Int]()\n\n    for number in numbers {\n        if number\
    \ > largest {\n            rolling_max = [Int](repeating: number, count: numbers.count\
    \ - rolling_max.count + 1)\n            largest = number\n        }\n    }\n\n\
    \    rolling_max.append(Int64(1))\n\n    return rolling_max", "    var max = numbers[0]\n\
    \    for number in numbers {\n        if number > max {\n            max = number\n\
    \        }\n    }\n    return numbers", "    var max: Int = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    return numbers.map({ (number) -> Int in\n        return max\n    })",
  '    return maxSequence(numbers, windowSize: 1).prefix(2)', "    var maximum = numbers[0]\n\
    \    var results = [Int](repeating: 0, count: numbers.count)\n    var counter\
    \ = 0\n    for n in numbers {\n        if maximum < n {\n            results[counter]\
    \ = maximum\n            counter = 0\n            maximum = n\n        } else\
    \ {\n            counter += 1\n        }\n    }\n    if counter == 0 {\n     \
    \   results[counter] = maximum\n    }\n    return results", "    return (0..<numbers.count).map\
    \ { idx in\n        guard idx != numbers.count - 1 else {\n            return\
    \ numbers[idx]\n        }\n        return max(numbers[idx], numbers[idx + 1])\n\
    \    }", "    return numbers.sorted { $0 < $1 }.map {\n        if numbers[Int($0)]\
    \ == nil {\n            numbers[Int($0)] = Int($0)\n        }\n        return\
    \ numbers[Int($0)]\n    }", "    var max = numbers[0]\n    var maxIndex: Int =\
    \ 0\n    var index = numbers.startIndex\n    while index != numbers.endIndex {\n\
    \        if numbers[index] > max {\n            max = numbers[index]\n       \
    \     maxIndex = index\n        }\n        index = index.successor()\n    }\n\
    \    return maxIndex.map { numbers[$0] }", "    guard numbers.count >= rolling_min_count\
    \ else {\n        return []\n    }\n    return numbers.reduce(0, { max($0, $1)\
    \ })", "    \n    var rolling_max = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if rolling_max < numbers[i] {\n            rolling_max = numbers[i]\n\
    \        }\n    }\n    return rolling_max", "    var rolling_max = 0\n    for\
    \ number in numbers {\n        if number > rolling_max {\n            rolling_max\
    \ = number\n        }\n    }\n    return rolling_max", "    \n    var max_value\
    \ = 0\n    var current_max = numbers[0]\n    for i in 1..<numbers.count {\n  \
    \      if numbers[i] > current_max {\n            current_max = numbers[i]\n \
    \       }\n    }\n    if current_max > max_value {\n        max_value = current_max\n\
    \    }\n    var result = [0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ != current_max {\n            result.append(numbers[i])\n        }\n    }\n\
    \    if max_value > 0 {\n        result.append(max_value)\n    }\n    return result",
  "    let numberCount = numberData.count\n    let result = Array(repeating: Int.max,\
    \ count: numberCount)\n\n    for index in stride(from: numberCount - 1, through:\
    \ 0, by: -1) {\n        result[index] = numbers[index] > result[index] ? numbers[index]\
    \ : result[index]\n    }\n    return result", '    return rolling_max(numbers,
    window: 1)', "    var maximum = numbers[0]\n    var indexes = Array(0..<numbers.count).map\
    \ { Int(arc4random_uniform(UInt32(numbers.count)))! }\n    while !numbers.indices.contains(indexes)\
    \ {\n        let index = indexes[indexes.count - 1]\n        if numbers[index]\
    \ > maximum {\n            maximum = numbers[index]\n        }\n        indexes[indexes.count\
    \ - 1] += 1\n    }\n    return Array(numbers[0..<indexes.count].map { numbers[$0]\
    \ }).reversed()", "    var result = numbers[0]\n    var max = numbers[0]\n   \
    \ for i in numbers.indices {\n        if result[i] > max {\n            result\
    \ = numbers[i:i+1]\n            max = numbers[i]\n        }\n    }\n    return\
    \ result", "    var rollingMax = [Int]()\n    var maxRollingTimes = [Int]()\n\
    \    for i in 0 ..< numbers.count {\n        if rollingMax.count < numbers.count\
    \ {\n            rollingMax.append(numbers[i])\n            maxRollingTimes.append(1)\n\
    \        } else {\n            if rollingMax[rollingMax.count - 1] < numbers[i]\
    \ {\n                rollingMax[rollingMax.count - 1] = numbers[i]\n         \
    \       maxRollingTimes[rollingMax.count - 1] = maxRollingTimes[rollingMax.count\
    \ - 1] + 1\n            }\n        }\n    }\n    return rollingMax", "    var\
    \ maxIndex = 0\n    var result = [Int](repeating: 0.0, count: numbers.count)\n\
    \    for index in numbers.indices {\n        result[index] = numbers[index]\n\
    \        if index > maxIndex {\n            maxIndex = index\n        }\n    }\n\
    \    return result.prefix(maxIndex + 1)", "    \n    // get number of elements\
    \ to generate\n    let count = numbers.count\n    \n    // create temporary array\
    \ of max values\n    var maxValues = [Int](repeating: 0, count: count)\n    \n\
    \    // start from beginning of array\n    for i in 0 ..< count {\n        maxValues[i]\
    \ = numbers[maxIndex: i]\n    }\n    \n    // iterate until last element\n   \
    \ for i in (count - 1 ..< numbers.count) {\n        \n        // set max to max\
    \ before last element\n        let maxBeforeLast = maxIndex: i\n        \n   \
    \     // set last element to max\n        let lastElement = numbers[i]\n     \
    \   \n        // check each element to check if it greater than the previous\n\
    \        for j in 0 ..< maxIndex {\n            \n            // if current element\
    \ is greater than the previous max, set max to current element\n            if\
    \ numbers[j] < lastElement {\n                maxBeforeLast = j\n            }\n\
    \            \n        }\n        \n        // update max value\n        maxValues[i]\
    \ = numbers[maxBeforeLast: i]\n    }\n    \n    return maxValues", "    if numbers.isEmpty\
    \ {\n        return []\n    }\n    var rolling_max = numbers[0]\n    var rolling_max_pos\
    \ = 0\n    for x in numbers {\n        if x > rolling_max {\n            rolling_max\
    \ = x\n        }\n        rolling_max_pos = rolling_max_pos + 1\n    }\n\n   \
    \ var result = [Int]()\n    for x in numbers {\n        if x == rolling_max {\n\
    \            result.append(rolling_max)\n            continue\n        }\n   \
    \     if x - rolling_max == rolling_max_pos {\n            rolling_max = x\n \
    \       }\n    }\n    return result", '    return numbers.reduce([], { $0.maxElement()
    < $1.maxElement() ? $0 : $1})', "  var max = [Int]()\n  var index = 0\n  var number\
    \ = numbers[0]\n  for i in 1..<numbers.count {\n    if number > numbers[i] {\n\
    \      max = append(max, number)\n      index = i\n      number = numbers[i]\n\
    \    } else {\n      number = numbers[i]\n    }\n  }\n  max = append(max, number)\n\
    \  return max", "    var max = [Int]()\n    for n in numbers {\n        if n >\
    \ max[0] {\n            max[0] = n\n        }\n    }\n    var max_index = -1\n\
    \    for n in numbers {\n        if n == max[0] {\n            max_index += 1\n\
    \        }\n    }\n    if max_index == 0 {\n        return numbers\n    }\n  \
    \  \n    // Get list of indexes in the original array where max element was found\n\
    \    var indexes = [Int]()\n    for n in numbers {\n        if n == max[0] {\n\
    \            indexes.insert(Int(n))\n        }\n    }\n    if max_index == 1 {\n\
    \        // Remove all those indexes from the original array - these were found\
    \ to contain the maximum element at the end\n        for index in indexes {\n\
    \            numbers.remove(at: index)\n        }\n        return numbers\n  \
    \  }\n    \n    // Find max element at last index of the array containing max\
    \ element\n    for index in 0..<numbers.count {\n        let current = numbers[index]\n\
    \        if max[0] == current {\n            numbers.remove(at: index)\n     \
    \       numbers.insert(current, at: numbers.endIndex)\n            break\n   \
    \     }\n    }\n    \n    max = rolling_max(numbers: numbers)\n    \n    // Add\
    \ found max element to original array\n    for index in indexes {\n        numbers.insert(max[0],\
    \ at: index)\n    }\n    return numbers", "    var max = [Int]()\n    var maxIndex\
    \ = 0\n\n    for idx in 0..<numbers.count {\n        if numbers[idx] < numbers[maxIndex]\
    \ {\n            max.append(numbers[idx])\n            maxIndex = idx\n      \
    \  }\n    }\n\n    return max", '    return numbers.window(by: -1).reduce(1, combineMax:
    {max, current in max(max, current)})', "    var rolling_max = numbers\n    var\
    \ rolling_maxIdx = 0\n    while rolling_maxIdx < numbers.count - 1 {\n       \
    \ if rolling_max[rolling_maxIdx] <= numbers[rolling_maxIdx + 1] {\n          \
    \  rolling_maxIdx += 1\n        } else {\n            rolling_max[rolling_maxIdx]\
    \ = numbers[rolling_maxIdx]\n            rolling_maxIdx += 1\n        }\n    }\n\
    \    return rolling_max", "    if numbers.isEmpty {\n        return []\n    }\n\
    \    var maxElement = numbers.first!\n    var maxIndex = -1\n    var maxIndexElement\
    \ = numbers.first!\n    var newElement: Int = 0\n    for i in 1..<numbers.count\
    \ {\n        if maxIndex == i {\n            newElement = maxElement\n       \
    \     maxIndexElement = maxIndex\n        } else {\n            if numbers[i -\
    \ 1] < numbers[maxIndex] {\n                newElement = numbers[i - 1]\n    \
    \            maxIndexElement = numbers[i - 1]\n            } else {\n        \
    \        newElement = maxElement\n                maxIndexElement = maxIndex\n\
    \            }\n        }\n        if maxIndexElement > numbers[i] {\n       \
    \     maxElement = maxIndexElement\n            maxIndex = i\n        }\n    }\n\
    \    if newElement > maxElement {\n        maxElement = newElement\n    }\n  \
    \  return [maxIndexElement, maxElement]", "    var res: [Int] = numbers\n    var\
    \ mx: Int = numbers.max()!\n    var maxIndex = -1\n\n    for i in 0..<numbers.count\
    \ {\n        res[i] = numbers[i]\n        if maxIndex < res[i] {\n           \
    \ maxIndex = res[i]\n        }\n    }\n    for i in 0..<numbers.count {\n    \
    \    res[maxIndex] = mx\n    }\n    return res", '    return rolling_max(numbers,
    numFrames: numbers?.count)', "    numbers.removeAll()\n    return numbers", '    rolling_max_helper(numbers,
    0)', "    let window = RollingMaxWindow(windowSize: numbers.count, stride: 1)\n\
    \    let rollingMax = numbers.windowed(by: window).maxElement()\n    return rollingMax",
  "    var max_number = numbers[0]\n    var result = [Int]()\n\n    for i in 1..<numbers.count\
    \ {\n        if max_number > numbers[i] {\n            max_number = numbers[i]\n\
    \        }\n        result.append(max_number)\n    }\n\n    return result", " \
    \   var maxIndex = 0\n    var maxValue = numbers[0]\n    for i in  0..<numbers.count\
    \ {\n        if numbers[i] > maxValue {\n            maxValue = numbers[i]\n \
    \           maxIndex = i\n        }\n    }\n    return Array(numbers[0..<maxIndex])",
  "    \n    var max = [Int](repeating: 0, count: numbers.count)\n    \n    for i\
    \ in numbers.indices {\n        \n        if max[i] < numbers[i] {\n         \
    \   \n            if max[i] < numbers[i-1] {\n                max[i] = numbers[i-1]\n\
    \            } else {\n                max[i] = numbers[i]\n            }\n  \
    \      }\n    }\n    \n    return max", "    var max = [Int]()\n    var index\
    \ = 0\n    var max = numbers.max()\n    while max > numbers[index] {\n       \
    \ max = numbers[index]\n        index += 1\n    }\n    maxIndex = index\n    while\
    \ index < numbers.count {\n        max = numbers[index]\n        if max > numbers[index]\
    \ {\n            max = numbers[index]\n            index++\n        }\n      \
    \  else {\n            break\n        }\n    }\n    return max", '    return numbers.sorted(by:
    >)', "    var result = numbers[numbers.startIndex]\n    let firstElementIndex\
    \ = numbers.startIndex\n    for i in numbers.startIndex..<numbers.endIndex {\n\
    \        if i > numbers.endIndex-1 {\n            break\n        }\n        if\
    \ numbers[i] > result {\n            result = numbers[i]\n        }\n    }\n \
    \   return result", "    var maxNumber = 0\n    var currentMaxNumber = 0\n\n \
    \   for number in numbers {\n        currentMaxNumber = maxNumber\n        maxNumber\
    \ = number\n    }\n\n    if maxNumber > currentMaxNumber {\n        numbers.append(currentMaxNumber)\n\
    \    }\n\n    return numbers", "    // TODO: use window\n    return []", "\tvar\
    \ rolling_max = [0]\n\tfor i in 0..<numbers.count {\n\t\trolling_max[0] += numbers[i]\n\
    \t\tif rolling_max[0] >= numbers[i] {\n\t\t\trolling_max[1] = numbers[i]\n\t\t\
    }\n\t}\n\treturn rolling_max", "    let rollingMax = numbers.reduce(0) { (max,\
    \ element) in\n        if max < element {\n            return element\n      \
    \  }\n        return max\n    }\n    return rollingMax", "    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n    }\n    rolling_max(numbers:\
    \ result, index: 0)\n    return result", "    var result = [Int]()\n    for i\
    \ in 0..<numbers.count {\n        result.append(max(numbers[i..<numbers.count]))\n\
    \    }\n    return result", "    var max_number : Int = numbers[0]\n    var max_indices\
    \ : [Int] = [0]\n    for number in numbers {\n        if number > max_number {\n\
    \            max_number = number\n        }\n        max_indices.append(max_indices.last\
    \ + 1)\n    }\n    return max_indices.map { numbers[$0] }", "    var max = [Int]()\n\
    \    var index = 0\n    var maxIdx = 0\n    for n in numbers {\n        if n >\
    \ max[maxIdx] {\n            max = Array(numbers[0..<index])\n            maxIdx\
    \ = index\n        }\n        max[maxIdx] = n\n        index++\n    }\n    return\
    \ max", "    var max = [Int]()\n    for x in numbers {\n        for y in max {\n\
    \            if y >= x {\n                break\n            } else {\n      \
    \          y.append(x)\n            }\n        }\n    }\n    return max", "  \
    \  if numbers.isEmpty {\n        return []\n    }\n\n    var maximums = NSArray()\n\
    \    var currentMax = numbers.first!\n    var maxCount = 0\n    for number in\
    \ numbers {\n        if number == currentMax {\n            maxCount += 1\n  \
    \      } else {\n            if maxCount == 0 {\n                maximums = NSArray(object:\
    \ number)\n            } else {\n                if maxCount > 1 {\n         \
    \           maximums = NSArray(object: currentMax, forKey: NSNumber(integer: maxCount))\n\
    \                } else {\n                    maximums.addObject(NSNumber(integer:\
    \ currentMax))\n                }\n            }\n            maxCount = 1\n \
    \           currentMax = number\n        }\n    }\n\n    if maxCount == 0 {\n\
    \        maximums = NSArray(object: currentMax)\n    } else {\n        if maxCount\
    \ > 1 {\n            maximums = NSArray(object: currentMax, forKey: NSNumber(integer:\
    \ maxCount))\n        } else {\n            maximums.addObject(NSNumber(integer:\
    \ currentMax))\n        }\n    }\n\n    return maximums.array as! [Int]", "  \
    \  var max_so_far = numbers.min()!\n    var max_numbers = numbers\n    for i in\
    \ numbers.indices {\n        if numbers[i] <= max_so_far {\n            continue\n\
    \        }\n        max_numbers[i] = max_so_far\n        max_so_far = numbers[i]\n\
    \    }\n    return max_numbers", "    var result = numbers[0]\n    for number\
    \ in numbers {\n        result = max(result, number)\n    }\n    return Array(result)",
  "    var max = numbers[0]\n    var minPos = numbers.startIndex\n    var minVal =\
    \ numbers[0]\n\n    for n in numbers {\n        if n < min {\n            min\
    \ = n\n            minPos = numbers.startIndex\n            minVal = n\n     \
    \   } else if n > max {\n            max = n\n        }\n    }\n\n    var result\
    \ = [Int]()\n\n    for n in numbers {\n        if n == min {\n            insert(result,\
    \ minVal)\n            minPos += 1\n        }\n    }\n\n    return result", " \
    \   return reduce(numbers) { (max: Int, n: Int) -> Int in\n        if n < max\
    \ {\n            max = n\n        }\n        return max\n    }", "    var max:\
    \ Int = 0\n    for num in numbers {\n        max = num if num > max else max\n\
    \    }\n    var rolling_max = [Int]()\n    for num in numbers {\n        rolling_max\
    \ = [num] + rolling_max\n    }\n    return rolling_max", "    \n    let rollingMax:\
    \ [Int] = [0]\n    var current: Int?\n    var max: Int?\n    for number in numbers\
    \ {\n        if current == nil {\n            current = number\n            max\
    \ = number\n        } else if number > current {\n            max = number\n \
    \       } else {\n            if max == nil {\n                max = number\n\
    \            }\n            current = max\n        }\n        rollingMax.append(max!)\n\
    \    }\n    return rollingMax", "    var rolling_max = [Int]()\n    var rolling_max_i\
    \ = 0\n    for n in numbers {\n        if rolling_max[rolling_max_i] > n {\n \
    \           rolling_max[rolling_max_i] = n\n        } else {\n            rolling_max_i\
    \ += 1\n        }\n    }\n    return rolling_max", "\tvar max = numbers.min()\n\
    \tvar result = [Int](repeating: 0, count: numbers.count)\n\tvar index = 0\n\n\t\
    for i in numbers {\n\t\tresult[index] = i\n\t\tif max < i {\n\t\t\tmax = i\n\t\
    \t}\n\t\tindex += 1\n\t}\n\n\treturn result", "    let window = numbers[numbers.startIndex]\n\
    \    var max = 0\n    var maxIndex = numbers.startIndex\n\n    for i in numbers.indices\
    \ {\n        if numbers[i] > window {\n            max = numbers[i]\n        \
    \    maxIndex = i\n        }\n    }\n    return [max]", '    return rolling_max_by(numbers,
    0)', "    var max_index = numbers.startIndex\n    var max_number = numbers[0]\n\
    \n    for i in 1..<numbers.count {\n        if numbers[i] > max_number {\n   \
    \         max_number = numbers[i]\n            max_index = i\n        }\n    }\n\
    \n    return Array(numbers[max_index...]).sorted()", "\tvar max = numbers[0]\n\
    \tvar result: [Int] = []\n\tfor i, number in numbers.enumerated() {\n\t\tif number\
    \ > max {\n\t\t\tmax = number\n\t\t\tresult = [number]\n\t\t\tcontinue\n\t\t}\n\
    \t\tresult.append(number)\n\t}\n\treturn result", '    return rolling_max_internal(numbers,
    Int64(0))', "    var maxSoFar = numbers[0]\n    return numbers.filter {\n    \
    \    currMax in\n        maxSoFar > currMax && currMax != 0\n    }", "    return\
    \ numbers.reduce(into: [Int]()) { rolling, number in\n        rolling[rolling.count-1]\
    \ < number ? rolling.append(number) : rolling\n    }", "    var maxSoFar: Int\
    \ = 0\n    var rollingMax = [Int]()\n\n    for i in 0..<numbers.count {\n    \
    \    rollingMax.append(numbers[i])\n        if maxSoFar < rollingMax.last {\n\
    \            maxSoFar = rollingMax.last\n        }\n    }\n    return rollingMax",
  "    numbers.sort()\n    var max_count = 0\n    var max_element = numbers[0]\n \
    \   for i in numbers {\n        if i > max_element {\n            max_count =\
    \ numbers.countIndex {$0 == i}\n            max_element = i\n        }\n    }\n\
    \    var result = [Int]()\n    for i in 0..<numbers.count {\n        if numbers.countIndex\
    \ {$0 == i} != max_count {\n            result.append(i)\n        }\n    }\n \
    \   return result", "    if numbers.isEmpty() { return [] }\n    \n    var maxIndex:\
    \ Int = 0\n    var rollingMax: Int?\n    var result: [Int] = []\n    for idx in\
    \ 0..<numbers.count {\n        if rollingMax == nil || numbers[idx] > rollingMax!\
    \ {\n            rollingMax = numbers[idx]\n            maxIndex = idx\n     \
    \   } else {\n            rollingMax! = numbers[idx]\n        }\n        \n  \
    \      result.append(rollingMax!)\n    }\n    \n    return result", '    return
    numbers.reduce(0, { $0 > $1 ? $1 : $0 })', "    var rolling_max : [Int] = [0]\n\
    \    var max_num = 0\n    for element in numbers {\n        max_num = max(max_num,\
    \ element)\n        rolling_max.append(max_num)\n    }\n    return rolling_max",
  "    var max = numbers[0]\n    var max_idx = 1\n    for idx in 1..<numbers.count\
    \ {\n        if max < numbers[idx] {\n            max = numbers[idx]\n       \
    \     max_idx = idx\n        }\n    }\n    return [max]", "    var max = numbers[0]\n\
    \    var maxIndex = numbers.startIndex\n    for i in numbers.dropFirst() {\n \
    \       if i > max {\n            max = i\n            maxIndex = numbers.index(after:\
    \ i)\n        }\n    }\n    return maxIndex == numbers.startIndex ? [max] : Array(numbers[maxIndex...])",
  "    var result = [Int]()\n    var prevMax = [Int]()\n\n    for number in numbers\
    \ {\n        if number > prevMax.last {\n            prevMax.append(number)\n\
    \        } else {\n            result.append(prevMax.last)\n            prevMax\
    \ = [number]\n        }\n    }\n\n    return result", "    let result = [Int]()\n\
    \    let window = numbers.count\n    for number in numbers {\n        let idx\
    \ = numbers.index(of: number) + window\n        result.append(numbers[idx])\n\
    \    }\n    return result", "    var res = Int()\n    var max_element = numbers[0]\n\
    \    for num in numbers {\n        if num > max_element {\n            max_element\
    \ = num\n        }\n    }\n    for num in numbers {\n        if num == max_element\
    \ {\n            res++\n        } else if num > max_element {\n            res\
    \ = num\n        }\n    }\n    return Array(res)", "    var max = [Int]()\n  \
    \  for number in numbers {\n        if max != nil {\n            for i in max\
    \ {\n                if number > i {\n                    max = [number]\n   \
    \                 break\n                } else {\n                    max = append(max,\
    \ number)\n                }\n            }\n        } else {\n            max\
    \ = number\n        }\n    }\n    return max", "    // TODO: Make it tail recursive\n\
    \    return rolling_max1(numbers, 0, numbers.count)", "    var result = [Int]()\n\
    \    var max = 0\n    for i in numbers {\n        if i > max {\n            result\
    \ = append(result, max)\n        }\n        max = i\n    }\n    result = append(result,\
    \ max)\n    return result", "    var max = [Int]()\n    for num in numbers {\n\
    \        max = max + (num).max()\n    }\n    return max", "    var array = [Int]()\n\
    \    var i = -1\n    for n in numbers {\n        if i < 0 {\n            i = n\n\
    \            continue\n        }\n        if n > i {\n            array.append(i)\n\
    \            i = n\n        }\n    }\n    array.append(i)\n    return array",
  "    // Return the last element in the array\n    let last = numbers.last!\n   \
    \ let length = numbers.count\n\n    // Initialize an array of max elements\n \
    \   var max = numbers.map { $0 }\n\n    // Initialize an array of number of max\
    \ elements\n    var max_num = numbers.map { $0 }\n\n    // Initialize an array\
    \ of index\n    var idx = [Int](repeating: 0, count: length)\n\n    for index\
    \ in 0..<length - 1 {\n        // Find max element in the array\n        let max_element\
    \ = max(idx, numbers.index(after: index))\n\n        // Update max elements\n\
    \        max[max_element] = numbers[max_element]\n\n        // Update max number\n\
    \        max_num[max_element] = numbers[max_element]\n\n        // Update index\n\
    \        idx[max_element] = index + max_element\n    }\n\n    // Return the max\
    \ numbers in the array\n    return max", "    var result = [Int]()\n    var current\
    \ = Int()\n    numbers.forEach({ number in\n        current = max(current, number)\n\
    \        result.append(current)\n    })\n    return result", '    return rolling_max(numbers,
    1)', "    let result = Array(repeating: -Int.max, count: numbers.count)\n    numbers.indices.forEach\
    \ {\n        result[$0] = max(result[$0], numbers[$0])\n    }\n    result", " \
    \   var maxElement = numbers[0]\n    var currentMaxElement = maxElement\n    var\
    \ index = 1\n    while currentMaxElement == maxElement {\n        if numbers[index]\
    \ > maxElement {\n            maxElement = numbers[index]\n        }\n       \
    \ index++\n    }\n    var rollingMax = [Int]()\n    rollingMax.append(maxElement)\n\
    \    index = 1\n    while index < numbers.count {\n        if numbers[index] >\
    \ maxElement {\n            rollingMax.append(maxElement)\n            index++\n\
    \        } else {\n            if numbers[index] == maxElement {\n           \
    \     currentMaxElement = numbers[index]\n                index++\n          \
    \  } else {\n                rollingMax.append(numbers[index])\n            }\n\
    \        }\n    }\n    return rollingMax", "  var result = [0]\n  for n in numbers\
    \ {\n    result.append(result[n-1] > n ? result[n-1] : n)\n  }\n  return result",
  "    var max = [Int]()\n    var index = 0\n    for value in numbers {\n        if\
    \ max != nil {\n            if max[index] < value {\n                max[index]\
    \ = value\n            }\n        }\n        index += 1\n        if index >= number.count\
    \ {\n            break\n        }\n    }\n    return max", "    var rolling_max\
    \ = Array(repeating: -1, count: numbers.count)\n    numbers.forEach { number in\n\
    \        if number > rolling_max[numbers.index(of: number)] {\n            rolling_max[numbers.index(of:\
    \ number)] = number\n        }\n    }\n    return rolling_max", "    numbers.withUnsafeBufferPointer()\
    \ { numberBufferPointer in\n        let count = numberBufferPointer.count\n  \
    \      let maxIndex = count - 1\n        var maxElement = numberBufferPointer.baseAddress!.advanced(by:\
    \ Int(maxIndex)).pointee\n        for number in numberBufferPointer {\n      \
    \      if number > maxElement {\n                maxElement = number\n       \
    \     }\n        }\n        return Array(maxElement.successor()..<maxElement)\n\
    \    }", '    return rolling_max(numbers, 0)', "    if numbers.isEmpty {\n   \
    \     return []\n    }\n    var max = numbers[0]\n    var max = numbers[0]\n \
    \   var min = numbers[0]\n    for number in numbers {\n        if number > max\
    \ {\n            max = number\n        }\n        if number < min {\n        \
    \    min = number\n        }\n    }\n    var result = [Int]()\n    var index =\
    \ numbers.startIndex\n    var index = numbers.startIndex\n    let number = numbers[index]\n\
    \    let limit = numbers.endIndex\n    while number != limit && index < numbers.endIndex\
    \ {\n        result.append(number)\n        number = numbers[index + 1]\n    \
    \    index++\n    }\n    return result", "    if numbers.isEmpty {\n        return\
    \ numbers\n    }\n\n    let window = numbers[numbers.count - 1]\n\n    let indexes:\
    \ [Int] = numbers.enumerated().map({ (index, number) -> Int in\n        if index\
    \ == 0 {\n            return number\n        }\n\n        let number = numbers[index\
    \ - 1]\n\n        if number > window {\n            return index\n        } else\
    \ {\n            return index - 1\n        }\n    })\n\n    var maxes = [Int]()\n\
    \n    while !indexes.isEmpty, indexes.count < numbers.count {\n        let index\
    \ = indexes[indexes.count - 1]\n\n        let number = numbers[index]\n      \
    \  let previous = numbers[index - 1]\n\n        if number > previous {\n     \
    \       maxes.append(number)\n            indexes.append(index)\n        } else\
    \ {\n            indexes.append(index)\n        }\n    }\n\n    return maxes",
  "    return numbers.sorted(by: >).reduce(into: []) { (result, element) in\n    \
    \    if result.last == nil || result.last! < element {\n            result +=\
    \ [element]\n        }\n    }", "\tvar rolling_max_elements = [Int]()\n\trolling_max_elements.append(numbers[0])\n\
    \t\n\tfor var i = 1 ; i < numbers.count ; i++ {\n\t\tif rolling_max_elements.last\
    \ < numbers[i]  {\n\t\t\trolling_max_elements.append(numbers[i])\n\t\t}\n\t}\n\
    \t\n\treturn rolling_max_elements", "\tvar maximum = numbers[0]\n\tfor _, number\
    \ in numbers.enumerated() {\n\t\tif number > maximum {\n\t\t\tmaximum = number\n\
    \t\t}\n\t}\n\treturn numbers.enumerated().map({ $0.0 == 0 ? $0.1 : $0.0 }).joined()",
  "    var max_so_far = numbers.first!\n    return numbers.enumerated().map { i, _\
    \ in\n        let current_max = numbers[i]\n        max_so_far = max(current_max,\
    \ max_so_far)\n        return max_so_far\n    }", "\tvar maximum = 0\n\tvar rolling_max\
    \ = [Int]()\n\tfor number in numbers {\n\t\tmaximum = maximum < number ? maximum\
    \ : number\n\t\tif maximum < number {\n\t\t\trolling_max = append(rolling_max,\
    \ number)\n\t\t}\n\t}\n\treturn rolling_max", "    var rolling = [0]\n    for\
    \ number in numbers {\n        if number == rolling[0] {\n            continue\n\
    \        }\n        rolling[0] += number\n    }\n    return rolling", "    var\
    \ max_rolling = numbers[0]\n    var max_so_far = numbers[0]\n    for i in 1 ..<\
    \ numbers.count {\n        if numbers[i] > max_so_far {\n            max_rolling\
    \ = max_so_far\n            max_so_far = numbers[i]\n        } else if numbers[i]\
    \ > max_rolling {\n            max_rolling = numbers[i]\n        }\n    }\n  \
    \  return max_rolling", "    var max = -9999999999\n    var rolling_max = -9999999999\n\
    \    for n in numbers {\n        if n >= max {\n            max = n\n        }\
    \ else {\n            rolling_max = n\n        }\n    }\n    return rolling_max",
  "    var max: Int? = nil\n    var rollingMax: [Int] = []\n    var i: Int = 0\n \
    \   for n in numbers {\n        if n == max {\n            rollingMax.append(n)\n\
    \        }\n        else {\n            if let m = max {\n                if rollingMax.contains(m)\
    \ {\n                    continue\n                }\n            }\n        \
    \    rollingMax.append(n)\n            max = n\n        }\n        i += 1\n  \
    \  }\n    return rollingMax", "    var max_so_far = 0\n    for number in numbers\
    \ {\n        max_so_far = max(number, max_so_far)\n    }\n    return Array(0..<numbers.count).map\
    \ { i in\n        return max_so_far\n    }", '    return rolling_max(numbers,
    1, 0)', "    let (min, max) = numbers.minMax()\n    var maxIndex = 0\n\n    for\
    \ number in numbers {\n        if number > max {\n            maxIndex = numbers.indexOf(max)\n\
    \        }\n\n        if number < min {\n            continue\n        }\n\n \
    \       if number == max {\n            maxIndex += 1\n        }\n\n        if\
    \ number == min {\n            maxIndex -= 1\n        }\n\n        let index =\
    \ numbers.indexOf(number, maxIndex)\n\n        if index == 0 {\n            numbers[index]\
    \ = number\n        }\n    }\n\n    return numbers", "    var maxIndex = 0\n \
    \   var max = 0\n    var maxValue = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] >= maxValue {\n            maxValue = numbers[i]\n\
    \            maxIndex = i\n        }\n    }\n    let rollingMax = [Int](repeating:\
    \ numbers[maxIndex], count: numbers.count - maxIndex + 1)\n    return rollingMax",
  "    var max = numbers[0]\n    var max_indexes: [Int] = []\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > max {\n            max = numbers[i]\n           \
    \ max_indexes = [i]\n        } else if numbers[i] == max {\n            max_indexes.append(i)\n\
    \        }\n    }\n    return max_indexes", "    var max = numbers[0]\n    var\
    \ maxIdx = 0\n    for idx in 1...numbers.count {\n        if numbers[idx] > max\
    \ {\n            max = numbers[idx]\n            maxIdx = idx\n        }\n   \
    \ }\n    numbers[maxIdx] = max\n    return numbers", "    // Scan array from left\
    \ until reach the maximum element, then the maximum element is the right\n   \
    \ // element to the left. So we scan array from right to left to find the maximum\
    \ element in O(n)\n    return scan(numbers, 0, numbers.count - 1)", '    return
    rolling_max(numbers, 0)', "    var index = 0\n    var max = 0\n    var rollingMax\
    \ = [Int]()\n\n    while index < numbers.count {\n        max = numbers[index]\n\
    \        if max < rollingMax.last {\n            rollingMax.append(max)\n    \
    \    } else {\n            if rollingMax.last < max {\n                rollingMax.insert(max,\
    \ at: 0)\n            }\n        }\n        index += 1\n    }\n    return rollingMax",
  "    if numbers.isEmpty {\n        return []\n    }\n\n    var maxValue = numbers[0]\n\
    \    var rollingMaxNumber = numbers[0]\n    for number in numbers {\n        if\
    \ number > rollingMaxNumber {\n            rollingMaxNumber = number\n       \
    \ }\n\n        if number > maxValue {\n            maxValue = number\n       \
    \ }\n    }\n\n    return Array(maxValue .. rollingMaxNumber)", "    var max =\
    \ numbers.max()!\n    var rolling_max = [Int](repeating: 0, count: numbers.count)\n\
    \    for number in numbers {\n        if number > max {\n            max = number\n\
    \        }\n        rolling_max[numbers.index(number)] = max\n    }\n    return\
    \ rolling_max", "    var max = [Int]()\n    var min = [Int]()\n    var cur = 0\n\
    \n    for v in numbers {\n        max = [v] + max\n        min = [v] + min\n \
    \   }\n    max = max.sorted()\n    min = min.sorted()\n    for idx in 0..<(max.count)\
    \ {\n        cur = max[idx] + min[idx]\n        if cur >= numbers[idx] {\n   \
    \         max[idx] = cur\n        } else {\n            min[idx] = cur\n     \
    \   }\n    }\n    return max", "    if numbers.isEmpty {\n        return []\n\
    \    }\n\n    var max: Int?\n    var maxIndex: Int?\n\n    for index in stride(from:\
    \ 0, to: numbers.count, by: 1) {\n        if max != nil && numbers[index] > max!\
    \ {\n            maxIndex = index\n        }\n        if max != nil && numbers[index]\
    \ == max! {\n            if maxIndex != nil {\n                return [max!, numbers[maxIndex!]]\n\
    \            } else {\n                return [max!]\n            }\n        }\
    \ else {\n            max = numbers[index]\n            maxIndex = index\n   \
    \     }\n    }\n\n    return []", "  var rollingMax = numbers[0]\n  for number\
    \ in numbers {\n    if number > rollingMax {\n      rollingMax = number\n    }\n\
    \  }\n  return rollingMax", "    var maximum = numbers.minElement()!\n    var\
    \ output = [Int]()\n    for i in 0..<numbers.count {\n        if numbers[i] >=\
    \ maximum {\n            output.append(numbers[i])\n        }\n        else {\n\
    \            output.append(maximum)\n        }\n        maximum = max(numbers[i],\
    \ maximum)\n    }\n    return output", "    var max = numbers[0]\n    var max_rolling\
    \ = [Int](repeating: 0, count: numbers.count)\n    var current_rolling = max_rolling\n\
    \    for (index, number) in numbers.enumerated() {\n        current_rolling[index]\
    \ = max\n        if max < number {\n            max = number\n        }\n    }\n\
    \    return max_rolling", "    var rolling_max: [Int] = []\n    var max_count\
    \ = 0\n    for n in numbers {\n        if rolling_max[rolling_max.count-1] ==\
    \ n {\n            max_count += 1\n        } else {\n            rolling_max[rolling_max.count-1]\
    \ = n\n            max_count = 1\n        }\n        if max_count > numbers.count\
    \ {\n            break\n        }\n    }\n    return rolling_max", "    if numbers.isEmpty\
    \ {\n        return numbers\n    }\n    var maxValue = numbers.max()!\n    var\
    \ maxIndex: Int? = numbers.firstIndex(of: maxValue)\n    for i in 1...numbers.count\
    \ {\n        if numbers[i-1] != maxValue {\n            maxValue = numbers[i-1]\n\
    \            maxIndex = i\n        }\n    }\n    return maxIndex == nil ? numbers\
    \ : numbers[maxIndex!...numbers.endIndex]", "    var max_val: Int = 0\n    var\
    \ max_val_index = 0\n    var result = [Int]()\n\n    for number in numbers {\n\
    \        if number > max_val {\n            max_val = number\n            max_val_index\
    \ = result.count\n            result[max_val_index] = number\n        }\n    }\n\
    \n    return result", "    var result: [Int] = []\n    for i in 0..<numbers.count\
    \ {\n        if numbers.count <= i {\n            break\n        }\n        result.append(numbers.last!)\n\
    \        numbers.removeLast()\n    }\n    return result", "\tvar result = [Int]()\n\
    \tvar maxIndex = 0\n\tvar maxValue = numbers[0]\n\tnumbers.forEach { value in\n\
    \t\tif value > maxValue {\n\t\t\tmaxIndex = result\n\t\t\tmaxValue = value\n\t\
    \t} else {\n\t\t\tresult.insert(maxIndex, value)\n\t\t}\n\t}\n\treturn result",
  "    var result = numbers\n    for rollingMax := 0; rollingMax < numbers.count;\
    \ rollingMax++ {\n        var max = numbers[rollingMax]\n        for currentIndex\
    \ := rollingMax + 1; currentIndex < numbers.count; currentIndex++ {\n        \
    \    if numbers[currentIndex] > max {\n                max = numbers[currentIndex]\n\
    \            }\n        }\n        result.append(max)\n    }\n    return result",
  "    var result: [Int] = []\n    var maxNumber = numbers[0]\n    for number in numbers\
    \ {\n        if number > maxNumber {\n            result.append(number)\n    \
    \    } else {\n            maxNumber = number\n        }\n    }\n    return result",
  "    var max = numbers[0]\n    var indexes = [Int]()\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > max {\n            max = numbers[i]\n           \
    \ indexes.removeAll()\n            indexes.append(i)\n        }\n    }\n    return\
    \ maxElements(numbers, indexes)", "  var result: [Int] = []\n  var min: Int? =\
    \ nil\n  var max: Int? = nil\n  for n in numbers {\n    if min == nil || n < min\
    \ {\n      min = n\n    }\n    if max == nil || n > max {\n      max = n\n   \
    \ }\n  }\n  for n in numbers {\n    if n <= max {\n      result.insert(n, at:\
    \ 0)\n    }\n  }\n  if min != nil && max != nil {\n    result.insert(min, at:\
    \ 0)\n    result.insert(max, at: 0)\n  }\n  return result", '    return rolling_max_helper(numbers)',
  "    var rollingMax = [Int]()\n    \n    for i in 0 ..< numbers.count {\n      \
    \  if rollingMax.contains(numbers[i]) {\n            continue\n        } else\
    \ {\n            rollingMax.append(numbers[i])\n        }\n    }\n    \n    return\
    \ rollingMax", "    var maximum = numbers[0]\n    var rollingMax = [Int]()\n\n\
    \    for i in 1..<numbers.count {\n        if numbers[i-1] > maximum {\n     \
    \       rollingMax.append(maximum)\n        } else {\n            rollingMax.append(numbers[i])\n\
    \        }\n\n        maximum = numbers[i]\n    }\n\n    return rollingMax", " \
    \   var max_so_far = numbers[0]\n    var max_to_add = numbers[0]\n    for n in\
    \ numbers {\n        if max_so_far < n {\n            max_so_far = n\n       \
    \ }\n        if n > max_to_add {\n            max_to_add = n\n        }\n    }\n\
    \    return [max_so_far, max_to_add]", "    \n    var maximum: Int?\n    for number\
    \ in numbers {\n        \n        guard number > 0 else {\n            return\
    \ numbers\n        }\n        \n        let maximumIndex = numbers.firstIndex(of:\
    \ number) + numbers.firstIndex(of: maximum!)\n        \n        maximum = numbers[maximumIndex]\n\
    \        \n    }\n    \n    return numbers", "    var max_element = 0\n    var\
    \ max_rolling_max_element = max_element\n\n    for num in numbers {\n        if\
    \ num > max_element {\n            max_element = num\n        } else {\n     \
    \       max_element = max(max_element, num)\n        }\n\n        if max_rolling_max_element\
    \ < max_element {\n            max_rolling_max_element = max_element\n       \
    \ }\n    }\n    return Array(repeating: max_rolling_max_element, count: numbers.count)",
  "    var largest = 0\n    var largestIndex = 0\n    for index in 0..<numbers.count\
    \ {\n        if numbers[index] > largest {\n            largest = numbers[index]\n\
    \            largestIndex = index\n        }\n    }\n\n    var largests = [Int]()\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] == largest {\n      \
    \      largests += [largest]\n        }\n    }\n    return largests", "    var\
    \ max = [Int]()\n    var rollingMax = [Int]()\n    var maxIndex = 0\n    var sum\
    \ = 0\n    for i in 0..<numbers.count {\n        sum += numbers[i]\n        rollingMax.append(0)\n\
    \        if sum >= numbers[i] {\n            rollingMax[maxIndex] = numbers[i]\n\
    \            maxIndex += 1\n        }\n    }\n    for i in 0..<maxIndex {\n  \
    \      max = append(max, rollingMax[i])\n    }\n    return max", "    if numbers.isEmpty\
    \ {\n        return []\n    }\n    var max_index = numbers.startIndex\n    var\
    \ max_number = numbers[0]\n    for index in numbers[1...] {\n        if max_number\
    \ < numbers[index] {\n            max_index = index\n            max_number =\
    \ numbers[index]\n        }\n    }\n    var result = [Int](repeating: max_number,\
    \ count: numbers.count - max_index)\n    result.append(max_number)\n    return\
    \ result", "    var res = Int()\n    var max = Int()\n    for num in numbers {\n\
    \        if num > max {\n            max = num\n        }\n    }\n    for num\
    \ in numbers {\n        if num > max {\n            res = res\n        } else\
    \ {\n            res = num > res ? num : res\n        }\n    }\n    return res",
  "    var result = [Int]()\n    var currentMax = numbers[0]\n    for number in numbers\
    \ {\n        if number > currentMax {\n            result.append(currentMax)\n\
    \        }\n        currentMax = number\n    }\n    result.append(currentMax)\n\
    \    return result", "    let length = numbers.count\n    var result = Array(repeating:\
    \ -1, count: length)\n    for idx in 0..<length {\n        let window = numbers[0..<idx]\n\
    \        let currentMax = window.max()!\n        result[idx] = currentMax\n  \
    \  }\n    return result", '    return rolling_max(numbers, to: Date())', "   \
    \ var max_number: Int = numbers.reduce(0, {$0 > $1.0 ? $0 : $1})\n    var max_index_to_keep:\
    \ Int = 0\n    for (_, index) in numbers.enumerated() {\n        if index == max_index_to_keep\
    \ {\n            continue\n        }\n        max_number = numbers[index]\n  \
    \      max_index_to_keep = index\n    }\n    var output = [Int]()\n    for (_,\
    \ index) in numbers.enumerated() {\n        if index == max_index_to_keep {\n\
    \            output.append(numbers[index])\n        } else {\n            output.append(numbers[index])\n\
    \        }\n    }\n    return output", "    var results = [Int]()\n    var rollingMaxValue\
    \ = numbers[0]\n    for i in numbers.indices {\n        if numbers[i] > rollingMaxValue\
    \ {\n            rollingMaxValue = numbers[i]\n            results.append(numbers[i])\n\
    \        }\n    }\n    return results", "    var rollingMax = [Int]()\n    for\
    \ number in numbers {\n        if rollingMax.count < number {\n            rollingMax.append(number)\n\
    \        } else {\n            if rollingMax[rollingMax.count - 1] < number {\n\
    \                rollingMax[rollingMax.count - 1] = number\n            }\n  \
    \      }\n    }\n    return rollingMax", "    var max = numbers[0]\n    var maxIndex\
    \ = numbers.startIndex\n    for i in numbers.indices {\n        if maxIndex -\
    \ i < max {\n            max = numbers[i] - numbers[i-maxIndex]\n            maxIndex\
    \ = i\n        }\n    }\n    return numbers[maxIndex..<numbers.endIndex]", '    return
    window(numbers, 1, 1).reduce(&max).reversed()', "    var rolling_max = [Int]()\n\
    \    for number in numbers {\n        if rolling_max[rolling_max.count-1] < number\
    \ {\n            rolling_max[rolling_max.count-1] = number\n        }\n    }\n\
    \    return rolling_max", "    var rolling_max = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > rolling_max {\n            rolling_max = numbers[i]\n\
    \        }\n    }\n    return rolling_max", "    var rollingMax = [Int]()\n  \
    \  for number in numbers {\n        rollingMax.append(max(rollingMax.last!, number))\n\
    \    }\n    return rollingMax", "    var max = numbers.slice()\n    for number\
    \ in numbers {\n        if number > max[0] {\n            max = number\n     \
    \   }\n    }\n    return max", "    var result: [Int] = []\n    let count = (numbers.count)\
    \ - 1\n\n    for number in numbers {\n        let index = numbers.index(of: number)!\n\
    \        result.append(numbers[index])\n        if index == 0 {\n            continue\n\
    \        }\n\n        for _ in 0 ..< count {\n            result.append(numbers[index\
    \ - 1])\n        }\n    }\n    return result", "    let maxIndexes = stride(from:\
    \ numbers.startIndex, to: numbers.endIndex, by: -1).map{ numbers.firstIndex(of:\
    \ $0) }\n    var maxs = [Int]()\n    for i in maxIndexes {\n        if i == numbers.endIndex\
    \ {\n            break\n        }\n        let index = numbers.index(before: i)\n\
    \        maxs.append(numbers[index])\n    }\n    return maxs", "    var max_number\
    \ = numbers[0]\n    var rolling_max_numbers = [Int]()\n    var max_rolling_numbers\
    \ = [Int]()\n    numbers.forEach { number in\n        if number > max_number {\n\
    \            rolling_max_numbers.append(max_number)\n            max_number =\
    \ number\n        } else {\n            max_number = number\n        }\n    }\n\
    \    rolling_max_numbers.append(max_number)\n    return rolling_max_numbers",
  "    var max = [Int]()\n    for i in numbers {\n        if i.isGreaterThan(max.last!)\
    \ {\n            max.append(i)\n        }\n    }\n    return max", '    return
    rolling_max(numbers, numbers)', "    var rolling_max = [Int]()\n    \n    for\
    \ number in numbers {\n        if rolling_max.contains(number) {\n           \
    \ continue\n        } else {\n            rolling_max.append(number)\n       \
    \ }\n    }\n    \n    return rolling_max", "    var max: Int = 0\n    return numbers.map\
    \ { number in\n        if number > max {\n            max = number\n        }\n\
    \        return number\n    }", "    let sum = numbers.reduce(0, {\n        (res,\
    \ value) -> Int in\n        guard value > res else {\n            return value\n\
    \        }\n        return res\n    })\n\n    var maximums = [Int](repeating:\
    \ -Int.max, count: numbers.count)\n    for index, _ in enumerate(numbers) {\n\
    \        maximums[index] = numbers[index] + sum\n    }\n\n    return maximums.prefix(numbers.count)",
  "    var max = [Int](repeating: 0, count: numbers.count)\n    var max = max[0]\n\
    \    for i in numbers {\n        if max < i {\n            max = i\n        }\n\
    \    }\n    return max", "    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        max = number > max ? number : max\n        result.append(max)\n\
    \    }\n    return result", '    return rolling_max(numbers, 0...numbers.count-1)',
  "    let length = numbers.count\n    var rollingMax: [Int] = [Int](repeating: 0,\
    \ count: length)\n    for i in 0..<numbers.count {\n        rollingMax[i] = max(numbers[i],\
    \ rollingMax[i-1])\n    }\n    return rollingMax", "    var max = 0\n    var array\
    \ = [Int]()\n    var sum = 0\n\n    for n in numbers {\n        sum += n\n   \
    \     if sum > max {\n            max = sum\n            array = numbers\n   \
    \     }\n    }\n\n    return array", "    if numbers.isEmpty {\n        return\
    \ []\n    }\n    \n    var maximum = numbers.reduce(Int.min, by: 0)\n    \n  \
    \  var max = maximum\n    var result: [Int] = []\n    \n    for number in numbers\
    \ {\n        if number > maximum {\n            result.append(max)\n         \
    \   max = number\n        } else {\n            max = number\n        }\n    }\n\
    \    \n    return result", '    return rolling_max(numbers, min: 1, max: numbers.count)',
  "    var result: [Int] = [0]\n    var rollingMax: Int? = nil\n    for number in\
    \ numbers {\n        rollingMax = result.remove(at: result.index(of: number))\n\
    \        if let rollingMax = rollingMax {\n            result.append(rollingMax)\n\
    \        } else {\n            result.append(number)\n        }\n    }\n    return\
    \ result", "    guard numbers.count > 0 else {\n        return []\n    }\n   \
    \ \n    var result = [Int]()\n    var highestValue = numbers[0]\n    var currentValue\
    \ = 0\n    var currentMax = 0\n    \n    for number in numbers {\n        if number\
    \ > highestValue {\n            highestValue = number\n        }\n        \n \
    \       if number == highestValue {\n            currentValue += 1\n        }\
    \ else {\n            result.appendInt(currentValue)\n            currentValue\
    \ = highestValue + 1\n            currentMax = highestValue\n        }\n    }\n\
    \    result.appendInt(currentValue)\n    \n    return result", '    return rolling_max(numbers,
    1)', "    var result = [Int]()\n    var maxIndexes = [Int]()\n\n    for number\
    \ in numbers {\n        let index = maxIndexes.firstIndex(of: number)\n      \
    \  if index == nil {\n            result.append(number)\n            maxIndexes.append(number)\n\
    \        } else {\n            result[index!] = number\n            maxIndexes[index!]\
    \ = number\n        }\n    }\n\n    return result", "    var max = [Int]()\n\n\
    \    if numbers.isEmpty {\n        return max\n    }\n\n    for var i = 0; i <\
    \ numbers.count - 1 {\n        let last = numbers[i]\n        var current = numbers[i\
    \ + 1]\n\n        while current > last {\n            current = current.prefix(by:\
    \ 1)\n        }\n\n        max[i] = current\n    }\n\n    return max", "    var\
    \ rolling_max = [Int]()\n    for number in numbers {\n        if let index = rolling_max.index(of:\
    \ number) {\n            rolling_max[index] = max(rolling_max[index], number)\n\
    \        } else {\n            rolling_max.append(number)\n        }\n    }\n\
    \    return rolling_max", "    rolling_max = numbers.reduce([]) { (rolling_max,\
    \ currentValue) in\n        if rolling_max == nil || rolling_max.last < currentValue\
    \ {\n            rolling_max.append(currentValue)\n        } else {\n        \
    \    rolling_max.append(rolling_max.last)\n        }\n        return rolling_max\n\
    \    }\n    return rolling_max", "    return numbers.reduce([]) { (acc, x) ->\
    \ [Int] in\n        if let idx = acc.firstIndex(where: { $0 > x }) {\n       \
    \     acc[idx] = acc[idx] > x ? acc[idx] : x\n        }\n        else { acc.append(x)\
    \ }\n        return acc\n    }", "    return numbers.reduce(0, { maxElement, element\
    \ in\n        let maxIndex = numbers.indexOf(maxElement)\n        let newMaxIndex\
    \ = maxIndex + rollingMaxSteps\n        return maxElement > element\n        \
    \    ? maxElement\n            : element > numbers[newMaxIndex]\n            \
    \    ? element\n                : numbers[newMaxIndex]\n    })", "    guard !numbers.isEmpty\
    \ else {\n        return []\n    }\n    return numbers.reduce { $0 < $1 ? $0 :\
    \ $1 }", "    let rolling_max = numbers.map { rolling_max($0, times: numbers.size)\
    \ }\n    return rolling_max.joined()", "    var result: [Int] = numbers\n    for\
    \ _ in 0 ..< numbers.count {\n        let max = numbers.max()!\n        result.remove(at:\
    \ result.index(of: max)!)\n    }\n    return result", "    var rollingMax: [Int]\
    \ = [0]\n    for i in numbers {\n        rollingMax.append(rollingMax.last! >\
    \ i ? rollingMax.last! : i)\n    }\n    return rollingMax"]
stop_tokens:
- "\n}"
