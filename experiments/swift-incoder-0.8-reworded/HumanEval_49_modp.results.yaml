language: swift
name: HumanEval_49_modp
results:
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch n {\n\tcase 0:\n\t\treturn 0\n\t\
    case p:\n\t\treturn 1\n\tcase p:\n\t\treturn 0\n\tdefault:\n\t\treturn Int((p\
    \ - 1) * n / p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp47cp8zvr/tmp47cp8zvr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c30871c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c30568b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c30568988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c305677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp47cp8zvr                        0x000055d099c6437d <unavailable> + 4989

    5    libc.so.6                          0x00002b5c30a5d460 __libc_start_main +
    245

    6    tmp47cp8zvr                        0x000055d099c64029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n == 0: return 1\n\tcase\
    \ n < 0: return modp(abs(n), p)\n\tcase p < 0: return modp(n, -p)\n\t}\n\treturn\
    \ powMod(n, p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptfoct4_1.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmptfoct4_1.swift:16:25: error: missing\
    \ argument labels 'n:p:' in call\n        case n < 0: return modp(abs(n), p)\n\
    \                               ^\n                                n:      p:\
    \ \n/tmp/tmptfoct4_1.swift:17:25: error: missing argument labels 'n:p:' in call\n\
    \        case p < 0: return modp(n, -p)\n                               ^\n  \
    \                              n: p: \n/tmp/tmptfoct4_1.swift:19:9: error: cannot\
    \ find 'powMod' in scope\n        return powMod(n, p, p)\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tvar q\
    \ = p / 2\n\tvar r = p % 2\n\tswitch {\n\tcase n == p:\n\t\treturn 1\n\tcase n\
    \ < p:\n\t\tq = q - 1\n\t\tr = p - q\n\t\tif r > 0 {\n\t\t\treturn r + modp(n,\
    \ q)\n\t\t}\n\tdefault:\n\t\tq = q + 1\n\t\tr = p - q\n\t\tif r > 0 {\n\t\t\t\
    return r + modp(n, q)\n\t\t}\n\t}\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyveybie4.swift:19:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyveybie4.swift:26:19: error: missing\
    \ argument labels 'n:p:' in call\n                        return r + modp(n, q)\n\
    \                                       ^\n                                  \
    \      n: p: \n/tmp/tmpyveybie4.swift:32:19: error: missing argument labels 'n:p:'\
    \ in call\n                        return r + modp(n, q)\n                   \
    \                    ^\n                                        n: p: \n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n *= -p\n    }\n \
    \   if p < 2 {\n        p *= 2\n    }\n    if p > p {\n        return p - 1\n\
    \    }\n    var mod = p\n    var d = n\n    while n > 0 {\n        mod %= p\n\
    \        n /= p\n        d *= p\n    }\n    if d == 1 && mod != 1 {\n        return\
    \ mod\n    }\n    return mod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0663nwsj.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n *= -p\n        ~ ^\n/tmp/tmp0663nwsj.swift:18:11:\
    \ error: left side of mutating operator isn't mutable: 'p' is a 'let' constant\n\
    \        p *= 2\n        ~ ^\n/tmp/tmp0663nwsj.swift:27:11: error: left side of\
    \ mutating operator isn't mutable: 'n' is a 'let' constant\n        n /= p\n \
    \       ~ ^\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let n = n & Mask(p)\n    let p = p & Mask(p)\n\
    \    let result = p + (n & Mask(p))\n    result %= p\n    return result | Mask(p)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc8776i13.swift:14:17: error: cannot find 'Mask' in scope\n    let\
    \ n = n & Mask(p)\n                ^~~~\n/tmp/tmpc8776i13.swift:15:17: error:\
    \ cannot find 'Mask' in scope\n    let p = p & Mask(p)\n                ^~~~\n\
    /tmp/tmpc8776i13.swift:16:27: error: cannot find 'Mask' in scope\n    let result\
    \ = p + (n & Mask(p))\n                          ^~~~\n/tmp/tmpc8776i13.swift:18:21:\
    \ error: cannot find 'Mask' in scope\n    return result | Mask(p)\n          \
    \          ^~~~\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch n {\n    case 0: return 0\n   \
    \ case 1: return p\n    case 2: return n\n    case 3: return p + (n & 1)\n   \
    \ case 4: return p + (n & 2)\n    case 5: return p + (n & 3)\n    case 6: return\
    \ p + (n & 4)\n    case 7: return p + (n & 5)\n    case 8: return p + (n & 6)\n\
    \    case 9: return p + (n & 7)\n    case 10: return p + (n & 8)\n    case 11:\
    \ return p + (n & 9)\n    case 12: return p + (n & 10)\n    case 13: return p\
    \ + (n & 11)\n    case 14: return p + (n & 12)\n    case 15: return p + (n & 13)\n\
    \    case 16: return p + (n & 14)\n    case 17: return p + (n & 15)\n    case\
    \ 18: return p + (n & 16)\n    case 19: return p + (n & 17)\n    case 20: return\
    \ p + (n & 18)\n    case 21: return p + (n & 19)\n    case 22: return p + (n &\
    \ 20)\n    case 23: return p + (n & 21)\n    case 24: return p + (n & 22)\n  \
    \  case 25: return p + (n & 23)\n    case 26: return p + (n & 24)\n    case 27:\
    \ return p + (n & 25)\n    case 28: return p + (n & 26)\n    case 29: return p\
    \ + (n & 27)\n    case 30: return p + (n & 28)\n    case 31: return p + (n & 29)\n\
    \    case 32: return p + (n & 30)\n    case 33: return p + (n & 31)\n    case\
    \ 34: return p + (n & 32)\n    case 35: return p + (n & 33)\n    case 36: return\
    \ p + (n & 34)\n    case 37: return p + (n & 35)\n    case 38: return p + (n &\
    \ 36)\n    case 39: return p + (n & 37)\n    case 40: return p + (n & 38)\n  \
    \  case 41: return p + (n & 39)\n    case 42: return p + (n & 40)\n    case 43:\
    \ return p + (n & 41)\n    case 44: return p + (n & 42)\n    case 45: return p\
    \ + (n & 43)\n    case 46: return p + (n & 44)\n    case 47: return p + (n & 45)\n\
    \    case 48: return p + (n & 46)\n    case 49: return p + (n & 47)\n    case\
    \ 50: return p + (n & 48)\n    case 51: return p + (n & 49)\n    case 52: return\
    \ p + (n & 50)\n    case 53: return p + (n & 51)\n    case 54: return p + (n &\
    \ 5\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc54xxszc.swift:70:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpc54xxszc.swift:69:25: note: to match this opening '('\n    case 54:\
    \ return p + (n & 5\n                        ^\n/tmp/tmpc54xxszc.swift:91:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpc54xxszc.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpc54xxszc.swift:14:5: error: switch must be exhaustive\n\
    \    switch n {\n    ^\n/tmp/tmpc54xxszc.swift:14:5: note: do you want to add\
    \ a default clause?\n    switch n {\n    ^\n/tmp/tmpc54xxszc.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < p {\n        return 0\n    }\n\
    \    // The algorithm implemented below is incomplete, it is only intended\n \
    \   // to convey an idea of what can be done to reduce modulo p to n.\n    var\
    \ q: Int\n    if n > p {\n        q = p % n\n    } else {\n        q = 0\n   \
    \ }\n    var x = 1\n    for _ in 0 .. (p - n) {\n        x = x * q\n        q\
    \ += 1\n    }\n    return x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptu0rvisb.swift:26:16: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for _ in 0 .. (p - n) {\n               ^~\n      \
    \         ...\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return n & (p ^ n) < 0 ? n | p : n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpx8x404jq/tmpx8x404jq.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d5bbc1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d5b8b8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d5b8b8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d5b8b77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx8x404jq                        0x00005562a44b023d <unavailable> + 4669

    5    libc.so.6                          0x00002b0d5bdad460 __libc_start_main +
    245

    6    tmpx8x404jq                        0x00005562a44afe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n >= 0 {\n        if n == p {\n   \
    \         return n\n        }\n        return p - modp(n - p, p)\n    }\n    return\
    \ modp((p - 1) * (p + 1), p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp73_a1vpv.swift:18:24: error: missing argument labels 'n:p:' in\
    \ call\n        return p - modp(n - p, p)\n                       ^\n        \
    \                n:     p: \n/tmp/tmp73_a1vpv.swift:20:16: error: missing argument\
    \ labels 'n:p:' in call\n    return modp((p - 1) * (p + 1), p)\n             \
    \  ^\n                n:                 p: \n"
  stdout: ''
  timestamp: 1660015063
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet r = p % n\n\tif r == 0 {\n\t\treturn\
    \ 1\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp1je8zsv8/tmp1je8zsv8.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d69da6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d69a9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d69a9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d69a9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1je8zsv8                        0x0000564ef241224d <unavailable> + 4685

    5    libc.so.6                          0x00002b9d69f92460 __libc_start_main +
    245

    6    tmp1je8zsv8                        0x0000564ef2411ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015063
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 { return 1 }\n    if n == 1\
    \ { return n }\n    let mask = (p - 1) << (n - 1)\n    return (n & mask) % (p\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpvg2rvsm_/tmpvg2rvsm_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a9a9e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a9a6d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a9a6d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a9a6d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvg2rvsm_                        0x000055fc5d55924d <unavailable> + 4685

    5    libc.so.6                          0x00002b0a9abcc460 __libc_start_main +
    245

    6    tmpvg2rvsm_                        0x000055fc5d558ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tvar res = 0\n\tfor i := 0; i < n; i++ {\n\
    \t\tres += p\n\t\tp %= p\n\t}\n\treturn res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1plb47xb.swift:15:9: error: expected type\n        for i := 0;\
    \ i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp1plb47xb.swift:15:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < n; i++\
    \ {\n               ^\n/tmp/tmp1plb47xb.swift:15:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := 0; i < n; i++ {\n               ^\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase p < 0:\n\t\treturn modp(abs(n), -p)\n\t}\n\tswitch {\n\tcase p ==\
    \ 0:\n\t\treturn 0\n\tcase n <= (p-1):\n\t\treturn p\n\tdefault:\n\t\ta := modp(n\
    \ / p, p)\n\t\tif a > 1 {\n\t\t\ta -= 1\n\t\t}\n\t\treturn a * p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplshpufzv.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmplshpufzv.swift:20:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmplshpufzv.swift:26:4:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       a := modp(n / p, p)\n                 ^\n                 ;\n/tmp/tmplshpufzv.swift:26:5:\
    \ error: expected expression\n                a := modp(n / p, p)\n          \
    \        ^\n/tmp/tmplshpufzv.swift:16:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp(-n, p)\n                           ^\n\
    \                            n:  p: \n/tmp/tmplshpufzv.swift:18:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), -p)\n  \
    \                         ^\n                            n:      p: \n/tmp/tmplshpufzv.swift:26:3:\
    \ error: cannot find 'a' in scope\n                a := modp(n / p, p)\n     \
    \           ^\n/tmp/tmplshpufzv.swift:27:6: error: cannot find 'a' in scope\n\
    \                if a > 1 {\n                   ^\n/tmp/tmplshpufzv.swift:28:4:\
    \ error: cannot find 'a' in scope\n                        a -= 1\n          \
    \              ^\n/tmp/tmplshpufzv.swift:30:10: error: cannot find 'a' in scope\n\
    \                return a * p\n                       ^\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(abs(n), p)\n\
    \  }\n\n  if p <= 0 {\n    return 0\n  }\n\n  if n == 0 {\n    return 1\n  }\n\
    \n  if p == 1 {\n    return n\n  }\n\n  var r = 0\n  while n > 0 {\n    n := n\
    \ / p\n    r ^= n\n  }\n  return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpneapzdmp.swift:32:6: error: consecutive statements on a line must\
    \ be separated by ';'\n    n := n / p\n     ^\n     ;\n/tmp/tmpneapzdmp.swift:32:7:\
    \ error: expected expression\n    n := n / p\n      ^\n/tmp/tmpneapzdmp.swift:15:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp(abs(n), p)\n\
    \               ^\n                n:      p: \n/tmp/tmpneapzdmp.swift:32:5: warning:\
    \ expression of type 'Int' is unused\n    n := n / p\n    ^\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tassert(n >= 0)\n\tassert(p >= 0)\n\tassert(p\
    \ < p)\n\t\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\n\tvar res = 1\n\t\n\twhile n\
    \ > 0 {\n\t\tif n&1 == 1 {\n\t\t\tres = (res*p) % p\n\t\t}\n\t\tn = n >> 1\n\t\
    }\n\t\n\treturn res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzyt3l_pj.swift:28:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = n >> 1\n                ^\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn -modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmps1bevj2j.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmps1bevj2j.swift:16:15: error: missing\
    \ argument labels 'n:p:' in call\n                return -modp(-n, p)\n      \
    \                      ^\n                             n:  p: \n"
  stdout: ''
  timestamp: 1660015063
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (p - 1) & n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpn04jtw0_/tmpn04jtw0_.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbc9c54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbc994bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbc994b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbc994a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn04jtw0_                        0x000055752aa631bd <unavailable> + 4541

    5    libc.so.6                          0x00002adbc9e40460 __libc_start_main +
    245

    6    tmpn04jtw0_                        0x000055752aa62e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015063
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 || p < 0 {\n\t\tif n == 0 {\n\t\
    \t\treturn 0\n\t\t}\n\t\treturn 1\n\t}\n\tif n <= p {\n\t\treturn n - p\n\t}\n\
    \treturn (p % n) + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmporn3qhfn/tmporn3qhfn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba0d1d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba0cec8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba0cec8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba0cec77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmporn3qhfn                        0x000055ba3e3c524d <unavailable> + 4685

    5    libc.so.6                          0x00002aba0d3bd460 __libc_start_main +
    245

    6    tmporn3qhfn                        0x000055ba3e3c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015063
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n%p + p) % p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpp1dynnxs/tmpp1dynnxs.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a1ea1dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a1e714b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a1e714988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a1e7137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp1dynnxs                        0x0000558c810eb2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1a1ec09460 __libc_start_main +
    245

    6    tmpp1dynnxs                        0x0000558c810eaef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var p = p\n    var result = 1\n    result\
    \ %= p\n    while n > 0 {\n        result *= p\n        n--\n        result %=\
    \ p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8yw0y63u.swift:19:10: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n        n--\n         ^~\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return (n * p + p) % (p * p) % p\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpblyvfr4s/tmpblyvfr4s.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b739df45c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b739dc3cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b739dc3c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b739dc3b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpblyvfr4s                        0x000055d900bb024d <unavailable> + 4685

    5    libc.so.6                          0x00002b739e131460 __libc_start_main +
    245

    6    tmpblyvfr4s                        0x000055d900bafef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n >= 0 {\n        return Int(pow(2,\
    \ Int(n)) - 1 + p)\n    }\n    if n == 0 {\n        return Int(p)\n    }\n   \
    \ if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 0 {\n        return\
    \ modp(Int(-n), p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprzq4dl80.swift:15:20: error: cannot find 'pow' in scope\n     \
    \   return Int(pow(2, Int(n)) - 1 + p)\n                   ^~~\n/tmp/tmprzq4dl80.swift:21:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n\
    \                   ^\n                    n:  p: \n/tmp/tmprzq4dl80.swift:24:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(Int(-n),\
    \ p)\n                   ^\n                    n:       p: \n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return modInt64ModInt(n, p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpy60xrl84.swift:14:10: error: cannot find 'modInt64ModInt' in scope\n\
    \  return modInt64ModInt(n, p)\n         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660015063
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet a = powMod(p, n-1, p)\n\tif a == 1 {\n\
    \t\treturn 0\n\t}\n\treturn a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfdao2ahy.swift:14:10: error: cannot find 'powMod' in scope\n  \
    \      let a = powMod(p, n-1, p)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n > p { return n }\n    if n < 0 {\
    \ return 0 }\n    if n == 0 { return 1 }\n    if n == p { return 0 }\n\n    let\
    \ dp = p\n    let dn = n - p\n    let rem = n % dp\n    return rem == 0 ? dp :\
    \ modp(rem, dp)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpm70nk7mu.swift:22:32: error: missing argument labels 'n:p:' in\
    \ call\n    return rem == 0 ? dp : modp(rem, dp)\n                           \
    \    ^\n                                n:   p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet t = n % (p - 1)\n\tlet r = t + (p -\
    \ 1)\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpvf9se91j/tmpvf9se91j.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7616eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7613e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7613e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7613e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf9se91j                        0x0000558da9e6324d <unavailable> + 4685

    5    libc.so.6                          0x00002ad7618d6460 __libc_start_main +
    245

    6    tmpvf9se91j                        0x0000558da9e62ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n > p {\n        return n % p\n   \
    \ }\n    if n < p {\n        return p - (n % p)\n    }\n    return 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpymj8bv94/tmpymj8bv94.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c9b0d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c9adccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c9adcc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c9adcb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpymj8bv94                        0x000056230b5bc24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1c9b2c1460 __libc_start_main +
    245

    6    tmpymj8bv94                        0x000056230b5bbef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return p\n    }\n\
    \    switch p {\n    case 0: return 1\n    case 1: return 0\n    case 2: return\
    \ 1\n    }\n    var result = p\n    var d = 0\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            result /= p\n            result += p\n        }\n  \
    \      d += 1\n        n /= 2\n    }\n    return (p - 1) & d\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkwmdo0i5.swift:17:5: error: switch must be exhaustive\n    switch\
    \ p {\n    ^\n/tmp/tmpkwmdo0i5.swift:17:5: note: do you want to add a default\
    \ clause?\n    switch p {\n    ^\n/tmp/tmpkwmdo0i5.swift:30:11: error: left side\
    \ of mutating operator isn't mutable: 'n' is a 'let' constant\n        n /= 2\n\
    \        ~ ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    \n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp27hm1nzb/tmp27hm1nzb.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad007423c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad00711ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad00711a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0071197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp27hm1nzb                        0x00005609281f62cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad00760f460 __libc_start_main +
    245

    6    tmp27hm1nzb                        0x00005609281f5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpirz9lrjv/tmpirz9lrjv.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0a2f67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0a2c5eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0a2c5e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0a2c5d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpirz9lrjv                        0x000055767027d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002ba0a3153460 __libc_start_main +
    245

    6    tmpirz9lrjv                        0x000055767027cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tif n < p {\n\t\treturn n\n\t}\n\tn = n % (p - 1)\n\treturn p + n - p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpz8aqxoeg.swift:20:2: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = n % (p - 1)\n        ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 { return 1 }\n    if p == 0\
    \ { return 0 }\n    var mod = 0\n    if n > p { mod += n - p }\n    mod += p -\
    \ 1\n    mod %= p\n    return mod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmprer2d8we/tmprer2d8we.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba71c6e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba71c3dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba71c3db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba71c3da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprer2d8we                        0x000055f11927e24d <unavailable> + 4685

    5    libc.so.6                          0x00002ba71c8d0460 __libc_start_main +
    245

    6    tmprer2d8we                        0x000055f11927def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return (n - n % p) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpilxlvxpe/tmpilxlvxpe.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0f9b55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0f984cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0f984c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0f984b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpilxlvxpe                        0x000055dc69ef524d <unavailable> + 4685

    5    libc.so.6                          0x00002ad0f9d41460 __libc_start_main +
    245

    6    tmpilxlvxpe                        0x000055dc69ef4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) + p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpi95secr6/tmpi95secr6.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae846e49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae846b40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae846b40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae846b3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi95secr6                        0x000055a92d67a1bd <unavailable> + 4541

    5    libc.so.6                          0x00002ae847035460 __libc_start_main +
    245

    6    tmpi95secr6                        0x000055a92d679e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\t// This assumes n and p are both positive.\n\
    \tlet r = p % n\n\tif r == 0 || n <= 0 {\n\t\tr = 0\n\t}\n\treturn r\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4pucic6v.swift:17:3: error: cannot assign to value: 'r' is a 'let'\
    \ constant\n                r = 0\n                ^\n/tmp/tmp4pucic6v.swift:15:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let r = p % n\n    \
    \    ^~~\n        var\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 1\n\t\
    }\n\treturn powmod(n, p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsrzvv3p0.swift:17:9: error: cannot find 'powmod' in scope\n   \
    \     return powmod(n, p, p)\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \n    if n == 1 {\n        return p\n    }\n\n    if n >= p {\n        return\
    \ modp(n - 1, p) % p\n    }\n\n    // Favor modp(n - p, p) since modp(n-1, p)\
    \ is prone to overflow\n    if n >= p - p {\n        return p - (modp(n - p, p)\
    \ + 1)\n    }\n\n    return modp((n - p) / p, p)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppt25ogvd.swift:23:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) % p\n                   ^\n            \
    \        n:     p: \n/tmp/tmppt25ogvd.swift:28:25: error: missing argument labels\
    \ 'n:p:' in call\n        return p - (modp(n - p, p) + 1)\n                  \
    \      ^\n                         n:     p: \n/tmp/tmppt25ogvd.swift:31:16: error:\
    \ missing argument labels 'n:p:' in call\n    return modp((n - p) / p, p)\n  \
    \             ^\n                n:           p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n+p, p)\n    }\n    return modp(n\
    \ - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk6d77wuj.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n+p, p)\n                   ^\n                  \
    \  n:   p: \n/tmp/tmpk6d77wuj.swift:26:16: error: missing argument labels 'n:p:'\
    \ in call\n    return modp(n - p, p)\n               ^\n                n:   \
    \  p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet m = n % (p - 1)\n\t\n\tif (m > p / 2)\
    \ {\n\t\tm %= p\n\t} else {\n\t\tm += p\n\t}\n\t\n\treturn m\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmps6qnsoie.swift:17:5: error: left side of mutating operator isn't\
    \ mutable: 'm' is a 'let' constant\n                m %= p\n                ~\
    \ ^\n/tmp/tmps6qnsoie.swift:14:2: note: change 'let' to 'var' to make it mutable\n\
    \        let m = n % (p - 1)\n        ^~~\n        var\n/tmp/tmps6qnsoie.swift:19:5:\
    \ error: left side of mutating operator isn't mutable: 'm' is a 'let' constant\n\
    \                m += p\n                ~ ^\n/tmp/tmps6qnsoie.swift:14:2: note:\
    \ change 'let' to 'var' to make it mutable\n        let m = n % (p - 1)\n    \
    \    ^~~\n        var\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n < (p - 1) {\n\t\treturn 0\n\t}\n\tif p == 1 {\n\
    \t\treturn 1\n\t}\n\treturn modp(n-p-1, p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppripxbgu.swift:26:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n-p-1, p)\n                   ^\n                \
    \    n:     p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n-1)&(n-p))&(n|(n-1))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsie5kywo/tmpsie5kywo.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1b4ac4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1b47bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1b47bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1b47ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsie5kywo                        0x00005607d00381bd <unavailable> + 4541

    5    libc.so.6                          0x00002ae1b4cb0460 __libc_start_main +
    245

    6    tmpsie5kywo                        0x00005607d0037e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        if n >= -p {\n   \
    \         return n - p\n        }\n        return n - p + p\n    }\n    if n >=\
    \ p {\n        return n - p\n    }\n    return n - p + p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpdnb9k4r7/tmpdnb9k4r7.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac71eb02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac71e7f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac71e7f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac71e7f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdnb9k4r7                        0x000055713866923d <unavailable> + 4669

    5    libc.so.6                          0x00002ac71ecee460 __libc_start_main +
    245

    6    tmpdnb9k4r7                        0x0000557138668e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // we cannot use 'mod p' because 'mod\
    \ p' can return 0\n    // (https://bugs.swift.org/browse/SR-5866)\n    var mod\
    \ = 0\n    while n > 0 {\n        n /= p\n        mod += 1\n    }\n    return\
    \ mod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8dux6j0i.swift:18:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n /= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p < n {\n        return modp(n - p, p)\n    }\n    return p % n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmps9il7moy.swift:18:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  let m = p % n\n  if m < 0 {\n    m += n\n\
    \  }\n  return m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmy25ndnp.swift:16:7: error: left side of mutating operator isn't\
    \ mutable: 'm' is a 'let' constant\n    m += n\n    ~ ^\n/tmp/tmpmy25ndnp.swift:14:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let m = p % n\n  ^~~\n  var\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tn %= p\n\tif n == 0 || n == p {\n\t\treturn\
    \ n\n\t} else if n == p {\n\t\treturn n - 1\n\t}\n\treturn n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2rxnau58.swift:14:4: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (p & (-n)) + (((n & (-p)) | n) <<\
    \ n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpjlop9_86/tmpjlop9_86.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d0458fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d04286b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d04286988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d042857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjlop9_86                        0x0000558e4b14b1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b3d0477b460 __libc_start_main +
    245

    6    tmpjlop9_86                        0x0000558e4b14ae69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(n + \" < 0\")\n\t\
    } else if n > p {\n\t\tpanic(n + \" > \" + p)\n\t}\n\n\treturn n & ((p - 1) ^\
    \ n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj0muk72z.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(n + \" < 0\")\n                ^~~~~\n/tmp/tmpj0muk72z.swift:15:11:\
    \ error: binary operator '+' cannot be applied to operands of type 'Int' and 'String'\n\
    \                panic(n + \" < 0\")\n                      ~ ^ ~~~~~~\n/tmp/tmpj0muk72z.swift:15:11:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int), (String, String)\n                panic(n + \" < 0\")\n        \
    \                ^\n/tmp/tmpj0muk72z.swift:17:3: error: cannot find 'panic' in\
    \ scope\n                panic(n + \" > \" + p)\n                ^~~~~\n/tmp/tmpj0muk72z.swift:17:13:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \                panic(n + \" > \" + p)\n                          ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let exp = p.logBase2()\n    return pow(Int(pow(Double(n),\
    \ Double(exp))), Double(exp))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp66757qo_.swift:14:17: error: value of type 'Int' has no member\
    \ 'logBase2'\n    let exp = p.logBase2()\n              ~ ^~~~~~~~\n/tmp/tmp66757qo_.swift:15:12:\
    \ error: cannot find 'pow' in scope\n    return pow(Int(pow(Double(n), Double(exp))),\
    \ Double(exp))\n           ^~~\n/tmp/tmp66757qo_.swift:15:20: error: cannot find\
    \ 'pow' in scope\n    return pow(Int(pow(Double(n), Double(exp))), Double(exp))\n\
    \                   ^~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p < 1 {\n        return Int(p) - 1\n\
    \    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpopom5ubn/tmpopom5ubn.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab67cfdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab67ccd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab67ccd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab67ccd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopom5ubn                        0x00005629e597f3fd <unavailable> + 5117

    5    libc.so.6                          0x00002ab67d1cb460 __libc_start_main +
    245

    6    tmpopom5ubn                        0x00005629e597f029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn bits.TrailingZeros64(bits.RotateLeft64(n,\
    \ 64)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa_wm47py.swift:14:9: error: cannot find 'bits' in scope\n     \
    \   return bits.TrailingZeros64(bits.RotateLeft64(n, 64)) % p\n              \
    \ ^~~~\n/tmp/tmpa_wm47py.swift:14:30: error: cannot find 'bits' in scope\n   \
    \     return bits.TrailingZeros64(bits.RotateLeft64(n, 64)) % p\n            \
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n == 0 && p == 0: return\
    \ 1\n\tcase n >= p && n <= INT_MAX:\n\t\tif n == p { return n }\n\t\tq := n -\
    \ p\n\t\tif q <= INT_MAX { // p is prime\n\t\t\tmod := 1\n\t\t\tfor x := 1; x\
    \ < q; x++ {\n\t\t\t\tif n % (x + p) == 0 {\n\t\t\t\t\tmod *= x\n\t\t\t\t\tbreak\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\treturn mod\n\t\t}\n\t\tmod := 1\n\t\tfor x := 2; x <\
    \ q; x++ {\n\t\t\tif n % (x + p) == 0 {\n\t\t\t\tmod *= x\n\t\t\t\tbreak\n\t\t\
    \t}\n\t\t}\n\t\treturn mod\n\tdefault:\n\t\tpanic(\"modp failed\")\n\t}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzrbz89n8.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpzrbz89n8.swift:18:4: error: consecutive\
    \ statements on a line must be separated by ';'\n                q := n - p\n\
    \                 ^\n                 ;\n/tmp/tmpzrbz89n8.swift:18:5: error: expected\
    \ expression\n                q := n - p\n                  ^\n/tmp/tmpzrbz89n8.swift:20:7:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \               mod := 1\n                           ^\n                     \
    \      ;\n/tmp/tmpzrbz89n8.swift:20:8: error: expected expression\n          \
    \              mod := 1\n                            ^\n/tmp/tmpzrbz89n8.swift:21:11:\
    \ error: expected type\n                        for x := 1; x < q; x++ {\n   \
    \                            ^\n                                <#type#>\n/tmp/tmpzrbz89n8.swift:21:11:\
    \ error: expected 'in' after for-each pattern\n                        for x :=\
    \ 1; x < q; x++ {\n                               ^\n/tmp/tmpzrbz89n8.swift:21:11:\
    \ error: expected Sequence expression for for-each loop\n                    \
    \    for x := 1; x < q; x++ {\n                               ^\n/tmp/tmpzrbz89n8.swift:29:6:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       mod := 1\n                   ^\n                   ;\n/tmp/tmpzrbz89n8.swift:29:7:\
    \ error: expected expression\n                mod := 1\n                    ^\n\
    /tmp/tmpzrbz89n8.swift:30:10: error: expected type\n                for x := 2;\
    \ x < q; x++ {\n                       ^\n                        <#type#>\n/tmp/tmpzrbz89n8.swift:30:10:\
    \ error: expected 'in' after for-each pattern\n                for x := 2; x <\
    \ q; x++ {\n                       ^\n/tmp/tmpzrbz89n8.swift:30:10: error: expected\
    \ Sequence expression for for-each loop\n                for x := 2; x < q; x++\
    \ {\n                       ^\n/tmp/tmpzrbz89n8.swift:18:3: error: cannot find\
    \ 'q' in scope\n                q := n - p\n                ^\n/tmp/tmpzrbz89n8.swift:19:6:\
    \ error: cannot find 'q' in scope\n   "
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n <= 0 {\n        return 0\n    }\n\
    \    if n > p { // n must be > p\n        return mod(n)\n    }\n    n %= p\n \
    \   if n == 0 {\n        return 0\n    }\n    if n >= p {\n        return mod(p)\n\
    \    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpz2vm6ha7.swift:18:16: error: cannot find 'mod' in scope\n     \
    \   return mod(n)\n               ^~~\n/tmp/tmpz2vm6ha7.swift:20:7: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n    n %= p\n\
    \    ~ ^\n/tmp/tmpz2vm6ha7.swift:25:16: error: cannot find 'mod' in scope\n  \
    \      return mod(p)\n               ^~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn\
    \ n + (p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpzzf2wqed/tmpzzf2wqed.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aec4240ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec42101b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec42101988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec421007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzzf2wqed                        0x0000561b0829f1bd <unavailable> + 4541

    5    libc.so.6                          0x00002aec425f6460 __libc_start_main +
    245

    6    tmpzzf2wqed                        0x0000561b0829ee69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n > p {\n        return modp(n - p,\
    \ p)\n    }\n    if n >= p {\n        return n - p\n    }\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgpgkhiwx.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let x = powMod(p, n - 1, p)\n    return\
    \ x % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpoayujz_u.swift:14:13: error: cannot find 'powMod' in scope\n  \
    \  let x = powMod(p, n - 1, p)\n            ^~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tn %= p\n\tif n < 0 {\n\t\tn = p + n\n\t\
    }\n\treturn n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3h7_hqk9.swift:14:4: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n/tmp/tmp3h7_hqk9.swift:16:3:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                n =\
    \ p + n\n                ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let res = pow(Double(n), Double(p)) -\
    \ Double(p)\n    return res * res / pow(Double(p), Double(p))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk74zj9xz.swift:14:15: error: cannot find 'pow' in scope\n    let\
    \ res = pow(Double(n), Double(p)) - Double(p)\n              ^~~\n/tmp/tmpk74zj9xz.swift:15:24:\
    \ error: cannot find 'pow' in scope\n    return res * res / pow(Double(p), Double(p))\n\
    \                       ^~~\n/tmp/tmpk74zj9xz.swift:15:22: error: no '/' candidates\
    \ produce the expected contextual result type 'Int'\n    return res * res / pow(Double(p),\
    \ Double(p))\n                     ^\nSwift.Duration:4:24: note: '/' produces\
    \ 'Duration', not the expected contextual result type 'Int'\n    public static\
    \ func / (lhs: Duration, rhs: Double) -> Duration\n                       ^\n\
    Swift.Duration:12:24: note: '/' produces 'Double', not the expected contextual\
    \ result type 'Int'\n    public static func / (lhs: Duration, rhs: Duration) ->\
    \ Double\n                       ^\nSwift.DurationProtocol:3:17: note: '/' produces\
    \ 'Duration', not the expected contextual result type 'Int'\n    static func /\
    \ (lhs: Self, rhs: Int) -> Self\n                ^\nSwift.DurationProtocol:7:17:\
    \ note: '/' produces 'Double', not the expected contextual result type 'Int'\n\
    \    static func / (lhs: Self, rhs: Self) -> Double\n                ^\nSwift.Duration:4:24:\
    \ note: '/' produces 'Duration', not the expected contextual result type 'Int'\n\
    \    public static func / (lhs: Duration, rhs: Double) -> Duration\n         \
    \              ^\nSwift.Duration:12:24: note: '/' produces 'Double', not the expected\
    \ contextual result type 'Int'\n    public static func / (lhs: Duration, rhs:\
    \ Duration) -> Double\n                       ^\nSwift.DurationProtocol:3:17:\
    \ note: '/' produces 'Duration', not the expected contextual result type 'Int'\n\
    \    static func / (lhs: Self, rhs: Int) -> Self\n                ^\nSwift.DurationProtocol:7:17:\
    \ note: '/' produces 'Double', not the expected contextual result type 'Int'\n\
    \    static func / (lhs: Self, rhs: Self) -> Double\n                ^\nSwift.Duration:4:24:\
    \ note: '/' produces 'Duration', not the expected contextual result type 'Int'\n\
    \    public static func / (lhs: Duration, rhs: Double) -"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let r = n % p\n    if r == 0 {\n     \
    \   return n\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp225vrb31/tmp225vrb31.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7f0637c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7f032eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7f032e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7f032d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp225vrb31                        0x000055a96504f2cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad7f0823460 __libc_start_main +
    245

    6    tmp225vrb31                        0x000055a96504eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp_f7z13ge/tmp_f7z13ge.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30a49b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30a46b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30a46b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30a46af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_f7z13ge                        0x0000562c0cb6f1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b30a4ba5460 __libc_start_main +
    245

    6    tmp_f7z13ge                        0x0000562c0cb6ee69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    n %= p\n    if n < 0 {\n        n *= -1\n\
    \        n %= p\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph6okexjz.swift:14:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n %= p\n    ~ ^\n/tmp/tmph6okexjz.swift:16:11:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n *= -1\n        ~ ^\n/tmp/tmph6okexjz.swift:17:11: error: left side\
    \ of mutating operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n\
    \        ~ ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n - 1)&(p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp5rqsh50v/tmp5rqsh50v.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac85de21c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac85db18b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac85db18988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac85db177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5rqsh50v                        0x0000558c003ae1bd <unavailable> + 4541

    5    libc.so.6                          0x00002ac85e00d460 __libc_start_main +
    245

    6    tmp5rqsh50v                        0x0000558c003ade69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  // TODO: This will be a lot more efficient\
    \ with bit operations.\n  // TODO: It would also be better if we could use signed\
    \ integers.\n  // TODO: Signed integers would make this quite a bit easier.\n\
    \  switch {\n  case n == 0: return 1\n  case n == 1: return p\n  case n < 0: return\
    \ modf(-n, p)\n  case p < 1: return modpow(p, n)\n  case p > p: return modpow(p,\
    \ n)\n  default: return n % p\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpe3r8me7m.swift:17:10: error: expected expression in 'switch' statement\n\
    \  switch {\n         ^\n/tmp/tmpe3r8me7m.swift:20:22: error: cannot find 'modf'\
    \ in scope\n  case n < 0: return modf(-n, p)\n                     ^~~~\n/tmp/tmpe3r8me7m.swift:21:22:\
    \ error: cannot find 'modpow' in scope\n  case p < 1: return modpow(p, n)\n  \
    \                   ^~~~~~\n/tmp/tmpe3r8me7m.swift:22:22: error: cannot find 'modpow'\
    \ in scope\n  case p > p: return modpow(p, n)\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return ((1 << (p - 1)) + 1) & -((1 << (p\
    \ - 1)) - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbs5k9zco/tmpbs5k9zco.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c1907dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c18d74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c18d74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c18d737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbs5k9zco                        0x000055d161d751bd <unavailable> + 4541

    5    libc.so.6                          0x00002b9c19269460 __libc_start_main +
    245

    6    tmpbs5k9zco                        0x000055d161d74e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return modpow(n, p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt25lzybm.swift:14:12: error: cannot find 'modpow' in scope\n  \
    \  return modpow(n, p, p)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let mask = 1 << (p - 1)\n\n    if n >=\
    \ p {\n        return ((n & (mask - 1)) ^ mask)\n    } else {\n        return\
    \ ((n | -mask) & -p) + p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpggb_y8az/tmpggb_y8az.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade629afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade626a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade626a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade626a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpggb_y8az                        0x00005628311b11bd <unavailable> + 4541

    5    libc.so.6                          0x00002ade62b9b460 __libc_start_main +
    245

    6    tmpggb_y8az                        0x00005628311b0e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n.bitwiseAnd(p).bitwiseXor(1).bitwiseShiftLeft(n.bitCount())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7r4_4i6k.swift:14:14: error: value of type 'Int' has no member\
    \ 'bitwiseAnd'\n    return n.bitwiseAnd(p).bitwiseXor(1).bitwiseShiftLeft(n.bitCount())\n\
    \           ~ ^~~~~~~~~~\n/tmp/tmp7r4_4i6k.swift:14:61: error: value of type 'Int'\
    \ has no member 'bitCount'\n    return n.bitwiseAnd(p).bitwiseXor(1).bitwiseShiftLeft(n.bitCount())\n\
    \                                                          ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn n & (p-1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp2s82deks/tmp2s82deks.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f66ea9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f66ba0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f66ba0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f66b9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2s82deks                        0x000055be423f11bd <unavailable> + 4541

    5    libc.so.6                          0x00002b7f67095460 __libc_start_main +
    245

    6    tmp2s82deks                        0x000055be423f0e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    if p == 1 {\n      return\
    \ n\n    }\n    return -modp(-n, p)\n  }\n  if p < 2 {\n    return 0\n  }\n  if\
    \ p > p {\n    p = 2\n  }\n  // TODO: replace with bit-shift.\n  if p == 1 {\n\
    \    return n & -p\n  }\n  var q = p / 2\n  var r = n % p\n  if r > 0 {\n    return\
    \ q + modp(n - r, p)\n  }\n  return q\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwg4m6s_y.swift:18:17: error: missing argument labels 'n:p:' in\
    \ call\n    return -modp(-n, p)\n                ^\n                 n:  p: \n\
    /tmp/tmpwg4m6s_y.swift:24:5: error: cannot assign to value: 'p' is a 'let' constant\n\
    \    p = 2\n    ^\n/tmp/tmpwg4m6s_y.swift:33:20: error: missing argument labels\
    \ 'n:p:' in call\n    return q + modp(n - r, p)\n                   ^\n      \
    \              n:     p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // TODO: this could be more efficient\
    \ with a bitwise and\n    // right shift (instead of modulo)\n    var result =\
    \ 1\n    for i := n - 1; result > 0 && i >= 0; i-- {\n        if ((result & 1)\
    \ == 1) {\n            result >>= 1\n        } else {\n            result >>=\
    \ 1\n            result |= p - 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpszie6goj.swift:17:12: error: expected type\n    for i := n - 1;\
    \ result > 0 && i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpszie6goj.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := n - 1; result > 0\
    \ && i >= 0; i-- {\n           ^\n/tmp/tmpszie6goj.swift:17:12: error: expected\
    \ Sequence expression for for-each loop\n    for i := n - 1; result > 0 && i >=\
    \ 0; i-- {\n           ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 0\n    }\n\
    \    t := n >> p // t will be <= n >> p\n    if t == n {\n        t = t % (p -\
    \ 1)\n    } else {\n        t = t % (p + 1)\n    }\n    return t\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpayqpm26m.swift:17:6: error: consecutive statements on a line must\
    \ be separated by ';'\n    t := n >> p // t will be <= n >> p\n     ^\n     ;\n\
    /tmp/tmpayqpm26m.swift:17:7: error: expected expression\n    t := n >> p // t\
    \ will be <= n >> p\n      ^\n/tmp/tmpayqpm26m.swift:17:5: error: cannot find\
    \ 't' in scope\n    t := n >> p // t will be <= n >> p\n    ^\n/tmp/tmpayqpm26m.swift:18:8:\
    \ error: cannot find 't' in scope\n    if t == n {\n       ^\n/tmp/tmpayqpm26m.swift:19:9:\
    \ error: cannot find 't' in scope\n        t = t % (p - 1)\n        ^\n/tmp/tmpayqpm26m.swift:19:13:\
    \ error: cannot find 't' in scope\n        t = t % (p - 1)\n            ^\n/tmp/tmpayqpm26m.swift:21:9:\
    \ error: cannot find 't' in scope\n        t = t % (p + 1)\n        ^\n/tmp/tmpayqpm26m.swift:21:13:\
    \ error: cannot find 't' in scope\n        t = t % (p + 1)\n            ^\n/tmp/tmpayqpm26m.swift:23:12:\
    \ error: cannot find 't' in scope\n    return t\n           ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\n\tif n\
    \ == 1 {\n\t\treturn 1\n\t}\n\n\tlet mut product = 0\n\n\tfor bit in &p {\n\t\t\
    if bit < 2 {\n\t\t\tproduct *= n\n\t\t} else {\n\t\t\tproduct *= 2\n\t\t\tproduct\
    \ %= n\n\t\t}\n\t}\n\n\treturn product\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprkx2aou4.swift:22:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut product\
    \ = 0\n                ^\n/tmp/tmprkx2aou4.swift:22:10: note: join the identifiers\
    \ together\n        let mut product = 0\n            ~~~~^~~~~~~\n           \
    \ mutproduct\n/tmp/tmprkx2aou4.swift:22:10: note: join the identifiers together\
    \ with camel-case\n        let mut product = 0\n            ~~~~^~~~~~~\n    \
    \        mutProduct\n/tmp/tmprkx2aou4.swift:24:13: error: '&' may only be used\
    \ to pass an argument to inout parameter\n        for bit in &p {\n          \
    \         ^\n/tmp/tmprkx2aou4.swift:33:9: error: cannot find 'product' in scope\n\
    \        return product\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch {\n    case n >= p && n < p+1:\n\
    \        return n - p + (p - n)*(n-1)\n    case n < p:\n        return p\n   \
    \ case n < p+1:\n        return 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgxnq4eua.swift:14:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase p < 0:\n\t\treturn modp(n,\
    \ -p) * -1\n\tcase p >= n:\n\t\treturn 0\n\tdefault:\n\t\tp = p * n\n\t\tn %=\
    \ p\n\t\treturn n / p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2nfrbs0g.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp2nfrbs0g.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n, -p) * -1\n  \
    \                         ^\n                            n: p: \n/tmp/tmp2nfrbs0g.swift:20:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ p * n\n                ^\n/tmp/tmp2nfrbs0g.swift:21:5: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n                n %= p\n  \
    \              ~ ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tcheckTypes(n, p)\n\treturn n % p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpoqiqhtx9.swift:14:2: error: cannot find 'checkTypes' in scope\n\
    \        checkTypes(n, p)\n        ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n - n % (p * p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpcvla6izn/tmpcvla6izn.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dd2c99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9dd2990b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9dd2990988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9dd298f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcvla6izn                        0x000056450b80924d <unavailable> + 4685

    5    libc.so.6                          0x00002b9dd2e85460 __libc_start_main +
    245

    6    tmpcvla6izn                        0x000056450b808ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1) | mod((n - 1) & p,\
    \ p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkx0kqqh6.swift:14:26: error: cannot find 'mod' in scope\n    return\
    \ n & (p - 1) | mod((n - 1) & p, p)\n                         ^~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let m = powMod(UInt32(p.bitLength), UInt32(n),\
    \ p)\n    return UInt32(m & UInt32(n))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpm5lb1k_9.swift:14:13: error: cannot find 'powMod' in scope\n  \
    \  let m = powMod(UInt32(p.bitLength), UInt32(n), p)\n            ^~~~~~\n/tmp/tmpm5lb1k_9.swift:14:29:\
    \ error: value of type 'Int' has no member 'bitLength'\n    let m = powMod(UInt32(p.bitLength),\
    \ UInt32(n), p)\n                          ~ ^~~~~~~~~\n/tmp/tmpm5lb1k_9.swift:15:12:\
    \ error: cannot convert return expression of type 'UInt32' to return type 'Int'\n\
    \    return UInt32(m & UInt32(n))\n           ^~~~~~~~~~~~~~~~~~~~~\n        \
    \   Int(                 )\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tvar result : Int\n\tswitch {\n\tcase n <\
    \ 0 && (n & (n - 1)) == 0: // power of 2\n\t\tresult = n\n\tcase n >= p:\n\t\t\
    result = p - n // mod p\n\tdefault:\n\t\tlet d = p - n % p\n\t\tlet r = n % p\n\
    \t\tresult = d + r\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeukuqoqb.swift:15:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  // TODO: use binary search and maybe optimize\n\
    \  return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpzxz_ydv0/tmpzxz_ydv0.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b689d9e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b689d6dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b689d6df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b689d6de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxz_ydv0                        0x000055f46277f2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b689dbd4460 __libc_start_main +
    245

    6    tmpzxz_ydv0                        0x000055f46277eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(fmt.Sprintf(\"n must\
    \ be non-negative, got %v\", n))\n\t}\n\tif p < 1 {\n\t\tpanic(fmt.Sprintf(\"\
    p must be positive, got %v\", p))\n\t}\n\tvar c uint\n\tif n >= p {\n\t\tc = 1\n\
    \t} else if p > 0 {\n\t\tc = p\n\t} else {\n\t\tpanic(fmt.Sprintf(\"n must be\
    \ >= 0, got %v\", n))\n\t}\n\tfor {\n\t\tx := n\n\t\tn /= p\n\t\tif n == 0 {\n\
    \t\t\treturn x\n\t\t}\n\t\tif n == 1 {\n\t\t\treturn c - x\n\t\t}\n\t\tx -= n\n\
    \t\tc *= p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpem7ibzwn.swift:20:8: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var c uint\n\
    \              ^\n/tmp/tmpem7ibzwn.swift:20:8: note: join the identifiers together\n\
    \        var c uint\n            ~~^~~~\n            cuint\n/tmp/tmpem7ibzwn.swift:20:8:\
    \ note: join the identifiers together with camel-case\n        var c uint\n  \
    \          ~~^~~~\n            cUint\n/tmp/tmpem7ibzwn.swift:28:6: error: expected\
    \ pattern\n        for {\n            ^\n/tmp/tmpem7ibzwn.swift:28:6: error: expected\
    \ Sequence expression for for-each loop\n        for {\n            ^\n/tmp/tmpem7ibzwn.swift:29:4:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       x := n\n                 ^\n                 ;\n/tmp/tmpem7ibzwn.swift:29:5:\
    \ error: expected expression\n                x := n\n                  ^\n/tmp/tmpem7ibzwn.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(fmt.Sprintf(\"n must\
    \ be non-negative, got %v\", n))\n                ^~~~~\n/tmp/tmpem7ibzwn.swift:15:9:\
    \ error: cannot find 'fmt' in scope\n                panic(fmt.Sprintf(\"n must\
    \ be non-negative, got %v\", n))\n                      ^~~\n/tmp/tmpem7ibzwn.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(fmt.Sprintf(\"p must\
    \ be positive, got %v\", p))\n                ^~~~~\n/tmp/tmpem7ibzwn.swift:18:9:\
    \ error: cannot find 'fmt' in scope\n                panic(fmt.Sprintf(\"p must\
    \ be positive, got %v\", p))\n                      ^~~\n/tmp/tmpem7ibzwn.swift:20:6:\
    \ error: type annotation missing in pattern\n        var c uint\n            ^\n\
    /tmp/tmpem7ibzwn.swift:26:3: error: cannot find 'panic' in scope\n           \
    \     panic(fmt.Sprintf(\"n must be >= 0, got %v\", n))\n                ^~~~~\n\
    /tmp/tmpem7ibzwn.swift:26:9: error: cannot find 'fmt' in scope\n             \
    \   panic(fmt.Sprintf(\"n must be >= 0, got %v\", n))\n                      ^~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 0\n    }\n\
    \    if p < 2 {\n        return n % p\n    }\n    var q = 1\n    for ; p > 2 &&\
    \ n >= p * q; q *= 2\n    return n % q\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3tihdu69.swift:21:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for ; p > 2 && n >= p * q; q *= 2\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3tihdu69.swift:21:38: error: expected '{' to start the body of for-each\
    \ loop\n    for ; p > 2 && n >= p * q; q *= 2\n                              \
    \       ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch {\n    case n < p:\n        return\
    \ n + p - 1\n    case n == p:\n        return n\n    case n > p:\n        return\
    \ modp(n - p, p)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_f6obn47.swift:14:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmp_f6obn47.swift:20:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpirz9lrjv/tmpirz9lrjv.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0a2f67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0a2c5eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0a2c5e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0a2c5d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpirz9lrjv                        0x000055767027d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002ba0a3153460 __libc_start_main +
    245

    6    tmpirz9lrjv                        0x000055767027cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // We use log2 to avoid overflow.\n  \
    \  let log2 = log2(p)\n    if n > p {\n        return n - p\n    }\n    if n ==\
    \ 0 {\n        return 1\n    }\n    if n == 1 {\n        return p\n    }\n   \
    \ if n == 2 {\n        return p\n    }\n    if log2 < modpModulus {\n        return\
    \ modpModulus\n    }\n    if log2 < modpModulus - 1 {\n        return modpModulus\
    \ - log2\n    }\n    return modpModulus - log2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7vvg5juc.swift:15:16: error: use of local variable 'log2' before\
    \ its declaration\n    let log2 = log2(p)\n               ^\n/tmp/tmp7vvg5juc.swift:15:9:\
    \ note: 'log2' declared here\n    let log2 = log2(p)\n        ^\n/tmp/tmp7vvg5juc.swift:28:15:\
    \ error: cannot find 'modpModulus' in scope\n    if log2 < modpModulus {\n   \
    \           ^~~~~~~~~~~\n/tmp/tmp7vvg5juc.swift:29:16: error: cannot find 'modpModulus'\
    \ in scope\n        return modpModulus\n               ^~~~~~~~~~~\n/tmp/tmp7vvg5juc.swift:31:15:\
    \ error: cannot find 'modpModulus' in scope\n    if log2 < modpModulus - 1 {\n\
    \              ^~~~~~~~~~~\n/tmp/tmp7vvg5juc.swift:32:16: error: cannot find 'modpModulus'\
    \ in scope\n        return modpModulus - log2\n               ^~~~~~~~~~~\n/tmp/tmp7vvg5juc.swift:32:28:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Int'\n\
    \        return modpModulus - log2\n               ~~~~~~~~~~~~^~~~~~\n/tmp/tmp7vvg5juc.swift:34:12:\
    \ error: cannot find 'modpModulus' in scope\n    return modpModulus - log2\n \
    \          ^~~~~~~~~~~\n/tmp/tmp7vvg5juc.swift:34:24: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int'\n    return modpModulus -\
    \ log2\n           ~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (pow(2, n) - 1) % (p - 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_dilz39h.swift:14:10: error: cannot find 'pow' in scope\n     \
    \   return (pow(2, n) - 1) % (p - 1)\n                ^~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n%p)+p) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpdf_kyfww/tmpdf_kyfww.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3f2b7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3f2873b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3f2873988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3f28727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdf_kyfww                        0x0000559aabba42cd <unavailable> + 4813

    5    libc.so.6                          0x00002af3f2d68460 __libc_start_main +
    245

    6    tmpdf_kyfww                        0x0000559aabba3ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return (n * pow(p, n)) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgjqh2rfs.swift:14:17: error: cannot find 'pow' in scope\n    return\
    \ (n * pow(p, n)) % p\n                ^~~\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n >= p {\n        return n % p\n  \
    \  }\n    n %= p\n    if n < 0 {\n        return modp(n - p, p) + p\n    }\n \
    \   return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc6blh6je.swift:17:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n %= p\n    ~ ^\n/tmp/tmpc6blh6je.swift:19:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\
    \ + p\n                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var a = BigUInt(n)\n  if a.isZero() { return\
    \ 1 }\n  var d = BigUInt(p)\n  var e = BigUInt(0)\n  var m = BigUInt(0)\n  var\
    \ r = BigUInt(0)\n  while true {\n    var q = BigUInt(a.bitCount()) - BigUInt(1)\n\
    \    var t = r\n    if a.bitCount() > p.bitCount() {\n      t = m\n    }\n   \
    \ if t == BigUInt(0) {\n      return 1\n    } else if a.bitCount() == p.bitCount()\
    \ {\n      if t.isZero() {\n        return BigUInt(0)\n      }\n      return BigUInt(0)\n\
    \    }\n    r.shrRsh(t, q)\n    if r.isZero() {\n      return BigUInt(0)\n   \
    \ }\n    m.shrRsh(t, BigUInt(q))\n    if m.isZero() {\n      if a.bitCount() ==\
    \ p.bitCount() {\n        return r.isZero() ? BigUInt(1) : BigUInt(0)\n      }\n\
    \      return BigUInt(0)\n    }\n    a.shrRsh(t, BigUInt(q))\n  }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjg0z2hhs.swift:14:11: error: cannot find 'BigUInt' in scope\n \
    \ var a = BigUInt(n)\n          ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:16:11: error:\
    \ cannot find 'BigUInt' in scope\n  var d = BigUInt(p)\n          ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:17:11:\
    \ error: cannot find 'BigUInt' in scope\n  var e = BigUInt(0)\n          ^~~~~~~\n\
    /tmp/tmpjg0z2hhs.swift:18:11: error: cannot find 'BigUInt' in scope\n  var m =\
    \ BigUInt(0)\n          ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:19:11: error: cannot find\
    \ 'BigUInt' in scope\n  var r = BigUInt(0)\n          ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:21:13:\
    \ error: cannot find 'BigUInt' in scope\n    var q = BigUInt(a.bitCount()) - BigUInt(1)\n\
    \            ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:21:37: error: cannot find 'BigUInt'\
    \ in scope\n    var q = BigUInt(a.bitCount()) - BigUInt(1)\n                 \
    \                   ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:23:25: error: value of type\
    \ 'Int' has no member 'bitCount'\n    if a.bitCount() > p.bitCount() {\n     \
    \                 ~ ^~~~~~~~\n/tmp/tmpjg0z2hhs.swift:26:13: error: cannot find\
    \ 'BigUInt' in scope\n    if t == BigUInt(0) {\n            ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:28:33:\
    \ error: value of type 'Int' has no member 'bitCount'\n    } else if a.bitCount()\
    \ == p.bitCount() {\n                              ~ ^~~~~~~~\n/tmp/tmpjg0z2hhs.swift:30:16:\
    \ error: cannot find 'BigUInt' in scope\n        return BigUInt(0)\n         \
    \      ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:32:14: error: cannot find 'BigUInt' in\
    \ scope\n      return BigUInt(0)\n             ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:36:14:\
    \ error: cannot find 'BigUInt' in scope\n      return BigUInt(0)\n           \
    \  ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:38:17: error: cannot find 'BigUInt' in scope\n\
    \    m.shrRsh(t, BigUInt(q))\n                ^~~~~~~\n/tmp/tmpjg0z2hhs.swift:40:28:\
    \ error: value of type 'Int' has no member 'bitCount'\n      if a.bitCount() ==\
    \ p.bitCount() {\n                         ~ ^~~~~~~~\n/tmp/tmpjg0z2hhs.swift:41:29:\
    \ error: cannot find 'BigUInt' in scope\n        return r.isZero() ? BigUInt(1)\
    \ : BigUInt(0)\n                            ^~~~~~~\n/tmp/tmpj"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\treturn -modp(-n, p)\n\t\
    }\n\tif p <= 1 {\n\t\tif n >= p {\n\t\t\treturn 0\n\t\t}\n\t\treturn n\n\t}\n\n\
    \tx := p\n\ty := n\n\n\tfor {\n\t\tif y % x == 0 {\n\t\t\treturn y\n\t\t}\n\t\t\
    x /= 2\n\t\ty /= x\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_y8udoin.swift:24:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := p\n         ^\n         ;\n/tmp/tmp_y8udoin.swift:24:4:\
    \ error: expected expression\n        x := p\n          ^\n/tmp/tmp_y8udoin.swift:27:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp_y8udoin.swift:27:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp_y8udoin.swift:15:15: error: missing argument labels 'n:p:'\
    \ in call\n                return -modp(-n, p)\n                            ^\n\
    \                             n:  p: \n/tmp/tmp_y8udoin.swift:24:2: error: cannot\
    \ find 'x' in scope\n        x := p\n        ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n <= 0 || p <= 0 {\n        return\
    \ -1\n    }\n\n    if n == 0 {\n        return 1\n    }\n\n    if n >= p {\n \
    \       return modp(n, p - 1)\n    }\n\n    let mut n = n\n\n    while n > p {\n\
    \        n = n - p\n    }\n\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3xnkhri3.swift:26:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut n = n\n\
    \            ^\n/tmp/tmp3xnkhri3.swift:26:13: note: join the identifiers together\n\
    \    let mut n = n\n        ~~~~^\n        mutn\n/tmp/tmp3xnkhri3.swift:26:13:\
    \ note: join the identifiers together with camel-case\n    let mut n = n\n   \
    \     ~~~~^\n        mutN\n/tmp/tmp3xnkhri3.swift:23:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp3xnkhri3.swift:29:9: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n        n = n - p\n        ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  if n <= p { return n }\n  let t = p % n\n\
    \  if t == 0 {\n    return p\n  } else {\n    return n + t - 1\n  }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpw6ya0_wk/tmpw6ya0_wk.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc290c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc28dbeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc28dbe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc28dbd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw6ya0_wk                        0x000055fa5ff5f2cd <unavailable> + 4813

    5    libc.so.6                          0x00002adc292b3460 __libc_start_main +
    245

    6    tmpw6ya0_wk                        0x000055fa5ff5eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    n &= p\n    return ((n & (-p)) + (n &\
    \ p))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwseg5vls.swift:14:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n &= p\n    ~ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var tmp: Int = n\n    for i in 0 ..< p\
    \ {\n        tmp = tmp & 1\n        tmp = tmp ^ 3\n    }\n    return tmp\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpi136d7tu/tmpi136d7tu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac44677cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac446473b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac446473988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4464727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi136d7tu                        0x0000558cf698d33d <unavailable> + 4925

    5    libc.so.6                          0x00002ac446968460 __libc_start_main +
    245

    6    tmpi136d7tu                        0x0000558cf698cfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn n %\
    \ p\n\tcase n <= p:\n\t\treturn n\n\tdefault:\n\t\tn -= p\n\t\treturn (n % p)\
    \ + p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq51pibwb.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpq51pibwb.swift:20:5: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n         \
    \       n -= p\n                ~ ^\n"
  stdout: ''
  timestamp: 1660015064
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\treturn 0\n\t}\n\n\tconst\
    \ modPow: Int = p - 1\n\n\tif p <= 1 {\n\t\treturn n\n\t}\n\n\tvar (\n\t\tq  \
    \   = NewBigUint64(modPow)\n\t\tresult = n.Abs().Cmp(modPow) * NewBigUint64(modPow)\n\
    \t)\n\n\tfor ; n > 0; n /= p { q = q.Mul(q, NewBigUint64(p)) }\n\tfor ; p.Cmp(q)\
    \ == 0; p = p.Sub(p, q, NewBigUint64(modPow)) { q = q.Mul(q, NewBigUint64(p))\
    \ }\n\n\treturn q\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptdtmaidu.swift:18:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        const modPow: Int = p - 1\n             ^\n   \
    \          ;\n/tmp/tmptdtmaidu.swift:18:14: error: consecutive statements on a\
    \ line must be separated by ';'\n        const modPow: Int = p - 1\n         \
    \           ^\n                    ;\n/tmp/tmptdtmaidu.swift:18:14: error: expected\
    \ expression\n        const modPow: Int = p - 1\n                    ^\n/tmp/tmptdtmaidu.swift:25:9:\
    \ error: expected ',' separator\n                q     = NewBigUint64(modPow)\n\
    \                      ^\n                 ,\n/tmp/tmptdtmaidu.swift:25:9: error:\
    \ expected pattern\n                q     = NewBigUint64(modPow)\n           \
    \           ^\n/tmp/tmptdtmaidu.swift:29:2: error: C-style for statement has been\
    \ removed in Swift 3\n        for ; n > 0; n /= p { q = q.Mul(q, NewBigUint64(p))\
    \ }\n        ^   ~~~~~~~~~~~~~~~\n/tmp/tmptdtmaidu.swift:30:2: error: C-style\
    \ for statement has been removed in Swift 3\n        for ; p.Cmp(q) == 0; p =\
    \ p.Sub(p, q, NewBigUint64(modPow)) { q = q.Mul(q, NewBigUint64(p)) }\n      \
    \  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptdtmaidu.swift:18:2:\
    \ error: cannot find 'const' in scope\n        const modPow: Int = p - 1\n   \
    \     ^~~~~\n/tmp/tmptdtmaidu.swift:18:8: error: cannot find 'modPow' in scope\n\
    \        const modPow: Int = p - 1\n              ^~~~~~\n/tmp/tmptdtmaidu.swift:25:3:\
    \ error: type annotation missing in pattern\n                q     = NewBigUint64(modPow)\n\
    \                ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n.pow(p).maskPow(p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprdtmv7yw.swift:14:14: error: value of type 'Int' has no member\
    \ 'pow'\n    return n.pow(p).maskPow(p)\n           ~ ^~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    n %= p\n    if n < 0 {\n        n += p\n\
    \    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5qgfl5_9.swift:14:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n %= p\n    ~ ^\n/tmp/tmp5qgfl5_9.swift:16:11:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n += p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet x = pow(IntPow(p, 1), n)\n\tlet y =\
    \ round(x / p)\n\treturn y\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt43q8n1n.swift:14:10: error: cannot find 'pow' in scope\n     \
    \   let x = pow(IntPow(p, 1), n)\n                ^~~\n/tmp/tmpt43q8n1n.swift:14:14:\
    \ error: cannot find 'IntPow' in scope\n        let x = pow(IntPow(p, 1), n)\n\
    \                    ^~~~~~\n/tmp/tmpt43q8n1n.swift:15:10: error: cannot find\
    \ 'round' in scope\n        let y = round(x / p)\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        // modp of negative\
    \ number is undefined\n        // https://bugs.webkit.org/show_bug.cgi?id=143099\n\
    \        return -1\n    }\n    if n == 0 {\n        return 1\n    }\n    if n\
    \ < p {\n        // n is a power of p\n        var r = 1\n        for i := 0;\
    \ i < n; i++ {\n            r *= p\n        }\n        return r\n    }\n    return\
    \ n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcdqot1_f.swift:25:16: error: expected type\n        for i := 0;\
    \ i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpcdqot1_f.swift:25:16:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < n; i++\
    \ {\n               ^\n/tmp/tmpcdqot1_f.swift:25:16: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < n; i++ {\n           \
    \    ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    \n    var result: Int = 0\n    \n    let\
    \ nMod = n % p\n    let nDivP = n % p\n    let nDivPAnd2P = n % p + p\n    \n\
    \    if nMod == 0 {\n        result = 0\n    } else if nMod == 1 {\n        result\
    \ = 1\n    } else if nMod == 2 {\n        result = p - 1\n    } else {\n     \
    \   if nDivP == 0 {\n            if nDivPAnd2P == 0 {\n                result\
    \ = n - p\n            } else {\n                result = p - 1\n            }\n\
    \        } else {\n            if nDivPAnd2P == 0 {\n                result =\
    \ p - 1\n            } else {\n                result = nDivPAnd2P\n         \
    \   }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphow9fnwv/tmphow9fnwv.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac81642c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac81339b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac81339988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac813387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphow9fnwv                        0x0000561d5d51024d <unavailable> + 4685

    5    libc.so.6                          0x00002aac8182e460 __libc_start_main +
    245

    6    tmphow9fnwv                        0x0000561d5d50fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var i = 0\n    if\
    \ n > p {\n        for _ in 1..<n-p {\n            result *= p\n        }\n  \
    \  }\n    if n < p {\n        for _ in 0..<p-n {\n            result /= p\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpwrq3lio4/tmpwrq3lio4.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaec9466c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaec915db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaec915d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaec915c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwrq3lio4                        0x0000564d4290b33d <unavailable> + 4925

    5    libc.so.6                          0x00002aaec9652460 __libc_start_main +
    245

    6    tmpwrq3lio4                        0x0000564d4290afe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet nMinusOne = n - 1\n\tlet pMinusOne =\
    \ p - UInt32(nMinusOne)\n\n\tlet one = UInt32(1)\n\tlet two = UInt32(2)\n\n\t\
    let result = Int(nMinusOne)\n\tlet mask = result < p ? one : two\n\n\treturn result\
    \ & mask\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6_p9m9u7.swift:15:20: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'UInt32'\n        let pMinusOne = p - UInt32(nMinusOne)\n\
    \                        ~ ^ ~~~~~~~~~~~~~~~~~\n/tmp/tmp6_p9m9u7.swift:15:20:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Int, Int), (UInt32, UInt32)\n        let pMinusOne = p - UInt32(nMinusOne)\n\
    \                          ^\n/tmp/tmp6_p9m9u7.swift:23:18: error: cannot convert\
    \ value of type 'UInt32' to expected argument type 'Int'\n        return result\
    \ & mask\n                        ^\n                        Int()\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 && p == 0 {\n        return\
    \ 1\n    }\n    if n >= p {\n        return 0\n    }\n    if n < p {\n       \
    \ return p - n\n    }\n    var remainder = n % p\n    return p + (n - remainder)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp0c4f0dbz/tmp0c4f0dbz.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea56a9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea56793b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea56793988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea567927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0c4f0dbz                        0x000056105a51b24d <unavailable> + 4685

    5    libc.so.6                          0x00002aea56c88460 __libc_start_main +
    245

    6    tmp0c4f0dbz                        0x000056105a51aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return 0\n  }\n  if p ==\
    \ 0 {\n    return 1\n  }\n  if n >= p {\n    return p - (p % n)\n  }\n  if p <=\
    \ 0 {\n    return 0\n  }\n  return p + modp(n - p, p)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp40zgrgjw.swift:26:18: error: missing argument labels 'n:p:' in\
    \ call\n  return p + modp(n - p, p)\n                 ^\n                  n:\
    \     p: \n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch {\n    case n % p == 0:\n     \
    \   return n\n    case n % p == p:\n        return n % p\n    case n % p == p\
    \ - 1:\n        return p + (n - p - 1) % p\n    default:\n        return n % p\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0kusfmmu.swift:14:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 || (p == 0 && n == 1) {\n  \
    \      return n\n    }\n\n    var r = 0\n    var mask = (1 << p) - 1 // 1<<p -\
    \ 1 = 1 << p\n    var i = -1\n\n    guard n > 0 else {\n        return -1\n  \
    \  }\n\n    for i = 0; i <= n; i++ {\n        r += i & mask\n        mask = (mask\
    \ >> 1) // mask = (mask << 1)\n    }\n\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk2hu8bjf.swift:26:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 0; i <= n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var result = 1\n  while n > 0 {\n    if\
    \ n % p == 0 {\n      break\n    }\n    n /= p\n    result++\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwp_q4x57.swift:19:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n /= p\n    ~ ^\n/tmp/tmpwp_q4x57.swift:20:11:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n    result++\n\
    \          ^~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n % p) + p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpxs2rwy8v/tmpxs2rwy8v.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae93cfafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae93cca6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae93cca6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae93cca57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxs2rwy8v                        0x0000562e82df92cd <unavailable> + 4813

    5    libc.so.6                          0x00002ae93d19b460 __libc_start_main +
    245

    6    tmpxs2rwy8v                        0x0000562e82df8ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n >= p {\n        return n - p\n  \
    \  }\n    if n < p {\n        return p + (p - n)\n    }\n    return 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpcqwxtjid/tmpcqwxtjid.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b60bc828c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60bc51fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60bc51f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60bc51e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcqwxtjid                        0x0000559f3a58b1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b60bca14460 __libc_start_main +
    245

    6    tmpcqwxtjid                        0x0000559f3a58ae69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  if n >= p { return n - p }\n  else { return\
    \ n % p }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpvgfe0zs7/tmpvgfe0zs7.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa2df60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa2dc57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa2dc57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa2dc567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgfe0zs7                        0x000055a635fa62cd <unavailable> + 4813

    5    libc.so.6                          0x00002baa2e14c460 __libc_start_main +
    245

    6    tmpvgfe0zs7                        0x000055a635fa5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return (n % (p - 1)) + 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpc1a6dfi3/tmpc1a6dfi3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11d555ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11d5251b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11d5251988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11d52507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1a6dfi3                        0x000055655d1b324d <unavailable> + 4685

    5    libc.so.6                          0x00002b11d5746460 __libc_start_main +
    245

    6    tmpc1a6dfi3                        0x000055655d1b2ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch {\n    case n < 0:\n        n +=\
    \ p\n    case n >= p:\n        n -= p\n    }\n    return n & (p - 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2xz95lyi.swift:14:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmp2xz95lyi.swift:16:11: error: left side of\
    \ mutating operator isn't mutable: 'n' is a 'let' constant\n        n += p\n \
    \       ~ ^\n/tmp/tmp2xz95lyi.swift:18:11: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n        n -= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n = -n\n    }\n  \
    \  if p < 0 {\n        p = -p\n    }\n    if p > p {\n        p = p\n    }\n \
    \   if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return n\n\
    \    }\n    if p < 2 {\n        return n\n    }\n    var ret = 1\n    var p2:\
    \ Int\n    for p2 = p; p2 > 1; p2 = p2 * 2 {\n        if n % p2 == 0 {\n     \
    \       ret = ret * (n - p2)\n        }\n    }\n    return ret\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdzlujvpi.swift:34:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for p2 = p; p2 > 1; p2 = p2 * 2 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdzlujvpi.swift:15:9: error: cannot assign to value: 'n' is a 'let' constant\n\
    \        n = -n\n        ^\n/tmp/tmpdzlujvpi.swift:18:9: error: cannot assign\
    \ to value: 'p' is a 'let' constant\n        p = -p\n        ^\n/tmp/tmpdzlujvpi.swift:21:9:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n        p = p\n    \
    \    ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\tif p % 2 !=\
    \ 0 {\n\t\t\tn += p\n\t\t}\n\t\telse if p == 0 {\n\t\t\tn = 0\n\t\t}\n\t\telse\
    \ {\n\t\t\tn = 1\n\t\t}\n\tcase n > p:\n\t\tn = n - p\n\tcase p == 0:\n\t\tn =\
    \ n\n\tdefault:\n\t\tn = (n - p) % p\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2vykshjz.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp2vykshjz.swift:17:6: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n         \
    \               n += p\n                        ~ ^\n/tmp/tmp2vykshjz.swift:20:4:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                   \
    \     n = 0\n                        ^\n/tmp/tmp2vykshjz.swift:23:4: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                        n = 1\n  \
    \                      ^\n/tmp/tmp2vykshjz.swift:26:3: error: cannot assign to\
    \ value: 'n' is a 'let' constant\n                n = n - p\n                ^\n\
    /tmp/tmp2vykshjz.swift:28:3: error: cannot assign to value: 'n' is a 'let' constant\n\
    \                n = n\n                ^\n/tmp/tmp2vykshjz.swift:30:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = (n - p)\
    \ % p\n                ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n >= p {\n\t\treturn 0\n\t}\n\tconst\
    \ q = p / 2\n\tvar result = 1\n\tvar k = 1\n\twhile n > 0 {\n\t\tif n & 1 {\n\t\
    \t\tresult *= q\n\t\t\tresult %= p\n\t\t}\n\t\tif k <= n {\n\t\t\tk *= q\n\t\t\
    \tk %= p\n\t\t}\n\t\tn >>= 1\n\t\tk *= q\n\t\tk %= p\n\t}\n\treturn result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptjd2asxe.swift:17:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        const q = p / 2\n             ^\n             ;\n\
    /tmp/tmptjd2asxe.swift:17:2: error: cannot find 'const' in scope\n        const\
    \ q = p / 2\n        ^~~~~\n/tmp/tmptjd2asxe.swift:17:8: error: cannot find 'q'\
    \ in scope\n        const q = p / 2\n              ^\n/tmp/tmptjd2asxe.swift:21:8:\
    \ error: type 'Int' cannot be used as a boolean; test for '!= 0' instead\n   \
    \             if n & 1 {\n                     ^\n                   ((   ) !=\
    \ 0)\n/tmp/tmptjd2asxe.swift:22:14: error: cannot find 'q' in scope\n        \
    \                result *= q\n                                  ^\n/tmp/tmptjd2asxe.swift:26:9:\
    \ error: cannot find 'q' in scope\n                        k *= q\n          \
    \                   ^\n/tmp/tmptjd2asxe.swift:29:5: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n                n >>= 1\n \
    \               ~ ^\n/tmp/tmptjd2asxe.swift:30:8: error: cannot find 'q' in scope\n\
    \                k *= q\n                     ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // TODO: check that 0 <= n <= p\n\n  \
    \  return n & (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8di5ndyw/tmp8di5ndyw.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9abb0f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9abadebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9abadeb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9abadea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8di5ndyw                        0x00005619485251bd <unavailable> + 4541

    5    libc.so.6                          0x00002b9abb2e0460 __libc_start_main +
    245

    6    tmp8di5ndyw                        0x0000561948524e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p-1) * (p-1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpgjgzq4ob/tmpgjgzq4ob.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5baa1c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ba9ebdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ba9ebd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ba9ebc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgjgzq4ob                        0x00005653f75081bd <unavailable> + 4541

    5    libc.so.6                          0x00002b5baa3b2460 __libc_start_main +
    245

    6    tmpgjgzq4ob                        0x00005653f7507e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == p {\n        return n\n    }\n    return n % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp9_4syk6l/tmp9_4syk6l.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7a189dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7a1594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac7a1594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7a15937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9_4syk6l                        0x000055f3276882cd <unavailable> + 4813

    5    libc.so.6                          0x00002ac7a1a89460 __libc_start_main +
    245

    6    tmp9_4syk6l                        0x000055f327687ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\n\t// Optimization:\
    \ If n is even, then n%p can never be even, since\n\t// p could be either even\
    \ or odd.\n\tif n&1 == 0 {\n\t\tn /= p\n\t}\n\n\treturn n % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp63tql03r.swift:21:5: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= p\n                ~\
    \ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpmlpm3dmj/tmpmlpm3dmj.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b526d19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b526ce92b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b526ce92988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b526ce917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmlpm3dmj                        0x000055973bdd82cd <unavailable> + 4813

    5    libc.so.6                          0x00002b526d387460 __libc_start_main +
    245

    6    tmpmlpm3dmj                        0x000055973bdd7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return powmod(n, p - 1, p) == 0 ? 0 : powmod(n,\
    \ p - 1, p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpat5huhar.swift:14:10: error: cannot find 'powmod' in scope\n  return\
    \ powmod(n, p - 1, p) == 0 ? 0 : powmod(n, p - 1, p - 1)\n         ^~~~~~\n/tmp/tmpat5huhar.swift:14:41:\
    \ error: cannot find 'powmod' in scope\n  return powmod(n, p - 1, p) == 0 ? 0\
    \ : powmod(n, p - 1, p - 1)\n                                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj32itbvo/tmpj32itbvo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cc8e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc8b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc8b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc8b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj32itbvo                        0x000055679410d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6cc9040460 __libc_start_main +
    245

    6    tmpj32itbvo                        0x000055679410cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    n %= p\n    if n == 0 {\n        return\
    \ n\n    }\n    var low = n / p\n    var high = n % p\n    return low + (high\
    \ * p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxew17sme.swift:14:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n %= p\n    ~ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 || p == 0 {\n        return\
    \ 0\n    }\n    if p == 1 {\n        return n\n    }\n    if p < 2 {\n       \
    \ return modp(p * 2, p)\n    }\n    if p < 4 {\n        if n % p == 0 {\n    \
    \        return p\n        }\n        return modp(p * 2, p)\n    }\n    if p <\
    \ 9 {\n        if n % p == 0 {\n            return p\n        }\n        if n\
    \ % p == 1 {\n            return p + 1\n        }\n        return modp(p * 2,\
    \ p)\n    }\n    if p < 18 {\n        if n % p == 1 {\n            return p +\
    \ 1\n        }\n        if n % p == 2 {\n            return p + 2\n        }\n\
    \        if n % p == 3 {\n            return p + 3\n        }\n        if n %\
    \ p == 4 {\n            return p + 4\n        }\n        if n % p == 5 {\n   \
    \         return p + 5\n        }\n        if n % p == 6 {\n            return\
    \ p + 6\n        }\n        if n % p == 7 {\n            return p + 7\n      \
    \  }\n        if n % p == 8 {\n            return p + 8\n        }\n        if\
    \ n % p == 9 {\n            return p + 9\n        }\n        if n % p == 10 {\n\
    \            return p + 10\n        }\n        if n % p == 11 {\n            return\
    \ p + 11\n        }\n        if n % p == 12 {\n            return p + 12\n   \
    \     }\n        if n % p == 13 {\n            return p + 13\n        }\n    \
    \    if n % p == 14 {\n            return p + 14\n        }\n        if n % p\
    \ == 15 {\n            return p + 15\n        }\n        return modp(p * 2, p)\n\
    \    }\n    if p < 99 {\n        if n % p == 2 {\n            return p + 2\n \
    \       }\n        if n % p == 3 {\n            return p + 3\n        }\n    \
    \    if n % p == 4 {\n            return p + 4\n        }\n        if n % p ==\
    \ 5 {\n            return p + 5\n        }\n        if n % p == 6 {\n        \
    \    return p + 6\n        }\n        if n % p == 7 {\n            return p +\
    \ 7\n        }\n        if n % p == 8 {\n            return p + 8\n        }\n\
    \        if n % p == 9 {\n            return p + 9\n        }\n        if n %\
    \ p == 10 {\n            return p + 10\n        }\n        if n % p == 11 {\n\
    \            return p + 11\n        }\n        if n % p == 12 {\n            return\
    \ p + 12\n        }\n        if n % p == 13 {\n            return p + 13\n   \
    \     }\n        if n % p == 14 {\n            return p + 14\n        }\n    \
    \    if n % p == 15 {\n            return p + 15\n        }\n        if n % p\
    \ == 16 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfo7a0e1q.swift:152:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpfo7a0e1q.swift:86:15:\
    \ note: to match this opening '{'\n    if p < 99 {\n              ^\n/tmp/tmpfo7a0e1q.swift:152:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpfo7a0e1q.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpfo7a0e1q.swift:21:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(p * 2, p)\n                   ^\n             \
    \       n:     p: \n/tmp/tmpfo7a0e1q.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(p * 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpfo7a0e1q.swift:36:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(p * 2, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpfo7a0e1q.swift:84:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(p * 2, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpfo7a0e1q.swift:134:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tvar n1, m1, n2, m2 int\n\tn1 = int64(n)\n\
    \tm1 = int64(p)\n\tn2 = int64(n1)\n\tm2 = int64(m1)\n\t// If n1 and m1 are both\
    \ even then n2 = m1 + 1 because n1 and m1 are even.\n\tif n1%2 == 0 && m1%2 ==\
    \ 0 {\n\t\tn2 = m1 + 1\n\t}\n\treturn n2 % m1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpleseqqns.swift:14:21: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var n1, m1,\
    \ n2, m2 int\n                           ^\n/tmp/tmpleseqqns.swift:14:21: note:\
    \ join the identifiers together\n        var n1, m1, n2, m2 int\n            \
    \            ~~~^~~\n                        m2int\n/tmp/tmpleseqqns.swift:14:21:\
    \ note: join the identifiers together with camel-case\n        var n1, m1, n2,\
    \ m2 int\n                        ~~~^~~\n                        m2Int\n/tmp/tmpleseqqns.swift:14:6:\
    \ error: type annotation missing in pattern\n        var n1, m1, n2, m2 int\n\
    \            ^\n/tmp/tmpleseqqns.swift:14:10: error: type annotation missing in\
    \ pattern\n        var n1, m1, n2, m2 int\n                ^\n/tmp/tmpleseqqns.swift:14:14:\
    \ error: type annotation missing in pattern\n        var n1, m1, n2, m2 int\n\
    \                    ^\n/tmp/tmpleseqqns.swift:14:18: error: type annotation missing\
    \ in pattern\n        var n1, m1, n2, m2 int\n                        ^\n/tmp/tmpleseqqns.swift:15:7:\
    \ error: cannot find 'int64' in scope\n        n1 = int64(n)\n             ^~~~~\n\
    /tmp/tmpleseqqns.swift:16:7: error: cannot find 'int64' in scope\n        m1 =\
    \ int64(p)\n             ^~~~~\n/tmp/tmpleseqqns.swift:17:7: error: cannot find\
    \ 'int64' in scope\n        n2 = int64(n1)\n             ^~~~~\n/tmp/tmpleseqqns.swift:18:7:\
    \ error: cannot find 'int64' in scope\n        m2 = int64(m1)\n             ^~~~~\n\
    /tmp/tmpleseqqns.swift:23:12: error: cannot convert return expression of type\
    \ 'UInt8' to return type 'Int'\n        return n2 % m1\n               ~~~^~~~\n\
    \               Int(   )\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\tif p < 0 {\n\
    \t\t\treturn 0\n\t\t}\n\t\treturn p + modp(abs(n), -p)\n\tcase n <= p:\n\t\treturn\
    \ n\n\tcase n == p:\n\t\treturn 1\n\tcase n == p - 1:\n\t\treturn modp(n, p-2)\n\
    \tdefault:\n\t\treturn modp(n, p - 1)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsofg0eow.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpsofg0eow.swift:19:18: error: missing\
    \ argument labels 'n:p:' in call\n                return p + modp(abs(n), -p)\n\
    \                               ^\n                                n:      p:\
    \ \n/tmp/tmpsofg0eow.swift:25:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p-2)\n                           ^\n         \
    \                   n: p: \n/tmp/tmpsofg0eow.swift:27:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n, p - 1)\n             \
    \              ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch {\n    case n > p:\n        return\
    \ n - p + p + 1\n    case n < p:\n        return p + p - n - 1\n    default:\n\
    \        return n\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpormjwuks.swift:14:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet m = p % n\n\tif m < 0 {\n\t\tm = (n\
    \ - m) % n\n\t}\n\treturn m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpe606eigc.swift:16:3: error: cannot assign to value: 'm' is a 'let'\
    \ constant\n                m = (n - m) % n\n                ^\n/tmp/tmpe606eigc.swift:14:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let m = p % n\n    \
    \    ^~~\n        var\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  // https://en.wikipedia.org/wiki/Modulo_operation\n\
    \  precondition(n, LessThanOrEqual.self)\n  precondition(p, LessThanOrEqual.self)\n\
    \  var rem = 0\n  repeat: while true {\n    if n == 0 || p == 0 {\n      return\
    \ rem\n    }\n    var q = n\n    n = p % q\n    rem = q\n    p = n\n  }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpexc2ukxz.swift:18:9: error: expected '{' after 'repeat'\n  repeat:\
    \ while true {\n        ^\n/tmp/tmpexc2ukxz.swift:26:3: error: expected 'while'\
    \ after body of 'repeat' statement\n  }\n  ^\n/tmp/tmpexc2ukxz.swift:15:19: error:\
    \ cannot find 'LessThanOrEqual' in scope\n  precondition(n, LessThanOrEqual.self)\n\
    \                  ^~~~~~~~~~~~~~~\n/tmp/tmpexc2ukxz.swift:15:16: error: type\
    \ 'Int' cannot be used as a boolean; test for '!= 0' instead\n  precondition(n,\
    \ LessThanOrEqual.self)\n               ^\n               ( != 0)\n/tmp/tmpexc2ukxz.swift:16:19:\
    \ error: cannot find 'LessThanOrEqual' in scope\n  precondition(p, LessThanOrEqual.self)\n\
    \                  ^~~~~~~~~~~~~~~\n/tmp/tmpexc2ukxz.swift:16:16: error: type\
    \ 'Int' cannot be used as a boolean; test for '!= 0' instead\n  precondition(p,\
    \ LessThanOrEqual.self)\n               ^\n               ( != 0)\n/tmp/tmpexc2ukxz.swift:23:5:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n    n = p % q\n    ^\n\
    /tmp/tmpexc2ukxz.swift:25:5: error: cannot assign to value: 'p' is a 'let' constant\n\
    \    p = n\n    ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    result ^= p + (n &\
    \ p - n)\n    if result < n {\n        result = result + p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpiqoknc0h/tmpiqoknc0h.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b4c439c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b4c130b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8b4c130988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8b4c12f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiqoknc0h                        0x000056479a8271bd <unavailable> + 4541

    5    libc.so.6                          0x00002b8b4c625460 __libc_start_main +
    245

    6    tmpiqoknc0h                        0x000056479a826e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n - p.powModInt(Int(n), Int(p))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanxvrv2x.swift:14:18: error: value of type 'Int' has no member\
    \ 'powModInt'\n    return n - p.powModInt(Int(n), Int(p))\n               ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    func mod(i: Int, r: Int) -> Int {\n  \
    \      return i % r\n    }\n    return n & (p-1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpvl1xfbjt/tmpvl1xfbjt.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31a534ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31a5041b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31a5041988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31a50407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvl1xfbjt                        0x000055900af1e1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b31a5536460 __libc_start_main +
    245

    6    tmpvl1xfbjt                        0x000055900af1de69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    n %= p\n    if n < 0 {\n        n += p\n\
    \    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5qgfl5_9.swift:14:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n %= p\n    ~ ^\n/tmp/tmp5qgfl5_9.swift:16:11:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n += p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn n -\
    \ 1\n\tcase n == 0:\n\t\treturn 1\n\tcase p == 0:\n\t\treturn 0\n\tcase p < 0:\n\
    \t\treturn modp(abs(n), abs(p))\n\t}\n\n\tlet q = (p - 1) >> 31\n\tlet r = p <<\
    \ 31\n\tlet s = n - 1\n\treturn modpow2(s, q, r)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvq3d2gcv.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvq3d2gcv.swift:22:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), abs(p))\n\
    \                           ^\n                            n:      p: \n/tmp/tmpvq3d2gcv.swift:28:9:\
    \ error: cannot find 'modpow2' in scope\n        return modpow2(s, q, r)\n   \
    \            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var res = 1\n  for i = 0; i < p; i++ {\n\
    \    res *= n\n  }\n  return Int(res)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9cjio240.swift:15:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for i = 0; i < p; i++ {\n  ^   ~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    assert(n >= 0, \"n must be non-negative\"\
    )\n    assert(p >= 1, \"p must be positive\")\n    if n == 0 {\n        return\
    \ 1\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n      \
    \  return n\n    }\n    if n >= p {\n        return p + (n - p) * (p - 1) / n\n\
    \    }\n    // n == p or a == p or b == p\n    return p + (n - p) * (p - 1) *\
    \ (p - 2) / n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpnfod383d/tmpnfod383d.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69fdc97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69fd98eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69fd98e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69fd98d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnfod383d                        0x000055a2d5eb72dd <unavailable> + 4829

    5    libc.so.6                          0x00002b69fde83460 __libc_start_main +
    245

    6    tmpnfod383d                        0x000055a2d5eb6f89 <unavailable> + 3977

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return (n+p-1)%p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpm9fux__m/tmpm9fux__m.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acab6023c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acab5d1ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acab5d1a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acab5d197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm9fux__m                        0x00005605cf48f24d <unavailable> + 4685

    5    libc.so.6                          0x00002acab620f460 __libc_start_main +
    245

    6    tmpm9fux__m                        0x00005605cf48eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n > p { return n }\n    p %= n\n  \
    \  return n + (p << 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpuqm8s61l.swift:15:7: error: left side of mutating operator isn't\
    \ mutable: 'p' is a 'let' constant\n    p %= n\n    ~ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < p && p % 2 == 1 {\n\t\treturn n\n\
    \t}\n\td := new(big.Int).SetInt64(1)\n\tfor i := 0; i < p; i++ {\n\t\td.Mul(d,\
    \ n)\n\t}\n\treturn d.Int64()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpumjrbk3d.swift:17:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        d := new(big.Int).SetInt64(1)\n         ^\n   \
    \      ;\n/tmp/tmpumjrbk3d.swift:17:4: error: expected expression\n        d :=\
    \ new(big.Int).SetInt64(1)\n          ^\n/tmp/tmpumjrbk3d.swift:18:9: error: expected\
    \ type\n        for i := 0; i < p; i++ {\n               ^\n                <#type#>\n\
    /tmp/tmpumjrbk3d.swift:18:9: error: expected 'in' after for-each pattern\n   \
    \     for i := 0; i < p; i++ {\n               ^\n/tmp/tmpumjrbk3d.swift:18:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < p; i++ {\n               ^\n/tmp/tmpumjrbk3d.swift:17:2: error: cannot find\
    \ 'd' in scope\n        d := new(big.Int).SetInt64(1)\n        ^\n/tmp/tmpumjrbk3d.swift:21:9:\
    \ error: cannot find 'd' in scope\n        return d.Int64()\n               ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n >= p {\n        return n - p;\n \
    \   } else {\n        return n - p + p;\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsh2qf_bg/tmpsh2qf_bg.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac83dde9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac83dae0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac83dae0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac83dadf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsh2qf_bg                        0x000055d38f81523d <unavailable> + 4669

    5    libc.so.6                          0x00002ac83dfd5460 __libc_start_main +
    245

    6    tmpsh2qf_bg                        0x000055d38f814e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"mod: n < 0\")\n\t\
    } else if p < 2 {\n\t\treturn 0\n\t} else if p > n {\n\t\treturn n\n\t}\n\tq,\
    \ _ := NewModPowInt(n, p % p, p)\n\treturn q\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpg7lc9z1i.swift:21:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q, _ := NewModPowInt(n, p % p, p)\n         ^\n\
    \         ;\n/tmp/tmpg7lc9z1i.swift:21:3: error: expected expression\n       \
    \ q, _ := NewModPowInt(n, p % p, p)\n         ^\n/tmp/tmpg7lc9z1i.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"mod: n < 0\")\n\
    \                ^~~~~\n/tmp/tmpg7lc9z1i.swift:21:2: error: cannot find 'q' in\
    \ scope\n        q, _ := NewModPowInt(n, p % p, p)\n        ^\n/tmp/tmpg7lc9z1i.swift:22:9:\
    \ error: cannot find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\n\tif n\
    \ >= p {\n\t\treturn 0\n\t}\n\n\tif n == p {\n\t\treturn 1\n\t}\n\n\tvar acc Int\n\
    \tfor i := 0; i < n; i++ {\n\t\tacc = acc*p + (1<<uint(i))\n\t}\n\n\treturn acc\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjoke1lpj.swift:26:10: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var acc Int\n\
    \                ^\n/tmp/tmpjoke1lpj.swift:26:10: note: join the identifiers together\n\
    \        var acc Int\n            ~~~~^~~\n            accInt\n/tmp/tmpjoke1lpj.swift:27:9:\
    \ error: expected type\n        for i := 0; i < n; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpjoke1lpj.swift:27:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 0; i < n; i++ {\n               ^\n/tmp/tmpjoke1lpj.swift:27:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < n; i++ {\n               ^\n/tmp/tmpjoke1lpj.swift:26:6: error: type annotation\
    \ missing in pattern\n        var acc Int\n            ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p < 1 {\n        guard n > 0 else {\
    \ return 1 }\n        return 0\n    }\n    var result = p % n\n    if result <\
    \ 0 {\n        result = result + n\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmprwvfwe21/tmprwvfwe21.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9520146c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b951fe3db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b951fe3d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b951fe3c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprwvfwe21                        0x000055baf69f624d <unavailable> + 4685

    5    libc.so.6                          0x00002b9520332460 __libc_start_main +
    245

    6    tmprwvfwe21                        0x000055baf69f5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n.wrap(p).wrap(p).wrap(p)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpql00fouh.swift:14:14: error: value of type 'Int' has no member\
    \ 'wrap'\n    return n.wrap(p).wrap(p).wrap(p)\n           ~ ^~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    return n & (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpouvf1dp2/tmpouvf1dp2.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4ee0b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4edda8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4edda8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4edda77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpouvf1dp2                        0x000055dc06f2b1bd <unavailable> + 4541

    5    libc.so.6                          0x00002ac4ee29d460 __libc_start_main +
    245

    6    tmpouvf1dp2                        0x000055dc06f2ae69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n >= p || n < 0 {\n        return -1\n\
    \    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmphys0k7ou/tmphys0k7ou.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b464d172c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b464ce69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b464ce69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b464ce687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphys0k7ou                        0x0000558d303462cd <unavailable> + 4813

    5    libc.so.6                          0x00002b464d35e460 __libc_start_main +
    245

    6    tmphys0k7ou                        0x0000558d30345ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch n {\n\tcase 0:\n\t\treturn 1\n\t\
    case 3:\n\t\treturn mod3p(n, p)\n\tcase 1101:\n\t\treturn mod101p(n, p)\n\t}\n\
    \treturn mod100p(n, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7sj1pjoc.swift:18:10: error: cannot find 'mod3p' in scope\n   \
    \             return mod3p(n, p)\n                       ^~~~~\n/tmp/tmp7sj1pjoc.swift:20:10:\
    \ error: cannot find 'mod101p' in scope\n                return mod101p(n, p)\n\
    \                       ^~~~~~~\n/tmp/tmp7sj1pjoc.swift:14:2: error: switch must\
    \ be exhaustive\n        switch n {\n        ^\n/tmp/tmp7sj1pjoc.swift:14:2: note:\
    \ do you want to add a default clause?\n        switch n {\n        ^\n/tmp/tmp7sj1pjoc.swift:22:9:\
    \ error: cannot find 'mod100p' in scope\n        return mod100p(n, p)\n      \
    \         ^~~~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 1\n    }\n    if p <= 1 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n >= p {\n        return\
    \ p\n    }\n    if n >= p {\n        return modp(n - p, p)\n    }\n    if n <=\
    \ p {\n        return modp(n - p, p)\n    }\n    return modp(p, n)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph8lns8vr.swift:30:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmph8lns8vr.swift:33:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmph8lns8vr.swift:35:16: error: missing argument\
    \ labels 'n:p:' in call\n    return modp(p, n)\n               ^\n           \
    \     n: p: \n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\tswitch {\n\t\
    \tcase p < 0:\n\t\t\tpanic(\"modp mod negative modulus (mod %d)\")\n\t\tdefault:\n\
    \t\t\treturn 0\n\t\t}\n\tcase n == 0:\n\t\treturn 1\n\tdefault:\n\t\treturn p\
    \ % n\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvf9nc9bx.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvf9nc9bx.swift:16:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmpvf9nc9bx.swift:18:4: error: cannot find 'panic' in scope\n\
    \                        panic(\"modp mod negative modulus (mod %d)\")\n     \
    \                   ^~~~~\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    n %= p\n    if n < 0 {\n        n += p\n\
    \    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5qgfl5_9.swift:14:7: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n    n %= p\n    ~ ^\n/tmp/tmp5qgfl5_9.swift:16:11:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n += p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n > p || n < 0 {\n\t\tpanic(\"modp: invalid\
    \ input\")\n\t}\n\tvar result UInt64\n\tfor n > 0 {\n\t\tif n > p {\n\t\t\tresult\
    \ += UInt64(p - 1)\n\t\t}\n\t\tn >>= 1\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\
    }\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpasatw1wl.swift:17:13: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var result UInt64\n\
    \                   ^\n/tmp/tmpasatw1wl.swift:17:13: note: join the identifiers\
    \ together\n        var result UInt64\n            ~~~~~~~^~~~~~\n           \
    \ resultUInt64\n/tmp/tmpasatw1wl.swift:18:8: error: expected 'in' after for-each\
    \ pattern\n        for n > 0 {\n              ^\n/tmp/tmpasatw1wl.swift:18:8:\
    \ error: unary operator cannot be separated from its operand\n        for n >\
    \ 0 {\n              ^~\n               \n/tmp/tmpasatw1wl.swift:15:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"modp: invalid input\"\
    )\n                ^~~~~\n/tmp/tmpasatw1wl.swift:17:6: error: type annotation\
    \ missing in pattern\n        var result UInt64\n            ^\n/tmp/tmpasatw1wl.swift:18:8:\
    \ error: '>' is not a prefix unary operator\n        for n > 0 {\n           \
    \   ^\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    if n == 0 { return 1\
    \ }\n    if n == p { return 0 }\n    for i in 0..<n {\n        res *= p\n    \
    \    res %= p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmprfju5iz5/tmprfju5iz5.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0951904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09515fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09515fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09515fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprfju5iz5                        0x0000558cb699633d <unavailable> + 4925

    5    libc.so.6                          0x00002b0951af0460 __libc_start_main +
    245

    6    tmprfju5iz5                        0x0000558cb6995fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var result = 1\n  for _ in 0..<n {\n   \
    \ result = result * p\n  }\n  return result % p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpo_pe97fk/tmpo_pe97fk.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b447cd5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b447ca56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b447ca56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b447ca557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo_pe97fk                        0x000055d52585d33d <unavailable> + 4925

    5    libc.so.6                          0x00002b447cf4b460 __libc_start_main +
    245

    6    tmpo_pe97fk                        0x000055d52585cfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660015065
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch n {\n    case 0: return 1\n   \
    \ case 1: return 0\n    default:\n        let p = p % n\n        if p < 0 {\n\
    \            p = p + n\n        }\n        return p\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpw4rs2g2e.swift:20:13: error: cannot assign to value: 'p' is a 'let'\
    \ constant\n            p = p + n\n            ^\n/tmp/tmpw4rs2g2e.swift:18:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let p = p % n\n    \
    \    ^~~\n        var\n"
  stdout: ''
  timestamp: 1660015065
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n%p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpil2_1wnz/tmpil2_1wnz.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae743c46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae74393db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae74393d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae74393c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpil2_1wnz                        0x0000556578bf02cd <unavailable> + 4813

    5    libc.so.6                          0x00002ae743e32460 __libc_start_main +
    245

    6    tmpil2_1wnz                        0x0000556578befef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn\
    \ p - n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpl6v0admq/tmpl6v0admq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad294339c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad294030b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad294030988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad29402f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl6v0admq                        0x0000558f851cc1bd <unavailable> + 4541

    5    libc.so.6                          0x00002ad294525460 __libc_start_main +
    245

    6    tmpl6v0admq                        0x0000558f851cbe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // TODO: switch to BigUint if performance\
    \ is critical\n    if n >= p {\n        return n\n    }\n    if p >= n {\n   \
    \     return 0\n    }\n    var result = n % p\n    if result > 0 {\n        result\
    \ = (n - result) % p\n    } else {\n        result = ((n - result) + p) % p\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp56679opl/tmp56679opl.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b96ab5b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b96ab2a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b96ab2a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96ab2a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56679opl                        0x000055ca57deb24d <unavailable> + 4685

    5    libc.so.6                          0x00002b96ab79c460 __libc_start_main +
    245

    6    tmp56679opl                        0x000055ca57deaef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) - (n & p)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpiqkd3hiv/tmpiqkd3hiv.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7a451bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7a4212b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba7a4212988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7a42117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiqkd3hiv                        0x0000558eb3dad1bd <unavailable> + 4541

    5    libc.so.6                          0x00002ba7a4707460 __libc_start_main +
    245

    6    tmpiqkd3hiv                        0x0000558eb3dace69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || (n == 1 && p == 1) || p ==\
    \ 1 {\n\t\treturn 0\n\t}\n\tn %= p\n\treturn n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpozolj0xr.swift:17:4: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < p {\n\t\tif n < 0 {\n\t\t\treturn\
    \ 0\n\t\t}\n\t\treturn n\n\t}\n\tif p < n {\n\t\tif p < 0 {\n\t\t\treturn 0\n\t\
    \t}\n\t\treturn p\n\t}\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t}\n\tif n >=\
    \ p {\n\t\tn -= p\n\t\treturn n\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpd2g24xua.swift:30:5: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n -= p\n                ~\
    \ ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < p { panic(\"modp: n must be bigger\
    \ than p\") }\n    var result = n & (p - 1)\n    if n > p { result += (p - n)\
    \ % p }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfhmb5kbj.swift:14:16: error: cannot find 'panic' in scope\n   \
    \ if n < p { panic(\"modp: n must be bigger than p\") }\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 1\n\t\
    }\n\tconst q = p / n\n\tconst r = p % n\n\tif q == r {\n\t\treturn q\n\t}\n\t\
    if r > 0 {\n\t\treturn modp(n, n)\n\t}\n\treturn modp(q, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeq5mry7k.swift:17:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        const q = p / n\n             ^\n             ;\n\
    /tmp/tmpeq5mry7k.swift:18:7: error: consecutive statements on a line must be separated\
    \ by ';'\n        const r = p % n\n             ^\n             ;\n/tmp/tmpeq5mry7k.swift:17:2:\
    \ error: cannot find 'const' in scope\n        const q = p / n\n        ^~~~~\n\
    /tmp/tmpeq5mry7k.swift:17:8: error: cannot find 'q' in scope\n        const q\
    \ = p / n\n              ^\n/tmp/tmpeq5mry7k.swift:18:2: error: cannot find 'const'\
    \ in scope\n        const r = p % n\n        ^~~~~\n/tmp/tmpeq5mry7k.swift:18:8:\
    \ error: cannot find 'r' in scope\n        const r = p % n\n              ^\n\
    /tmp/tmpeq5mry7k.swift:19:5: error: cannot find 'q' in scope\n        if q ==\
    \ r {\n           ^\n/tmp/tmpeq5mry7k.swift:19:10: error: cannot find 'r' in scope\n\
    \        if q == r {\n                ^\n/tmp/tmpeq5mry7k.swift:20:10: error:\
    \ cannot find 'q' in scope\n                return q\n                       ^\n\
    /tmp/tmpeq5mry7k.swift:22:5: error: cannot find 'r' in scope\n        if r > 0\
    \ {\n           ^\n/tmp/tmpeq5mry7k.swift:23:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(n, n)\n                        \
    \   ^\n                            n: p: \n/tmp/tmpeq5mry7k.swift:25:14: error:\
    \ cannot find 'q' in scope\n        return modp(q, p)\n                    ^\n\
    /tmp/tmpeq5mry7k.swift:25:13: error: missing argument labels 'n:p:' in call\n\
    \        return modp(q, p)\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let a = pow(m, Int(n), p)\n    let b =\
    \ pow(m, Int(n), p)\n    let result = a - b\n    if result > p { result = result\
    \ - p }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp29tr0ucc.swift:14:13: error: cannot find 'pow' in scope\n    let\
    \ a = pow(m, Int(n), p)\n            ^~~\n/tmp/tmp29tr0ucc.swift:14:17: error:\
    \ cannot find 'm' in scope\n    let a = pow(m, Int(n), p)\n                ^\n\
    /tmp/tmp29tr0ucc.swift:15:13: error: cannot find 'pow' in scope\n    let b = pow(m,\
    \ Int(n), p)\n            ^~~\n/tmp/tmp29tr0ucc.swift:15:17: error: cannot find\
    \ 'm' in scope\n    let b = pow(m, Int(n), p)\n                ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tlet modp = modp(Abs(n),\
    \ p)\n\t\tif modp == 1 {\n\t\t\treturn 0\n\t\t}\n\t\treturn modp\n\t}\n\n\tlet\
    \ m = Mod(n, p)\n\tif m == 0 {\n\t\treturn 1\n\t}\n\n\treturn m\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfi62i913.swift:15:19: error: cannot find 'Abs' in scope\n     \
    \           let modp = modp(Abs(n), p)\n                                ^~~\n\
    /tmp/tmpfi62i913.swift:15:18: error: missing argument labels 'n:p:' in call\n\
    \                let modp = modp(Abs(n), p)\n                               ^\n\
    \                                n:      p: \n/tmp/tmpfi62i913.swift:22:10: error:\
    \ cannot find 'Mod' in scope\n        let m = Mod(n, p)\n                ^~~\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  // Special case when n = 0\n  if n == 0\
    \ {\n    return 1\n  }\n  if n == 1 {\n    return 0\n  }\n\n  // Compute result\
    \ = ((n-1)/p) % p\n  // We want to compute:\n  //\n  //     result = (result *\
    \ p + 1) %p\n  //\n  // We want to make sure that the modulo remainder is 0 when\
    \ the\n  // result is larger than p. This means that we have to\n  // shift our\
    \ result one bit to the right, and correct the value\n  // to be zero if the result\
    \ was smaller than p.\n  // If result > p, result - p will be negative.\n  //\n\
    \  // Example 1:\n  //\n  // Let n = 6 and p = 7.\n  // The expression ((6-1)/7)\
    \ % 7 yields 4, and the expression 4 % 7 yields\n  // 4. The value of (6-1)/7\
    \ is -4, and the value of 4 is 4.\n  //\n  // Example 2:\n  //\n  // Let n = 10\
    \ and p = 5\n  // The expression ((10-1)/5) % 5 yields 0, and the expression 0\
    \ % 5 yields\n  // 0. The value of (10-1)/5 is -2, and the value of -2 is 0.\n\
    \  let result = ((n - 1) / (p - 1)) % p\n\n  // Make sure we get a valid result,\
    \ i.e. the modulo remainder is 0 when\n  // the result is larger than p\n  if\
    \ result > p {\n    return result - p\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpd5aio4_q/tmpd5aio4_q.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad9d35bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad9d052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad9d052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad9d0517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd5aio4_q                        0x0000559896aec24d <unavailable> + 4685

    5    libc.so.6                          0x00002aad9d547460 __libc_start_main +
    245

    6    tmpd5aio4_q                        0x0000559896aebef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch {\n    case n < 0:\n        return\
    \ (p - 1) & ^(n + 1)\n    case n >= p:\n        return 0\n    case n == 0 && p\
    \ > 0:\n        return 1\n    case n == p && p > 1:\n        return n\n    }\n\
    \n    // n == p && p >= 2\n    // n == p && p >= 3\n    // n >= 0 && n > p\n \
    \   // n >= 0 && n < p\n    // n < 0 && n < p\n    // n < 0 && n > p\n    // n\
    \ < 0 && n == p\n    switch {\n    case n < p && n >= p:\n        return n - p\n\
    \    case n > p && n >= p:\n        return n + p\n    case n < p && n < p:\n \
    \       return n + p\n    case n > p && n < p:\n        return n - p\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpr54zb1zo.swift:14:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmpr54zb1zo.swift:32:12: error: expected expression\
    \ in 'switch' statement\n    switch {\n           ^\n/tmp/tmpr54zb1zo.swift:16:26:\
    \ error: '^' is not a prefix unary operator\n        return (p - 1) & ^(n + 1)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // We only support integers as input.\n\
    \    if n != Int(n) || p != Int(p) {\n        throw NumericError(\"modp(): arguments\
    \ must be integers\")\n    }\n\n    // Return n modulo p, or 0 when both n and\
    \ p are 0.\n    if n == 0 && p == 0 {\n        return 0\n    }\n    if n <= p\
    \ && n % p == 0 {\n        return n\n    }\n\n    // Find p1 such that n and p\
    \ are coprime. p1 must be odd.\n    var p1 = p - 1\n    if p1 % 2 == 1 {\n   \
    \     p1 -= 1\n    }\n\n    // Choose m such that p1 < m*p < n and m is coprime.\n\
    \    var m = Int(n)\n    var i = 1\n    while p*i < n && p*m > n {\n        i\
    \ += 1\n        m *= Int(p)\n    }\n\n    // Return n modulo m when m*p is small\
    \ enough.\n    return n - (m*p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgk1589z6.swift:16:15: error: cannot find 'NumericError' in scope\n\
    \        throw NumericError(\"modp(): arguments must be integers\")\n        \
    \      ^~~~~~~~~~~~\n/tmp/tmpgk1589z6.swift:16:9: error: error is not handled\
    \ because the enclosing function is not declared 'throws'\n        throw NumericError(\"\
    modp(): arguments must be integers\")\n        ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t} else if p\
    \ == 0 {\n\t\treturn 0\n\t}\n\tswitch {\n\tcase n < 0:\n\t\tswitch {\n\t\tcase\
    \ n >= p:\n\t\t\treturn n - p\n\t\tdefault:\n\t\t\treturn n - 1\n\t\t}\n\tcase\
    \ n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn 1 + modp(n - 1, p) / p\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5kujva3o.swift:19:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp5kujva3o.swift:21:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmp5kujva3o.swift:30:18: error: missing argument labels 'n:p:'\
    \ in call\n                return 1 + modp(n - 1, p) / p\n                   \
    \            ^\n                                n:     p: \n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 || p == 0 {\n        return\
    \ 1\n    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpjm1p_glc/tmpjm1p_glc.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f72f38c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f72c2fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f72c2f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f72c2e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjm1p_glc                        0x000055c5728aa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9f73124460 __libc_start_main +
    245

    6    tmpjm1p_glc                        0x000055c5728a9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tassert(n >= 0 && p >= 0 && n > p)\n\tassert(p\
    \ > 0)\n\t\n\treturn (n - p) % (p + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpkm7yatri/tmpkm7yatri.swift:14: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b068ee31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b068eb28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b068eb28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b068eb277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkm7yatri                        0x000055b440fb4661 <unavailable> + 5729

    5    tmpkm7yatri                        0x000055b440fb41e0 <unavailable> + 4576

    6    libc.so.6                          0x00002b068f01d460 __libc_start_main +
    245

    7    tmpkm7yatri                        0x000055b440fb3ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"mod: negative modulus\"\
    )\n\t}\n\n\tif n < p {\n\t\treturn powmod(n, p, p)\n\t}\n\n\trem := n % p\n\t\
    n /= p\n\n\tmod := powmod(n, p, p)\n\tif rem > 0 {\n\t\tmod = -mod\n\t}\n\n\t\
    return mod * p + rem\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptb68y2v0.swift:22:5: error: consecutive statements on a line must\
    \ be separated by ';'\n        rem := n % p\n           ^\n           ;\n/tmp/tmptb68y2v0.swift:22:6:\
    \ error: expected expression\n        rem := n % p\n            ^\n/tmp/tmptb68y2v0.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"mod: negative modulus\"\
    )\n                ^~~~~\n/tmp/tmptb68y2v0.swift:19:10: error: cannot find 'powmod'\
    \ in scope\n                return powmod(n, p, p)\n                       ^~~~~~\n\
    /tmp/tmptb68y2v0.swift:22:2: error: cannot find 'rem' in scope\n        rem :=\
    \ n % p\n        ^~~\n/tmp/tmptb68y2v0.swift:26:5: error: cannot find 'rem' in\
    \ scope\n        if rem > 0 {\n           ^~~\n/tmp/tmptb68y2v0.swift:27:3: error:\
    \ cannot find 'mod' in scope\n                mod = -mod\n                ^~~\n\
    /tmp/tmptb68y2v0.swift:27:10: error: cannot find 'mod' in scope\n            \
    \    mod = -mod\n                       ^~~\n/tmp/tmptb68y2v0.swift:30:9: error:\
    \ cannot find 'mod' in scope\n        return mod * p + rem\n               ^~~\n\
    /tmp/tmptb68y2v0.swift:30:19: error: cannot find 'rem' in scope\n        return\
    \ mod * p + rem\n                         ^~~\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  switch {\n  case n == 0 where p != 1: return\
    \ 0\n  case n >= p where n % p == 0: return n\n  default: return (n + (p - 1))\
    \ % p\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0pqj2xyq.swift:14:10: error: expected expression in 'switch' statement\n\
    \  switch {\n         ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n > p || n <= 0: return\
    \ 0\n\tcase n == 0: return 1\n\tcase n == 1: return p\n\tcase n <= 9: return p\
    \ + (n % p)\n\tcase n <= 18: return p + (n % p) + ((p * p + (n % p)) % (p ^ p))\n\
    \tcase n <= 27: return p + (n % p) + ((p * p + (n % p) + (p ^ p)) % (p * p + (p\
    \ ^ p)))\n\tcase n <= 36: return p + (n % p) + ((p * p + (n % p) + (p * p + p))\
    \ % (p * p + p)) + ((p * p + (n % p)) % (p * p + (p ^ p)))\n\tcase n <= 45: return\
    \ p + (n % p) + ((p * p + (n % p) + (p * p + p) + (p ^ p)) % (p * p + p)) + ((p\
    \ * p + (n % p) + (p * p + p)) % (p * p + (p ^ p)))\n\tcase n <= 54: return p\
    \ + (n % p) + ((p * p + (n % p) + (p * p + p) + (p * p + p)) % (p * p + p)) +\
    \ ((p * p + (n % p) + (p * p + p) + (p * p + p)) % (p * p + (p ^ p)))\n\t}\n\t\
    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjyznk3ry.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet mask = n - p\n\tlet mask2 = mask * mask\n\
    \tlet mask3 = (mask2 >> 1) + 1\n\treturn mask & mask3\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpiimxofem/tmpiimxofem.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1071c65c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b107195cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b107195c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b107195b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiimxofem                        0x00005566346b01bd <unavailable> + 4541

    5    libc.so.6                          0x00002b1071e51460 __libc_start_main +
    245

    6    tmpiimxofem                        0x00005566346afe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var q = p - 1\n    for ; n >= q; n-- {\n\
    \        q %= p\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj0qfthif.swift:15:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for ; n >= q; n-- {\n    ^   ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tn %= p\n\tif n < 0 {\n\t\treturn ((p - 1)\
    \ &+ n) % (p)\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp39vafgpa.swift:14:4: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n >= p {\n\t\tif n == 0 {\n\t\t\treturn\
    \ 1\n\t\t}\n\t\treturn n % p\n\t}\n\n\tlet k = p - n\n\treturn n % p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp26ttidzy/tmp26ttidzy.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf793dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf790d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf790d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf790d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp26ttidzy                        0x000055592a2cc2cd <unavailable> + 4813

    5    libc.so.6                          0x00002abf795c8460 __libc_start_main +
    245

    6    tmp26ttidzy                        0x000055592a2cbef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // Avoid overflow by limiting n's magnitude\
    \ to MIN_P and MAX_P respectively.\n    n = clamp(n, 0, p + 1)\n    let r = n\
    \ % p\n    if r == 0 || r == p {\n        return n\n    }\n    return p - r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptt8cn5bw.swift:15:9: error: cannot find 'clamp' in scope\n    n\
    \ = clamp(n, 0, p + 1)\n        ^~~~~\n/tmp/tmptt8cn5bw.swift:15:5: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n    n = clamp(n, 0, p + 1)\n    ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn n - p.power(n).signum()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt5mmx42n.swift:14:15: error: value of type 'Int' has no member\
    \ 'power'\n        return n - p.power(n).signum()\n                   ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 0\n    var m = 1\n    var i\
    \ = 0\n    for n > 0 {\n        if m % 2 == 1 {\n            res += (n % 2) *\
    \ m / p\n        }\n        m *= p\n        n /= p\n        i += 1\n    }\n  \
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyf5hrvzb.swift:17:11: error: expected 'in' after for-each pattern\n\
    \    for n > 0 {\n          ^\n/tmp/tmpyf5hrvzb.swift:17:11: error: unary operator\
    \ cannot be separated from its operand\n    for n > 0 {\n          ^~\n      \
    \     \n/tmp/tmpyf5hrvzb.swift:17:11: error: '>' is not a prefix unary operator\n\
    \    for n > 0 {\n          ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    switch {\n    case n < 0 {\n        return\
    \ modp(negate(n), p)\n    } else if n < p {\n        return n\n    }\n    return\
    \ p % n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpee7beahx.swift:14:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmpee7beahx.swift:15:16: error: expected ':'\
    \ after 'case'\n    case n < 0 {\n               ^\n/tmp/tmpee7beahx.swift:17:6:\
    \ error: consecutive statements on a line must be separated by ';'\n    } else\
    \ if n < p {\n     ^\n     ;\n/tmp/tmpee7beahx.swift:17:7: error: expected expression\n\
    \    } else if n < p {\n      ^\n/tmp/tmpee7beahx.swift:42:31: error: expected\
    \ '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n            \
    \                  ^\n/tmp/tmpee7beahx.swift:13:34: note: to match this opening\
    \ '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n\
    /tmp/tmpee7beahx.swift:16:21: error: cannot find 'negate' in scope\n        return\
    \ modp(negate(n), p)\n                    ^~~~~~\n/tmp/tmpee7beahx.swift:15:16:\
    \ error: closure expression is unused\n    case n < 0 {\n               ^\n/tmp/tmpee7beahx.swift:15:16:\
    \ note: did you mean to use a 'do' statement?\n    case n < 0 {\n            \
    \   ^\n               do \n/tmp/tmpee7beahx.swift:24:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    assert(n >= 0, \"modulo in negative numbers\"\
    )\n    assert(p >= 1, \"modulo in prime numbers\")\n    \n    if p*n > n {\n \
    \       return modp(n-p*p, p)\n    }\n    \n    n -= p - 1\n    \n    if n ==\
    \ 0 {\n        return 1\n    }\n    \n    // calculate first n-1 digits\n    var\
    \ firstDigits: Int = n % p\n    var remainder = n / p\n    \n    // calculate\
    \ digits for next iteration, until we run out of digits\n    var digits = p\n\
    \    for remaining := 0; digits < firstDigits; digits++ {\n        if remainder\
    \ == 0 {\n            return 0\n        }\n        remainder--\n    }\n    \n\
    \    // calculate last digit\n    var lastDigit: Int\n    if remainder == 0 {\n\
    \        lastDigit = 1\n    } else {\n        lastDigit = remainder % p\n    \
    \    remainder = remainder / p\n    }\n    \n    var result = lastDigit + digits\n\
    \    \n    if result > p {\n        return modp(p*result, p)\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_4dslgc5.swift:33:20: error: expected type\n    for remaining :=\
    \ 0; digits < firstDigits; digits++ {\n                   ^\n                \
    \    <#type#>\n/tmp/tmp_4dslgc5.swift:33:20: error: expected 'in' after for-each\
    \ pattern\n    for remaining := 0; digits < firstDigits; digits++ {\n        \
    \           ^\n/tmp/tmp_4dslgc5.swift:33:20: error: expected Sequence expression\
    \ for for-each loop\n    for remaining := 0; digits < firstDigits; digits++ {\n\
    \                   ^\n/tmp/tmp_4dslgc5.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n-p*p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmp_4dslgc5.swift:21:7: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n    n -= p - 1\n    ~ ^\n/tmp/tmp_4dslgc5.swift:52:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(p*result,\
    \ p)\n                   ^\n                    n:        p: \n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  let mut s = n\n  let mut r = 0\n  while\
    \ n > 0 {\n    r = r * p % s + 1\n    s = s * p % s\n    n = n / p\n  }\n  return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp92h4lt19.swift:14:11: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n  let mut s = n\n  \
    \        ^\n/tmp/tmp92h4lt19.swift:14:11: note: join the identifiers together\n\
    \  let mut s = n\n      ~~~~^\n      muts\n/tmp/tmp92h4lt19.swift:14:11: note:\
    \ join the identifiers together with camel-case\n  let mut s = n\n      ~~~~^\n\
    \      mutS\n/tmp/tmp92h4lt19.swift:15:11: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n  let mut r = 0\n  \
    \        ^\n/tmp/tmp92h4lt19.swift:15:11: note: join the identifiers together\n\
    \  let mut r = 0\n      ~~~~^\n      mutr\n/tmp/tmp92h4lt19.swift:15:11: note:\
    \ join the identifiers together with camel-case\n  let mut r = 0\n      ~~~~^\n\
    \      mutR\n/tmp/tmp92h4lt19.swift:15:7: error: invalid redeclaration of 'mut'\n\
    \  let mut r = 0\n      ^\n/tmp/tmp92h4lt19.swift:14:7: note: 'mut' previously\
    \ declared here\n  let mut s = n\n      ^\n/tmp/tmp92h4lt19.swift:17:5: error:\
    \ cannot find 'r' in scope\n    r = r * p % s + 1\n    ^\n/tmp/tmp92h4lt19.swift:17:9:\
    \ error: cannot find 'r' in scope\n    r = r * p % s + 1\n        ^\n/tmp/tmp92h4lt19.swift:17:17:\
    \ error: cannot find 's' in scope\n    r = r * p % s + 1\n                ^\n\
    /tmp/tmp92h4lt19.swift:18:5: error: cannot find 's' in scope\n    s = s * p %\
    \ s\n    ^\n/tmp/tmp92h4lt19.swift:18:9: error: cannot find 's' in scope\n   \
    \ s = s * p % s\n        ^\n/tmp/tmp92h4lt19.swift:18:17: error: cannot find 's'\
    \ in scope\n    s = s * p % s\n                ^\n/tmp/tmp92h4lt19.swift:19:5:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n    n = n / p\n    ^\n\
    /tmp/tmp92h4lt19.swift:21:10: error: cannot find 'r' in scope\n  return r\n  \
    \       ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let t = Int((1 << p) * n) >> p\n    return\
    \ t % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpryg_9j5s/tmpryg_9j5s.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a9d454c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a9d14bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a9d14b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a9d14a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpryg_9j5s                        0x0000559cd2f423fd <unavailable> + 5117

    5    libc.so.6                          0x00002b0a9d640460 __libc_start_main +
    245

    6    tmpryg_9j5s                        0x0000559cd2f42029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 || p < 0 {\n        return 0\
    \ // should never happen\n    }\n    if n == 0 {\n        return 1\n    }\n  \
    \  if p == 1 {\n        return n\n    }\n    let res = n % p\n    if res == 0\
    \ || res == p {\n        return res\n    }\n    return n - res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpf0kwzhgd/tmpf0kwzhgd.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b219f2c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b219efbab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b219efba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b219efb97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf0kwzhgd                        0x00005576eae5024d <unavailable> + 4685

    5    libc.so.6                          0x00002b219f4af460 __libc_start_main +
    245

    6    tmpf0kwzhgd                        0x00005576eae4fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if n <= p {\n        return n &\
    \ (p - 1)\n    }\n    if p < 2 {\n        return n - p\n    }\n    d := (p - 1)\
    \ >> 1\n    return (n >> d) & p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpodblsoi2.swift:26:6: error: consecutive statements on a line must\
    \ be separated by ';'\n    d := (p - 1) >> 1\n     ^\n     ;\n/tmp/tmpodblsoi2.swift:26:7:\
    \ error: expected expression\n    d := (p - 1) >> 1\n      ^\n/tmp/tmpodblsoi2.swift:26:5:\
    \ error: cannot find 'd' in scope\n    d := (p - 1) >> 1\n    ^\n/tmp/tmpodblsoi2.swift:27:18:\
    \ error: cannot find 'd' in scope\n    return (n >> d) & p\n                 ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 { return 1 }\n    if p == 0\
    \ { return 0 }\n    if n == p { return n }\n    if n % p == 0 { return modp(n\
    \ / p, p) }\n    if p % n == 0 { return modp(n, p) }\n    return modp(n / p, p)\
    \ * modp(n, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp__oqheu0.swift:17:32: error: missing argument labels 'n:p:' in\
    \ call\n    if n % p == 0 { return modp(n / p, p) }\n                        \
    \       ^\n                                n:     p: \n/tmp/tmp__oqheu0.swift:18:32:\
    \ error: missing argument labels 'n:p:' in call\n    if p % n == 0 { return modp(n,\
    \ p) }\n                               ^\n                                n: p:\
    \ \n/tmp/tmp__oqheu0.swift:19:16: error: missing argument labels 'n:p:' in call\n\
    \    return modp(n / p, p) * modp(n, p)\n               ^\n                n:\
    \     p: \n/tmp/tmp__oqheu0.swift:19:33: error: missing argument labels 'n:p:'\
    \ in call\n    return modp(n / p, p) * modp(n, p)\n                          \
    \      ^\n                                 n: p: \n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if n >= p {\n        return n %\
    \ p\n    } else {\n        return ((n - 1) % p + p) % p\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpuz_j2ebc/tmpuz_j2ebc.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b962c4c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b962c1beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b962c1be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b962c1bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuz_j2ebc                        0x000055f47776624d <unavailable> + 4685

    5    libc.so.6                          0x00002b962c6b3460 __libc_start_main +
    245

    6    tmpuz_j2ebc                        0x000055f477765ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n > p || n < 0 {\n        return n\n\
    \    }\n    var res = 1\n    if n < p {\n        res = (p % n) + n\n    }\n  \
    \  if p < n {\n        res = (n % p) + p\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp0y_863q4/tmp0y_863q4.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20d7724c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20d741bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20d741b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20d741a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0y_863q4                        0x000055f51dbb524d <unavailable> + 4685

    5    libc.so.6                          0x00002b20d7910460 __libc_start_main +
    245

    6    tmp0y_863q4                        0x000055f51dbb4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn\
    \ p - n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpl6v0admq/tmpl6v0admq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad294339c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad294030b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad294030988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad29402f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl6v0admq                        0x0000558f851cc1bd <unavailable> + 4541

    5    libc.so.6                          0x00002ad294525460 __libc_start_main +
    245

    6    tmpl6v0admq                        0x0000558f851cbe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn n %\
    \ p\n\tcase n == p:\n\t\treturn 1\n\tcase n > 0:\n\t\treturn modp(n - 1, p) +\
    \ modp(n, p)\n\tdefault:\n\t\treturn modp(n + 1, p)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpaxrjcv7b.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpaxrjcv7b.swift:20:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p) + modp(n,\
    \ p)\n                           ^\n                            n:     p: \n/tmp/tmpaxrjcv7b.swift:20:31:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p) + modp(n, p)\n                                            ^\n      \
    \                                       n: p: \n/tmp/tmpaxrjcv7b.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ + 1, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        p *= -1\n        n\
    \ *= -1\n    }\n    if n < p {\n        return n\n    }\n    if p < n {\n    \
    \    p *= -1\n    }\n    return p - (n%p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpd_7mvofj.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'p' is a 'let' constant\n        p *= -1\n        ~ ^\n/tmp/tmpd_7mvofj.swift:16:11:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n *= -1\n        ~ ^\n/tmp/tmpd_7mvofj.swift:22:11: error: left side\
    \ of mutating operator isn't mutable: 'p' is a 'let' constant\n        p *= -1\n\
    \        ~ ^\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 1\n\t\
    }\n\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn n + p - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp19h8_8wd/tmp19h8_8wd.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4fffc02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4fff8f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4fff8f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4fff8f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp19h8_8wd                        0x000055f8d36461bd <unavailable> + 4541

    5    libc.so.6                          0x00002b4fffdee460 __libc_start_main +
    245

    6    tmp19h8_8wd                        0x000055f8d3645e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 1\n\t\
    } else if n <= p {\n\t\treturn 0\n\t}\n\n\tif p < 2*n {\n\t\treturn n - p\n\t\
    } else {\n\t\tif p < 2*n+1 {\n\t\t\treturn modp(n - p, p) + p\n\t\t} else {\n\t\
    \t\tmod := 1\n\t\t\tfor i := 0; i < n-p && i < p; i++ {\n\t\t\t\tif mod*p > p\
    \ {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tmod *= p\n\t\t\t}\n\t\t\tif mod < p {\n\
    \t\t\t\treturn p\n\t\t\t} else {\n\t\t\t\treturn mod\n\t\t\t}\n\t\t}\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwm1xy0km.swift:26:7: error: consecutive statements on a line must\
    \ be separated by ';'\n                        mod := 1\n                    \
    \       ^\n                           ;\n/tmp/tmpwm1xy0km.swift:26:8: error: expected\
    \ expression\n                        mod := 1\n                            ^\n\
    /tmp/tmpwm1xy0km.swift:27:11: error: expected type\n                        for\
    \ i := 0; i < n-p && i < p; i++ {\n                               ^\n        \
    \                        <#type#>\n/tmp/tmpwm1xy0km.swift:27:11: error: expected\
    \ 'in' after for-each pattern\n                        for i := 0; i < n-p &&\
    \ i < p; i++ {\n                               ^\n/tmp/tmpwm1xy0km.swift:27:11:\
    \ error: expected Sequence expression for for-each loop\n                    \
    \    for i := 0; i < n-p && i < p; i++ {\n                               ^\n/tmp/tmpwm1xy0km.swift:24:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(n - p, p) + p\n                                   ^\n                 \
    \                   n:     p: \n/tmp/tmpwm1xy0km.swift:26:4: error: cannot find\
    \ 'mod' in scope\n                        mod := 1\n                        ^~~\n\
    /tmp/tmpwm1xy0km.swift:33:7: error: cannot find 'mod' in scope\n             \
    \           if mod < p {\n                           ^~~\n/tmp/tmpwm1xy0km.swift:36:12:\
    \ error: cannot find 'mod' in scope\n                                return mod\n\
    \                                       ^~~\n"
  stdout: ''
  timestamp: 1660015066
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let res = n % p\n    if res == 0 {\n \
    \       return res\n    }\n    return p - res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpts9ii74_/tmpts9ii74_.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c65f47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c65c3eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c65c3e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c65c3d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpts9ii74_                        0x00005629c1b7824d <unavailable> + 4685

    5    libc.so.6                          0x00002b6c66133460 __libc_start_main +
    245

    6    tmpts9ii74_                        0x00005629c1b77ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015066
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for n > 0 {\n    \
    \    if n < p {\n            result = result * n\n        }\n        n >>= 1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprdzjb9ul.swift:15:11: error: expected 'in' after for-each pattern\n\
    \    for n > 0 {\n          ^\n/tmp/tmprdzjb9ul.swift:15:11: error: unary operator\
    \ cannot be separated from its operand\n    for n > 0 {\n          ^~\n      \
    \     \n/tmp/tmprdzjb9ul.swift:15:11: error: '>' is not a prefix unary operator\n\
    \    for n > 0 {\n          ^\n"
  stdout: ''
  timestamp: 1660015066
