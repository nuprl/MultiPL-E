language: swift
name: HumanEval_139_special_factorial
results:
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 1 {\n        return 1\n    }\n    return factorial(n)\
    \ * (n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvek64fn3.swift:14:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * factorial(n-1) * factorial(n-2) * factorial(n-3)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7fy_pv58.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n-1) * factorial(n-2) * factorial(n-3)\n\
    \           ^~~~~~~~~\n/tmp/tmp7fy_pv58.swift:11:27: error: cannot find 'factorial'\
    \ in scope\n    return factorial(n) * factorial(n-1) * factorial(n-2) * factorial(n-3)\n\
    \                          ^~~~~~~~~\n/tmp/tmp7fy_pv58.swift:11:44: error: cannot\
    \ find 'factorial' in scope\n    return factorial(n) * factorial(n-1) * factorial(n-2)\
    \ * factorial(n-3)\n                                           ^~~~~~~~~\n/tmp/tmp7fy_pv58.swift:11:61:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) * factorial(n-1)\
    \ * factorial(n-2) * factorial(n-3)\n                                        \
    \                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result *= n\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpq7tdyuud/tmpq7tdyuud.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ed07c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ed04beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ed04be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ed04bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq7tdyuud                        0x0000561d2b853337 <unavailable> + 4919

    5    libc.so.6                          0x00002b8ed09b3460 __libc_start_main +
    245

    6    tmpq7tdyuud                        0x0000561d2b852fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 0: return 1\n\tcase 1: return 1\n\tcase\
    \ 2: return 2\n\tcase 3: return 6\n\tcase 4: return 24\n\tcase 5: return 120\n\
    \tcase 6: return 720\n\tcase 7: return 5040\n\tcase 8: return 40320\n\tcase 9:\
    \ return 362880\n\tcase 10: return 3628800\n\tcase 11: return 39916800\n\tcase\
    \ 12: return 479001600\n\tcase 13: return 6227020800\n\tcase 14: return 87178291200\n\
    \tcase 15: return 1307674368000\n\tcase 16: return 19720896008000\n\tcase 17:\
    \ return 25204404000704000\n\tcase 18: return 3247925432799200\n\tcase 19: return\
    \ 409604907280072000\n\tcase 20: return 52199023255553600\n\tcase 21: return 620448401733239416\n\
    \tcase 22: return 121645100408832000\n\tcase 23: return 2432902008176640000\n\t\
    case 24: return 51090942171709440000\n\tcase 25: return 1124000727777607680000\n\
    \tcase 26: return 25852016738884976640000\n\tcase 27: return 620448401733239416000\n\
    \tcase 28: return 12089258196146291456000\n\tcase 29: return 241375846204232256640000\n\
    \tcase 30: return 5872025300265574915200\n\tcase 31: return 138350587816969440000\n\
    \tcase 32: return 19725073858507201406400000\n\tcase 33: return 411518807585587324800000\n\
    \tcase 34: return 8796093022209939296000000\n\tcase 35: return 1759218604441655272096000000\n\
    \tcase 36: return 3518437208883276800000000\n\tcase 37: return 703687441776640000000\n\
    \tcase 38: return 140737488355328000000000\n\tcase 39: return 2814749767106566560000000\n\
    \tcase 40: return 56294995342131296000000000\n\tcase 41: return 11258999068426240000000000000\n\
    \tcase 42: return 2251799813685248000000000000000\n\tcase 43: return 4503599627370496000000000000000\n\
    \tcase 44\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe3qh7sje.swift:56:9: error: expected ':' after 'case'\n       \
    \ case 44\n               ^\n/tmp/tmpe3qh7sje.swift:75:37: error: expected '}'\
    \ at end of brace statement\nassert(special_factorial(n: 1) == 1)\n          \
    \                          ^\n/tmp/tmpe3qh7sje.swift:10:39: note: to match this\
    \ opening '{'\nfunc special_factorial(n: Int) -> Int {\n                     \
    \                 ^\n/tmp/tmpe3qh7sje.swift:11:2: error: switch must be exhaustive\n\
    \        switch n {\n        ^\n/tmp/tmpe3qh7sje.swift:11:2: note: do you want\
    \ to add a default clause?\n        switch n {\n        ^\n/tmp/tmpe3qh7sje.swift:60:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let product = 1\n    for i in 0..<n {\n        product =\
    \ product * factorial(i)\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdhatgwfu.swift:13:29: error: cannot find 'factorial' in scope\n\
    \        product = product * factorial(i)\n                            ^~~~~~~~~\n\
    /tmp/tmpdhatgwfu.swift:13:9: error: cannot assign to value: 'product' is a 'let'\
    \ constant\n        product = product * factorial(i)\n        ^~~~~~~\n/tmp/tmpdhatgwfu.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let product = 1\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return 1\n    }\n    var factorial =\
    \ 1\n    for _ in 0..<n {\n        factorial *= n\n    }\n    return factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmp6nleqcsc/tmp6nleqcsc.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2d6e76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2d6b6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2d6b6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2d6b6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6nleqcsc                        0x00005647476ed337 <unavailable> + 4919

    5    libc.so.6                          0x00002ae2d7062460 __libc_start_main +
    245

    6    tmp6nleqcsc                        0x00005647476ecfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return factorial(4)\n  \
    \  case 1:\n        return 1\n    case 2:\n        return 2\n    case 3:\n   \
    \     return 6\n    case 4:\n        return 24\n    case 5:\n        return 120\n\
    \    case 6:\n        return 720\n    case 7:\n        return 5040\n    case 8:\n\
    \        return 40320\n    case 9:\n        return 362880\n    case 10:\n    \
    \    return 3628800\n    case 11:\n        return 39916800\n    case 12:\n   \
    \     return 479001600\n    case 13:\n        return 6227020800\n    case 14:\n\
    \        return 87178291200\n    case 15:\n        return 1307674368000\n    case\
    \ 16:\n        return 20922789888000\n    case 17:\n        return 355687428096000\n\
    \    case 18:\n        return 6402373705728000\n    case 19:\n        return 12164510040883200\n\
    \    case 20:\n        return 2432902008176640000\n    case 21:\n        return\
    \ 51090942171709440000\n    case 22:\n        return 1124000727777607680000\n\
    \    case 23:\n        return 25852016738884976640000\n    case 24:\n        return\
    \ 620448401733239439360000\n    case 25:\n        return 12758800579710142000000\n\
    \    case 26:\n        return 2555111512359632000000\n    case 27:\n        return\
    \ 5142297580555720000000\n    case 28:\n        return 1048576000000000000000\n\
    \    case 29:\n        return 2097152000\n    case 30:\n        return 425946116809600000000\n\
    \    case 31:\n        return 845890092599200640000\n    case 32:\n        return\
    \ 1679687372800000000000000000000000000000000\n    case 33:\n        return 3276700000000000000000000000000000000000\n\
    \    case 34:\n        return 65536000000000000000000000000000000000000\n    case\
    \ 35:\n        return 13107300000000000000000000000000000000000000\n    case 36:\n\
    \        return 262144000000000000000000000000000000000000000\n    case 37:\n\
    \        return 5242880000000000000000000000000000000000000000\n    case 38:\n\
    \        return 1048576000000000000000000000000000000000000000000\n    case 39:\n\
    \        return 209715200000000000000000000000000000000000000000000\n    case\
    \ 40:\n        return 4294967296000000000000000000000000000000000000000000000000\n\
    \    case 41:\n        return 85899345920000000000000000000000000000000000000000000000000\n\
    \    case 42:\n        return 1717986918400000000000000000000000000000000000000000000000000\n\
    \    case 43:\n        return 34359738368000000000000000000000000000000000000000000000000000\n\
    \    case 44:\n        return 68719476736000000000000000000000000000000000000000000000000000000\n\
    \    case 45:\n        return 13743895347680000000000000000000000000000000000000000000000000000000\n\
    \    case 46:\n        return 274\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkgzpwahr.swift:124:37: error: expected '}' at end of brace statement\n\
    assert(special_factorial(n: 1) == 1)\n                                    ^\n\
    /tmp/tmpkgzpwahr.swift:10:39: note: to match this opening '{'\nfunc special_factorial(n:\
    \ Int) -> Int {\n                                      ^\n/tmp/tmpkgzpwahr.swift:13:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(4)\n     \
    \          ^~~~~~~~~\n/tmp/tmpkgzpwahr.swift:11:5: error: switch must be exhaustive\n\
    \    switch n {\n    ^\n/tmp/tmpkgzpwahr.swift:11:5: note: do you want to add\
    \ a default clause?\n    switch n {\n    ^\n/tmp/tmpkgzpwahr.swift:109:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let fact = 1\n    for _n in 1...n {\n        fact = fact\
    \ * _n\n    }\n    return fact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqy9vc3lb.swift:13:9: error: cannot assign to value: 'fact' is a\
    \ 'let' constant\n        fact = fact * _n\n        ^~~~\n/tmp/tmpqy9vc3lb.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let fact = 1\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return 1\n    }\n\n    var result =\
    \ 1\n    for x in 1...n {\n        result *= x\n    }\n\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmp0arl6aeu/tmp0arl6aeu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b641d1d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b641ced0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b641ced0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b641cecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0arl6aeu                        0x0000561242788337 <unavailable> + 4919

    5    libc.so.6                          0x00002b641d3c5460 __libc_start_main +
    245

    6    tmp0arl6aeu                        0x0000561242787fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return 1\n    } else {\n        return\
    \ n * special_factorial(n - 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpywtnp2bp.swift:14:38: error: missing argument label 'n:' in call\n\
    \        return n * special_factorial(n - 1)\n                               \
    \      ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 0:\n\t\treturn 1\n\tcase 1:\n\t\treturn\
    \ 1\n\tdefault:\n\t\treturn n * special_factorial(n - 1)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqv4tl2sa.swift:17:32: error: missing argument label 'n:' in call\n\
    \                return n * special_factorial(n - 1)\n                       \
    \                      ^\n                                             n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return 1\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    case 3:\n        return\
    \ 6\n    case 4:\n        return 24\n    case 5:\n        return 120\n    default:\n\
    \        return factorial(n)*factorial(n-1)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuitlilg7.swift:25:16: error: cannot find 'factorial' in scope\n\
    \        return factorial(n)*factorial(n-1)\n               ^~~~~~~~~\n/tmp/tmpuitlilg7.swift:25:29:\
    \ error: cannot find 'factorial' in scope\n        return factorial(n)*factorial(n-1)\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tvar factorial = Int(1)\n\tfor _ in 0..<n {\n\t\tfactorial *=\
    \ Int(n - 1)\n\t}\n\treturn factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmplf48135w/tmplf48135w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b365657bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3656272b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3656272988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b36562717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplf48135w                        0x0000556631849477 <unavailable> + 5239

    5    libc.so.6                          0x00002b3656767460 __libc_start_main +
    245

    6    tmplf48135w                        0x0000556631849129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return 1\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    case 3:\n        return\
    \ 6\n    case 4:\n        return 24\n    case 5:\n        return 120\n    default:\n\
    \        if n <= 1 {\n            return 1\n        } else {\n            return\
    \ n * special_factorial(n - 1)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpha0chszq.swift:28:42: error: missing argument label 'n:' in call\n\
    \            return n * special_factorial(n - 1)\n                           \
    \              ^\n                                         n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for i in 1...n {\n        result = result\
    \ * i\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmps4hknt0j/tmps4hknt0j.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abda0bebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abda08e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abda08e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abda08e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps4hknt0j                        0x000055c7cb198337 <unavailable> + 4919

    5    libc.so.6                          0x00002abda0dd7460 __libc_start_main +
    245

    6    tmps4hknt0j                        0x000055c7cb197fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\t// Calculate the factorial of the number using recursion\n\t\
    func factorial(_ n: Int) -> Int {\n\t\tswitch n {\n\t\tcase 0:\n\t\t\treturn 1\n\
    \t\tcase 1:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn n * factorial(n-1)\n\t\
    \t}\n\t}\n\n\treturn factorial(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpbh8d8esx/tmpbh8d8esx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66c588cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66c5583b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66c5583988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66c55827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh8d8esx                        0x00005633e820c1b7 <unavailable> + 4535

    5    libc.so.6                          0x00002b66c5a78460 __libc_start_main +
    245

    6    tmpbh8d8esx                        0x00005633e820be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    var factorial =\
    \ 1\n    for _ in 1...n {\n        factorial *= n\n    }\n    return factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpkh2arioc/tmpkh2arioc.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6019a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba60169db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba60169d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba60169c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkh2arioc                        0x000055f8193df337 <unavailable> + 4919

    5    libc.so.6                          0x00002ba601b92460 __libc_start_main +
    245

    6    tmpkh2arioc                        0x000055f8193defe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n  var result = 0\n  for k in 0..<n {\n    result = result * k\
    \ + factorial(n - k)\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7szuzzxu.swift:13:27: error: cannot find 'factorial' in scope\n\
    \    result = result * k + factorial(n - k)\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var fact = 1\n\n    for _ in 0..<n {\n        fact *= n\n\
    \    }\n\n    return fact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpmsqtjpux/tmpmsqtjpux.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acfd8fbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acfd8cb3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acfd8cb3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acfd8cb27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmsqtjpux                        0x0000561910942337 <unavailable> + 4919

    5    libc.so.6                          0x00002acfd91a8460 __libc_start_main +
    245

    6    tmpmsqtjpux                        0x0000561910941fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1..(n-1) {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_996lcko.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for _ in 1..(n-1) {\n              ^~\n           \
    \   ...\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return 1\n    }\n    if n == 2 {\n \
    \       return 2\n    }\n    return n * special_factorial(n - 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz6avai99.swift:17:34: error: missing argument label 'n:' in call\n\
    \    return n * special_factorial(n - 1)\n                                 ^\n\
    \                                 n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for x in 0..<n {\n        result = result\
    \ * (x)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpf31ji6fg/tmpf31ji6fg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6ab66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a6a85db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a6a85d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a6a85c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf31ji6fg                        0x000055829ee85337 <unavailable> + 4919

    5    libc.so.6                          0x00002b9a6ad52460 __libc_start_main +
    245

    6    tmpf31ji6fg                        0x000055829ee84fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var num = 1\n    for i in 1..n {\n        num *= i\n    }\n\
    \    return num\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl5wz4a68.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..n {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n <= 1 {\n\t\treturn 1\n\t} else {\n\t\treturn factorial(n)\
    \ * factorial(n - 1)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpnpkoxcmo.swift:14:10: error: cannot find 'factorial' in scope\n\
    \                return factorial(n) * factorial(n - 1)\n                    \
    \   ^~~~~~~~~\n/tmp/tmpnpkoxcmo.swift:14:25: error: cannot find 'factorial' in\
    \ scope\n                return factorial(n) * factorial(n - 1)\n            \
    \                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 1:\n\t\treturn 1\n\tcase 2:\n\t\treturn\
    \ 2\n\tcase 3:\n\t\treturn 6\n\tcase 4:\n\t\treturn 24\n\tcase 5:\n\t\treturn\
    \ 120\n\tcase 6:\n\t\treturn 720\n\tcase 7:\n\t\treturn 5040\n\tcase 8:\n\t\t\
    return 40320\n\tcase 9:\n\t\treturn 362880\n\tcase 10:\n\t\treturn 3628800\n\t\
    case 11:\n\t\treturn 39916800\n\tcase 12:\n\t\treturn 479001600\n\tcase 13:\n\t\
    \treturn 6227020800\n\tcase 14:\n\t\treturn 87178291200\n\tcase 15:\n\t\treturn\
    \ 1307674368000\n\tcase 16:\n\t\treturn 20922789888000\n\tcase 17:\n\t\treturn\
    \ 355687428096000\n\tcase 18:\n\t\treturn 6402373705728000\n\tcase 19:\n\t\treturn\
    \ 121645100408832000\n\tcase 20:\n\t\treturn 2432902008176640000\n\tcase 21:\n\
    \t\treturn 51090942171709440000\n\tcase 22:\n\t\treturn 1124000727777607680000\n\
    \tcase 23:\n\t\treturn 25852016738884976640000\n\tcase 24:\n\t\treturn 620448401733239439360000\n\
    \tcase 25:\n\t\treturn 15511210043330985984000000\n\tcase 26:\n\t\treturn 403291461126605635584000000\n\
    \tcase 27:\n\t\treturn 10888869450418352160768000000\n\tcase 28:\n\t\treturn 304888344611713860501504000000\n\
    \tcase 29:\n\t\treturn 8841761993739701954543616000000\n\tcase 30:\n\t\treturn\
    \ 265252859812191058636308480000000\n\tcase 31:\n\t\treturn 732674330302267539836602400000000\n\
    \tcase 32:\n\t\treturn 142606361698716410687442464000000000\n\tcase 33:\n\t\t\
    return 51422966249614547296056258147040000000000\n\tcase 34:\n\t\treturn 11258037803759205243194217600000000000\n\
    \tcase 35:\n\t\treturn 251165869243290200817664000000000000\n\tcase 36:\n\t\t\
    return 5242880000000000001884541320000000\n\tcase 37:\n\t\treturn 10485760000000000094054071312000\n\
    \tcase 38:\n\t\treturn 209715200000000\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy_hv7xyx.swift:106:37: error: expected '}' at end of brace statement\n\
    assert(special_factorial(n: 1) == 1)\n                                    ^\n\
    /tmp/tmpy_hv7xyx.swift:10:39: note: to match this opening '{'\nfunc special_factorial(n:\
    \ Int) -> Int {\n                                      ^\n/tmp/tmpy_hv7xyx.swift:11:2:\
    \ error: switch must be exhaustive\n        switch n {\n        ^\n/tmp/tmpy_hv7xyx.swift:11:2:\
    \ note: do you want to add a default clause?\n        switch n {\n        ^\n\
    /tmp/tmpy_hv7xyx.swift:91:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n\n    for _ in 0..<n {\n        factorial\
    \ *= n\n    }\n\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmpmdmwrsnm/tmpmdmwrsnm.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c96b68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c9685fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7c9685f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7c9685e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmdmwrsnm                        0x0000559e50a18337 <unavailable> + 4919

    5    libc.so.6                          0x00002b7c96d54460 __libc_start_main +
    245

    6    tmpmdmwrsnm                        0x0000559e50a17fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let factorial = factorial(n)\n    return factorial * factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpclelc9il.swift:11:21: error: use of local variable 'factorial'\
    \ before its declaration\n    let factorial = factorial(n)\n                 \
    \   ^\n/tmp/tmpclelc9il.swift:11:9: note: 'factorial' declared here\n    let factorial\
    \ = factorial(n)\n        ^\n/tmp/tmpclelc9il.swift:12:22: error: cannot convert\
    \ return expression of type 'Duration' to return type 'Int'\n    return factorial\
    \ * factorial\n           ~~~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let factorial = factorial(n: n)\n\n    if n < 2 {\n     \
    \   return factorial\n    }\n\n    return factorial * special_factorial(n: n -\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\n\
    assert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\n\
    assert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf4v8kajy.swift:11:21: error: use of local variable 'factorial'\
    \ before its declaration\n    let factorial = factorial(n: n)\n              \
    \      ^\n/tmp/tmpf4v8kajy.swift:11:9: note: 'factorial' declared here\n    let\
    \ factorial = factorial(n: n)\n        ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    precondition(n >= 0, \"n must be greater or equal than zero\"\
    )\n    return Int(n) * factorial(Int(n) + 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp11z8dtqg.swift:12:21: error: cannot find 'factorial' in scope\n\
    \    return Int(n) * factorial(Int(n) + 1)\n                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 0 {\n        return 0\n    }\n    if n == 1 {\n \
    \       return 1\n    }\n    return n * special_factorial(n - 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5vnyszej.swift:17:34: error: missing argument label 'n:' in call\n\
    \    return n * special_factorial(n - 1)\n                                 ^\n\
    \                                 n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return 0\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    default:\n        let fac\
    \ = factorial(n)\n        let result = factorial(n - 1) * fac\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbzc8fx3b.swift:19:19: error: cannot find 'factorial' in scope\n\
    \        let fac = factorial(n)\n                  ^~~~~~~~~\n/tmp/tmpbzc8fx3b.swift:20:22:\
    \ error: cannot find 'factorial' in scope\n        let result = factorial(n -\
    \ 1) * fac\n                     ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for i := 1; i <= n; i++ {\n      \
    \  factorial *= i\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp96rdmjia.swift:12:12: error: expected type\n    for i := 1; i <=\
    \ n; i++ {\n           ^\n            <#type#>\n/tmp/tmp96rdmjia.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i <= n; i++ {\n\
    \           ^\n/tmp/tmp96rdmjia.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i <= n; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n < 0 {\n        return 0\n    }\n\n    var result = 1\n\
    \    for _ in 0..<n {\n        result *= n\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpvl8iogjh/tmpvl8iogjh.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2b080c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ad77b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a2ad77988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a2ad767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvl8iogjh                        0x0000560415da2337 <unavailable> + 4919

    5    libc.so.6                          0x00002b8a2b26c460 __libc_start_main +
    245

    6    tmpvl8iogjh                        0x0000560415da1fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return special_factorial_recursive(n)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphfow8bnq.swift:11:12: error: cannot find 'special_factorial_recursive'\
    \ in scope\n    return special_factorial_recursive(n)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    // write code here\n    if n < 0 {\n        return 0\n  \
    \  }\n    var result: Int = 0\n    for _ in 0..<n {\n        result = (result\
    \ * n) + 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp8_2v61ub/tmp8_2v61ub.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a15b35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a1582cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a1582c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a1582b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8_2v61ub                        0x000055a25817f337 <unavailable> + 4919

    5    libc.so.6                          0x00002b9a15d21460 __libc_start_main +
    245

    6    tmp8_2v61ub                        0x000055a25817efe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = factorial(n)\n    if factorial == 0 {\n \
    \       return 0\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvr1k33a1.swift:11:21: error: use of local variable 'factorial'\
    \ before its declaration\n    var factorial = factorial(n)\n                 \
    \   ^\n/tmp/tmpvr1k33a1.swift:11:9: note: 'factorial' declared here\n    var factorial\
    \ = factorial(n)\n        ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    // base case\n    if n == 1 {\n        return Int(1)\n  \
    \  }\n    \n    let result = factorial(n) * (n - 1)\n\n    if n > 1 {\n      \
    \  result *= special_factorial(n - 1)\n    }\n\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplyixoe0y.swift:16:18: error: cannot find 'factorial' in scope\n\
    \    let result = factorial(n) * (n - 1)\n                 ^~~~~~~~~\n/tmp/tmplyixoe0y.swift:19:37:\
    \ error: missing argument label 'n:' in call\n        result *= special_factorial(n\
    \ - 1)\n                                    ^\n                              \
    \      n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) / factorial(n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1k3zc20y.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) / factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmp1k3zc20y.swift:11:27:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) / factorial(n\
    \ - 1)\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var fact = 1\n    for _ in 1...n {\n        fact *= factorial(n-1)\n\
    \    }\n    return fact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpr9uabn62.swift:13:17: error: cannot find 'factorial' in scope\n\
    \        fact *= factorial(n-1)\n                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n == 1 {\n\t\treturn 1\n\t}\n\n\treturn n * special_factorial(n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxjok979h.swift:15:31: error: missing argument label 'n:' in call\n\
    \        return n * special_factorial(n - 1)\n                               \
    \      ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 0 || n == 1 {\n        return 1\n    }\n    return\
    \ factorial(n) * (n - 1) * special_factorial(n - 2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe0agi5z0.swift:14:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1) * special_factorial(n - 2)\n           ^~~~~~~~~\n\
    /tmp/tmpe0agi5z0.swift:14:55: error: missing argument label 'n:' in call\n   \
    \ return factorial(n) * (n - 1) * special_factorial(n - 2)\n                 \
    \                                     ^\n                                    \
    \                  n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0: return 1\n    case 1: return 1\n\
    \    case 2: return 2\n    default: return n * special_factorial(n - 1)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcrjcnfz7.swift:15:43: error: missing argument label 'n:' in call\n\
    \    default: return n * special_factorial(n - 1)\n                          \
    \                ^\n                                          n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n < 1 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn 1\n\
    \t}\n\treturn n * special_factorial(n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpg359uwlx.swift:17:31: error: missing argument label 'n:' in call\n\
    \        return n * special_factorial(n - 1)\n                               \
    \      ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1 ..< n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmpeiqxiqlu/tmpeiqxiqlu.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abee7432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abee7129b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abee7129988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abee71287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeiqxiqlu                        0x000056419115a337 <unavailable> + 4919

    5    libc.so.6                          0x00002abee761e460 __libc_start_main +
    245

    6    tmpeiqxiqlu                        0x0000564191159fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * special_factorial(n - 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsfkunqi3.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * special_factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmpsfkunqi3.swift:11:45:\
    \ error: missing argument label 'n:' in call\n    return factorial(n) * special_factorial(n\
    \ - 1)\n                                            ^\n                      \
    \                      n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n\n    for number in 1...n {\n        result\
    \ *= number\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmpndveakuu/tmpndveakuu.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6fbc09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6fb900b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6fb900988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6fb8ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpndveakuu                        0x0000556889e0b337 <unavailable> + 4919

    5    libc.so.6                          0x00002ba6fbdf5460 __libc_start_main +
    245

    6    tmpndveakuu                        0x0000556889e0afe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tvar result = 1\n\tfor i := 1; i <= n; i++ {\n\t\tresult *=\
    \ i\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_nagdjwo.swift:12:9: error: expected type\n        for i := 1;\
    \ i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp_nagdjwo.swift:12:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 1; i <= n; i++\
    \ {\n               ^\n/tmp/tmp_nagdjwo.swift:12:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := 1; i <= n; i++ {\n               ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result *= n\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpq7tdyuud/tmpq7tdyuud.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ed07c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ed04beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ed04be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ed04bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq7tdyuud                        0x0000561d2b853337 <unavailable> + 4919

    5    libc.so.6                          0x00002b8ed09b3460 __libc_start_main +
    245

    6    tmpq7tdyuud                        0x0000561d2b852fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    // Return 0 if n < 0 or > 0.\n    if n <= 0 {\n        return\
    \ 0\n    }\n    // Return factorial of n without using factorial() function.\n\
    \    if n == 1:\n        return 1\n    }\n    return n * special_factorial(n -\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\n\
    assert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\n\
    assert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpylmnfufk.swift:16:14: error: expected '{' after 'if' condition\n\
    \    if n == 1:\n             ^\n/tmp/tmpylmnfufk.swift:20:1: error: extraneous\
    \ '}' at top level\n}\n^\n/tmp/tmpylmnfufk.swift:19:5: error: return invalid outside\
    \ of a func\n    return n * special_factorial(n - 1)\n    ^\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    var factorial = 1\n    for i = 1; i <\
    \ n; i++ {\n        factorial *= i\n        result += factorial\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwas5wzgk.swift:13:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 1; i < n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1...n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp_f_98o_t/tmp_f_98o_t.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f381c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f37ebdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f37ebd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f37ebc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_f_98o_t                        0x000056055f11c337 <unavailable> + 4919

    5    libc.so.6                          0x00002b5f383b2460 __libc_start_main +
    245

    6    tmp_f_98o_t                        0x000056055f11bfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979312
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n == 1 {\n\t\treturn 1\n\t}\n\n\treturn factorial(n) * special_factorial(n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7kz5c6ae.swift:15:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) * special_factorial(n - 1)\n               ^~~~~~~~~\n\
    /tmp/tmp7kz5c6ae.swift:15:42: error: missing argument label 'n:' in call\n   \
    \     return factorial(n) * special_factorial(n - 1)\n                       \
    \                         ^\n                                                n:\
    \ \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * (n - 1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq7qp0h5n.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\treturn factorial(n) / factorial(n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy4uzcft_.swift:11:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) / factorial(n - 1)\n               ^~~~~~~~~\n/tmp/tmpy4uzcft_.swift:11:24:\
    \ error: cannot find 'factorial' in scope\n        return factorial(n) / factorial(n\
    \ - 1)\n                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tfactorial := 1\n\tfor i := 1; i <= n {\n\t\tfactorial *= i\n\
    \t}\n\treturn factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjpybm30z.swift:11:11: error: consecutive statements on a line must\
    \ be separated by ';'\n        factorial := 1\n                 ^\n          \
    \       ;\n/tmp/tmpjpybm30z.swift:11:12: error: expected expression\n        factorial\
    \ := 1\n                  ^\n/tmp/tmpjpybm30z.swift:12:9: error: expected type\n\
    \        for i := 1; i <= n {\n               ^\n                <#type#>\n/tmp/tmpjpybm30z.swift:12:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 1; i <= n {\n\
    \               ^\n/tmp/tmpjpybm30z.swift:12:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := 1; i <= n {\n               ^\n/tmp/tmpjpybm30z.swift:11:2:\
    \ error: cannot find 'factorial' in scope\n        factorial := 1\n        ^~~~~~~~~\n\
    /tmp/tmpjpybm30z.swift:15:9: error: cannot find 'factorial' in scope\n       \
    \ return factorial\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    // Implementation Note: The function will receive an integer\
    \ as input and\n    // should return the special factorial of this integer.\n\
    \    var result = 1\n    for (i: Int = 0; i < n; i++ {\n        result = result\
    \ * (i + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph_huw9dz.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i: Int = 0; i < n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph_huw9dz.swift:17:18: error: expected '{' to start the body of for-each\
    \ loop\n    return result\n                 ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 1 {\n        return 1\n    }\n    return (n * special_factorial(n\
    \ - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq78ibafx.swift:14:35: error: missing argument label 'n:' in call\n\
    \    return (n * special_factorial(n - 1))\n                                 \
    \ ^\n                                  n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(factorial(n))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjl_safjb.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(factorial(n))\n           ^~~~~~~~~\n/tmp/tmpjl_safjb.swift:11:22:\
    \ error: cannot find 'factorial' in scope\n    return factorial(factorial(n))\n\
    \                     ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    if n <= 1 {\n        return factorial\n\
    \    }\n    for _ in 1...n {\n        factorial *= n\n    }\n    return factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpz23aw_de/tmpz23aw_de.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7d945cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7d9153b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7d9153988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7d91527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz23aw_de                        0x00005599e90df337 <unavailable> + 4919

    5    libc.so.6                          0x00002ae7d9648460 __libc_start_main +
    245

    6    tmpz23aw_de                        0x00005599e90defe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 1 {\n        return 1\n    }\n    if n == 0 {\n \
    \       return 0\n    }\n\n    return factorial(n - 1) * special_factorial(n -\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\n\
    assert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\n\
    assert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpag3aohxa.swift:18:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n - 1) * special_factorial(n - 1)\n           ^~~~~~~~~\n\
    /tmp/tmpag3aohxa.swift:18:49: error: missing argument label 'n:' in call\n   \
    \ return factorial(n - 1) * special_factorial(n - 1)\n                       \
    \                         ^\n                                                n:\
    \ \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq8li7x96.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * factorial(n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_bl_bvnq.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmp_bl_bvnq.swift:11:27:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) * factorial(n\
    \ - 1)\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979276
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for i in 1...n {\n        factorial\
    \ *= i\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp98ltvf00/tmp98ltvf00.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb45dc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb45abdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb45abd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb45abc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp98ltvf00                        0x00005650e705c337 <unavailable> + 4919

    5    libc.so.6                          0x00002abb45fb2460 __libc_start_main +
    245

    6    tmp98ltvf00                        0x00005650e705bfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979276
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 0 {\n        return 0\n    }\n    var result = 1\n\
    \    for i := 1; i <= n; i++ {\n        result *= i\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzca2szt4.swift:15:12: error: expected type\n    for i := 1; i <=\
    \ n; i++ {\n           ^\n            <#type#>\n/tmp/tmpzca2szt4.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i <= n; i++ {\n\
    \           ^\n/tmp/tmpzca2szt4.swift:15:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i <= n; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return factorial(0)\n  \
    \  case 1:\n        return factorial(1)\n    case 2:\n        return factorial(1)\n\
    \    case 3:\n        return factorial(2)\n    case 4:\n        return factorial(3)\n\
    \    case 5:\n        return factorial(4)\n    case 6:\n        return factorial(5)\n\
    \    case 7:\n        return factorial(6)\n    case 8:\n        return factorial(7)\n\
    \    case 9:\n        return factorial(8)\n    case 10:\n        return factorial(9)\n\
    \    case 11:\n        return factorial(10)\n    case 12:\n        return factorial(11)\n\
    \    case 13:\n        return factorial(12)\n    case 14:\n        return factorial(13)\n\
    \    case 15:\n        return factorial(14)\n    case 16:\n        return factorial(15)\n\
    \    case 17:\n        return factorial(16)\n    case 18:\n        return factorial(17)\n\
    \    case 19:\n        return factorial(18)\n    case 20:\n        return factorial(19)\n\
    \    case 21:\n        return factorial(20)\n    case 22:\n        return factorial(21)\n\
    \    case 23:\n        return factorial(22)\n    case 24:\n        return factorial(23)\n\
    \    case 25:\n        return factorial(24)\n    case 26:\n        return factorial(25)\n\
    \    case 27:\n        return factorial(26)\n    case 28:\n        return factorial(27)\n\
    \    case 29:\n        return factorial(28)\n    case 30:\n        return factorial(29)\n\
    \    case 31:\n        return factorial(30)\n    case 32:\n        return factorial(31)\n\
    \    case 33:\n        return factorial(32)\n    case 34:\n        return factorial(33)\n\
    \    case 35:\n        return factorial(34)\n    case 36:\n        return factorial(35)\n\
    \    case 37:\n        return factorial(36)\n    case 38:\n        return factorial(37)\n\
    \    case 39:\n        return factorial(38)\n    case 40:\n        return factorial(39)\n\
    \    case 41:\n        return factorial(40)\n    case 42:\n        return factorial(41)\n\
    \    case 43:\n        return factorial(42)\n    case 44:\n        return factorial(43)\n\
    \    case 45:\n        return factorial(44)\n    case 46:\n        return factorial(45)\n\
    \    case 47:\n        return factorial(46)\n    case 48:\n        return factorial(47)\n\
    \    case 49:\n        return factorial(48)\n    case 50:\n        return factorial(49)\n\
    \    case 51:\n        return factorial(50)\n    case 52:\n        return factorial(51)\n\
    \    case 53:\n        return factorial(52)\n    case 54:\n        return factorial(53)\n\
    \    case 55:\n        return factorial(54)\n    case 56:\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkgovt34l.swift:124:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case 56:\n    ^~~~~~~~\n            \
    \ break\n/tmp/tmpkgovt34l.swift:144:37: error: expected '}' at end of brace statement\n\
    assert(special_factorial(n: 1) == 1)\n                                    ^\n\
    /tmp/tmpkgovt34l.swift:10:39: note: to match this opening '{'\nfunc special_factorial(n:\
    \ Int) -> Int {\n                                      ^\n/tmp/tmpkgovt34l.swift:13:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(0)\n     \
    \          ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:15:16: error: cannot find 'factorial'\
    \ in scope\n        return factorial(1)\n               ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:17:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(1)\n     \
    \          ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:19:16: error: cannot find 'factorial'\
    \ in scope\n        return factorial(2)\n               ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:21:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(3)\n     \
    \          ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:23:16: error: cannot find 'factorial'\
    \ in scope\n        return factorial(4)\n               ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:25:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(5)\n     \
    \          ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:27:16: error: cannot find 'factorial'\
    \ in scope\n        return factorial(6)\n               ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:29:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(7)\n     \
    \          ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:31:16: error: cannot find 'factorial'\
    \ in scope\n        return factorial(8)\n               ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:33:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(9)\n     \
    \          ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:35:16: error: cannot find 'factorial'\
    \ in scope\n        return factorial(10)\n               ^~~~~~~~~\n/tmp/tmpkgovt34l.swift:37:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(11)\n    \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 2:\n\t\treturn 1\n\tcase 3:\n\t\treturn\
    \ 4\n\tcase 5:\n\t\treturn 10\n\tcase 7:\n\t\treturn 50\n\tcase 10:\n\t\treturn\
    \ 100\n\tcase 20:\n\t\treturn 400\n\tcase 50:\n\t\treturn 1000\n\tcase 100:\n\t\
    \treturn 4000\n\tdefault:\n\t\tswitch {\n\t\tcase n < 2:\n\t\t\treturn 0\n\t\t\
    case n > 100:\n\t\t\treturn math.PowInt(n,float64(100))\n\t\tdefault:\n\t\t\t\
    return factorial(n) * float64(n)\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_e1l7tc6.swift:29:10: error: expected expression in 'switch' statement\n\
    \                switch {\n                       ^\n/tmp/tmp_e1l7tc6.swift:33:11:\
    \ error: cannot find 'math' in scope\n                        return math.PowInt(n,float64(100))\n\
    \                               ^~~~\n/tmp/tmp_e1l7tc6.swift:33:25: error: cannot\
    \ find 'float64' in scope\n                        return math.PowInt(n,float64(100))\n\
    \                                             ^~~~~~~\n/tmp/tmp_e1l7tc6.swift:35:11:\
    \ error: cannot find 'factorial' in scope\n                        return factorial(n)\
    \ * float64(n)\n                               ^~~~~~~~~\n/tmp/tmp_e1l7tc6.swift:35:26:\
    \ error: cannot find 'float64' in scope\n                        return factorial(n)\
    \ * float64(n)\n                                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n  var factorial = 1\n  for _ in 1...n {\n    factorial *= n\n\
    \  }\n  return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmp9ac6zd3u/tmp9ac6zd3u.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f2e7c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f2e4b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f2e4b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f2e4b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ac6zd3u                        0x000055f180fd4337 <unavailable> + 4919

    5    libc.so.6                          0x00002b7f2e9ae460 __libc_start_main +
    245

    6    tmp9ac6zd3u                        0x000055f180fd3fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return n * factorial(n)\n    } else\
    \ {\n        return factorial(n) * factorial(n - 1)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpr3xqry7q.swift:12:20: error: cannot find 'factorial' in scope\n\
    \        return n * factorial(n)\n                   ^~~~~~~~~\n/tmp/tmpr3xqry7q.swift:14:16:\
    \ error: cannot find 'factorial' in scope\n        return factorial(n) * factorial(n\
    \ - 1)\n               ^~~~~~~~~\n/tmp/tmpr3xqry7q.swift:14:31: error: cannot\
    \ find 'factorial' in scope\n        return factorial(n) * factorial(n - 1)\n\
    \                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 1 {\n        return 1.0\n    } else {\n        return\
    \ n * special_factorial(n - 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9gsbe9ur.swift:12:16: error: cannot convert return expression of\
    \ type 'Double' to return type 'Int'\n        return 1.0\n               ^~~\n\
    \               Int( )\n/tmp/tmp9gsbe9ur.swift:14:38: error: missing argument\
    \ label 'n:' in call\n        return n * special_factorial(n - 1)\n          \
    \                           ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1..(n-1) {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_996lcko.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for _ in 1..(n-1) {\n              ^~\n           \
    \   ...\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0: return 1\n    case 1: return n\n\
    \    case 2: return n * special_factorial(n: n - 1)\n    case 3: return n * special_factorial(n:\
    \ n - 2) * special_factorial(n: n - 3)\n    default: return n * special_factorial(n:\
    \ n - 1) * special_factorial(n: n - 2) * special_factorial(n: n - 3)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmp8_muujwn/tmp8_muujwn.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10f9598c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10f928fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10f928f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10f928e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8_muujwn                        0x0000555afcc4b1b7 <unavailable> + 4535

    5    libc.so.6                          0x00002b10f9784460 __libc_start_main +
    245

    6    tmp8_muujwn                        0x0000555afcc4ae69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var res = 1\n    for _ in 0..<n {\n        res = res * factorial(n-1)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd0ouojei.swift:13:21: error: cannot find 'factorial' in scope\n\
    \        res = res * factorial(n-1)\n                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return 1\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    case 3:\n        return\
    \ 6\n    case 4:\n        return 24\n    case 5:\n        return 120\n    case\
    \ 6:\n        return 720\n    case 7:\n        return 5040\n    case 8:\n    \
    \    return 40320\n    case 9:\n        return 362880\n    case 10:\n        return\
    \ 3628800\n    case 11:\n        return 39916800\n    case 12:\n        return\
    \ 479001600\n    case 13:\n        return 6227020800\n    case 14:\n        return\
    \ 87178291200\n    case 15:\n        return 130767436800\n    case 16:\n     \
    \   return 20922789888000\n    case 17:\n        return 355687428096000\n    case\
    \ 18:\n        return 6402373705728000\n    case 19:\n        return 121645100408832000\n\
    \    case 20:\n        return 2432902008176640000\n    case 21:\n        return\
    \ 51090942171709440000\n    case 22:\n        return 1124000727777607680000\n\
    \    case 23:\n        return 25852016738884976640000\n    case 24:\n        return\
    \ 620448401733239439360000\n    case 25:\n        return 1258291752755522533120000\n\
    \    case 26:\n        return 25172363452133174544000000\n    case 27:\n     \
    \   return 580549421750423542400000000\n    case 28:\n        return 137438953471810488000000000\n\
    \    case 29:\n        return 218922993982003760000000000\n    case 30:\n    \
    \    return 4398046511104160000000000000\n    case 31:\n        return 879609302220822500000000000000\n\
    \    case 32:\n        return 17592186044416000000000000000\n    case 33:\n  \
    \      return 35184372088832000000000000000\n    case 34:\n        return 6871947673664000000000000000\n\
    \    case 35:\n        return 13466939526624000000000000000\n    case 36:\n  \
    \      return 217827208968064000000000000000\n    case 37:\n        return 43429448190224000000000000000\n\
    \    case 38:\n        return 9173510043330208000000000000000\n    case 39:\n\
    \        return 181002973831152000000000000000\n    case 40:\n        return 36028797018963968000000000000000\n\
    \    case 41:\n        return 70472308658089984000000000000000\n    case 42:\n\
    \        return 140737488355328000000000000000\n    case \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5teqdsk9.swift:98:9: error: expected pattern\n    case \n     \
    \   ^\n/tmp/tmp5teqdsk9.swift:98:9: error: expected ':' after 'case'\n    case\
    \ \n        ^\n/tmp/tmp5teqdsk9.swift:117:37: error: expected '}' at end of brace\
    \ statement\nassert(special_factorial(n: 1) == 1)\n                          \
    \          ^\n/tmp/tmp5teqdsk9.swift:10:39: note: to match this opening '{'\n\
    func special_factorial(n: Int) -> Int {\n                                    \
    \  ^\n/tmp/tmp5teqdsk9.swift:102:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var ret = 1\n    for _ in 1..n {\n        ret *= n\n    }\n\
    \    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6r4zydte.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for _ in 1..n {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return n * factorial(n + 1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm0g48ots.swift:11:16: error: cannot find 'factorial' in scope\n\
    \    return n * factorial(n + 1)\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) / (factorial(n-1) * factorial(n-2) *\
    \ ... * factorial(0))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppy7zrpzv.swift:11:62: error: unary operator cannot be separated\
    \ from its operand\n    return factorial(n) / (factorial(n-1) * factorial(n-2)\
    \ * ... * factorial(0))\n                                                    \
    \         ^  ~\n                                                             \
    \   \n/tmp/tmppy7zrpzv.swift:11:66: error: unary operator cannot be separated\
    \ from its operand\n    return factorial(n) / (factorial(n-1) * factorial(n-2)\
    \ * ... * factorial(0))\n                                                    \
    \             ^~\n                                                           \
    \       \n/tmp/tmppy7zrpzv.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) / (factorial(n-1) * factorial(n-2) * ... * factorial(0))\n\
    \           ^~~~~~~~~\n/tmp/tmppy7zrpzv.swift:11:28: error: cannot find 'factorial'\
    \ in scope\n    return factorial(n) / (factorial(n-1) * factorial(n-2) * ... *\
    \ factorial(0))\n                           ^~~~~~~~~\n/tmp/tmppy7zrpzv.swift:11:45:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) / (factorial(n-1)\
    \ * factorial(n-2) * ... * factorial(0))\n                                   \
    \         ^~~~~~~~~\n/tmp/tmppy7zrpzv.swift:11:66: error: '*' is not a prefix\
    \ unary operator\n    return factorial(n) / (factorial(n-1) * factorial(n-2) *\
    \ ... * factorial(0))\n                                                      \
    \           ^\n/tmp/tmppy7zrpzv.swift:11:68: error: cannot find 'factorial' in\
    \ scope\n    return factorial(n) / (factorial(n-1) * factorial(n-2) * ... * factorial(0))\n\
    \                                                                   ^~~~~~~~~\n\
    /tmp/tmppy7zrpzv.swift:11:12: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return factorial(n) / (factorial(n-1) * factorial(n-2)\
    \ * ... * factorial(0))\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979408
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result *= n\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpq7tdyuud/tmpq7tdyuud.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ed07c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ed04beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ed04be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ed04bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq7tdyuud                        0x0000561d2b853337 <unavailable> + 4919

    5    libc.so.6                          0x00002b8ed09b3460 __libc_start_main +
    245

    6    tmpq7tdyuud                        0x0000561d2b852fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var fact = 1\n    if n <= 1 {\n        return fact\n    }\n\
    \    for _ in 0..<n {\n        fact *= (n-1)\n    }\n    return fact\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpedcvehf5/tmpedcvehf5.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e9a895c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e9a58cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e9a58c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e9a58b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpedcvehf5                        0x000055bd15538337 <unavailable> + 4919

    5    libc.so.6                          0x00002b1e9aa81460 __libc_start_main +
    245

    6    tmpedcvehf5                        0x000055bd15537fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n  var result = 1\n  for _ in 0..<n {\n    result *= n\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpq_q_hn0e/tmpq_q_hn0e.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7c0b38c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7c082fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac7c082f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7c082e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_q_hn0e                        0x00005611fad19337 <unavailable> + 4919

    5    libc.so.6                          0x00002ac7c0d24460 __libc_start_main +
    245

    6    tmpq_q_hn0e                        0x00005611fad18fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * (n - 1) * (n - 2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgzd6s5mv.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1) * (n - 2)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * factorial(n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_bl_bvnq.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmp_bl_bvnq.swift:11:27:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) * factorial(n\
    \ - 1)\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979276
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return 1\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    case 3:\n        return\
    \ 6\n    case 4:\n        return 24\n    default:\n        var result = 1\n  \
    \      for _ in 1...n {\n            result *= n\n        }\n        return result\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpe6_w_7f1/tmpe6_w_7f1.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d0498cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d04683b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d04683988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d046827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe6_w_7f1                        0x0000563a1b9e5337 <unavailable> + 4919

    5    libc.so.6                          0x00002b0d04b78460 __libc_start_main +
    245

    6    tmpe6_w_7f1                        0x0000563a1b9e4fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) / (factorial(n-1) * factorial(n-2))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe6tqqy2v.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) / (factorial(n-1) * factorial(n-2))\n           ^~~~~~~~~\n\
    /tmp/tmpe6tqqy2v.swift:11:28: error: cannot find 'factorial' in scope\n    return\
    \ factorial(n) / (factorial(n-1) * factorial(n-2))\n                         \
    \  ^~~~~~~~~\n/tmp/tmpe6tqqy2v.swift:11:45: error: cannot find 'factorial' in\
    \ scope\n    return factorial(n) / (factorial(n-1) * factorial(n-2))\n       \
    \                                     ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 0..<n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp64f6ha07/tmp64f6ha07.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d52916c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d5260db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d5260d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d5260c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64f6ha07                        0x000055d12adc4337 <unavailable> + 4919

    5    libc.so.6                          0x00002b3d52b02460 __libc_start_main +
    245

    6    tmp64f6ha07                        0x000055d12adc3fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\treturn factorial(n) / factorial(n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy4uzcft_.swift:11:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) / factorial(n - 1)\n               ^~~~~~~~~\n/tmp/tmpy4uzcft_.swift:11:24:\
    \ error: cannot find 'factorial' in scope\n        return factorial(n) / factorial(n\
    \ - 1)\n                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979380
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1...n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp_f_98o_t/tmp_f_98o_t.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f381c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f37ebdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f37ebd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f37ebc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_f_98o_t                        0x000056055f11c337 <unavailable> + 4919

    5    libc.so.6                          0x00002b5f383b2460 __libc_start_main +
    245

    6    tmp_f_98o_t                        0x000056055f11bfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979312
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if (n <= 1) {\n        return Int(1)\n    }\n    \n    return\
    \ factorial(n) * (n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqmm5dd01.swift:15:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * (n - 1)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp48lpgkm_.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1)!\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tprecondition(n >= 0, \"n must be greater or equal to 0.\")\n\
    \tif n == 1 {\n\t\treturn 1\n\t}\n\tresult := 1\n\tfor i := 1; i < n; i++ {\n\t\
    \tresult *= i\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5mzaieh6.swift:15:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := 1\n              ^\n              ;\n\
    /tmp/tmp5mzaieh6.swift:15:9: error: expected expression\n        result := 1\n\
    \               ^\n/tmp/tmp5mzaieh6.swift:16:9: error: expected type\n       \
    \ for i := 1; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5mzaieh6.swift:16:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 1; i < n; i++\
    \ {\n               ^\n/tmp/tmp5mzaieh6.swift:16:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := 1; i < n; i++ {\n               ^\n/tmp/tmp5mzaieh6.swift:15:2:\
    \ error: cannot find 'result' in scope\n        result := 1\n        ^~~~~~\n\
    /tmp/tmp5mzaieh6.swift:19:9: error: cannot find 'result' in scope\n        return\
    \ result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1...n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp_f_98o_t/tmp_f_98o_t.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f381c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f37ebdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f37ebd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f37ebc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_f_98o_t                        0x000056055f11c337 <unavailable> + 4919

    5    libc.so.6                          0x00002b5f383b2460 __libc_start_main +
    245

    6    tmp_f_98o_t                        0x000056055f11bfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979312
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n  var result = 1\n  for var i = 0; i < n; i++ {\n    result *=\
    \ i\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxthtmak2.swift:12:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for var i = 0; i < n; i++ {\n  ^   ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    precondition(n >= 0, \"n must be greater than or equal to\
    \ 0\")\n    var factorial = 1\n    for k in 0..<n {\n        factorial *= k\n\
    \    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpmi_10v2l/tmpmi_10v2l.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5c2cc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5c29bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5c29ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5c29b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmi_10v2l                        0x00005605b07443c7 <unavailable> + 5063

    5    libc.so.6                          0x00002af5c2eaf460 __libc_start_main +
    245

    6    tmpmi_10v2l                        0x00005605b0744079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n)*factorial(n - 1)*factorial(n - 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk3_u0g7m.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n)*factorial(n - 1)*factorial(n - 2)\n           ^~~~~~~~~\n\
    /tmp/tmpk3_u0g7m.swift:11:25: error: cannot find 'factorial' in scope\n    return\
    \ factorial(n)*factorial(n - 1)*factorial(n - 2)\n                        ^~~~~~~~~\n\
    /tmp/tmpk3_u0g7m.swift:11:42: error: cannot find 'factorial' in scope\n    return\
    \ factorial(n)*factorial(n - 1)*factorial(n - 2)\n                           \
    \              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) / (factorial(n - 1) * factorial(n - 2))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6iw4onnj.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) / (factorial(n - 1) * factorial(n - 2))\n           ^~~~~~~~~\n\
    /tmp/tmp6iw4onnj.swift:11:28: error: cannot find 'factorial' in scope\n    return\
    \ factorial(n) / (factorial(n - 1) * factorial(n - 2))\n                     \
    \      ^~~~~~~~~\n/tmp/tmp6iw4onnj.swift:11:47: error: cannot find 'factorial'\
    \ in scope\n    return factorial(n) / (factorial(n - 1) * factorial(n - 2))\n\
    \                                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var total = 1\n    for number in 1..<n {\n        total *=\
    \ number\n    }\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpekf4m553/tmpekf4m553.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c41309c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c41000b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c41000988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c40fff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpekf4m553                        0x00005594088bc337 <unavailable> + 4919

    5    libc.so.6                          0x00002b2c414f5460 __libc_start_main +
    245

    6    tmpekf4m553                        0x00005594088bbfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 1..n {\n        result *= n\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphgg230uo.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for _ in 1..n {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var fact = 1\n    for _ in 1...n {\n        fact *= n\n \
    \   }\n    return fact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpslh35zvz/tmpslh35zvz.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b393609bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3935d92b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3935d92988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3935d917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpslh35zvz                        0x000055f03d653337 <unavailable> + 4919

    5    libc.so.6                          0x00002b3936287460 __libc_start_main +
    245

    6    tmpslh35zvz                        0x000055f03d652fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * factorial(n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_bl_bvnq.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmp_bl_bvnq.swift:11:27:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) * factorial(n\
    \ - 1)\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979276
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return 1\n    }\n\n    return n * special_factorial(n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphhp3ixw8.swift:15:34: error: missing argument label 'n:' in call\n\
    \    return n * special_factorial(n - 1)\n                                 ^\n\
    \                                 n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var product = 1\n    for _ in 0..<n {\n        product *=\
    \ n\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpnhtm0zj4/tmpnhtm0zj4.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0972a12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0972709b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0972709988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09727087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnhtm0zj4                        0x000055beb95b2337 <unavailable> + 4919

    5    libc.so.6                          0x00002b0972bfe460 __libc_start_main +
    245

    6    tmpnhtm0zj4                        0x000055beb95b1fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial: Int = 0\n    var n: Int = 0\n\n    if n <=\
    \ 1 {\n        return n\n    }\n\n    n = n - 1\n    factorial = 1\n    for _\
    \ in 0..<n {\n        factorial *= n\n        n--\n    }\n    return factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzmgrobp1.swift:22:10: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n        n--\n         ^~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let f = Int(n)\n    if f < 1 {\n        f = 1\n    }\n  \
    \  if f < 10 {\n        return pow(f, 2)\n    }\n    let ans = 1\n    for i in\
    \ 1..10 {\n        if i % 2 == 0 {\n            ans = ans * f\n        }\n   \
    \     f = f * f\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4am895t4.swift:13:9: error: cannot assign to value: 'f' is a 'let'\
    \ constant\n        f = 1\n        ^\n/tmp/tmp4am895t4.swift:11:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let f = Int(n)\n    ^~~\n    var\n/tmp/tmp4am895t4.swift:16:16:\
    \ error: cannot find 'pow' in scope\n        return pow(f, 2)\n              \
    \ ^~~\n/tmp/tmp4am895t4.swift:19:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..10 {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * (factorial(n - 1) * factorial(n - 2))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpu7ew7imi.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (factorial(n - 1) * factorial(n - 2))\n           ^~~~~~~~~\n\
    /tmp/tmpu7ew7imi.swift:11:28: error: cannot find 'factorial' in scope\n    return\
    \ factorial(n) * (factorial(n - 1) * factorial(n - 2))\n                     \
    \      ^~~~~~~~~\n/tmp/tmpu7ew7imi.swift:11:47: error: cannot find 'factorial'\
    \ in scope\n    return factorial(n) * (factorial(n - 1) * factorial(n - 2))\n\
    \                                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 0 ..< n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmpb2jz9hmr/tmpb2jz9hmr.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17c85cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17c82c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17c82c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17c82c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb2jz9hmr                        0x000055e04b46f337 <unavailable> + 4919

    5    libc.so.6                          0x00002b17c87b7460 __libc_start_main +
    245

    6    tmpb2jz9hmr                        0x000055e04b46efe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n < 0 {\n        return 0\n    }\n    return factorial(n)\
    \ * factorial(n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0u2j0lvi.swift:14:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmp0u2j0lvi.swift:14:27:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) * factorial(n\
    \ - 1)\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return n * special_factorial(n: n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for number in 1..(n-1) {\n       \
    \ factorial *= number\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpa5efbnlw.swift:12:20: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for number in 1..(n-1) {\n                   ^~\n \
    \                  ...\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 1 {\n        return 1\n    }\n    if n == 0 {\n \
    \       return 0\n    }\n\n    let factorial = factorial(n: n - 1)\n    return\
    \ factorial * factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8o9w_9nd.swift:18:21: error: use of local variable 'factorial'\
    \ before its declaration\n    let factorial = factorial(n: n - 1)\n          \
    \          ^\n/tmp/tmp8o9w_9nd.swift:18:9: note: 'factorial' declared here\n \
    \   let factorial = factorial(n: n - 1)\n        ^\n/tmp/tmp8o9w_9nd.swift:19:22:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Int'\n\
    \    return factorial * factorial\n           ~~~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(factorial(n))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjl_safjb.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(factorial(n))\n           ^~~~~~~~~\n/tmp/tmpjl_safjb.swift:11:22:\
    \ error: cannot find 'factorial' in scope\n    return factorial(factorial(n))\n\
    \                     ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result :Int = 1\n    for _ in 0..<n {\n        result\
    \ *= n\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpx2qi7ydm/tmpx2qi7ydm.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63f7619c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63f7310b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63f7310988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63f730f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx2qi7ydm                        0x000055ea8a573337 <unavailable> + 4919

    5    libc.so.6                          0x00002b63f7805460 __libc_start_main +
    245

    6    tmpx2qi7ydm                        0x000055ea8a572fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\treturn 0\n\t}\n\tvar factorial = 1\n\tfor ;\
    \ n > 0; n-- {\n\t\tfactorial *= n\n\t}\n\treturn factorial\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5t6_dr85.swift:15:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for ; n > 0; n-- {\n        ^   ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\treturn factorial(n) / factorial(n-1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9jcxg63y.swift:11:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) / factorial(n-1)\n               ^~~~~~~~~\n/tmp/tmp9jcxg63y.swift:11:24:\
    \ error: cannot find 'factorial' in scope\n        return factorial(n) / factorial(n-1)\n\
    \                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var sum = 1\n    for i := 1; i <= n; i++ {\n        sum *=\
    \ i\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp54is65vs.swift:12:12: error: expected type\n    for i := 1; i <=\
    \ n; i++ {\n           ^\n            <#type#>\n/tmp/tmp54is65vs.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i <= n; i++ {\n\
    \           ^\n/tmp/tmp54is65vs.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i <= n; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 1:\n\t\treturn 1\n\tcase 2:\n\t\treturn\
    \ 2\n\tcase 3:\n\t\treturn 6\n\tcase 4:\n\t\treturn 24\n\tcase 5:\n\t\treturn\
    \ 120\n\tdefault:\n\t\tif n > 0 {\n\t\t\tpreFactorial := special_factorial(n -\
    \ 1)\n\t\t\tpostFactorial := special_factorial(n - 2)\n\t\t\treturn preFactorial\
    \ * postFactorial\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp39lp4kmx.swift:24:16: error: consecutive statements on a line must\
    \ be separated by ';'\n                        preFactorial := special_factorial(n\
    \ - 1)\n                                    ^\n                              \
    \      ;\n/tmp/tmp39lp4kmx.swift:24:17: error: expected expression\n         \
    \               preFactorial := special_factorial(n - 1)\n                   \
    \                  ^\n/tmp/tmp39lp4kmx.swift:24:4: error: cannot find 'preFactorial'\
    \ in scope\n                        preFactorial := special_factorial(n - 1)\n\
    \                        ^~~~~~~~~~~~\n/tmp/tmp39lp4kmx.swift:26:11: error: cannot\
    \ find 'preFactorial' in scope\n                        return preFactorial *\
    \ postFactorial\n                               ^~~~~~~~~~~~\n/tmp/tmp39lp4kmx.swift:26:26:\
    \ error: cannot find 'postFactorial' in scope\n                        return\
    \ preFactorial * postFactorial\n                                             \
    \ ^~~~~~~~~~~~~\n/tmp/tmp39lp4kmx.swift:26:24: error: cannot convert return expression\
    \ of type 'Duration' to return type 'Int'\n                        return preFactorial\
    \ * postFactorial\n                               ~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 0..<n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp64f6ha07/tmp64f6ha07.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d52916c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d5260db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d5260d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d5260c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64f6ha07                        0x000055d12adc4337 <unavailable> + 4919

    5    libc.so.6                          0x00002b3d52b02460 __libc_start_main +
    245

    6    tmp64f6ha07                        0x000055d12adc3fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return n * special_factorial(n-1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2qtd22g_.swift:14:34: error: missing argument label 'n:' in call\n\
    \    return n * special_factorial(n-1)\n                                 ^\n \
    \                                n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return 1\n    case 1:\n\
    \        return n\n    case 2:\n        return n * special_factorial(n: n - 1)\n\
    \    default:\n        return n * special_factorial(n: n - 2)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpk_skmxan/tmpk_skmxan.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5022d84c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5022a7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5022a7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5022a7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk_skmxan                        0x00005627e6cdc1b7 <unavailable> + 4535

    5    libc.so.6                          0x00002b5022f70460 __libc_start_main +
    245

    6    tmpk_skmxan                        0x00005627e6cdbe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return 1\n    }\n    return n * special_factorial(n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7_1cbas5.swift:14:34: error: missing argument label 'n:' in call\n\
    \    return n * special_factorial(n - 1)\n                                 ^\n\
    \                                 n: \n"
  stdout: ''
  timestamp: 1659979312
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for i : Int in 1...n {\n        factorial\
    \ *= i\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp3x8e72wa/tmp3x8e72wa.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a44ffcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a44cf3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a44cf3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a44cf27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3x8e72wa                        0x00005589b596d337 <unavailable> + 4919

    5    libc.so.6                          0x00002b2a451e8460 __libc_start_main +
    245

    6    tmp3x8e72wa                        0x00005589b596cfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1..n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplt9mn83r.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for _ in 1..n {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var ret = factorial(n)\n    for n >= 2 {\n        ret = ret\
    \ * n\n        n = n - 1\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvnjfobcs.swift:12:11: error: expected 'in' after for-each pattern\n\
    \    for n >= 2 {\n          ^\n/tmp/tmpvnjfobcs.swift:12:11: error: unary operator\
    \ cannot be separated from its operand\n    for n >= 2 {\n          ^ ~\n    \
    \        \n/tmp/tmpvnjfobcs.swift:11:15: error: cannot find 'factorial' in scope\n\
    \    var ret = factorial(n)\n              ^~~~~~~~~\n/tmp/tmpvnjfobcs.swift:12:11:\
    \ error: '>=' is not a prefix unary operator\n    for n >= 2 {\n          ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    // Your code here\n    let factorial = factorial(n)\n   \
    \ let result = factorial * (factorial-1)/2\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpa27n8s_l.swift:12:21: error: use of local variable 'factorial'\
    \ before its declaration\n    let factorial = factorial(n)\n                 \
    \   ^\n/tmp/tmpa27n8s_l.swift:12:9: note: 'factorial' declared here\n    let factorial\
    \ = factorial(n)\n        ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 0..<n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp64f6ha07/tmp64f6ha07.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d52916c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d5260db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d5260d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d5260c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64f6ha07                        0x000055d12adc4337 <unavailable> + 4919

    5    libc.so.6                          0x00002b3d52b02460 __libc_start_main +
    245

    6    tmp64f6ha07                        0x000055d12adc3fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 0:\n\t\treturn 1\n\tcase 1:\n\t\treturn\
    \ n\n\tdefault:\n\t\treturn n * special_factorial(n - 1)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj2b_nrrm.swift:17:32: error: missing argument label 'n:' in call\n\
    \                return n * special_factorial(n - 1)\n                       \
    \                      ^\n                                             n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    precondition(n >= 0)\n    let factorial: Int = factorial(n:\
    \ n)\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5jx1wdxi.swift:12:26: error: use of local variable 'factorial'\
    \ before its declaration\n    let factorial: Int = factorial(n: n)\n         \
    \                ^\n/tmp/tmp5jx1wdxi.swift:12:9: note: 'factorial' declared here\n\
    \    let factorial: Int = factorial(n: n)\n        ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\treturn factorial(n) / factorial(n-1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9jcxg63y.swift:11:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) / factorial(n-1)\n               ^~~~~~~~~\n/tmp/tmp9jcxg63y.swift:11:24:\
    \ error: cannot find 'factorial' in scope\n        return factorial(n) / factorial(n-1)\n\
    \                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return Int(math.Pow(Double(n), Double(factorial(n))))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp27_qg1ba.swift:11:16: error: cannot find 'math' in scope\n    return\
    \ Int(math.Pow(Double(n), Double(factorial(n))))\n               ^~~~\n/tmp/tmp27_qg1ba.swift:11:43:\
    \ error: cannot find 'factorial' in scope\n    return Int(math.Pow(Double(n),\
    \ Double(factorial(n))))\n                                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let factorial = Int(math.factorial(n))\n    return factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9omnuyy7.swift:11:25: error: cannot find 'math' in scope\n    let\
    \ factorial = Int(math.factorial(n))\n                        ^~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 0 ..< n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmpb2jz9hmr/tmpb2jz9hmr.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17c85cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17c82c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17c82c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17c82c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb2jz9hmr                        0x000055e04b46f337 <unavailable> + 4919

    5    libc.so.6                          0x00002b17c87b7460 __libc_start_main +
    245

    6    tmpb2jz9hmr                        0x000055e04b46efe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for var i = 1; i <= n; i++ {\n   \
    \     factorial *= i\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9s7u3hkt.swift:12:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 1; i <= n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 0:\n\t\treturn 1\n\tcase 1:\n\t\treturn\
    \ 1\n\tdefault:\n\t\treturn n * special_factorial(n - 1)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqv4tl2sa.swift:17:32: error: missing argument label 'n:' in call\n\
    \                return n * special_factorial(n - 1)\n                       \
    \                      ^\n                                             n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 0:\n        return 1\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    case 3:\n        return\
    \ 3\n    case 4:\n        return 4\n    case 5:\n        return 9\n    case 6:\n\
    \        return 24\n    case 7:\n        return 120\n    case 8:\n        return\
    \ 720\n    case 9:\n        return 5040\n    case 10:\n        return 40320\n\
    \    case 11:\n        return 362880\n    case 12:\n        return 3628800\n \
    \   case 13:\n        return 39916800\n    case 14:\n        return 479001600\n\
    \    case 15:\n        return 6227020800\n    case 16:\n        return 87178291200\n\
    \    case 17:\n        return 1307674368000\n    case 18:\n        return 20922789888000\n\
    \    case 19:\n        return 355687428096000\n    case 20:\n        return 6402373705728000\n\
    \    case 21:\n        return 121645100408832000\n    case 22:\n        return\
    \ 2432902008176640000\n    case 23:\n        return 51090942171709440000\n   \
    \ case 24:\n        return 1124000727777607680000\n    case 25:\n        return\
    \ 25852016738884976640000\n    case 26:\n        return 620448401733239439360000\n\
    \    case 27:\n        return 138350557681902932229360000\n    case 28:\n    \
    \    return 283662140737095515576000000\n    case 29:\n        return 55227035913081140632000000\n\
    \    case 30:\n        return 1125899906842624000000000\n    case 31:\n      \
    \  return 251721119348114048000000000\n    case 32:\n        return 51090942171709440000000000\n\
    \    case 33:\n        return 10307921510148400000000000\n    case 34:\n     \
    \   return 20922789888000800064000000\n    case 35:\n        return 35568742809600064000000\n\
    \    case 36:\n        return 640237370572800064000000\n    case 37:\n       \
    \ return 12164510040883200064000000\n    case 38:\n        return 2432902008176640000000\n\
    \    case 39:\n        return 510909421717094400000000000\n    case 40:\n    \
    \    return 103079215101484000000000000\n    case 41:\n        return 209227898880008000128000000\n\
    \    case 42:\n        return 355687428096000128000000\n    case 43:\n       \
    \ return 6402373705728000128000000\n    case 44\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6yzke10y.swift:100:12: error: expected ':' after 'case'\n    case\
    \ 44\n           ^\n/tmp/tmp6yzke10y.swift:119:37: error: expected '}' at end\
    \ of brace statement\nassert(special_factorial(n: 1) == 1)\n                 \
    \                   ^\n/tmp/tmp6yzke10y.swift:10:39: note: to match this opening\
    \ '{'\nfunc special_factorial(n: Int) -> Int {\n                             \
    \         ^\n/tmp/tmp6yzke10y.swift:11:5: error: switch must be exhaustive\n \
    \   switch n {\n    ^\n/tmp/tmp6yzke10y.swift:11:5: note: do you want to add a\
    \ default clause?\n    switch n {\n    ^\n/tmp/tmp6yzke10y.swift:104:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var fact = 1\n    for _ in 0..<n {\n        fact *= n\n \
    \   }\n    return fact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpkb42c_nv/tmpkb42c_nv.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af643ab4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6437abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6437ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6437aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkb42c_nv                        0x0000559309c60337 <unavailable> + 4919

    5    libc.so.6                          0x00002af643ca0460 __libc_start_main +
    245

    6    tmpkb42c_nv                        0x0000559309c5ffe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tvar fact = 1\n\tfor i = 1; i <= n; i++ {\n\t\tfact *= i\n\t\
    }\n\treturn fact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwcf_a9ju.swift:12:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for i = 1; i <= n; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 0..<n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp64f6ha07/tmp64f6ha07.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d52916c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d5260db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d5260d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d5260c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64f6ha07                        0x000055d12adc4337 <unavailable> + 4919

    5    libc.so.6                          0x00002b3d52b02460 __libc_start_main +
    245

    6    tmp64f6ha07                        0x000055d12adc3fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n < 0 {\n        print(\"Error: n must be positive\")\n\
    \    }\n    if n == 1 {\n        return 1\n    }\n    return (n * special_factorial(n\
    \ - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps2v7q253.swift:17:35: error: missing argument label 'n:' in call\n\
    \    return (n * special_factorial(n - 1))\n                                 \
    \ ^\n                                  n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\treturn factorial(special_factorial_formula(n))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_mrb45be.swift:11:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(special_factorial_formula(n))\n               ^~~~~~~~~\n\
    /tmp/tmp_mrb45be.swift:11:19: error: cannot find 'special_factorial_formula' in\
    \ scope\n        return factorial(special_factorial_formula(n))\n            \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * special_factorial(n - 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsfkunqi3.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * special_factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmpsfkunqi3.swift:11:45:\
    \ error: missing argument label 'n:' in call\n    return factorial(n) * special_factorial(n\
    \ - 1)\n                                            ^\n                      \
    \                      n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = factorial(1)\n\n    for i = 2; i <= n; i++\
    \ {\n        factorial *= i\n    }\n\n    return factorial\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2m89al70.swift:13:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 2; i <= n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~\n/tmp/tmp2m89al70.swift:11:21:\
    \ error: use of local variable 'factorial' before its declaration\n    var factorial\
    \ = factorial(1)\n                    ^\n/tmp/tmp2m89al70.swift:11:9: note: 'factorial'\
    \ declared here\n    var factorial = factorial(1)\n        ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n  var res = 1\n  for _ in 0..<n {\n    res *= n\n  }\n  return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpm3ga95kl/tmpm3ga95kl.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab07f474c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab07f16bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab07f16b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab07f16a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm3ga95kl                        0x00005593352d9337 <unavailable> + 4919

    5    libc.so.6                          0x00002ab07f660460 __libc_start_main +
    245

    6    tmpm3ga95kl                        0x00005593352d8fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var ret = 1\n    var fact = 1\n\n    for _ in 0..<n {\n \
    \       fact = fact * ret\n        ret++\n    }\n\n    return fact\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4ekez2dm.swift:16:12: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        ret++\n           ^~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    var i = 0\n    while i < n {\n   \
    \     factorial *= i++\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbfdi0bgn.swift:14:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        factorial *= i++\n                      ^~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 0:\n\t\treturn 1\n\tcase 1:\n\t\treturn\
    \ 1\n\tcase 2:\n\t\treturn 2\n\tcase 3:\n\t\treturn 6\n\tcase 4:\n\t\treturn 24\n\
    \tcase 5:\n\t\treturn 120\n\tcase 6:\n\t\treturn 720\n\tcase 7:\n\t\treturn 5040\n\
    \tcase 8:\n\t\treturn 40320\n\tcase 9:\n\t\treturn 362880\n\tcase 10:\n\t\treturn\
    \ 3628800\n\tcase 11:\n\t\treturn 39916800\n\tcase 12:\n\t\treturn 479001600\n\
    \tcase 13:\n\t\treturn 6227020800\n\tcase 14:\n\t\treturn 87178291200\n\tcase\
    \ 15:\n\t\treturn 1307674368000\n\tcase 16:\n\t\treturn 20922789888000\n\tcase\
    \ 17:\n\t\treturn 355687428096000\n\tcase 18:\n\t\treturn 6402373705728000\n\t\
    case 19:\n\t\treturn 121645100408832000\n\tcase 20:\n\t\treturn 2432902008176640000\n\
    \tcase 21:\n\t\treturn 51090942171709440000\n\tcase 22:\n\t\treturn 1124000727777607680000\n\
    \tcase 23:\n\t\treturn 25852016738884976640000\n\tcase 24:\n\t\treturn 620448401733239439360000\n\
    \tcase 25:\n\t\treturn 15511210043330985984000000\n\tcase 26:\n\t\treturn 403291461126605635584000000\n\
    \tcase 27:\n\t\treturn 10888869450418352160768000000\n\tcase 28:\n\t\treturn 3048883446117138605015872000000\n\
    \tcase 29:\n\t\treturn 8841761993739701954543616000000\n\tcase 30:\n\t\treturn\
    \ 265252859812191058636308480000000\n\tcase 31:\n\t\treturn 8222838654177922817725562880000000\n\
    \tcase 32:\n\t\treturn 263130836933693530167218012160000000\n\tcase 33:\n\t\t\
    return 8683317618811886495518194401280000000\n\tcase 34:\n\t\treturn 28521267317840315039862144044800000000\n\
    \tcase 35:\n\t\treturn 102516213363391578010288127046400000000\n\tcase 36:\n\t\
    \treturn 223143551314211611920089700729600000000\n\tcase 37:\n\t\treturn 564613443658229080752436\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd_swbr91.swift:106:37: error: expected '}' at end of brace statement\n\
    assert(special_factorial(n: 1) == 1)\n                                    ^\n\
    /tmp/tmpd_swbr91.swift:10:39: note: to match this opening '{'\nfunc special_factorial(n:\
    \ Int) -> Int {\n                                      ^\n/tmp/tmpd_swbr91.swift:11:2:\
    \ error: switch must be exhaustive\n        switch n {\n        ^\n/tmp/tmpd_swbr91.swift:11:2:\
    \ note: do you want to add a default clause?\n        switch n {\n        ^\n\
    /tmp/tmpd_swbr91.swift:91:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let result = 1\n    for _ in 1...n {\n        result *= n\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq94ob1mq.swift:13:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result *= n\n        ~~~~~~ ^\n\
    /tmp/tmpq94ob1mq.swift:11:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var product = 1\n    for _ in 0..<n {\n        product *=\
    \ n\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpnhtm0zj4/tmpnhtm0zj4.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0972a12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0972709b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0972709988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09727087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnhtm0zj4                        0x000055beb95b2337 <unavailable> + 4919

    5    libc.so.6                          0x00002b0972bfe460 __libc_start_main +
    245

    6    tmpnhtm0zj4                        0x000055beb95b1fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result: Int = 1\n    for number in 1...n {\n        result\
    \ = result * number\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpi83rqo82/tmpi83rqo82.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afda6c61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afda6958b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afda6958988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afda69577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi83rqo82                        0x000055b754b68337 <unavailable> + 4919

    5    libc.so.6                          0x00002afda6e4d460 __libc_start_main +
    245

    6    tmpi83rqo82                        0x000055b754b67fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 1 {\n        return 1\n    }\n    var factorial =\
    \ 1\n    for index in 0..<n {\n        factorial *= index\n    }\n    return factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmp_08da9lm/tmp_08da9lm.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad27054ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad270245b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad270245988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2702447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_08da9lm                        0x000055bd99b64337 <unavailable> + 4919

    5    libc.so.6                          0x00002ad27073a460 __libc_start_main +
    245

    6    tmp_08da9lm                        0x000055bd99b63fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * factorial(n-1) * factorial(n-2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjhaad60h.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n-1) * factorial(n-2)\n           ^~~~~~~~~\n\
    /tmp/tmpjhaad60h.swift:11:27: error: cannot find 'factorial' in scope\n    return\
    \ factorial(n) * factorial(n-1) * factorial(n-2)\n                          ^~~~~~~~~\n\
    /tmp/tmpjhaad60h.swift:11:44: error: cannot find 'factorial' in scope\n    return\
    \ factorial(n) * factorial(n-1) * factorial(n-2)\n                           \
    \                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    if n >= 0 {\n        for _ in 0..<n {\n\
    \            result *= (n + 1)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpc8ekt51v/tmpc8ekt51v.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b54f6fa9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54f6ca0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54f6ca0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54f6c9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc8ekt51v                        0x0000562ab7729337 <unavailable> + 4919

    5    libc.so.6                          0x00002b54f7195460 __libc_start_main +
    245

    6    tmpc8ekt51v                        0x0000562ab7728fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var total = 1\n    for _ in 1...n {\n        total *= n\n\
    \    }\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmp0yic9o87/tmp0yic9o87.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b7800cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b77d03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8b77d03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8b77d027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0yic9o87                        0x0000562f4d836337 <unavailable> + 4919

    5    libc.so.6                          0x00002b8b781f8460 __libc_start_main +
    245

    6    tmp0yic9o87                        0x0000562f4d835fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tvar factorial Int = 1\n\tfor factorial < n {\n\t\tfactorial\
    \ *= factorial\n\t}\n\treturn factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1r1cpzgv.swift:11:16: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var factorial\
    \ Int = 1\n                      ^\n/tmp/tmp1r1cpzgv.swift:11:16: note: join the\
    \ identifiers together\n        var factorial Int = 1\n            ~~~~~~~~~~^~~\n\
    \            factorialInt\n/tmp/tmp1r1cpzgv.swift:12:16: error: expected 'in'\
    \ after for-each pattern\n        for factorial < n {\n                      ^\n\
    /tmp/tmp1r1cpzgv.swift:12:16: error: unary operator cannot be separated from its\
    \ operand\n        for factorial < n {\n                      ^~\n           \
    \            \n/tmp/tmp1r1cpzgv.swift:12:16: error: '<' is not a prefix unary\
    \ operator\n        for factorial < n {\n                      ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 0 {\n        return n\n    }\n    return factorial(n)\
    \ * special_factorial(n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdcac0sj5.swift:14:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * special_factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmpdcac0sj5.swift:14:45:\
    \ error: missing argument label 'n:' in call\n    return factorial(n) * special_factorial(n\
    \ - 1)\n                                            ^\n                      \
    \                      n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * factorial(n-1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3mxkm19q.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n-1)\n           ^~~~~~~~~\n/tmp/tmp3mxkm19q.swift:11:27:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) * factorial(n-1)\n\
    \                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979312
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tvar result Int\n\n\tfor i := 1; i <= n; i++ {\n\t\tresult *=\
    \ i\n\t}\n\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq0hud24e.swift:11:13: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var result Int\n\
    \                   ^\n/tmp/tmpq0hud24e.swift:11:13: note: join the identifiers\
    \ together\n        var result Int\n            ~~~~~~~^~~\n            resultInt\n\
    /tmp/tmpq0hud24e.swift:13:9: error: expected type\n        for i := 1; i <= n;\
    \ i++ {\n               ^\n                <#type#>\n/tmp/tmpq0hud24e.swift:13:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 1; i <= n; i++\
    \ {\n               ^\n/tmp/tmpq0hud24e.swift:13:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := 1; i <= n; i++ {\n               ^\n/tmp/tmpq0hud24e.swift:11:6:\
    \ error: type annotation missing in pattern\n        var result Int\n        \
    \    ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result *= n\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpq7tdyuud/tmpq7tdyuud.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ed07c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ed04beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ed04be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ed04bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq7tdyuud                        0x0000561d2b853337 <unavailable> + 4919

    5    libc.so.6                          0x00002b8ed09b3460 __libc_start_main +
    245

    6    tmpq7tdyuud                        0x0000561d2b852fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n < 2 {\n        return n\n    }\n\n    let a = 1\n  \
    \  for _ in 0 ..< n {\n        a *= n\n    }\n    return a\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_f517gbv.swift:17:11: error: left side of mutating operator isn't\
    \ mutable: 'a' is a 'let' constant\n        a *= n\n        ~ ^\n/tmp/tmp_f517gbv.swift:15:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let a = 1\n    ^~~\n   \
    \ var\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) // factorial(0) is 1, factorial(1) ==\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\n\
    assert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\n\
    assert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqg6bm8wd.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) // factorial(0) is 1, factorial(1) == 0\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return factorial(n)\
    \ * (n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1eig6i94.swift:14:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq8li7x96.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) / special_factorial_sum(n)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptngs9x3d.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) / special_factorial_sum(n)\n           ^~~~~~~~~\n/tmp/tmptngs9x3d.swift:11:27:\
    \ error: cannot find 'special_factorial_sum' in scope\n    return factorial(n)\
    \ / special_factorial_sum(n)\n                          ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 0 {\n        return 0\n    }\n    return n * (n -\
    \ 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpfyblvjbs/tmpfyblvjbs.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d44440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d44137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d44137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d441367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfyblvjbs                        0x000055a1598791b7 <unavailable> + 4535

    5    libc.so.6                          0x00002b8d4462c460 __libc_start_main +
    245

    6    tmpfyblvjbs                        0x000055a159878e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n  var result = 1\n  for _ in 1...n {\n    result *= n\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpd90wm_zc/tmpd90wm_zc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90f7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90c73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa90c73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa90c727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd90wm_zc                        0x0000555c94036337 <unavailable> + 4919

    5    libc.so.6                          0x00002baa91168460 __libc_start_main +
    245

    6    tmpd90wm_zc                        0x0000555c94035fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\treturn factorial(n) / (factorial(n - 1) * factorial(n - 2))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5yj68jcn.swift:11:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) / (factorial(n - 1) * factorial(n - 2))\n       \
    \        ^~~~~~~~~\n/tmp/tmp5yj68jcn.swift:11:25: error: cannot find 'factorial'\
    \ in scope\n        return factorial(n) / (factorial(n - 1) * factorial(n - 2))\n\
    \                               ^~~~~~~~~\n/tmp/tmp5yj68jcn.swift:11:44: error:\
    \ cannot find 'factorial' in scope\n        return factorial(n) / (factorial(n\
    \ - 1) * factorial(n - 2))\n                                                 \
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tvar result : Int = 0\n\tswitch n {\n\tcase 0:\n\t\tresult =\
    \ 1\n\tcase 1:\n\t\tresult = 1\n\tcase 2:\n\t\tresult = 2\n\tcase 3:\n\t\tresult\
    \ = 3\n\tcase 4:\n\t\tresult = 4\n\tcase 5:\n\t\tresult = 5\n\tcase 6:\n\t\tresult\
    \ = 6\n\tcase 7:\n\t\tresult = 7\n\tcase 8:\n\t\tresult = 8\n\tcase 9:\n\t\tresult\
    \ = 9\n\tcase 10:\n\t\tresult = 10\n\tcase 11:\n\t\tresult = 11\n\tcase 12:\n\t\
    \tresult = 12\n\tcase 13:\n\t\tresult = 13\n\tcase 14:\n\t\tresult = 14\n\tcase\
    \ 15:\n\t\tresult = 15\n\tdefault:\n\t\tvar fatfactorial = 1\n\t\tfor i := 1;\
    \ i <= n; i++ {\n\t\t\tfatfactorial *= i\n\t\t}\n\t\tresult = fatfactorial\n\t\
    }\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdw2wjvjh.swift:47:10: error: expected type\n                for\
    \ i := 1; i <= n; i++ {\n                       ^\n                        <#type#>\n\
    /tmp/tmpdw2wjvjh.swift:47:10: error: expected 'in' after for-each pattern\n  \
    \              for i := 1; i <= n; i++ {\n                       ^\n/tmp/tmpdw2wjvjh.swift:47:10:\
    \ error: expected Sequence expression for for-each loop\n                for i\
    \ := 1; i <= n; i++ {\n                       ^\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n\n    if n == 1 {\n        return factorial\n\
    \    }\n    else {\n        for i in 2...n {\n            factorial *= i\n   \
    \     }\n\n        return factorial\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpdir8vs1c/tmpdir8vs1c.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3be836dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3be8064b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3be8064988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3be80637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdir8vs1c                        0x000055f6cce33337 <unavailable> + 4919

    5    libc.so.6                          0x00002b3be8559460 __libc_start_main +
    245

    6    tmpdir8vs1c                        0x000055f6cce32fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var result = 1\n    for index in 1...n {\n        result\
    \ *= index\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmpiz06vl92/tmpiz06vl92.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90d781fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90d7516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90d7516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90d75157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiz06vl92                        0x000055cbc1a35337 <unavailable> + 4919

    5    libc.so.6                          0x00002b90d7a0b460 __libc_start_main +
    245

    6    tmpiz06vl92                        0x000055cbc1a34fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * (n - 1) * special_factorial(n - 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjdqqqu6k.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1) * special_factorial(n - 1)\n           ^~~~~~~~~\n\
    /tmp/tmpjdqqqu6k.swift:11:55: error: missing argument label 'n:' in call\n   \
    \ return factorial(n) * (n - 1) * special_factorial(n - 1)\n                 \
    \                                     ^\n                                    \
    \                  n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * special_factorial(n-1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps00swsap.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * special_factorial(n-1)\n           ^~~~~~~~~\n/tmp/tmps00swsap.swift:11:45:\
    \ error: missing argument label 'n:' in call\n    return factorial(n) * special_factorial(n-1)\n\
    \                                            ^\n                             \
    \               n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial: Int = 0\n\n    for _ in 0..<n {\n        factorial\
    \ *= n\n    }\n\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmphv2tuk9d/tmphv2tuk9d.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6fa820c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6fa517b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6fa517988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6fa5167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphv2tuk9d                        0x000055b5fe2e7337 <unavailable> + 4919

    5    libc.so.6                          0x00002ae6faa0c460 __libc_start_main +
    245

    6    tmphv2tuk9d                        0x000055b5fe2e6fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return n\n    }\n    var ret = 1\n \
    \   for i = 1; i < n; i++ {\n        ret *= i\n    }\n    return ret\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6fclbm0u.swift:15:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 1; i < n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n < 2 {\n        return 1\n    }\n    return n * special_factorial(n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_nq20313.swift:14:34: error: missing argument label 'n:' in call\n\
    \    return n * special_factorial(n - 1)\n                                 ^\n\
    \                                 n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n == 1 {\n\t\treturn 1\n\t}\n\n\tif n < 2 {\n\t\treturn\
    \ 0\n\t}\n\n\tret := factorial(n)\n\tfor i := 2; i <= n; i++ {\n\t\tret *= i\n\
    \t}\n\n\treturn ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvvr28x6r.swift:19:5: error: consecutive statements on a line must\
    \ be separated by ';'\n        ret := factorial(n)\n           ^\n           ;\n\
    /tmp/tmpvvr28x6r.swift:19:6: error: expected expression\n        ret := factorial(n)\n\
    \            ^\n/tmp/tmpvvr28x6r.swift:20:9: error: expected type\n        for\
    \ i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpvvr28x6r.swift:20:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++\
    \ {\n               ^\n/tmp/tmpvvr28x6r.swift:20:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpvvr28x6r.swift:19:2:\
    \ error: cannot find 'ret' in scope\n        ret := factorial(n)\n        ^~~\n\
    /tmp/tmpvvr28x6r.swift:24:9: error: cannot find 'ret' in scope\n        return\
    \ ret\n               ^~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * factorial(n - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_bl_bvnq.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * factorial(n - 1)\n           ^~~~~~~~~\n/tmp/tmp_bl_bvnq.swift:11:27:\
    \ error: cannot find 'factorial' in scope\n    return factorial(n) * factorial(n\
    \ - 1)\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979276
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    factorial(n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmporrevf38.swift:11:5: error: cannot find 'factorial' in scope\n\
    \    factorial(n - 1)\n    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var product = 1\n    for _ in 1...n {\n        product *=\
    \ n\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpusnnt0cx/tmpusnnt0cx.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6724b0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6724803b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6724803988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67248027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusnnt0cx                        0x000055989161b337 <unavailable> + 4919

    5    libc.so.6                          0x00002b6724cf8460 __libc_start_main +
    245

    6    tmpusnnt0cx                        0x000055989161afe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tvar factorial = 1\n\tfor _ in 0..<n {\n\t\tfactorial *= n\n\
    \t}\n\treturn factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmpesm4afku/tmpesm4afku.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f21cdbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f219d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f219d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f219d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpesm4afku                        0x000055eaacb7a337 <unavailable> + 4919

    5    libc.so.6                          0x00002b5f21ec7460 __libc_start_main +
    245

    6    tmpesm4afku                        0x000055eaacb79fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n <= 1 {\n        return 1\n    } else {\n        return\
    \ n * special_factorial(n - 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpywtnp2bp.swift:14:38: error: missing argument label 'n:' in call\n\
    \        return n * special_factorial(n - 1)\n                               \
    \      ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979380
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    switch n {\n    case 1:\n        return 1\n    case 2:\n\
    \        return 2\n    case 3:\n        return 6\n    case 4:\n        return\
    \ 24\n    case 5:\n        return 120\n    default:\n        return n * special_factorial(n\
    \ - 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpo6fnc0q4.swift:23:38: error: missing argument label 'n:' in call\n\
    \        return n * special_factorial(n - 1)\n                               \
    \      ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 1..<n {\n        factorial\
    \ *= n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmpubz17h8l/tmpubz17h8l.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8853f35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8853c2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8853c2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8853c2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpubz17h8l                        0x000055eb5241c337 <unavailable> + 4919

    5    libc.so.6                          0x00002b8854121460 __libc_start_main +
    245

    6    tmpubz17h8l                        0x000055eb5241bfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 0:\n\t\treturn 1\n\tcase 1:\n\t\treturn\
    \ n\n\tdefault:\n\t\tlet result = factorial(n) * (n - 1)\n\t\treturn result\n\t\
    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3hfo71xa.swift:17:16: error: cannot find 'factorial' in scope\n\
    \                let result = factorial(n) * (n - 1)\n                       \
    \      ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n < 0 {\n        throwInputError(message: \"The Brazilian\
    \ factorial is undefined for negative numbers.\",\n                       location:\
    \ .startOfInput)\n    }\n    if n == 1 {\n        return 1\n    }\n    return\
    \ (n * special_factorial(n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuj8849xf.swift:12:9: error: cannot find 'throwInputError' in scope\n\
    \        throwInputError(message: \"The Brazilian factorial is undefined for negative\
    \ numbers.\",\n        ^~~~~~~~~~~~~~~\n/tmp/tmpuj8849xf.swift:13:35: error: cannot\
    \ infer contextual base in reference to member 'startOfInput'\n              \
    \         location: .startOfInput)\n                                 ~^~~~~~~~~~~~\n\
    /tmp/tmpuj8849xf.swift:18:35: error: missing argument label 'n:' in call\n   \
    \ return (n * special_factorial(n - 1))\n                                  ^\n\
    \                                  n: \n"
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return n * special_factorial(n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1fne7y7z.swift:14:34: error: missing argument label 'n:' in call\n\
    \    return n * special_factorial(n - 1)\n                                 ^\n\
    \                                 n: \n"
  stdout: ''
  timestamp: 1659979312
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial: Int\n    if n <= 1 {\n        factorial =\
    \ n\n    } else {\n        factorial = 1\n        for _ in 1 ..< n {\n       \
    \     factorial *= n\n        }\n    }\n    return factorial\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpny7cz5nq/tmpny7cz5nq.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86a85f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86a82f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86a82f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86a82ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpny7cz5nq                        0x000055ef6a26b337 <unavailable> + 4919

    5    libc.so.6                          0x00002b86a87e5460 __libc_start_main +
    245

    6    tmpny7cz5nq                        0x000055ef6a26afe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    precondition(n >= 0, \"The integer must be bigger than 0.\"\
    )\n    if n <= 1 {\n        return 1\n    } else {\n        return factorial(n)\
    \ * (special_factorial(n - 1))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpg74nfcye.swift:15:16: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) * (special_factorial(n - 1))\n               ^~~~~~~~~\n\
    /tmp/tmpg74nfcye.swift:15:50: error: missing argument label 'n:' in call\n   \
    \     return factorial(n) * (special_factorial(n - 1))\n                     \
    \                            ^\n                                             \
    \    n: \n"
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq8li7x96.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979381
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n  if n <= 0 {\n    return 0\n  }\n  var result = 1\n  for count\
    \ in 0 ..< n {\n    result *= count\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpk39ry7tu/tmpk39ry7tu.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ad5f54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ad5c4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ad5c4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ad5c4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk39ry7tu                        0x0000558cb4a43337 <unavailable> + 4919

    5    libc.so.6                          0x00002b2ad6140460 __libc_start_main +
    245

    6    tmpk39ry7tu                        0x0000558cb4a42fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    var result = 0\n\
    \    for _ in 1...n {\n        result *= n\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmp94dtgz85/tmp94dtgz85.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2e90e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2e8ddfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2e8ddf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2e8dde7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94dtgz85                        0x00005588497f1337 <unavailable> + 4919

    5    libc.so.6                          0x00002ab2e92d4460 __libc_start_main +
    245

    6    tmp94dtgz85                        0x00005588497f0fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n < 2 {\n        return n\n    }\n\n    let factorial\
    \ = 1\n    for i in 1...n {\n        factorial *= i\n    }\n\n    return factorial\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpoha9i7wk.swift:17:19: error: left side of mutating operator isn't\
    \ mutable: 'factorial' is a 'let' constant\n        factorial *= i\n        ~~~~~~~~~\
    \ ^\n/tmp/tmpoha9i7wk.swift:15:5: note: change 'let' to 'var' to make it mutable\n\
    \    let factorial = 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = factorialHelper(n)\n    if factorial == 0\
    \ {\n        return factorial\n    }\n    return factorial - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpig5f_p3q.swift:11:21: error: cannot find 'factorialHelper' in scope\n\
    \    var factorial = factorialHelper(n)\n                    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979382
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _n in 1 ... n {\n        factorial\
    \ *= _n\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp0dx5ji4_/tmp0dx5ji4_.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b7a425c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b7a11cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b7a11c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b7a11b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0dx5ji4_                        0x000055f39f2dd337 <unavailable> + 4919

    5    libc.so.6                          0x00002b1b7a611460 __libc_start_main +
    245

    6    tmp0dx5ji4_                        0x000055f39f2dcfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    return factorial(n) * (n - 1) * special_factorial(n - 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjdqqqu6k.swift:11:12: error: cannot find 'factorial' in scope\n\
    \    return factorial(n) * (n - 1) * special_factorial(n - 1)\n           ^~~~~~~~~\n\
    /tmp/tmpjdqqqu6k.swift:11:55: error: missing argument label 'n:' in call\n   \
    \ return factorial(n) * (n - 1) * special_factorial(n - 1)\n                 \
    \                                     ^\n                                    \
    \                  n: \n"
  stdout: ''
  timestamp: 1659979381
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tswitch n {\n\tcase 1:\n\t\treturn 1\n\tcase 2:\n\t\treturn\
    \ 2\n\tcase 3:\n\t\treturn 3\n\tcase 4:\n\t\treturn 4\n\tcase 5:\n\t\treturn 5\n\
    \tcase 6:\n\t\treturn 6\n\tcase 7:\n\t\treturn 7\n\tcase 8:\n\t\treturn 8\n\t\
    case 9:\n\t\treturn 9\n\tcase 10:\n\t\treturn 10\n\tcase 11:\n\t\treturn 11\n\t\
    case 12:\n\t\treturn 12\n\tcase 13:\n\t\treturn 13\n\tcase 14:\n\t\treturn 14\n\
    \tcase 15:\n\t\treturn 15\n\tcase 16:\n\t\treturn 16\n\tcase 17:\n\t\treturn 17\n\
    \tcase 18:\n\t\treturn 18\n\tcase 19:\n\t\treturn 19\n\tcase 20:\n\t\treturn 20\n\
    \tcase 21:\n\t\treturn 21\n\tcase 22:\n\t\treturn 22\n\tcase 23:\n\t\treturn 23\n\
    \tcase 24:\n\t\treturn 24\n\tcase 25:\n\t\treturn 25\n\tcase 26:\n\t\treturn 26\n\
    \tcase 27:\n\t\treturn 27\n\tcase 28:\n\t\treturn 28\n\tcase 29:\n\t\treturn 29\n\
    \tcase 30:\n\t\treturn 30\n\tcase 31:\n\t\treturn 31\n\tcase 32:\n\t\treturn 32\n\
    \tcase 33:\n\t\treturn 33\n\tcase 34:\n\t\treturn 34\n\tcase 35:\n\t\treturn 35\n\
    \tcase 36:\n\t\treturn 36\n\tcase 37:\n\t\treturn 37\n\tcase 38:\n\t\treturn 38\n\
    \tcase 39:\n\t\treturn 39\n\tcase 40:\n\t\treturn 40\n\tcase 41:\n\t\treturn 41\n\
    \tcase 42:\n\t\treturn 42\n\tcase 43:\n\t\treturn 43\n\tcase 44:\n\t\treturn 44\n\
    \tcase 45:\n\t\treturn 45\n\tcase 46:\n\t\treturn 46\n\tcase 47:\n\t\treturn 47\n\
    \tcase 48:\n\t\treturn 48\n\tcase 49:\n\t\treturn 49\n\tcase 50:\n\t\treturn 50\n\
    \tcase 51:\n\t\treturn 51\n\tcase 52:\n\t\treturn 52\n\tcase 53:\n\t\treturn 53\n\
    \tcase 54:\n\t\treturn 54\n\tcase 55:\n\t\treturn 55\n\tcase 56:\n\t\treturn 56\n\
    \tcase 57:\n\t\treturn 57\n\tcase 58:\n\t\treturn 58\n\tcase 59:\n\t\treturn 59\n\
    \tcase 60:\n\t\treturn 60\n\tcase 61:\n\t\treturn 61\n\tcase 62:\n\t\treturn 62\n\
    \tcase 63:\n\t\treturn 63\n\tcase 64:\n\t\treturn 64\n\tcase 65:\n\t\treturn 65\n\
    \tcase 66:\n\t\treturn 66\n\tcase 67:\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpavhkpm_5.swift:144:2: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 67:\n        ^~~~~~~~\n    \
    \             break\n/tmp/tmpavhkpm_5.swift:164:37: error: expected '}' at end\
    \ of brace statement\nassert(special_factorial(n: 1) == 1)\n                 \
    \                   ^\n/tmp/tmpavhkpm_5.swift:10:39: note: to match this opening\
    \ '{'\nfunc special_factorial(n: Int) -> Int {\n                             \
    \         ^\n/tmp/tmpavhkpm_5.swift:11:2: error: switch must be exhaustive\n \
    \       switch n {\n        ^\n/tmp/tmpavhkpm_5.swift:11:2: note: do you want\
    \ to add a default clause?\n        switch n {\n        ^\n/tmp/tmpavhkpm_5.swift:149:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    let result = 1\n    for _ in 0..<n {\n        result *= n\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxhivmt5w.swift:13:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result *= n\n        ~~~~~~ ^\n\
    /tmp/tmpxhivmt5w.swift:11:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979382
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    for _ in 0..<n {\n        factorial\
    \ *= factorial\n    }\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5)\
    \ == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpr5hq3lko/tmpr5hq3lko.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88c480bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88c4502b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88c4502988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88c45017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr5hq3lko                        0x000056474cea8337 <unavailable> + 4919

    5    libc.so.6                          0x00002b88c49f7460 __libc_start_main +
    245

    6    tmpr5hq3lko                        0x000056474cea7fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * special_factorial(n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwxwuvo9h.swift:14:31: error: missing argument label 'n:' in call\n\
    \        return n * special_factorial(n - 1)\n                               \
    \      ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n\tif n == 1 {\n\t\treturn 1\n\t}\n\treturn factorial(n) * (n\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4)\
    \ == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvtncn791.swift:14:9: error: cannot find 'factorial' in scope\n\
    \        return factorial(n) * (n - 1)\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979382
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var f = 1\n    for _ in 1...n {\n        f *= n\n    }\n\
    \    return f\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(special_factorial(n:\
    \ 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n:\
    \ 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"
  status: Exception
  stderr: 'tmp1w770zp5/tmp1w770zp5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac652bbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6528b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6528b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6528b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1w770zp5                        0x0000557e60a95337 <unavailable> + 4919

    5    libc.so.6                          0x00002ac652da8460 __libc_start_main +
    245

    6    tmp1w770zp5                        0x0000557e60a94fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n    var factorial_1 = 1\n    var factorial_2\
    \ = 1\n    for _ in 0..<n {\n        factorial = factorial * (n - 1)\n       \
    \ factorial_1 = factorial_1 * n\n        factorial_2 = factorial_2 * n - 1\n \
    \   }\n    return factorial * factorial_1 * factorial_2\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n:\
    \ 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n:\
    \ 1) == 1)"
  status: Exception
  stderr: 'tmpcloez5cj/tmpcloez5cj.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28a3acdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28a37c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28a37c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28a37c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcloez5cj                        0x000055996c019337 <unavailable> + 4919

    5    libc.so.6                          0x00002b28a3cb9460 __libc_start_main +
    245

    6    tmpcloez5cj                        0x000055996c018fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
- exit_code: 1
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    if n == 1 {\n        return 1\n    } else {\n        return\
    \ n * special_factorial(n - 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfj3iwvll.swift:14:38: error: missing argument label 'n:' in call\n\
    \        return n * special_factorial(n - 1)\n                               \
    \      ^\n                                     n: \n"
  stdout: ''
  timestamp: 1659979382
- exit_code: -4
  program: "\n/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(n: 4)\n/// 288\n/// The function will receive an integer as\
    \ input and should return the special\n/// factorial of this integer.\nfunc special_factorial(n:\
    \ Int) -> Int {\n    var factorial = 1\n\n    for _ in 1 ..< n {\n        factorial\
    \ *= 1\n    }\n\n    return factorial\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\n\
    assert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1)\
    \ == 1)"
  status: Exception
  stderr: 'tmp1iupfye2/tmp1iupfye2.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9734bb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97348a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97348a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97348a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1iupfye2                        0x0000555850f9f337 <unavailable> + 4919

    5    libc.so.6                          0x00002b9734d9c460 __libc_start_main +
    245

    6    tmp1iupfye2                        0x0000555850f9efe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979382
