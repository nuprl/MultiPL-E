name: HumanEval_12_longest
language: swift
prompt: "\n/// Out of array of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return nil in case the input\
  \ array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n/// >>> longest(strings:\
  \ [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings: [\"a\", \"bb\", \"\
  ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\n\
  assert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings:\
  \ [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
completions: ["    let length = strings.reduce(into: 0, { result, string in\n    \
    \    return max(result, string.characters.count)\n    })\n    return strings.firstIndex(of:\
    \ String(repeating: \"a\", count: length))", '    return longest(arrays.toArray(strings))',
  "  if strings.count == 0 {\n    return nil\n  }\n\n  // We sort the strings so that\
    \ the longest ones come first (like Python's sorted(key=len)\n  // function).\n\
    \  let sortedStrings = strings.sorted()\n\n  // We go through all the strings\
    \ and keep a pointer to the longest one.\n  var longest = String?()\n  var longestStringIndex\
    \ = 0\n\n  for index in strings.indices {\n    let string = sortedStrings[index]\n\
    \    let length = string.characters.count\n\n    if length > longest!.characters.count\
    \ {\n      longest = string\n      longestStringIndex = index\n    }\n  }\n\n\
    \  return longest", "    if strings.isEmpty {\n        return nil\n    }\n   \
    \ var max: String = \"\"\n    var maxLength = 0\n    for s in strings {\n    \
    \    if s.count > maxLength {\n            maxLength = s.count\n            max\
    \ = s\n        }\n    }\n    return max", "  var longest = \"\"\n  for string\
    \ in strings { // NOTE: mutating loop variable, bad practice.\n    if longest.characters.count\
    \ < string.characters.count {\n      longest = string\n    }\n  }\n  return longest",
  "    var maxLen = 0\n    var longest: String = nil\n\n    for str in strings {\n\
    \        let len = str.count\n        if len > maxLen {\n            maxLen =\
    \ len\n            longest = str\n        }\n    }\n\n    return longest", " \
    \   if isEmpty(strings) {\n        return nil\n    }\n    if let str = longestString(strings)\
    \ {\n        return str\n    }\n    return nil", "    return strings.reduce((_:\
    \ String?, i: String) -> String? {\n        if _ == \"\" {\n            return\
    \ i\n        }\n\n        if i.count < _.count {\n            return _\n     \
    \   }\n        return i\n    })", "    let maxSize = strings.max(by: { (string1,\
    \ string2) in string1.count > string2.count })\n    return maxSize.count == 0\
    \ ? nil : maxSize[0]", "    if strings.isEmpty {\n        return nil\n    }\n\n\
    \    let longestString = strings.reduce((max: Int, cur: String, curIndex: Int)\
    \ -> Int? {\n        if max < cur.length {\n            return max\n        }\n\
    \        return curIndex\n    })\n\n    if longestString == nil {\n        return\
    \ nil\n    }\n\n    return strings[longestString!]", "    if strings == nil ||\
    \ strings.IsEmpty() {\n        return nil\n    }\n\n    // sort to get the longest\
    \ first\n    var strings = strings.sorted()\n\n    // find longest\n    var longestString\
    \ = strings[0]\n    var longestLength = longestString.characters.count\n\n   \
    \ for s in strings {\n        if s.characters.count > longestLength {\n      \
    \      longestString = s\n            longestLength = longestString.characters.count\n\
    \        }\n    }\n\n    return longestString", "    if strings.isEmpty() {\n\
    \        return nil\n    }\n    \n    var longest: Int = 0\n    var longestStr:\
    \ String? = nil\n    for str in strings {\n        if str.count > longest {\n\
    \            longest = str.count\n            longestStr = str\n        }\n  \
    \  }\n    return longestStr", '    return longest(strings, { $0.count })', " \
    \ if strings.isEmpty() {\n    return nil\n  }\n\n  maxLen, _ := maxStringLen(strings)\n\
    \  return strings.first(where: { $0.count == maxLen })", '    return longestFromSliceString(strings...)',
  "    if strings.isEmpty {\n        return nil\n    }\n\n    let longestString =\
    \ strings.reduce(\"\", { result, string in\n        if result.count < string.count\
    \ {\n            return result\n        } else if result.count == string.count\
    \ {\n            return string\n        } else {\n            return result\n\
    \        }\n    })\n\n    return longestString", "  if let first = strings.first\
    \ {\n    if strings.count == 1 {\n      return first\n    }\n    let longest =\
    \ strings.reduce(0, { (result, string) -> Int? in\n      let length = string.count\n\
    \      guard result < length else { return nil }\n      return result\n    })\n\
    \    return longest\n  }\n  return nil", "    var maxLength = 0\n    var longestString:\
    \ String?\n\n    for str in strings {\n        if str.characters.count > maxLength\
    \ {\n            maxLength = str.characters.count\n            longestString =\
    \ str\n        }\n    }\n\n    return longestString", "    if strings.isEmpty\
    \ { return nil }\n    guard strings.count > 0 else {\n        return nil\n   \
    \ }\n    guard let longest = strings.max else { return nil }\n    return longest",
  "    if strings.isEmpty { return nil }\n    var longest = strings[0]\n    for s\
    \ in strings {\n        if longest.length < s.length { longest = s }\n    }\n\
    \    return longest", '    return longest(strings.sorted())', '    return longestElements(strings).map
    { $0 }', "    if strings.isEmpty {\n        return nil\n    }\n\n    var maxLen:\
    \ Int = 0\n    var maxIndex = 0\n    for index, s in strings.enumerated() {\n\
    \        if s.count > maxLen {\n            maxIndex = index\n            maxLen\
    \ = s.count\n        }\n    }\n\n    if maxLen == 0 {\n        return nil\n  \
    \  }\n\n    return strings[maxIndex]", "    var maxLength = Int.max\n    var longestString\
    \ = String()\n    var longestStringIndex = 0\n    for index in 0..<strings.count\
    \ {\n        if strings[index].count > maxLength {\n            maxLength = strings[index].count\n\
    \            longestString = strings[index]\n            longestStringIndex =\
    \ index\n        }\n    }\n\n    if longestString.count > maxLength {\n      \
    \  return nil\n    }\n\n    return longestString", "    guard !strings.isEmpty\
    \ else { return nil }\n    var maxCount = 1 // first string is as long\n    var\
    \ maxIndex = -1\n\n    for index in strings.indices {\n        var count = 0\n\
    \n        if let substring = strings[maxIndex] {\n            count = maxCount.count\
    \ + substring.length - index\n        }\n\n        if count > maxCount {\n   \
    \         maxCount = count\n            maxIndex = index\n        }\n    }\n\n\
    \    return maxIndex >= 0 ? strings[maxIndex] : nil", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n\n    var maxLen = Int.max\n    var longest: String?\
    \ = nil\n\n    for str in strings {\n        let len = str.count\n        if len\
    \ > maxLen {\n            maxLen = len\n            longest = str\n        }\n\
    \    }\n\n    return longest", "  if strings.isEmpty {\n    return nil\n  }\n\n\
    \  guard strings[0].isEmpty else { return strings[0] }\n\n  var longest = strings[0]\n\
    \  for str in strings.dropFirst() {\n    if str.count > longest.count {\n    \
    \  longest = str\n    }\n  }\n\n  return longest", '    return longest(strings,
    nil)', '    return longest(strings, nil)', "    guard !strings.isEmpty else {\
    \ return nil }\n\n    var longest: String = \"\"\n\n    for str in strings {\n\
    \        if str.count > longest.count {\n            longest = str\n        }\n\
    \    }\n\n    return longest", "    // TODO: optimise this\n    if strings.IsEmpty()\
    \ {\n        return nil\n    }\n    var longest = strings[0]\n    for _, string\
    \ in strings.Iter() {\n        if longest == string {\n            continue\n\
    \        }\n        if longest.count < string.count {\n            longest = string\n\
    \        }\n    }\n    return longest", '    return longestHelper(strings, nil)',
  "    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(into:\
    \ nil) { longest, current in\n        longest = (longest ?? current).count < current.count\n\
    \            return current }", "    guard !strings.isEmpty else {\n        return\
    \ nil\n    }\n    return strings.reduce(\n        { $0.count < $1.count ? $0 :\
    \ $1\n        },\n        { $0.count > $1.count ? $0 : $1 })", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    if strings.count <= 1 {\n        return strings.first\n\
    \    }\n    var longest = strings[0]\n    for s in strings {\n        if s.length\
    \ >= longest.length {\n            longest = s\n        }\n    }\n    return longest",
  "\treturn longest(strings: strings, lengths: nil)", "    if strings.isEmpty {\n\
    \        return nil\n    }\n\n    var longestLength = Int.max\n\n    for s in\
    \ strings {\n        let length = s.count ?? 0\n\n        if length > longestLength\
    \ {\n            longestLength = length\n        }\n    }\n\n    return longestLength\
    \ == Int.max ? nil : strings.first", "    if strings == nil {\n        return\
    \ nil\n    }\n    var longestString = strings[0]\n    for string in strings {\n\
    \        if string.length > longestString.length {\n            longestString\
    \ = string\n        }\n    }\n    return longestString", "    if strings == nil\
    \ {\n        return nil\n    }\n    let sortedStrings = strings.sorted(by: { $0.count\
    \ > $1.count })\n    return sortedStrings.first", "    if strings.IsEmpty() {\n\
    \        return nil\n    }\n    let length = strings.reduce(0, {$0 + $1.count})\n\
    \    if length < 0 {\n        return nil\n    }\n    let maxString = strings.reduce(\"\
    \") {\n        var accum = $0\n        if let idx = $1.index(before: $0.endIndex,\
    \ offsetBy: 1) {\n            accum = String(self[idx..<idx].joined())\n     \
    \   }\n        return accum\n    }\n    if maxString.count == length {\n     \
    \   return maxString\n    }\n    return nil", "    if strings.count == 0 {\n \
    \       return nil\n    }\n\n    var longestString = strings[0]\n    var minStringLength\
    \ = StringMaxLength\n\n    for s in strings {\n        guard s.count > minStringLength\
    \ else { return nil }\n        if s.count < minStringLength {\n            minStringLength\
    \ = s.count\n            longestString = s\n        }\n    }\n\n    return longestString",
  "    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings.first\n\
    \    for s in strings {\n        if s.count > longest!.count {\n            longest\
    \ = s\n        }\n    }\n    return longest", '    return longest(strings: strings,
    transform: nil)', "    if strings.isEmpty { return nil }\n    let longest = strings.reduce(\"\
    \") { $0.count<$1.count ? $0 : $1 }\n    if strings.count == 1 { return strings\
    \ as? String == longest ? longest : nil }\n    return longest", "    return max(strings)\
    \ { longest, _ in\n        longest.count\n    }", '    return longestHelper(strings,
    0, [], 0)', "    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(\"\
    \") {\n        if $0.count < $1.count {\n            return $1\n        } else\
    \ {\n            return $0\n        }\n    }", '    return longest(strings, emptyString:
    true)', "    // Short-circuiting the first time through. Until then, we always\
    \ have to iterate over the full list.\n    guard !strings.isEmpty else { return\
    \ nil }\n\n    var maxLen: Int = 0\n    var longestStr: String? = nil\n\n    for\
    \ s in strings {\n        if s.count > maxLen {\n            maxLen = s.count\n\
    \            longestStr = s\n        }\n    }\n\n    return longestStr", "  var\
    \ longest = \"\"\n\n  for s in strings {\n    longest = s.count < longest.count\
    \ ? s : longest\n  }\n\n  return longest", '  return longest(strings.map(String.init))',
  "    let s = strings.reduce((max: String, next: String) in\n        max == next.length\
    \ ? next : max)\n    return s == \"\" ? nil : s", "  if strings.isEmpty {\n  \
    \  return nil\n  }\n  let max = strings.reduce(\"\") { $0.count < $1.count ? $0\
    \ : $1 }\n  return strings.filter({ $0.count == max.count }).first", '    return
    longestInternal(strings, 0)', "    if strings.isEmpty {\n        return nil\n\
    \    }\n\n    let maxCount = strings.reduce(0, { acc, elem in\n        let count\
    \ = elem.count\n        return max(acc, count)\n    })\n\n    if maxCount == 0\
    \ {\n        return nil\n    }\n\n    return strings[maxCount - 1]", "    guard\
    \ !strings.isEmpty else { return nil }\n    return strings.reduce(\"\") { lhs,\
    \ rhs in\n        return lhs.count < rhs.count ? lhs : rhs\n    }", "    if isEmpty(strings)\
    \ {\n        return nil\n    }\n\n    var longestString : String?\n    for s in\
    \ strings {\n        if longestString == nil || len(s) > len(longestString) {\n\
    \            longestString = s\n        }\n    }\n\n    return longestString",
  "    if strings.isEmpty() {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") { (acc, curr) in\n        if acc.isEmpty {\n            return curr\n    \
    \    }\n        let (prev, curr) = acc.splitFirst()\n        return (curr.length\
    \ < prev.length) ? curr : prev\n    }\n    return longest", "    var longest =\
    \ strings[0]\n    var longestIdx = 0\n    for idx, string in strings.enumerated()\
    \ {\n        if string.length <= longest.length {\n            longest = string\n\
    \            longestIdx = idx\n        }\n    }\n    if longestIdx >= strings.count\
    \ {\n        return nil\n    }\n    return strings[longestIdx]", "\tguard !strings.isEmpty\
    \ else {\n\t\treturn nil\n\t}\n\treturn strings.reduce(into: \"\") { $0 < $1.count\
    \ ? $0 : $1 < $1.count ? $1 }", "    return longestWithIndex(strings.enumerated().map{\
    \ (index, value) -> String? in\n        return value\n    })", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n\n    var longest: Int = 0\n    var maxLength\
    \ = 0\n    for i in strings.indices {\n        let len = strings[i].characters.count\n\
    \        if len > maxLength {\n            maxLength = len\n            longest\
    \ = i\n        }\n    }\n\n    if longest < maxLength {\n        return strings[longest]\n\
    \    }\n\n    return nil", "  if !strings.isEmpty {\n    return strings.sort{\
    \ $0.count < $1.count }.first\n  }\n  return nil", '    return longestN(count:
    strings.count, argument: strings)', '    return longestHelper(strings, 0).max',
  "  if strings.isEmpty {\n    return nil\n  }\n\n  var longest = strings.reduce(0,\
    \ combineLongestLength)\n  if longest > strings[0].count {\n    return strings[0]\n\
    \  }\n\n  var result = strings[0]\n  for string in strings.dropFirst() {\n   \
    \ if string.count > longest {\n      longest = string.count\n      result = string\n\
    \    }\n  }\n\n  return result", "    var longestString = nil\n    for stringToCompare\
    \ in strings {\n        if stringToCompare.count > longestString.count {\n   \
    \         longestString = stringToCompare\n        }\n    }\n    return longestString",
  "    guard !strings.isEmpty else {\n        return nil\n    }\n\n    if strings.count\
    \ == 1 {\n        return strings[0]\n    }\n\n    var lengths = Array(repeating:\
    \ 0, count: strings.count)\n    for str in strings {\n        guard !str.isEmpty\
    \ else {\n            return nil\n        }\n        lengths[strings.index(str,\
    \ offsetBy: 0)] += 1\n    }\n\n    if lengths.isEmpty {\n        return nil\n\
    \    }\n\n    var longest: String = nil\n    var idx: Int = 0\n    var foundLongest:\
    \ Bool = false\n    for idx in 0..<lengths.count {\n        let length = lengths[idx]\n\
    \        if length > longest!.count {\n            longest = strings[idx]\n  \
    \          foundLongest = true\n        } else if length == longest!.count {\n\
    \            if foundLongest {\n                return longest\n            }\n\
    \        }\n    }\n\n    return longest", "    guard !strings.isEmpty else { return\
    \ nil }\n\n    var maxLen = 0\n    var longest = nil\n    for str in strings {\n\
    \        let newLen = str.characters.count\n        if newLen > maxLen {\n   \
    \         maxLen = newLen\n            longest = str\n        }\n    }\n    return\
    \ longest", '    return longest(from: strings)', '    return longestInPlace(strings).first',
  "    var lengths = stringList.map({ $0.count })\n    var bestString: String = nil\n\
    \    var bestLength = Int.max\n    for length in lengths {\n        if length\
    \ == bestLength {\n            continue\n        }\n        if bestLength == length\
    \ {\n            bestLength = Int.max\n            bestString = nil\n        }\n\
    \        if bestString != nil && length == bestLength {\n            continue\n\
    \        }\n        if bestLength < length {\n            bestLength = length\n\
    \            bestString = stringList[lengths.index(lengths.startIndex, offsetBy:\
    \ length)]\n        }\n    }\n    return bestString", "    let longest = strings.reduce((max,\
    \ string) => {\n        return max == nil || string.length > max.length ? string\
    \ : max\n    })\n\n    return longest != nil ? longest : nil", '  return longestIndexes(strings)[0]',
  "    var max: Int = 0\n    var longest: String?\n    for s in strings {\n      \
    \  max = max > s.count ? max : s.count\n        if s.count == max {\n        \
    \    longest = s\n        }\n    }\n    return longest", "    var max: Int? =\
    \ nil\n    for string in strings {\n        if max is Int {\n            if max\
    \ > string.characters.count {\n                max = string.characters.count\n\
    \            }\n        } else {\n            if let max = max {\n           \
    \     if max < string.characters.count {\n                    max = nil\n    \
    \            }\n            } else {\n                max = string.characters.count\n\
    \            }\n        }\n    }\n    return max", "  var longest: String = String()\n\
    \  for str in strings {\n    if str.length >= longest.length {\n      longest\
    \ = str\n    }\n  }\n  return longest", "    guard !strings.isEmpty else {\n \
    \       return nil\n    }\n\n    var longest = \"\"\n    var longestLongest =\
    \ String()\n    for s in strings {\n        if s.count > longest.count {\n   \
    \         longest = s\n            longestLongest = longest\n        } else {\n\
    \            if s.count < longest.count {\n                longest = s\n     \
    \           longestLongest = longest\n            }\n        }\n    }\n\n    return\
    \ longestLongest", "    if strings.IsEmpty() {\n        return nil\n    }\n\n\
    \    // Create a map with all the strings' lengths. Sort the map by value, and\
    \ get the first one\n    // by enumerating it.\n    var lengths = strings.map\
    \ { $0.length }\n    if lengths.isEmpty {\n        return nil\n    }\n    lengths.sortInPlace()\n\
    \    guard let firstLongest = lengths.first else {\n        return nil\n    }\n\
    \n    // If the longest string is longer than all the strings, return it right\
    \ away.\n    if longestLength == nil {\n        return firstLongest\n    }\n\n\
    \    // If the first longest string has the same length, return it.\n    if let\
    \ index = strings.firstIndex(where: {$0.length == longestLength!}) {\n       \
    \ return strings[index]\n    }\n\n    // If all the strings have the same length,\
    \ return the longest one\n    return firstLongest", "    if strings.isEmpty {\
    \ return nil }\n    let longest = strings[0]\n    for string in strings {\n  \
    \      if string.count > longest.count {\n            longest = string\n     \
    \   }\n    }\n    return longest", "    guard !strings.isEmpty else { return nil\
    \ }\n    var longest = strings.first!\n    for s in strings {\n        if s.count\
    \ < longest.count {\n            longest = s\n        }\n    }\n    return longest",
  "  if strings.isEmpty {\n    return nil\n  }\n  strings.sort(by: >)\n  return strings.first!",
  "    guard !strings.isEmpty else { return nil }\n\n    var maxLength = 0\n    var\
    \ longestString: String?\n\n    for string in strings {\n        let length =\
    \ (string as NSString).length\n        if length > maxLength {\n            maxLength\
    \ = length\n            longestString = string\n        }\n    }\n\n    return\
    \ longestString", '    return longest(strings: strings, length: Int64.max)', " \
    \   if strings.isEmpty {\n        return nil\n    }\n\n    return strings.reduce(String.max,\
    \ { lhs, rhs in\n        return lhs.characters.count < rhs.characters.count ?\
    \ lhs : rhs\n    })", '    longestImpl("", strings.count())', '  return longestInPlace(strings,
    lengths: strings.map { str in str.count })', '    return longest(strings, longestStringLength)',
  "  guard !strings.isEmpty else {\n    return nil\n  }\n\n  // Create a dictionary\
    \ to store the longest string and its length\n  var longest = Dictionary<Int,\
    \ String>()\n\n  for item in strings {\n    let length = item.length\n\n    //\
    \ If string already exists, update its length\n    if longest.keys.contains(length)\
    \ {\n      longest[length] = item\n    } else {\n      // If string doesn't exist\
    \ in dictionary, create a new dictionary entry\n      let newLongest = Dictionary<Int,\
    \ String>()\n\n      // Set longest as new dictionary entry\n      longest = newLongest\n\
    \n      // Add this length as key for new entry\n      longest[length] = item\n\
    \    }\n  }\n\n  // Return the longest string\n  return longest[longest.keys.maxElement()].value",
  "    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") {\n        if let length = $1.count, length > $0.count {\n            $0 =\
    \ $1\n        }\n        return $0\n    }\n    return longest", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n\n    var longest = \"\"\n    for string in strings\
    \ {\n        if string.isEmpty || len(longest) < len(string) {\n            longest\
    \ = string\n        }\n    }\n\n    return longest", "    guard !strings.isEmpty\
    \ else { return nil }\n    let longest = strings.reduce(\"\") { (s1, s2) in\n\
    \        let (max1, max2) = (s1.count, s2.count)\n        if max1 > max2 {\n \
    \           return s1\n        } else if max2 > max1 {\n            return s2\n\
    \        } else {\n            return s1\n        }\n    }\n    return longest",
  "  if strings == nil || strings.isEmpty {\n    return nil\n  }\n  var longest =\
    \ strings[0]\n  for s in strings {\n    if longest.count < s.count {\n      longest\
    \ = s\n    }\n  }\n  return longest", '    return longest(strings.map { $0.length
    })', "    if strings.isEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = String()\n    var currentLongest = String()\n\n    for string in strings {\n\
    \        if string.characters.count > currentLongest.characters.count {\n    \
    \        currentLongest = string\n        }\n\n        if string.characters.count\
    \ == currentLongest.characters.count {\n            if longest == \"\" {\n   \
    \             longest = currentLongest\n            } else {\n               \
    \ if currentLongest > longest {\n                    longest = currentLongest\n\
    \                }\n            }\n        }\n    }\n    return longest", "  \
    \  let longest = strings.reduce(\"\") { (longest, str) in\n        return maxLength(longest,\
    \ str)\n    }\n    return longest.count == 0 ? nil : longest", '    return longest(strings.compactMap({
    $0 }))', "    guard let longestString = strings.reduce(into: \"\") { longestString,\
    \ current in\n        if current.count == longestString.count {\n            longestString\
    \ += current\n        } else {\n            longestString = current\n        }\n\
    \    }\n    return longestString", "    guard !strings.isEmpty else { return nil\
    \ }\n    let longest = strings.maxLength\n    return longest.firstOrNil()", " \
    \   if strings.isEmpty {\n        return nil\n    }\n    \n    var maxLen = UInt32(0)\n\
    \    var longestString: String?\n    for str in strings {\n        guard let str\
    \ = str as? String, str.characters.count > maxLen else {\n            return nil\n\
    \        }\n        maxLen = str.characters.count\n        longestString = str\n\
    \    }\n    \n    return longestString", "    let max = strings[0]\n    for string\
    \ in strings {\n        if string.count > max.count {\n            max = string\n\
    \        }\n    }\n    return max", "  var best: String? = nil\n  var max: String?\
    \ = nil\n  for s in strings { // FIXME: Switch to for in\n    if s.count > best.count\
    \ || (best.count == s.count && best.compare(s) == .orderedAscending) {\n     \
    \ best = s\n      max = s\n    }\n  }\n  return max", '    return longest(strings,
    nil)', "    guard !strings.isEmpty else { return nil }\n    return strings.sorted().reduce(nil)\
    \ { longest, string in\n        guard longest == nil || longest!.count < string.count\
    \ else { return longest }\n        return string\n    }", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n\n    var longest = \"\"\n    for s in strings\
    \ {\n        if s.count > longest.count {\n            longest = s\n        }\n\
    \    }\n    return longest", '    return longest(strings, { $0.count })', "  \
    \  if !strings.isEmpty {\n        var longest = strings[0]\n        for string\
    \ in strings {\n            if string.length > longest.length {\n            \
    \    longest = string\n            }\n        }\n        return longest\n    }\n\
    \    return nil", "  if strings == nil || strings.isEmpty() {\n    return nil\n\
    \  }\n  var longest = strings[0]\n  for string in strings {\n    if string.count\
    \ > longest.count {\n      longest = string\n    }\n  }\n  return longest", " \
    \ let count = strings.length\n\n  for index in 0..<count {\n    if let longest\
    \ = strings.max(by: {$0.count < $1.count}) {\n      return longest\n    }\n  }\n\
    \  return nil", "    switch strings.count {\n    case 0: return nil\n    case\
    \ 1: return strings[0]\n    default: return strings.reduce(into: \"\") { longest,\
    \ str in\n        longest.isEmpty ? longest = str : longest.characters.count >\
    \ str.characters.count ? longest : str\n    }", "    guard !strings.isEmpty else\
    \ { return nil }\n    return strings.reduce((prev: String, next: String) -> String?\
    \ in\n        guard prev?.length == next.length else { return nil }\n        return\
    \ prev\n    )", "\treturn longest(arrays.toArrayOfStrings(strings))", "  if strings.isEmpty\
    \ { return nil }\n  var maxLength = strings.first!.length\n  var longest = strings.first!\n\
    \  for string in strings.dropFirst() {\n    if string.length > maxLength {\n \
    \     maxLength = string.length\n      longest = string\n    }\n  }\n  return\
    \ longest", "    var longestString: String? = nil\n    for str in strings {\n\
    \        if longestString == nil || longestString.count < str.count {\n      \
    \      longestString = str\n        }\n    }\n    return longestString", "   \
    \ guard !strings.isEmpty else {\n        return nil\n    }\n    var maxLength\
    \ = 0\n    var longest: String = nil\n    for str in strings {\n        let length\
    \ = str.characters.count\n        if length > maxLength {\n            maxLength\
    \ = length\n            longest = str\n        }\n    }\n    return longest",
  '  return longestImpl(strings).longest', "    let longestLength = 0\n    for s in\
    \ strings {\n        let length = s.count\n        if length > longestLength {\n\
    \            longestLength = length\n        }\n    }\n    if longestLength ==\
    \ 0 {\n        return nil\n    }\n    for s in strings {\n        if longestLength\
    \ != s.count {\n            return s\n        }\n    }\n    return nil", "   \
    \ if strings.count == 0 {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for i in 1..<strings.count {\n        if strings[i].count > longest.count\
    \ {\n            longest = strings[i]\n        }\n    }\n    return longest",
  "    var longest = \"\"\n    for string in strings {\n        if string.count ==\
    \ longest.count {\n            return string\n        }\n        if longest.count\
    \ > 0 {\n            if longest.count < string.count {\n                return\
    \ nil\n            }\n        }\n        longest = string\n    }\n    return longest",
  "    guard let first = strings.first else {\n        return nil\n    }\n    return\
    \ strings.reduce(first, maxLengthOfArray: 0)", "    if strings == nil || strings.isEmpty\
    \ {\n        return nil\n    }\n    var longest = \"\"\n    for string in strings\
    \ {\n        if string != \"\" && longest.count < string.count {\n           \
    \ longest = string\n        }\n    }\n    return longest", "  let longest = strings.maxElement()\n\
    \  return longest != nil ? longest! : nil", "    let longest = strings.reduce((max,\
    \ cur) -> String? {\n        let len = cur.utf8.count\n        return len > max?.utf8.count\
    \ ?? len ?? max?.utf8.count ?? 0\n    }, nil)\n    return longest", '    return
    strings.maxBy({ (string, string2) in string.count })', "    if strings == nil\
    \ || strings.isEmpty() {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest", "    if strings.isEmpty {\n    \
    \    return nil\n    }\n    let maxSize = strings.map({ $0.count }).max()!\n \
    \   return strings.sorted(by: { $0.count < $1.count }).first(where: { $0.count\
    \ == maxSize })", "    // longest is O(n), so it's better to do that in two passes\n\
    \    // first pass: compute longest from shortest string\n    var longest: String?\
    \ = nil\n    var shortest = strings.reduce((minLen: Int, curString: String) ->\
    \ Int {\n        return (minLen > curString.characters.count) ? minLen : curString.characters.count\n\
    \    })\n    for curString in strings {\n        let curLen = curString.characters.count\n\
    \        if curLen > shortest {\n            longest = curString\n           \
    \ shortest = curLen\n        }\n    }\n    // second pass: return the longest\
    \ if there's more than one string\n    return longest == nil ? nil : longest",
  "    if strings == nil {\n        return nil\n    }\n    return strings.reduce(into:\
    \ [String](), { result, string in\n        var currentLongestLength = 0\n    \
    \    for string in result {\n            let length = string.characters.count\n\
    \            if length > currentLongestLength {\n                currentLongestLength\
    \ = length\n            }\n        }\n        result.append(string)\n        currentLongestLength\
    \ = currentLongestLength ?? 0\n        for string in result {\n            string.length\
    \ = currentLongestLength\n        }\n    })", "    if strings.isEmpty() {\n  \
    \      return nil\n    }\n\n    var maxLength: Int = 0\n    var longest: String?\n\
    \n    for s in strings {\n        let len = s.count ?? 0\n        if len > maxLength\
    \ {\n            maxLength = len\n            longest = s\n        }\n    }\n\n\
    \    return longest", "    // Check parameter\n    guard !strings.isEmpty else\
    \ { return nil }\n\n    // Get the max string length\n    var maxStringLength\
    \ = 0\n    for s in strings {\n        let stringLength = s.characters.count\n\
    \        if stringLength > maxStringLength {\n            maxStringLength = stringLength\n\
    \        }\n    }\n\n    // Search for the longest one in array of strings\n \
    \   var longest: String?\n    for s in strings {\n        if maxStringLength ==\
    \ s.characters.count {\n            longest = s\n            break\n        }\n\
    \    }\n\n    return longest", "    if strings.isEmpty {\n        return nil\n\
    \    }\n\n    var longest = strings[0]\n    for string in strings.dropFirst()\
    \ {\n        if string.count > longest.count {\n            longest = string\n\
    \        }\n    }\n    return longest", "    var stringLengths: [Int] = [0]\n\
    \    var longestIndex = 0\n    for index in 0..<strings.count {\n        stringLengths[index]\
    \ = strings[index].count\n        if stringLengths[index] > stringLengths[longestIndex]\
    \ {\n            longestIndex = index\n        }\n    }\n    return strings[longestIndex]\
    \ ?? nil", '  return longest(strings: strings, transform: nil)', "    var longestString\
    \ = String()\n    var longestIndex = -1\n    for index in 0..<strings.count {\n\
    \        let string = strings[index]\n        if longestString.isEmpty {\n   \
    \         longestString = string\n            longestIndex = index\n        }\
    \ else if longestString.characters.count < string.characters.count {\n       \
    \     longestString = string\n            longestIndex = index\n        }\n  \
    \  }\n    return longestIndex != -1 ? strings[longestIndex] : nil", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    if strings.count == 1 {\n        return strings[0]\n\
    \    }\n    return strings.maxElement()", '  return longestNonEmpty(strings: strings,
    maxLength: -1)', '    return longest(strings, maxLength: 1)', '    return longest(strings:
    strings.sorted())', "    if strings.isEmpty {\n        return nil\n    }\n   \
    \ longest := strings.reduce(Int.max, {$0.compare($1) < 0 ? $0 : $1})\n    return\
    \ longest.count == 1 ? longest[0] : nil", "    longest = strings.reduce([String]()){\
    \ array, $1 in\n        var array = array\n        guard array.count < $1.count\
    \ else { return array }\n        array.append($1)\n        return array\n    }\n\
    \    return longest.count == 0 ? nil : longest[0]", "    if strings.isEmpty {\n\
    \        return nil\n    }\n\n    let longest = strings.reduce(into: \"\") {\n\
    \        let (prev: String, current: String, $0) = args\n        let length =\
    \ current.characters.count\n        prev.characters.count > length ? prev : current\n\
    \    }\n\n    return longest", "    precondition(strings.count > 0)\n    var maxLength\
    \ = strings[0].count {\n        didSet {\n            if maxLength < newValue\
    \ {\n                maxLength = newValue\n            }\n        }\n    }\n \
    \   for string in strings {\n        if maxLength < string.count {\n         \
    \   maxLength = string.count\n        }\n    }\n    return strings[strings.index(strings,\
    \ maxLength)]", "    if strings.isEmpty {\n        return nil\n    }\n    var\
    \ longest = strings[0]\n    for i in 1..<strings.count {\n        if longest.length\
    \ < strings[i].length {\n            longest = strings[i]\n        }\n    }\n\
    \    return longest", "    var longest = \"\"\n    for s in strings {\n      \
    \  if s.count > longest.count {\n            longest = s\n        }\n    }\n \
    \   return longest", "    if strings.isEmpty() {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for i in 1..<strings.count {\n        if longest.count\
    \ < strings[i].count {\n            longest = strings[i]\n        }\n    }\n \
    \   return longest", "  var longest = \"\"\n  for s in strings {\n    if s.count\
    \ > longest.count {\n      longest = s\n    }\n  }\n  return longest", "    guard\
    \ !strings.isEmpty else { return nil }\n    let longest = strings[0]\n    for\
    \ s in strings {\n        if longest.count < s.count {\n            longest =\
    \ s\n        }\n    }\n    return longest", "    var longest = strings[0]\n  \
    \  for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest", "    var maxLength = 0\n    for\
    \ s in strings {\n        let length = s.count ?? 0\n        if length > maxLength\
    \ {\n            maxLength = length\n        }\n    }\n    return strings.first\
    \ { $0.count == maxLength }", '  return longestElement(strings).map(String.init)',
  "    if strings.isEmpty {\n        return nil\n    }\n\n    return strings.reduce(into:\
    \ [String](), { result, element in\n        if let lastIndex = result.lastIndex(where:\
    \ { $0.count < element.count }) {\n            result[lastIndex] = element\n \
    \       } else {\n            result.append(element)\n        }\n    })", '    return
    longest(strings, count: -1)', '  return longest(strings.sorted()).last', '  return
    longest(strings: strings.filter({ $0.count > 1 }))', "    if strings.isEmpty {\n\
    \        return nil\n    }\n    var longest = strings[0]\n    for s in strings\
    \ {\n        if longest.count < s.count {\n            longest = s\n        }\n\
    \    }\n    return longest", "  if strings.isEmpty {\n    return nil\n  }\n\n\
    \  let sortedStrings = strings.sorted(by: { $0.count < $1.count })\n  return sortedStrings.last!",
  "    var maxLength = 0\n    for s in strings {\n        if s.count > maxLength {\n\
    \            maxLength = s.count\n        }\n    }\n    if maxLength == 0 {\n\
    \        return nil\n    }\n    if maxLength > 1 {\n        return strings.filter{$0.count\
    \ == maxLength}.sorted{$0.count < $1.count}.first\n    }\n    return strings.sorted{$0.count\
    \ < $1.count}.first", "    if strings.isEmpty {\n        return nil\n    }\n \
    \   var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest",
  "\tif strings.IsEmpty(ArrayOfStrings(strings).array) {\n\t\treturn nil\n\t}\n\n\t\
    return longestLongestString(ArrayOfStrings(strings).array)", "    guard !strings.isEmpty\
    \ else {\n        return nil\n    }\n\n    guard let first = strings.first else\
    \ {\n        return nil\n    }\n\n    let maxLengths = strings.map({ String($0.count)\
    \ }).max() ?? 0\n\n    var longest: Int?\n    for (i, s) in strings.enumerated()\
    \ {\n        if maxLengths > s.count {\n            maxLengths = s.count\n   \
    \         longest = i\n        }\n    }\n\n    return longest?.description ??\
    \ first", "  var maxLength = 0\n  var maxString: String?\n  for s in strings {\n\
    \    if s.count > maxLength {\n      maxLength = s.count\n      maxString = s\n\
    \    }\n  }\n  return maxString", "    if isEmpty(strings) {\n        return nil\n\
    \    }\n    var maxLength = 0\n    var longest: Int = 0\n    for str in strings\
    \ {\n        if str.length > maxLength {\n            maxLength = str.characters.count\n\
    \            longest = 0\n        }\n        if str.length > maxLength && str.characters.count\
    \ > longest {\n            longest = str.characters.count\n        }\n    }\n\
    \    return strings.first(where: { (s: String) -> Bool in\n        return s.characters.count\
    \ > longest\n    })", "    if strings.isEmpty {\n        return nil\n    }\n \
    \   var longest = strings.first!\n    for s in strings {\n        if s.count >\
    \ longest.count {\n            longest = s\n        }\n    }\n    return longest",
  "    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for str in strings {\n        if str.count > longest.count {\n          \
    \  longest = str\n        }\n    }\n    return longest", "    var maxLength =\
    \ 0\n    var longest : String?\n\n    for s in strings {\n        let len: Int\
    \ = s.count\n        if len > maxLength {\n            maxLength = len\n     \
    \       longest = s\n        }\n    }\n    return longest", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var longest = \"\"\n    var foundLongest =\
    \ false\n    for s in strings {\n        if s.count > longest.count {\n      \
    \      longest = s\n            foundLongest = true\n        }\n    }\n    if\
    \ foundLongest {\n        return longest\n    }\n    return strings.first", " \
    \ guard !strings.isEmpty else {\n    return nil\n  }\n  return strings.reduce((max:\
    \ String, cur: String) -> String in\n    guard max.count < cur.count else { return\
    \ max }\n    return cur\n  )", "  if strings.isEmpty { return nil }\n  return\
    \ longestWithOption(strings: strings, longestLength: 0)", "    return longest(\n\
    \        strings,\n        options: .init(distance: distanceLargerThan: 0),\n\
    \        locale: nil\n    )", "    var longest = \"\"\n    var longestLength =\
    \ NSString.stringLength(strings[0])\n    for s in strings {\n        let length\
    \ = NSString.stringLength(s);\n        if length > longestLength {\n         \
    \   longest = s\n            longestLength = length\n        }\n    }\n    return\
    \ longest", "  if strings.isEmpty {\n    return nil\n  }\n  var longest: Int =\
    \ 0\n  var longestString: String = \"\"\n  for index in 0..<strings.count {\n\
    \    if strings.count > 0 && strings.last == strings[index] {\n      continue\n\
    \    }\n    if longestString == \"\" && strings[index].count > longest {\n   \
    \   longest = strings[index].count\n      longestString = strings[index]\n   \
    \ }\n    if strings[index].count > longest {\n      longest = strings[index].count\n\
    \      longestString = strings[index]\n    }\n  }\n  if strings.last == longestString\
    \ {\n    return longestString\n  }\n  return nil", '    return max(strings, {
    $0.count < $1.count })', "    if strings.isEmpty { return nil }\n    let longest\
    \ = strings.reduce(\"\") { (result, curr) in\n        let length = result.characters.count\
    \ + curr.characters.count\n        return length > result.characters.count ? curr\
    \ : result\n    }\n    return longest", "    if strings.isEmpty {\n        return\
    \ nil\n    }\n    return strings.maxElement()", "    if strings.isEmpty {\n  \
    \      return nil\n    }\n\n    if strings.count > 1 {\n        var maxLength\
    \ = 0\n        for s in strings {\n            if s.count > maxLength {\n    \
    \            maxLength = s.count\n            }\n        }\n        return strings.first(where:\
    \ { (s) in s.count == maxLength })\n    } else {\n        return strings.first\n\
    \    }", "    if strings.isEmpty {\n        return nil\n    }\n    return max(strings,\
    \ { $0.count })", '    return longestN(by: longest, sortedBy: compare)', '    return
    longest(sortedBy(strings.sorted()), strings.sorted())', '    return longest(strings:
    strings, invariant: nil)', "    precondition(0 < strings.count)\n    if strings.count\
    \ == 0 { return nil }\n    guard let longest = strings.reduce(\"\") {\n      \
    \  (result, string) in return max(longest, string.length).characters.count < result.characters.count\
    \ ? max(longest, string.length) : result\n    }\n    return longest", "  if strings.isEmpty\
    \ {\n    return nil\n  }\n\n  var maxLength = 0\n  var maxString = strings[0]\n\
    \n  for string in strings {\n    if maxLength < string.count {\n      maxLength\
    \ = string.count\n      maxString = string\n    }\n  }\n\n  return maxString",
  "    if strings.isEmpty {\n        return nil\n    }\n\n    var max: String? = nil\n\
    \n    for str in strings {\n        if max != nil && str.length >= max!.length\
    \ {\n            return max\n        }\n\n        max = str\n    }\n\n    return\
    \ max", "    var longest = strings[0]\n    var counter = strings.reduce(0, combine:\
    \ { $0 + $1.count })\n    for s in strings {\n        if s.count > counter {\n\
    \            counter = s.count\n            longest = s\n        }\n    }\n  \
    \  return longest", "    guard !strings.isEmpty else { return nil }\n    let longest\
    \ = strings.reduce(into: \"\") {\n        if $0.count < $1.count { $0 = $1 }\n\
    \        else { $0 = $0 }\n    }\n    return longest", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var longestString: String?\n    var maxStringLength:\
    \ Int?\n    for s in strings {\n        var length = s.characters.count\n    \
    \    if maxStringLength == nil {\n            maxStringLength = &length\n    \
    \    } else if *maxStringLength > length {\n            maxStringLength = &length\n\
    \            longestString = s\n        }\n    }\n    return longestString", " \
    \   var maxLength = 0\n    var longest: String?\n\n    for s in strings {\n  \
    \      guard let len = s.count else { return nil }\n        if len > maxLength\
    \ { maxLength = len; longest = s }\n    }\n\n    return longest", "    var longest\
    \ : String? = nil\n    for string in strings {\n        if let stringLength =\
    \ string.characters.count {\n            if longest == nil || stringLength > longest!.characters.count\
    \ {\n                longest = string\n            }\n        }\n    }\n    return\
    \ longest", "    guard let first = strings.first else {\n        return nil\n\
    \    }\n\n    var longest = first\n    for str in strings.dropFirst() {\n    \
    \    if str.count > longest.count {\n            longest = str\n        }\n  \
    \  }\n    return longest", "  let maxLen = UInt32(0)\n  var longestString: String?\n\
    \  for str in strings {\n    if str.length > maxLen {\n      maxLen = str.length\n\
    \      longestString = str\n    }\n  }\n  return longestString", "    guard strings.count\
    \ > 0 else {\n        return nil\n    }\n    var longest: String = nil\n    var\
    \ longestLength = Int64(0)\n    for s in strings {\n        guard let len = s.length\
    \ else { continue }\n        if len > longestLength {\n            longest = s\n\
    \            longestLength = len\n        }\n    }\n    return longest", '  return
    longestLongest(strings, 0).map(_.p0)', "    var maxLength = 0\n    var longest:\
    \ String?\n\n    for s in strings {\n        if s.count > maxLength {\n      \
    \      maxLength = s.count\n            longest = s\n        }\n    }\n    return\
    \ longest", "    let minSize = min(strings.map({ $0.count }))\n    var longest:\
    \ Int? = nil\n    for str in strings {\n        if str.count == minSize {\n  \
    \          if let lenStr = str.length {\n                if !longest || lenStr\
    \ < longest! {\n                    longest = lenStr\n                }\n    \
    \        }\n        }\n    }\n    return longest ?? \"\"", "    guard !strings.isEmpty\
    \ else {\n        return nil\n    }\n    return longest1(strings)", "  if strings.isEmpty\
    \ {\n    return nil\n  }\n\n  var longestString = strings[0]\n  for string in\
    \ strings {\n    if string.count == longestString.count {\n      continue\n  \
    \  }\n    if string.count > longestString.count {\n      longestString = string\n\
    \    }\n  }\n  return longestString", "    if strings.isEmpty { return nil }\n\
    \    var currentLongestLength = strings.first?.count ?? 0\n    for string in strings\
    \ {\n        if currentLongestLength > string.count {\n            currentLongestLength\
    \ = string.count\n        }\n    }\n    return strings.first?.prefix(currentLongestLength)",
  "    var longest = strings.first\n    for s in strings {\n        if s.count > longest!.count\
    \ {\n            longest = s\n        }\n    }\n    return longest", "    var\
    \ max: Int = 0\n    var longest: String = nil\n\n    for s in strings {\n    \
    \    guard let l = s.count else { return nil }\n        if l > max {\n       \
    \     max = l\n            longest = s\n        }\n    }\n\n    return longest",
  "    guard !strings.isEmpty else { return nil }\n    guard let first = strings.first\
    \ else { return nil }\n    guard !first.isEmpty else { return nil }\n    guard\
    \ strings.count >= 2 else { return first }\n\n    let longest = strings.max()\n\
    \    return longest", "    guard !strings.isEmpty else { return nil }\n    var\
    \ longest = strings[0]\n    for string in strings {\n        if longest.count\
    \ > string.count { longest = string }\n    }\n    return longest"]
stop_tokens:
- "\n}"
