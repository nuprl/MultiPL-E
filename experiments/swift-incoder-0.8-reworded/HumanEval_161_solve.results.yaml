language: swift
name: HumanEval_161_solve
results:
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : \n \
    \       s.characters.reduce(\"\") { \n            switch $0 {\n            case\
    \ \"a\":\n                \"\"\n            case \"b\":\n                \"b\"\
    \n            case \"c\":\n                \"c\"\n            case \"d\":\n  \
    \              \"d\"\n            case \"e\":\n                \"e\"\n       \
    \     case \"f\":\n                \"f\"\n            case \"g\":\n          \
    \      \"g\"\n            case \"h\":\n                \"h\"\n            case\
    \ \"i\":\n                \"i\"\n            case \"j\":\n                \"j\"\
    \n            case \"k\":\n                \"k\"\n            case \"l\":\n  \
    \              \"l\"\n            case \"m\":\n                \"m\"\n       \
    \     case \"n\":\n                \"n\"\n            case \"o\":\n          \
    \      \"o\"\n            case \"p\":\n                \"p\"\n            case\
    \ \"q\":\n                \"q\"\n            case \"r\":\n                \"r\"\
    \n            case \"s\":\n                \"s\"\n            case \"t\":\n  \
    \              \"t\"\n            case \"u\":\n                \"u\"\n       \
    \     case \"v\":\n                \"v\"\n            case \"w\":\n          \
    \      \"w\"\n            case \"x\":\n                \"x\"\n            case\
    \ \"y\":\n                \"y\"\n            case \"z\":\n                \"z\"\
    \n            case \"A\":\n                \"A\"\n            case \"B\":\n  \
    \              \"B\"\n            case \"C\":\n                \"C\"\n       \
    \     case \"D\":\n                \"D\"\n            case \"E\":\n          \
    \      \"E\"\n            case \"F\":\n                \"F\"\n            case\
    \ \"G\":\n                \"G\"\n            case \"H\":\n                \"H\"\
    \n            case \"I\":\n                \"I\"\n            case \"J\":\n  \
    \              \"J\"\n            case \"K\":\n                \"K\"\n       \
    \     case \"L\":\n                \"L\"\n            case \"M\":\n          \
    \      \"M\"\n            case \"N\":\n                \"N\"\n            case\
    \ \"O\":\n                \"O\"\n            case \"P\":\n                \"P\"\
    \n            case \"Q\":\n                \"Q\"\n            case \"R\":\n  \
    \              \"R\"\n            case \"S\":\n                \"S\"\n       \
    \     case \"T\":\n                \"T\"\n            case \"U\":\n          \
    \      \"U\"\n            case \"V\":\n                \"V\"\n            case\
    \ \"W\":\n                \"W\"\n            case \"X\":\n                \"X\"\
    \n            case \"Y\":\n                \"Y\"\n            case \"Z\":\n  \
    \              \"Z\"\n            default:\n                \"\"\n           \
    \ }\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp08u0_63_.swift:16:33: error: contextual closure type '(String,\
    \ String.Element) throws -> String' (aka '(String, Character) throws -> String')\
    \ expects 2 arguments, but 1 was used in closure body\n        s.characters.reduce(\"\
    \") { \n                                ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let regex = try? NSRegularExpression(pattern:\
    \ \"[a-z]+\", options: .caseInsensitive) else { return \"\" }\n    let range =\
    \ NSMakeRange(0, s.count)\n    let newS = regex.stringByReplacingMatches(in: s,\
    \ options: .regularExpression, range: range, withTemplate: \"\", replacement:\
    \ \"\")\n    return newS\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqlff7bih.swift:15:28: error: cannot find 'NSRegularExpression'\
    \ in scope\n    guard let regex = try? NSRegularExpression(pattern: \"[a-z]+\"\
    , options: .caseInsensitive) else { return \"\" }\n                          \
    \ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpqlff7bih.swift:15:77: error: cannot infer contextual\
    \ base in reference to member 'caseInsensitive'\n    guard let regex = try? NSRegularExpression(pattern:\
    \ \"[a-z]+\", options: .caseInsensitive) else { return \"\" }\n              \
    \                                                             ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpqlff7bih.swift:16:17: error: cannot find 'NSMakeRange' in scope\n    let\
    \ range = NSMakeRange(0, s.count)\n                ^~~~~~~~~~~\n/tmp/tmpqlff7bih.swift:17:64:\
    \ error: cannot infer contextual base in reference to member 'regularExpression'\n\
    \    let newS = regex.stringByReplacingMatches(in: s, options: .regularExpression,\
    \ range: range, withTemplate: \"\", replacement: \"\")\n                     \
    \                                         ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let chars = Array(s)\
    \ else {\n        return \"\"\n    }\n\n    var output = \"\"\n    for char in\
    \ chars {\n        guard let uppercase = Character(char).uppercased(), let lowercase\
    \ = Character(char).lowercased() else {\n            output = char\n         \
    \   break\n        }\n\n        if uppercase == lowercase {\n            output\
    \ = char\n        } else {\n            output = Character(char).capitalizedString\n\
    \        }\n    }\n\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp11tmckon.swift:15:11: error: initializer for conditional binding\
    \ must have Optional type, not 'Array<String.Element>' (aka 'Array<Character>')\n\
    \    guard let chars = Array(s) else {\n          ^           ~~~~~~~~\n/tmp/tmp11tmckon.swift:21:41:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      guard let uppercase = Character(char).uppercased(), let lowercase = Character(char).lowercased()\
    \ else {\n                                        ^\n                        \
    \                extendedGraphemeClusterLiteral: \n/tmp/tmp11tmckon.swift:21:87:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      guard let uppercase = Character(char).uppercased(), let lowercase = Character(char).lowercased()\
    \ else {\n                                                                   \
    \                   ^\n                                                      \
    \                                extendedGraphemeClusterLiteral: \n/tmp/tmp11tmckon.swift:22:22:\
    \ error: cannot assign value of type 'String.Element' (aka 'Character') to type\
    \ 'String'\n            output = char\n                     ^~~~\n/tmp/tmp11tmckon.swift:27:22:\
    \ error: cannot assign value of type 'String.Element' (aka 'Character') to type\
    \ 'String'\n            output = char\n                     ^~~~\n/tmp/tmp11tmckon.swift:29:32:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \          output = Character(char).capitalizedString\n                      \
    \         ^\n                               extendedGraphemeClusterLiteral: \n\
    /tmp/tmp11tmckon.swift:29:38: error: value of type 'Character' has no member 'capitalizedString'\n\
    \            output = Character(char).capitalizedString\n                    \
    \ ~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : s.lowercased()\
    \ + String(s.unicodeScalars.map {\n        Character($0) > (Character($0) ? Character($0)\
    \ : Character($0)).toUppercase()\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwiba1mef.swift:15:45: error: no exact matches in call to initializer\
    \ \n    return s.isEmpty ? s : s.lowercased() + String(s.unicodeScalars.map {\n\
    \                                            ^\n/tmp/tmpwiba1mef.swift:15:45:\
    \ note: found candidate with type '([Bool]) -> String'\n    return s.isEmpty ?\
    \ s : s.lowercased() + String(s.unicodeScalars.map {\n                       \
    \                     ^\n/tmp/tmpwiba1mef.swift:15:45: note: found candidate with\
    \ type '([Bool]) -> String'\n    return s.isEmpty ? s : s.lowercased() + String(s.unicodeScalars.map\
    \ {\n                                            ^\n/tmp/tmpwiba1mef.swift:15:45:\
    \ note: found candidate with type '([Bool]) -> String'\n    return s.isEmpty ?\
    \ s : s.lowercased() + String(s.unicodeScalars.map {\n                       \
    \                     ^\n/tmp/tmpwiba1mef.swift:16:26: error: cannot convert value\
    \ of type 'Character' to expected condition type 'Bool'\n        Character($0)\
    \ > (Character($0) ? Character($0) : Character($0)).toUppercase()\n          \
    \               ^~~~~~~~~~~~~\n/tmp/tmpwiba1mef.swift:16:73: error: value of type\
    \ 'Character' has no member 'toUppercase'\n        Character($0) > (Character($0)\
    \ ? Character($0) : Character($0)).toUppercase()\n                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let firstChar = s.first\
    \ else {\n        return s\n    }\n    \n    if let lower = firstChar.lowercased()\
    \ {\n        return s.replacingOccurrences(of: lower, with: upper)\n    }\n  \
    \  return s.replacingOccurrences(of: firstChar.uppercased(), with: firstChar)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm5hr1l1o.swift:20:56: error: cannot find 'upper' in scope\n   \
    \     return s.replacingOccurrences(of: lower, with: upper)\n                \
    \                                       ^~~~~\n/tmp/tmpm5hr1l1o.swift:20:18: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        return\
    \ s.replacingOccurrences(of: lower, with: upper)\n               ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm5hr1l1o.swift:19:8: error: initializer for conditional binding must have\
    \ Optional type, not 'String'\n    if let lower = firstChar.lowercased() {\n \
    \      ^           ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm5hr1l1o.swift:22:14: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    return s.replacingOccurrences(of:\
    \ firstChar.uppercased(), with: firstChar)\n           ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \\u{0061}\\u{0062}\\u{0063}\\u{0064}\".unicodeScalars)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpi3204a5k.swift:15:81: error: missing argument for parameter #2\
    \ in call\n    return s.characters.reduce(\"\\u{0061}\\u{0062}\\u{0063}\\u{0064}\"\
    .unicodeScalars)\n                                                           \
    \                     ^\n                                                    \
    \                            , <#(String.UnicodeScalarView, String.Element) throws\
    \ -> String.UnicodeScalarView#>\nSwift.Sequence:2:28: note: 'reduce' declared\
    \ here\n    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmpi3204a5k.swift:15:25: error: cannot convert\
    \ return expression of type 'String.UnicodeScalarView' to return type 'String'\n\
    \    return s.characters.reduce(\"\\u{0061}\\u{0062}\\u{0063}\\u{0064}\".unicodeScalars)\n\
    \           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ \"\"\n    }\n    var result = ''\n    var index = 0\n    for char in s {\n \
    \       let charValue = Character(char)\n        let charAsInt = Int(charValue)\n\
    \        if charAsInt > 64 {\n            let upperCaseChar = String(charValue,\
    \ radix: 16).uppercased()\n            let lowerCaseChar = String(charValue, radix:\
    \ 16).lowercased()\n            if charValue == lowerCaseChar{\n             \
    \   let charString = String(charAsInt - 64)\n                result.append(charString)\n\
    \                result.append(upperCaseChar)\n                index+=1\n    \
    \        }\n            else {\n                let charString = String(charAsInt\
    \ + 64)\n                result.append(charString)\n                result.append(lowerCaseChar)\n\
    \                index+=1\n            }\n        }\n        else {\n        \
    \    result.append(char)\n        }\n    }\n    if index < s.count {\n       \
    \ result = result.substring(to: index)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph0iqgw3o.swift:18:18: error: single-quoted string literal found,\
    \ use '\"'\n    var result = ''\n                 ^~\n                 \"\"\n\
    /tmp/tmph0iqgw3o.swift:21:25: error: no exact matches in call to initializer \n\
    \        let charValue = Character(char)\n                        ^\nSwift.Character:5:23:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(extendedGraphemeClusterLiteral:)')\n\
    \    @inlinable public init(extendedGraphemeClusterLiteral value: Character)\n\
    \                      ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(unicodeScalarLiteral:)')\n\
    \    public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)\n\
    \           ^\n/tmp/tmph0iqgw3o.swift:44:25: error: value of type 'String' has\
    \ no member 'substring'\n        result = result.substring(to: index)\n      \
    \           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var rString = s.characters.map\
    \ { c in\n        \n        var letter = \"\"\n        \n        if c >= 97 &&\
    \ c <= 122 {\n            letter = String.init(charactersIn: Array(s.characters)[s.index(s.startIndex,\
    \ offsetBy: c)])\n        } else if c >= 65 && c <= 90 {\n            letter =\
    \ String.init(charactersIn: Array(s.characters)[s.index(s.startIndex, offsetBy:\
    \ c) - 65])\n        }\n        return letter\n    }\n    return String(rString.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpn9xyt9nv.swift:19:12: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n        if c >= 97 && c <=\
    \ 122 {\n           ^\n/tmp/tmpn9xyt9nv.swift:19:23: error: cannot convert value\
    \ of type 'String.Element' (aka 'Character') to expected argument type 'Int'\n\
    \        if c >= 97 && c <= 122 {\n                      ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \") {\n        switch String($0) {\n        case \"a\" ... \"z\": \n         \
    \   return String($0).uppercased();\n        case \"A\" ... \"Z\": \n        \
    \    return String($0).lowercased();\n        default:\n            return String($0);\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5_egxfhk.swift:15:47: error: contextual closure type '(String,\
    \ String.Element) throws -> String' (aka '(String, Character) throws -> String')\
    \ expects 2 arguments, but 1 was used in closure body\n    return s.characters.reversed().reduce(\"\
    \") {\n                                              ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ char in s.unicodeScalars {\n        switch char {\n        case .isUpper:\n\
    \            result += String.init(capacity: char.unicodeScalars.count) + char.unicodeScalars.reversed()\n\
    \        case .isLower:\n            result += char.unicodeScalars.reversed()\n\
    \        default:\n            result += char.unicodeScalars\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwi7gd9af.swift:18:15: error: type 'Unicode.Scalar' has no member\
    \ 'isUpper'\n        case .isUpper:\n             ~^~~~~~~\n/tmp/tmpwi7gd9af.swift:20:15:\
    \ error: type 'Unicode.Scalar' has no member 'isLower'\n        case .isLower:\n\
    \             ~^~~~~~~\n/tmp/tmpwi7gd9af.swift:19:30: error: no exact matches\
    \ in call to initializer \n            result += String.init(capacity: char.unicodeScalars.count)\
    \ + char.unicodeScalars.reversed()\n                             ^\n/tmp/tmpwi7gd9af.swift:19:30:\
    \ note: found candidate with type '(Character) -> String'\n            result\
    \ += String.init(capacity: char.unicodeScalars.count) + char.unicodeScalars.reversed()\n\
    \                             ^\n/tmp/tmpwi7gd9af.swift:19:30: note: found candidate\
    \ with type '(Unicode.Scalar) -> String'\n            result += String.init(capacity:\
    \ char.unicodeScalars.count) + char.unicodeScalars.reversed()\n              \
    \               ^\n/tmp/tmpwi7gd9af.swift:19:30: note: found candidate with type\
    \ '(String.UnicodeScalarView) -> String'\n            result += String.init(capacity:\
    \ char.unicodeScalars.count) + char.unicodeScalars.reversed()\n              \
    \               ^\n/tmp/tmpwi7gd9af.swift:19:30: note: found candidate with type\
    \ '(String.UTF16View) -> String'\n            result += String.init(capacity:\
    \ char.unicodeScalars.count) + char.unicodeScalars.reversed()\n              \
    \               ^\n/tmp/tmpwi7gd9af.swift:19:30: note: found candidate with type\
    \ '(String.UTF8View) -> String'\n            result += String.init(capacity: char.unicodeScalars.count)\
    \ + char.unicodeScalars.reversed()\n                             ^\n/tmp/tmpwi7gd9af.swift:19:30:\
    \ note: found candidate with type '(__shared Substring) -> String'\n         \
    \   result += String.init(capacity: char.unicodeScalars.count) + char.unicodeScalars.reversed()\n\
    \                             ^\n/tmp/tmpwi7gd9af.swift:19:30: note: found candidate\
    \ with type '(Substring.UnicodeScalarView) -> String'\n            result += String.init(capacity:\
    \ char.unicodeScalars.count) + char.unicodeScalars.reversed()\n   "
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var ret: String = \"\"\n  \
    \  var i = s.startIndex\n    while i != s.endIndex {\n        switch s[i]{\n \
    \       case \"a\": ret += \"A\"; break\n        case \"b\": ret += \"b\"; break\n\
    \        case \"c\": ret += \"c\"; break\n        case \"d\": ret += \"D\"; break\n\
    \        case \"e\": ret += \"E\"; break\n        case \"f\": ret += \"F\"; break\n\
    \        case \"g\": ret += \"G\"; break\n        case \"h\": ret += \"h\"; break\n\
    \        case \"i\": ret += \"i\"; break\n        case \"j\": ret += \"J\"; break\n\
    \        case \"k\": ret += \"k\"; break\n        case \"l\": ret += \"L\"; break\n\
    \        case \"m\": ret += \"M\"; break\n        case \"n\": ret += \"N\"; break\n\
    \        case \"o\": ret += \"O\"; break\n        case \"p\": ret += \"p\"; break\n\
    \        case \"q\": ret += \"Q\"; break\n        case \"r\": ret += \"R\"; break\n\
    \        case \"s\": ret += \"s\"; break\n        case \"t\": ret += \"T\"; break\n\
    \        case \"u\": ret += \"u\"; break\n        case \"v\": ret += \"v\"; break\n\
    \        case \"w\": ret += \"W\"; break\n        case \"x\": ret += \"x\"; break\n\
    \        case \"y\": ret += \"y\"; break\n        case \"z\": ret += \"Z\"; break\n\
    \        case \"0\": ret += \"0\"; break\n        case \"1\": ret += \"1\"; break\n\
    \        case \"2\": ret += \"2\"; break\n        case \"3\": ret += \"3\"; break\n\
    \        case \"4\": ret += \"4\"; break\n        case \"5\": ret += \"5\"; break\n\
    \        case \"6\": ret += \"6\"; break\n        case \"7\": ret += \"7\"; break\n\
    \        case \"8\": ret += \"8\"; break\n        case \"9\": ret += \"9\"; break\n\
    \        default: break\n        }\n        i += 1\n    }\n    if ret == \"\"\
    \ {\n        ret = s\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bh3ljul.swift:57:11: error: binary operator '+=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n        i += 1\n        ~ ^  ~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n\n    var s = s\n    var r = \"\"\n    var l = s.count\n\n    for\
    \ _ in 0 ..< l {\n        if s[i] == s.lowercased() {\n            s = s.lowercased()\n\
    \        } else if s[i] == s.uppercased() {\n            s = s.uppercased()\n\
    \        } else {\n            r = r + s[i]\n        }\n    }\n\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp04jsmfqj.swift:24:14: error: cannot find 'i' in scope\n       \
    \ if s[i] == s.lowercased() {\n             ^\n/tmp/tmp04jsmfqj.swift:26:21: error:\
    \ cannot find 'i' in scope\n        } else if s[i] == s.uppercased() {\n     \
    \               ^\n/tmp/tmp04jsmfqj.swift:29:23: error: cannot find 'i' in scope\n\
    \            r = r + s[i]\n                      ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard !s.contains(\"#\") ==\
    \ false else {\n        let chars = s.characters.map {\n            switch $0\
    \ {\n            case \"A\" ... \"Z\":\n                return \"a\"\n       \
    \     case \"a\" ... \"z\":\n                return \"A\"\n            default:\n\
    \                return String($0)\n            }\n        }\n        return String(chars)\n\
    \    }\n    \n    let chars = s.characters.map {\n        switch $0 {\n      \
    \  case \"A\" ... \"Z\":\n            return \"a\"\n        case \"a\" ... \"\
    z\":\n            return \"A\"\n        default:\n            return String($0)\n\
    \        }\n    }\n    \n    return String(chars)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmlfvah1g.swift:16:23: error: 'characters' is unavailable: Please\
    \ use String directly\n        let chars = s.characters.map {\n              \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpmlfvah1g.swift:26:16:\
    \ error: no exact matches in call to initializer \n        return String(chars)\n\
    \               ^\nSwift.String:4:12: note: candidate requires that the types\
    \ 'String' and 'Character' be equivalent (requirement specified as 'S.Element'\
    \ == 'Character')\n    public init<S>(_ characters: S) where S : Sequence, S.Element\
    \ == Character\n           ^\nSwift.RangeReplaceableCollection:3:23: note: candidate\
    \ requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent\
    \ (requirement specified as 'Self.Element' == 'S.Element')\n    @inlinable public\
    \ init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element\n     \
    \                 ^\nSwift.String:2:12: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(describing:)')\n    public init<Subject>(describing instance:\
    \ Subject)\n           ^\nSwift.String:3:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(describing:)')\n    @inlinable public init<Subject>(describing\
    \ instance: Subject) where Subject : CustomStringConvertible\n               \
    \       ^\nSwift.String:6:12: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(reflecting:)')\n    public init<Subject>(reflecting subject: Subject)\n\
    \           ^\n/tmp/tmpmlfvah1g.swift:29:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    let chars = s.characters.map {\n           \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpmlfvah1g.swift:40:12:\
    \ error: no exact matches in call to initializer \n    return String(chars)\n\
    \           ^\nSwift.String:4:12: note: candidate requires that the types 'String'\
    \ and 'Character' be equivalent (requirement spe"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var chars = s.characters\n\
    \    var index = chars.startIndex\n    var finalString = \"\"\n    while index\
    \ != chars.endIndex {\n        if chars[index].isLetter {\n            var capitalized\
    \ = chars[index].uppercaseString\n            chars[index] = chars[index].lowercaseString\n\
    \            chars[index] = capitalized\n        } else {\n            chars[index]\
    \ = chars[index].lowercaseString\n        }\n        finalString += String(chars[index])\n\
    \        index++\n    }\n    return finalString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpq66y30b7.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpq66y30b7.swift:20:44:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   var capitalized = chars[index].uppercaseString\n                         \
    \     ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpq66y30b7.swift:21:18: error: cannot\
    \ assign through subscript: subscript is get-only\n            chars[index] =\
    \ chars[index].lowercaseString\n            ~~~~~^~~~~~~\n/tmp/tmpq66y30b7.swift:21:41:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   chars[index] = chars[index].lowercaseString\n                           ~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmpq66y30b7.swift:22:18: error: cannot assign through\
    \ subscript: subscript is get-only\n            chars[index] = capitalized\n \
    \           ~~~~~^~~~~~~\n/tmp/tmpq66y30b7.swift:24:18: error: cannot assign through\
    \ subscript: subscript is get-only\n            chars[index] = chars[index].lowercaseString\n\
    \            ~~~~~^~~~~~~\n/tmp/tmpq66y30b7.swift:24:41: error: value of type\
    \ 'Character' has no member 'lowercaseString'\n            chars[index] = chars[index].lowercaseString\n\
    \                           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpq66y30b7.swift:27:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var string = \"\"\n    for\
    \ c in s {\n        switch c {\n        case \"a\":\n            string += \"\
    A\"\n        case \"b\":\n            string += \"b\"\n        case \"c\":\n \
    \           string += \"C\"\n        case \"d\":\n            string += \"D\"\n\
    \        case \"e\":\n            string += \"E\"\n        case \"f\":\n     \
    \       string += \"F\"\n        case \"g\":\n            string += \"G\"\n  \
    \      case \"h\":\n            string += \"h\"\n        case \"i\":\n       \
    \     string += \"I\"\n        case \"j\":\n            string += \"j\"\n    \
    \    case \"k\":\n            string += \"K\"\n        case \"l\":\n         \
    \   string += \"L\"\n        case \"m\":\n            string += \"m\"\n      \
    \  case \"n\":\n            string += \"N\"\n        case \"o\":\n           \
    \ string += \"O\"\n        case \"p\":\n            string += \"P\"\n        case\
    \ \"q\":\n            string += \"Q\"\n        case \"r\":\n            string\
    \ += \"R\"\n        case \"s\":\n            string += \"S\"\n        case \"\
    t\":\n            string += \"T\"\n        case \"u\":\n            string +=\
    \ \"U\"\n        case \"v\":\n            string += \"V\"\n        case \"w\"\
    :\n            string += \"W\"\n        case \"x\":\n            string += \"\
    X\"\n        case \"y\":\n            string += \"Y\"\n        case \"z\":\n \
    \           string += \"Z\"\n        case \"1\":\n            string += \"1\"\n\
    \        case \"2\":\n            string += \"2\"\n        case \"3\":\n     \
    \       string += \"3\"\n        case \"4\":\n            string += \"4\"\n  \
    \      case \"5\":\n            string += \"5\"\n        case \"6\":\n       \
    \     string += \"6\"\n        case \"7\":\n            string += \"7\"\n    \
    \    case \"8\":\n            string += \"8\"\n        case \"9\":\n         \
    \   string += \"9\"\n        default:\n            string += String(c)\n     \
    \   }\n    }\n    if string.characters.count < string.characters.count {\n   \
    \     string = string.reversed()\n    }\n    return string\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgj1c1z__.swift:92:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count < string.characters.count\
    \ {\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgj1c1z__.swift:92:41: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count < string.characters.count\
    \ {\n                                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpgj1c1z__.swift:93:25: error: no 'reversed'\
    \ candidates produce the expected contextual result type 'String'\n        string\
    \ = string.reversed()\n                        ^\nSwift.Sequence:2:40: note: 'reversed()'\
    \ produces '[String.Element]' (aka 'Array<Character>'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> [Self.Element]\n\
    \                                       ^\nSwift.BidirectionalCollection:2:40:\
    \ note: 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var reversedString = \"\"\n\
    \n    for char in s.characters {\n        if char.lowercased() == char {\n   \
    \         reversedString += char.uppercased()\n        } else {\n            reversedString\
    \ += char\n        }\n    }\n\n    return reversedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bpw_t_v.swift:17:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6bpw_t_v.swift:18:30:\
    \ error: binary operator '==' cannot be applied to operands of type 'String' and\
    \ 'Character'\n        if char.lowercased() == char {\n           ~~~~~~~~~~~~~~~~~\
    \ ^  ~~~~\n/tmp/tmp6bpw_t_v.swift:18:30: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \        if char.lowercased() == char {\n                             ^\n/tmp/tmp6bpw_t_v.swift:21:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            reversedString += char\n                              ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var resultString = \"\"\n \
    \   for i in s.characters {\n        switch i.unicodeScalars.first!.value {\n\
    \        case 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\
    \ 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\
    \ 0x59, 0x5a, 0x61, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048,\
    \ 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052,\
    \ 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x0000, 0x01a0,\
    \ 0x01a2, 0x01a4, 0x01a6, 0x01a8, 0x01aa, 0x01b0, 0x01b2, 0x01b4, 0x01b6, 0x01b8,\
    \ 0x01ba, 0x01c0, 0x01c2, 0x01c4, 0x01c6, 0x01c8, 0x01ca, 0x01cc, 0x01ce, 0x01d0,\
    \ 0x01d2, 0x01d4, 0x01d6, 0x01d8, 0x01da, 0x01de, 0x01e0, 0x01e2, 0x01e4, 0x01e6,\
    \ 0x01e8, 0x01ea, 0x01f0, 0x01f2, 0x01f4, 0x01f6, 0x01f8, 0x01fa, 0x02c7, 0x02d8,\
    \ 0x02d9, 0x02db, 0x02c7, 0x02db, 0x02c7, 0x02d8, 0x02da, 0x02c7, 0x02d9, 0x02da,\
    \ 0x02da, 0x02c7, 0x02d9, 0x02d8, 0x02db, 0x02db, 0x02db, 0x02c7, 0x02da, 0x02d9,\
    \ 0x02db, 0x02da, 0x02db, 0x02da, 0x02db, 0x02d8, 0x02d8, 0x02d8, 0x02d8, 0x02db,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02db, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd5ix5fy7.swift:18:1260: error: expected ':' after 'case'\n    \
    \    case 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,\
    \ 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\
    \ 0x5a, 0x61, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048,\
    \ 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052,\
    \ 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x0000, 0x01a0,\
    \ 0x01a2, 0x01a4, 0x01a6, 0x01a8, 0x01aa, 0x01b0, 0x01b2, 0x01b4, 0x01b6, 0x01b8,\
    \ 0x01ba, 0x01c0, 0x01c2, 0x01c4, 0x01c6, 0x01c8, 0x01ca, 0x01cc, 0x01ce, 0x01d0,\
    \ 0x01d2, 0x01d4, 0x01d6, 0x01d8, 0x01da, 0x01de, 0x01e0, 0x01e2, 0x01e4, 0x01e6,\
    \ 0x01e8, 0x01ea, 0x01f0, 0x01f2, 0x01f4, 0x01f6, 0x01f8, 0x01fa, 0x02c7, 0x02d8,\
    \ 0x02d9, 0x02db, 0x02c7, 0x02db, 0x02c7, 0x02d8, 0x02da, 0x02c7, 0x02d9, 0x02da,\
    \ 0x02da, 0x02c7, 0x02d9, 0x02d8, 0x02db, 0x02db, 0x02db, 0x02c7, 0x02da, 0x02d9,\
    \ 0x02db, 0x02da, 0x02db, 0x02da, 0x02db, 0x02d8, 0x02d8, 0x02d8, 0x02d8, 0x02db,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02db, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02\n             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                          "
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var chars = s.characters\n\
    \    if chars.isEmpty{\n        return \"\"\n    }\n    if chars.count == 1 {\n\
    \        return chars[0]\n    }\n    var index = 0\n    var reversedIndex = 0\n\
    \    var reversedString = \"\"\n    guard chars.count > 1 else { return \"\" }\n\
    \    while index < chars.count {\n        let char = chars[index]\n        if\
    \ char == chars.first {\n            if chars[index] != chars.last {\n       \
    \         reversedString = String(chars.suffix(from: reversedIndex))\n       \
    \     }\n            reversedIndex += 1\n        } else if char == chars.last\
    \ {\n            reversedString += String(chars.prefix(from: reversedIndex))\n\
    \            reversedIndex -= 1\n        } else {\n            reversedString\
    \ += String(char.reversed())\n        }\n        index += 1\n    }\n    return\
    \ reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw56wmnlo.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw56wmnlo.swift:20:21:\
    \ error: cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return chars[0]\n               ~~~~~^~~\n/tmp/tmpw56wmnlo.swift:27:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = chars[index]\n             \
    \      ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpw56wmnlo.swift:29:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if chars[index] != chars.last {\n               ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpw56wmnlo.swift:30:60:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                reversedString = String(chars.suffix(from: reversedIndex))\n\
    \                                                           ^\n/tmp/tmpw56wmnlo.swift:34:44:\
    \ error: no exact matches in call to instance method 'prefix'\n            reversedString\
    \ += String(chars.prefix(from: reversedIndex))\n                             \
    \              ^\nSwift.Sequence:7:40: note: incorrect labels for candidate (have:\
    \ '(from:)', expected: '(_:)')\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> PrefixSequence<Self>\n                                  \
    \     ^\nSwift.Collection:6:40: note: incorrect labels for candidate (have: '(from:)',\
    \ expected: '(_:)')\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> Self.SubSequence\n                                       ^\n/tmp/tm"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .sorted()\n    \n    var newString = \"\"\n    \n    for i in 0..<s.characters.count\
    \ {\n        let character = s.characters[i]\n        var reversed = \"\"\n  \
    \      for index in 0..<alphabet.characters.count {\n            if alphabet[index].lowercased()\
    \ == character.lowercased() {\n                reversed = alphabet[index].uppercased()\
    \ + reversed\n            } else {\n                reversed = alphabet[index].lowercased()\
    \ + reversed\n            }\n        }\n        newString = \"\\(newString)\\\
    (reversed)\"\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp043z3fru.swift:19:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp043z3fru.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let character = s.characters[i]\n     \
    \                   ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp043z3fru.swift:20:27: error: 'characters'\
    \ is unavailable: Please use String directly\n        let character = s.characters[i]\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp043z3fru.swift:22:35: error: value of type '[String.Element]'\
    \ (aka 'Array<Character>') has no member 'characters'\n        for index in 0..<alphabet.characters.count\
    \ {\n                         ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.lowercased().reduce(\"\
    \") { (result, c) in\n        if let index = result.rangeOfString(c as! String),\
    \ index != nil {\n            \n            let prefix = result[(index!.startIndex!)..<index!.endIndex!]\n\
    \            let suffix = result[index!.endIndex!..<(index!.startIndex!)]\n  \
    \          \n            let newPrefix = prefix.map { String($0).capitalized }\n\
    \            let newSuffix = suffix.map { String($0).capitalized }\n         \
    \   \n            return String(format: \"%s%@\", newPrefix, newSuffix)\n    \
    \    }\n        \n        return result + String(format: \"%@\", c as! String)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_zt1u_7x.swift:16:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if let index = result.rangeOfString(c as! String),\
    \ index != nil {\n                       ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp_zt1u_7x.swift:16:47:\
    \ warning: cast from 'String.Element' (aka 'Character') to unrelated type 'String'\
    \ always fails\n        if let index = result.rangeOfString(c as! String), index\
    \ != nil {\n                                            ~ ^   ~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s == \"\" {\n        return\
    \ \"\"\n    }\n    var strList = s.characters\n    if s.characters.count <= 1\
    \ {\n        return \"\"\n    }\n    for str in strList {\n        if let charValue\
    \ = str.unicodeScalars.first {\n            let isLower: Bool\n            if\
    \ charValue < 0x00000070 {\n                isLower = true\n            } else\
    \ {\n                isLower = false\n            }\n            let isUpper =\
    \ charValue > 0x00000070 ? false : true\n            let result = String.init(unicodeScalars:\
    \ [(charValue - 0x00000030) * 0x10000 + (isLower ? 0x00000040 : 0x00000061)] as\
    \ [UInt8], count: 2)\n            if !result.isEmpty {\n                let resultString\
    \ = result.reversed\n                if resultString.characters.count > 0 {\n\
    \                    strList.removeAll(where: { char in resultString.contains(char)\
    \ })\n                }\n            }\n        }\n    }\n    return String(strList)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmphgi4k3s5.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    var strList = s.characters\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphgi4k3s5.swift:19:10:\
    \ error: 'characters' is unavailable: Please use String directly\n    if s.characters.count\
    \ <= 1 {\n         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphgi4k3s5.swift:25:26: error: referencing operator function '<' on\
    \ 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \            if charValue < 0x00000070 {\n                         ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n         \
    \ ^\n/tmp/tmphgi4k3s5.swift:30:37: error: referencing operator function '>' on\
    \ 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \            let isUpper = charValue > 0x00000070 ? false : true\n           \
    \                         ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'Unicode.Scalar'\n\
    extension BinaryInteger {\n          ^\n/tmp/tmphgi4k3s5.swift:31:33: error: no\
    \ exact matches in call to initializer \n            let result = String.init(unicodeScalars:\
    \ [(charValue - 0x00000030) * 0x10000 + (isLower ? 0x00000040 : 0x00000061)] as\
    \ [UInt8], count: 2)\n                                ^\n/tmp/tmphgi4k3s5.swift:31:33:\
    \ note: candidate has partially matching parameter list (repeating: String, count:\
    \ Int)\n            let result = String.init(unicodeScalars: [(charValue - 0x00000030)\
    \ * 0x10000 + (isLower ? 0x00000040 : 0x00000061)] as [UInt8], count: 2)\n   \
    \                             ^\n/tmp/tmphgi4k3s5.swift:31:33: note: candidate\
    \ has partially matching parameter list (repeating: Character, count: Int)\n \
    \           let result = String.init(unicodeScalars: [(charValue - 0x00000030)\
    \ * 0x10000 + (isLower ? 0x00000040 : 0x00000061)] as [UInt8], c"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // use some form of dictionary\
    \ lookup\n    let letterDict = [\"a\":\"A\", \"b\":\"B\", \"c\":\"C\", \"d\":\"\
    D\", \"e\":\"E\", \"f\":\"F\", \"g\":\"G\", \"h\":\"H\", \"i\":\"I\", \"j\":\"\
    J\", \"k\":\"K\", \"l\":\"L\", \"m\":\"M\", \"n\":\"N\", \"o\":\"O\", \"p\":\"\
    P\", \"q\":\"Q\", \"r\":\"R\", \"s\":\"S\", \"t\":\"T\", \"u\":\"U\", \"v\":\"\
    V\", \"w\":\"W\", \"x\":\"X\", \"y\":\"Y\", \"z\":\"Z\"]\n    var reverse = \"\
    \"\n\n    for c in s {\n        if letterDict[c] != nil {\n            reverse\
    \ += letterDict[c]!\n        } else {\n            reverse += c\n        }\n \
    \   }\n\n    return reverse\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpltui_m9f.swift:20:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if letterDict[c] != nil {\n    \
    \                  ^\n/tmp/tmpltui_m9f.swift:21:35: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            reverse\
    \ += letterDict[c]!\n                                  ^\n/tmp/tmpltui_m9f.swift:23:24:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            reverse += c\n                       ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.map({ Character($0).isUppercase\
    \ == false ? $0.lowercased() : $0.uppercased() }).reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd7grxihx.swift:15:30: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    return s.map({ Character($0).isUppercase == false ? $0.lowercased()\
    \ : $0.uppercased() }).reduce(\"\") { $0 + String($1) }\n                    \
    \         ^\n                             extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s == \"\" {\n        return\
    \ \"\"\n    }\n    if s[0].isUpper() {\n        return s.uppercased()\n    }\n\
    \    if s[0].isLower() {\n        return s.lowercased()\n    }\n    return s\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplke0e4dc.swift:18:13: error: value of type 'Character' has no member\
    \ 'isUpper'\n    if s[0].isUpper() {\n       ~~~~ ^~~~~~~\n/tmp/tmplke0e4dc.swift:21:13:\
    \ error: value of type 'Character' has no member 'isLower'\n    if s[0].isLower()\
    \ {\n       ~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce((acc,\
    \ c) -> String in\n        switch c {\n        case s.lowercased() -> acc\n  \
    \          .replacingOccurrences(of: s.lowercased(), with: s.uppercased())\n \
    \       case s.uppercased() -> acc\n            .replacingOccurrences(of: s.uppercased(),\
    \ with: s.lowercased())\n        case _ -> acc\n    }).reversed().reduce((acc,\
    \ c) -> c != s.lowercased() ? c : acc.append(c.capitalized()))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmps9p76ohy.swift:15:51: error: expected ',' separator\n    return\
    \ s.characters.reduce((acc, c) -> String in\n                                \
    \                  ^\n                                                 ,\n/tmp/tmps9p76ohy.swift:15:51:\
    \ error: expected expression in list of expressions\n    return s.characters.reduce((acc,\
    \ c) -> String in\n                                                  ^\n/tmp/tmps9p76ohy.swift:15:33:\
    \ error: cannot find 'acc' in scope\n    return s.characters.reduce((acc, c) ->\
    \ String in\n                                ^~~\n/tmp/tmps9p76ohy.swift:15:38:\
    \ error: cannot find 'c' in scope\n    return s.characters.reduce((acc, c) ->\
    \ String in\n                                     ^\n/tmp/tmps9p76ohy.swift:15:32:\
    \ error: expected type before '->'\n    return s.characters.reduce((acc, c) ->\
    \ String in\n                               ^\n/tmp/tmps9p76ohy.swift:22:27: error:\
    \ cannot find 'acc' in scope\n    }).reversed().reduce((acc, c) -> c != s.lowercased()\
    \ ? c : acc.append(c.capitalized()))\n                          ^~~\n/tmp/tmps9p76ohy.swift:22:32:\
    \ error: cannot find 'c' in scope\n    }).reversed().reduce((acc, c) -> c != s.lowercased()\
    \ ? c : acc.append(c.capitalized()))\n                               ^\n/tmp/tmps9p76ohy.swift:22:38:\
    \ error: cannot find 'c' in scope\n    }).reversed().reduce((acc, c) -> c != s.lowercased()\
    \ ? c : acc.append(c.capitalized()))\n                                     ^\n\
    /tmp/tmps9p76ohy.swift:22:60: error: cannot find 'c' in scope\n    }).reversed().reduce((acc,\
    \ c) -> c != s.lowercased() ? c : acc.append(c.capitalized()))\n             \
    \                                              ^\n/tmp/tmps9p76ohy.swift:22:64:\
    \ error: cannot find 'acc' in scope\n    }).reversed().reduce((acc, c) -> c !=\
    \ s.lowercased() ? c : acc.append(c.capitalized()))\n                        \
    \                                       ^~~\n/tmp/tmps9p76ohy.swift:22:75: error:\
    \ cannot find 'c' in scope\n    }).reversed().reduce((acc, c) -> c != s.lowercased()\
    \ ? c : acc.append(c.capitalized()))\n                                 "
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\treturn s.lowercased().map({ c\
    \ -> String in\n\t\tif c.isLetter {\n\t\t\tlet char = c.uppercased()\n\t\t\treturn\
    \ char\n\t\t} else {\n\t\t\treturn c\n\t\t}\n\t}).joinWithSeparator(\"\").reversed().joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpi963ha1s.swift:20:11: error: cannot convert return expression of\
    \ type 'String.Element' (aka 'Character') to return type 'String'\n          \
    \              return c\n                               ^\n/tmp/tmpi963ha1s.swift:22:5:\
    \ error: value of type '[String]' has no member 'joinWithSeparator'\n        }).joinWithSeparator(\"\
    \").reversed().joined()\n~~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result: String = \"\"\n\
    \    for i in s.characters {\n        switch i {\n        case let c as Character:\n\
    \            var upperCase = c\n            var lowerCase = c\n            if\
    \ c.isLowercase {\n                lowerCase = Character(c).uppercaseString\n\
    \            }\n            else {\n                upperCase = Character(c).lowercaseString\n\
    \            }\n            result = result + String(Character(upperCase) + Character(lowerCase))\n\
    \        default:\n            result = result + String(Character(i))\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcr_w8o1z.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcr_w8o1z.swift:18:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpcr_w8o1z.swift:22:39: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n                lowerCase = Character(c).uppercaseString\n        \
    \                              ^\n                                      extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpcr_w8o1z.swift:22:42: error: value of type 'Character' has no member\
    \ 'uppercaseString'\n                lowerCase = Character(c).uppercaseString\n\
    \                            ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpcr_w8o1z.swift:25:39:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \              upperCase = Character(c).lowercaseString\n                    \
    \                  ^\n                                      extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpcr_w8o1z.swift:25:42: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n                upperCase = Character(c).lowercaseString\n\
    \                            ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpcr_w8o1z.swift:27:48:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \          result = result + String(Character(upperCase) + Character(lowerCase))\n\
    \                                               ^\n                          \
    \                     extendedGraphemeClusterLiteral: \n/tmp/tmpcr_w8o1z.swift:27:59:\
    \ error: binary operator '+' cannot be applied to two 'Character' operands\n \
    \           result = result + String(Character(upperCase) + Character(lowerCase))\n\
    \                                                          ^\nSwift.FloatingPoint:1:17:\
    \ note: candidate requires that 'Character' conform to 'FloatingPoint' (requirement\
    \ specified as 'Self' : 'Floating"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : s.reversed().uppercased()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpofjmv2ni.swift:15:41: error: value of type 'ReversedCollection<String>'\
    \ has no member 'uppercased'\n    return s.isEmpty ? s : s.reversed().uppercased()\n\
    \                           ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    if let\
    \ startIndex = (s.startIndex.advanced(by: s.startIndex.distance(to: s.endIndex,\
    \ to: s.startIndex)) as Int) {\n        var char = s.characters.reversed()\n \
    \       char = char.suffixFrom(startIndex)\n        char = char.dropLast()\n \
    \       char = char.map { $0.isUppercase ? $0.lowercased() : $0 }\n        result\
    \ = String(char)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9ds7hkee.swift:16:39: error: value of type 'String.Index' has no\
    \ member 'advanced'\n    if let startIndex = (s.startIndex.advanced(by: s.startIndex.distance(to:\
    \ s.endIndex, to: s.startIndex)) as Int) {\n                         ~~~~~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmp9ds7hkee.swift:16:65: error: value of type 'String.Index'\
    \ has no member 'distance'\n    if let startIndex = (s.startIndex.advanced(by:\
    \ s.startIndex.distance(to: s.endIndex, to: s.startIndex)) as Int) {\n       \
    \                                            ~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp9ds7hkee.swift:17:22:\
    \ error: 'characters' is unavailable: Please use String directly\n        var\
    \ char = s.characters.reversed()\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9ds7hkee.swift:18:21: error: value of\
    \ type 'ReversedCollection<String>' has no member 'suffixFrom'\n        char =\
    \ char.suffixFrom(startIndex)\n               ~~~~ ^~~~~~~~~~\n/tmp/tmp9ds7hkee.swift:19:21:\
    \ error: no 'dropLast' candidates produce the expected contextual result type\
    \ 'ReversedCollection<String>'\n        char = char.dropLast()\n             \
    \       ^\nSwift.Collection:4:40: note: 'dropLast' produces 'Slice<ReversedCollection<String>>',\
    \ not the expected contextual result type 'ReversedCollection<String>'\n    @inlinable\
    \ public __consuming func dropLast(_ k: Int = 1) -> Self.SubSequence\n       \
    \                                ^\nSwift.Sequence:5:40: note: 'dropLast' produces\
    \ '[ReversedCollection<String>.Element]' (aka 'Array<Character>'), not the expected\
    \ contextual result type 'ReversedCollection<String>'\n    @inlinable public __consuming\
    \ func dropLast(_ k: Int = 1) -> [Self.Element]\n                            \
    \           ^\n/tmp/tmp9ds7hkee.swift:20:21: error: cannot assign value of type\
    \ '[ReversedCollection<String>.Element]' (aka 'Array<Character>') to type 'ReversedCollection<String>'\n\
    \        char = char.map { $0.isUppercase ? $0.lowercased() : $0 }\n         \
    \      ~~~~~^~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var s = s\n    for i in s.characters\
    \ {\n        switch i.unicodeScalars.first!.value {\n        case UnicodeScalar(lowercase\
    \ | Uppercase):\n            s.append(i.unicodeScalars.first!.value)\n       \
    \ case UnicodeScalar(lowercase | Lowercase):\n            s.append(i.unicodeScalars.first!.value)\n\
    \        case UnicodeScalar(uppercase | Uppercase):\n            s.append(i.unicodeScalars.first!.value)\n\
    \        case UnicodeScalar(uppercase | Lowercase):\n            s.append(i.unicodeScalars.first!.value)\n\
    \        default:\n            s.append(i)\n        }\n    }\n    return s.reverse()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp38x8k4il.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp38x8k4il.swift:18:28:\
    \ error: cannot find 'lowercase' in scope\n        case UnicodeScalar(lowercase\
    \ | Uppercase):\n                           ^~~~~~~~~\n/tmp/tmp38x8k4il.swift:18:40:\
    \ error: cannot find 'Uppercase' in scope\n        case UnicodeScalar(lowercase\
    \ | Uppercase):\n                                       ^~~~~~~~~\n/tmp/tmp38x8k4il.swift:18:14:\
    \ error: expression pattern of type 'UnicodeScalar' (aka 'Unicode.Scalar') cannot\
    \ match values of type 'UInt32'\n        case UnicodeScalar(lowercase | Uppercase):\n\
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp38x8k4il.swift:20:28:\
    \ error: cannot find 'lowercase' in scope\n        case UnicodeScalar(lowercase\
    \ | Lowercase):\n                           ^~~~~~~~~\n/tmp/tmp38x8k4il.swift:20:40:\
    \ error: cannot find 'Lowercase' in scope\n        case UnicodeScalar(lowercase\
    \ | Lowercase):\n                                       ^~~~~~~~~\n/tmp/tmp38x8k4il.swift:20:14:\
    \ error: expression pattern of type 'UnicodeScalar' (aka 'Unicode.Scalar') cannot\
    \ match values of type 'UInt32'\n        case UnicodeScalar(lowercase | Lowercase):\n\
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp38x8k4il.swift:22:28:\
    \ error: cannot find 'uppercase' in scope\n        case UnicodeScalar(uppercase\
    \ | Uppercase):\n                           ^~~~~~~~~\n/tmp/tmp38x8k4il.swift:22:40:\
    \ error: cannot find 'Uppercase' in scope\n        case UnicodeScalar(uppercase\
    \ | Uppercase):\n                                       ^~~~~~~~~\n/tmp/tmp38x8k4il.swift:22:14:\
    \ error: expression pattern of type 'UnicodeScalar' (aka 'Unicode.Scalar') cannot\
    \ match values of type 'UInt32'\n        case UnicodeScalar(uppercase | Uppercase):\n\
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp38x8k4il.swift:24:28:\
    \ error: cannot find 'uppercase' in sc"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters[s.characters.startIndex.map\
    \ { charIndx -> String in\n        let charCode = s.characters[charIndx]\n   \
    \     \n        switch charCode {\n        case \"a\":\n            return \"\
    A\"\n        case \"b\":\n            return \"B\"\n        case \"c\":\n    \
    \        return \"C\"\n        case \"d\":\n            return \"D\"\n       \
    \ case \"e\":\n            return \"E\"\n        case \"f\":\n            return\
    \ \"F\"\n        case \"g\":\n            return \"G\"\n        case \"h\":\n\
    \            return \"H\"\n        case \"i\":\n            return \"I\"\n   \
    \     case \"j\":\n            return \"J\"\n        case \"k\":\n           \
    \ return \"K\"\n        case \"l\":\n            return \"L\"\n        case \"\
    m\":\n            return \"M\"\n        case \"n\":\n            return \"N\"\n\
    \        case \"o\":\n            return \"O\"\n        case \"p\":\n        \
    \    return \"P\"\n        case \"q\":\n            return \"Q\"\n        case\
    \ \"r\":\n            return \"R\"\n        case \"s\":\n            return \"\
    S\"\n        case \"t\":\n            return \"T\"\n        case \"u\":\n    \
    \        return \"U\"\n        case \"v\":\n            return \"V\"\n       \
    \ case \"w\":\n            return \"W\"\n        case \"x\":\n            return\
    \ \"X\"\n        case \"y\":\n            return \"Y\"\n        case \"z\":\n\
    \            return \"Z\"\n        default:\n            return \"\"\n       \
    \ }\n    }.map { $0.reversed().joined(separator: \"\") }.reversed()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkrs7468t.swift:75:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpkrs7468t.swift:15:24: note: to match this opening '['\n    return s.characters[s.characters.startIndex.map\
    \ { charIndx -> String in\n                       ^\n/tmp/tmpkrs7468t.swift:15:49:\
    \ error: value of type 'String.Index' has no member 'map'\n    return s.characters[s.characters.startIndex.map\
    \ { charIndx -> String in\n                        ~~~~~~~~~~~~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \") { result, char in\n        if case let .letter(l) = char {\n            if\
    \ let i = Int(String(l).uppercaseString.utf8) {\n                let c = String(UnicodeScalar(i))\n\
    \                return result + c\n            } else {\n                return\
    \ result + String(l)\n            }\n        } else {\n            return result\
    \ + String(char)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpap9x250p.swift:16:22: error: type 'String.Element' (aka 'Character')\
    \ has no member 'letter'\n        if case let .letter(l) = char {\n          \
    \          ~^~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\treturn s.reversed().filter{$0.isLetter}.joinWithSeparator(\"\
    \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9gh8knw7.swift:15:42: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'joinWithSeparator'\n        return s.reversed().filter{$0.isLetter}.joinWithSeparator(\"\
    \")\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let firstChar = s.first\
    \ else {\n        return s\n    }\n    let s = s[1...].lowercased()\n    return\
    \ firstChar.isLetter ? s.reversed().append(firstChar) : s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpidxslioo.swift:18:13: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \    let s = s[1...].lowercased()\n            ^~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpidxslioo.swift:19:46: error: no exact matches in call to instance method\
    \ 'append'\n    return firstChar.isLetter ? s.reversed().append(firstChar) : s\n\
    \                                             ^\n/tmp/tmpidxslioo.swift:19:46:\
    \ note: found candidate with type '(__owned String.Element) -> ()' (aka '(__owned\
    \ Character) -> ()')\n    return firstChar.isLetter ? s.reversed().append(firstChar)\
    \ : s\n                                             ^\n/tmp/tmpidxslioo.swift:19:31:\
    \ error: cannot convert return expression of type '()' to return type 'String'\n\
    \    return firstChar.isLetter ? s.reversed().append(firstChar) : s\n        \
    \   ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let stringArr = s.characters.split(separator:\
    \ \"\")\n    guard stringArr.count > 0 else { return s }\n    var resultString\
    \ = stringArr.joinWithSeparator(\"\")\n    var count = 1\n    var currentLetter\
    \ = \"\"\n    for char in stringArr {\n        if char.isLetter {\n          \
    \  currentLetter = char\n        } else {\n            count = count - 1\n   \
    \     }\n        if count < 0 {\n            resultString = resultString.replacingOccurrences(of:\
    \ currentLetter, with: char)\n            count = 1\n        }\n    }\n    return\
    \ resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkm33g87v.swift:15:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stringArr = s.characters.split(separator: \"\"\
    )\n                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpkm33g87v.swift:17:34: error: value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') has no member 'joinWithSeparator'\n    var resultString\
    \ = stringArr.joinWithSeparator(\"\")\n                       ~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkm33g87v.swift:21:17: error: value of type 'String.SubSequence' (aka 'Substring')\
    \ has no member 'isLetter'\n        if char.isLetter {\n           ~~~~ ^~~~~~~~\n\
    /tmp/tmpkm33g87v.swift:22:29: error: cannot assign value of type 'String.SubSequence'\
    \ (aka 'Substring') to type 'String'\n            currentLetter = char\n     \
    \                       ^~~~\n                            String( )\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result: String = s\n  \
    \  for char in s.characters {\n        let index = result.index(of: char)\n  \
    \      if let index = index {\n            if String(result[index]).lowercased()\
    \ == String(char).lowercased() {\n                result[index] = String(char).uppercased()\n\
    \            } else {\n                result[index] = String(char).lowercased()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3do3fwdz.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3do3fwdz.swift:17:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: char)\n                           ^\n/tmp/tmp3do3fwdz.swift:17:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: char)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmp3do3fwdz.swift:20:23:\
    \ error: cannot assign through subscript: subscript is get-only\n            \
    \    result[index] = String(char).uppercased()\n                ~~~~~~^~~~~~~\n\
    /tmp/tmp3do3fwdz.swift:20:46: error: cannot assign value of type 'String' to subscript\
    \ of type 'Character'\n                result[index] = String(char).uppercased()\n\
    \                                ~~~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp3do3fwdz.swift:22:23:\
    \ error: cannot assign through subscript: subscript is get-only\n            \
    \    result[index] = String(char).lowercased()\n                ~~~~~~^~~~~~~\n\
    /tmp/tmp3do3fwdz.swift:22:46: error: cannot assign value of type 'String' to subscript\
    \ of type 'Character'\n                result[index] = String(char).lowercased()\n\
    \                                ~~~~~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // use regular expression to\
    \ replace the character\n    // with its case reversed version or its original\
    \ version\n    // if it has no letter after replacing its case\n    // else return\
    \ the original string\n\n    // use regex to find the letter at the end of the\
    \ string\n    // if found, use regex to find whether the string's case\n    //\
    \ is upper or lower than that of the letter found at the end\n\n    return stringReversing(s)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ilieopv.swift:24:12: error: cannot find 'stringReversing' in scope\n\
    \    return stringReversing(s)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    str.forEach\
    \ { str in\n        if let c = str.character(at: 0) {\n            str = str.replacingOccurrences(of:\
    \ c, with: String.Uppercase)\n        } else if let c = str.character(at: 1) {\n\
    \            str = str.replacingOccurrences(of: c, with: String.Lowercase)\n \
    \       } else {\n            str = str\n        }\n    }\n    return str\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz0vnllzq.swift:17:24: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'character'\n        if let c = str.character(at:\
    \ 0) {\n                   ~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.isEmpty == false else\
    \ {\n        return s\n    }\n\n    var ret = \"\"\n    var lower = false\n  \
    \  for char in s {\n        guard let charValue = char.asciiValue else {\n   \
    \         print(\"Can't convert to ASCII\")\n            return s\n        }\n\
    \n        if charValue >= 97 && charValue <= 122 {\n            guard lower ==\
    \ false else {\n                ret += charValue\n                continue\n \
    \           }\n            lower = true\n        } else {\n            if lower\
    \ == false {\n                ret += charValue\n                continue\n   \
    \         }\n            guard let charVal = char.uppercased().asciiValue else\
    \ {\n                print(\"Can't convert to ASCII\")\n                return\
    \ s\n            }\n            if charVal >= 97 && charVal <= 122 {\n       \
    \         ret += charVal\n            } else {\n                ret += char\n\
    \            }\n            lower = false\n        }\n    }\n    return ret\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkr4kp2nb.swift:29:24: error: cannot convert value of type 'UInt8'\
    \ to expected argument type 'String'\n                ret += charValue\n     \
    \                  ^\n/tmp/tmpkr4kp2nb.swift:35:24: error: cannot convert value\
    \ of type 'UInt8' to expected argument type 'String'\n                ret += charValue\n\
    \                       ^\n/tmp/tmpkr4kp2nb.swift:38:51: error: value of type\
    \ 'String' has no member 'asciiValue'\n            guard let charVal = char.uppercased().asciiValue\
    \ else {\n                                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpkr4kp2nb.swift:45:24:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                ret += char\n                       ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ character in s.characters {\n        if let character = character as? String\
    \ {\n            result = character.characters.map { char -> String in\n     \
    \           let lower = [String(char).lowercased()]\n                let upper\
    \ = [String(char).uppercased()]\n                \n                if let lower\
    \ = lower,\n                   let upper = upper,\n                   lower.count\
    \ == 1 && upper.count == 1 {\n                    return upper + lower\n     \
    \           } else {\n                    return char\n                }\n   \
    \         }.joined()\n        }\n    }\n    if result.characters.count == 0 {\n\
    \        result = \"#\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpigswjen_.swift:16:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in s.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpigswjen_.swift:17:38:\
    \ warning: cast from 'Character' to unrelated type 'String' always fails\n   \
    \     if let character = character as? String {\n                           ~~~~~~~~~\
    \ ^   ~~~~~~\n/tmp/tmpigswjen_.swift:25:34: error: cannot convert return expression\
    \ of type 'Array<String>' to return type 'String'\n                    return\
    \ upper + lower\n                           ~~~~~~^~~~~~~\n/tmp/tmpigswjen_.swift:32:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    if result.characters.count\
    \ == 0 {\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var resultString = \"\"\n \
    \   for index in stride(from: 0, through: s.count, by: 1) {\n        let charVal\
    \ = s.characters[index]\n        if let charVal = charVal {\n            if charVal\
    \ >= 48 && charVal <= 57 {\n                let newCharVal = charVal - 48;\n \
    \               resultString += String(newCharVal)\n            } else {\n   \
    \             resultString += String(charVal)\n            }\n        } else {\n\
    \            if let charVal = Int(s) {\n                resultString += String(charVal\
    \ - 48)\n            } else {\n                resultString += \"0\"\n       \
    \     }\n        }\n    }\n    return resultString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzmenm68o.swift:17:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let charVal\
    \ = s.characters[index]\n                      ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpzmenm68o.swift:17:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ charVal = s.characters[index]\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzmenm68o.swift:19:16: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            if charVal\
    \ >= 48 && charVal <= 57 {\n               ^\n/tmp/tmpzmenm68o.swift:19:33: error:\
    \ cannot convert value of type 'Character' to expected argument type 'Int'\n \
    \           if charVal >= 48 && charVal <= 57 {\n                            \
    \    ^\n/tmp/tmpzmenm68o.swift:20:34: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n                let newCharVal = charVal -\
    \ 48;\n                                 ^\n/tmp/tmpzmenm68o.swift:18:12: error:\
    \ initializer for conditional binding must have Optional type, not 'Character'\n\
    \        if let charVal = charVal {\n           ^             ~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \") { result, character in\n        if character == \"a\" {\n            if result\
    \ != \"\" {\n                result.append(\"@\")\n            }\n           \
    \ result.append(character)\n        } else if character == \"A\" {\n         \
    \   if result != \"\" {\n                result.append(\"#\")\n            }\n\
    \            result.append(character)\n        } else if character == \"#\" {\n\
    \            if result != \"\" {\n                result.append(\"A\")\n     \
    \       }\n            result.append(character)\n        } else if character ==\
    \ \"@\" {\n            if result != \"\" {\n                result.append(\"a\"\
    )\n            }\n            result.append(character)\n        } else {\n   \
    \         result.append(character)\n        }\n        return result\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmprn_82dqe.swift:18:24: error: cannot use mutating member on immutable\
    \ value: 'result' is a 'let' constant\n                result.append(\"@\")\n\
    \                ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty  {return s}\n\
    \    let rev = s.characters.reversed().map(String.init).joined()\n    return rev.isEmpty?\
    \ rev : \"#\"+rev\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8_ju61i.swift:17:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return rev.isEmpty? rev : \"#\"+rev\n             \
    \          ^\n                       ;\n/tmp/tmpk8_ju61i.swift:17:28: error: consecutive\
    \ statements on a line must be separated by ';'\n    return rev.isEmpty? rev :\
    \ \"#\"+rev\n                           ^\n                           ;\n/tmp/tmpk8_ju61i.swift:17:29:\
    \ error: expected expression\n    return rev.isEmpty? rev : \"#\"+rev\n      \
    \                      ^\n/tmp/tmpk8_ju61i.swift:16:17: error: 'characters' is\
    \ unavailable: Please use String directly\n    let rev = s.characters.reversed().map(String.init).joined()\n\
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpk8_ju61i.swift:17:23: error: cannot convert return expression of\
    \ type 'Bool?' to return type 'String'\n    return rev.isEmpty? rev : \"#\"+rev\n\
    \           ~~~~~~~~~~~^\n/tmp/tmpk8_ju61i.swift:17:25: warning: expression of\
    \ type 'String' is unused\n    return rev.isEmpty? rev : \"#\"+rev\n         \
    \               ^~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let chars = s.characters,\
    \ chars.count > 0 else {\n        return s\n    }\n    var newChars = [Character]()\n\
    \    var currentIndex = 0\n    while currentIndex < chars.count {\n        var\
    \ isLastLetter = false\n        var isNextLetter = false\n        for _ in 0..<chars.count\
    \ {\n            let char = chars[currentIndex]\n            if char == Character.lowercaseLetter\
    \ {\n                isLastLetter = true\n                newChars.append(Character(char.uppercaseString))\n\
    \            } else if char == Character.uppercaseLetter {\n                isNextLetter\
    \ = true\n                newChars.append(Character(char.lowercaseString))\n \
    \           } else if char == Character.numberChar {\n                newChars.append(Character(char.uppercaseString))\n\
    \            } else if char == Character.symbolChar {\n                newChars.append(Character(char.lowercaseString))\n\
    \            } else {\n                newChars.append(char)\n            }\n\
    \            currentIndex += 1\n        }\n        if isLastLetter {\n       \
    \     if isNextLetter {\n                currentIndex -= 1\n            } else\
    \ {\n                currentIndex -= 1\n                currentIndex -= 1\n  \
    \          }\n        } else {\n            currentIndex += 1\n        }\n   \
    \ }\n    return String(newChars)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ahlp4y0.swift:15:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let chars = s.characters, chars.count > 0 else\
    \ {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_ahlp4y0.swift:15:11: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    guard let chars = s.characters,\
    \ chars.count > 0 else {\n          ^           ~~~~~~~~~~~~\n/tmp/tmp_ahlp4y0.swift:24:24:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            let char = chars[currentIndex]\n  \
    \                     ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_ahlp4y0.swift:25:34: error: type 'Character'\
    \ has no member 'lowercaseLetter'\n            if char == Character.lowercaseLetter\
    \ {\n                       ~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp_ahlp4y0.swift:27:48:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \       newChars.append(Character(char.uppercaseString))\n                   \
    \                       ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp_ahlp4y0.swift:28:41: error:\
    \ type 'Character' has no member 'uppercaseLetter'\n            } else if char\
    \ == Character.uppercaseLetter {\n                              ~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp_ahlp4y0.swift:30:48: error: value of type 'Character' has no member 'lowercaseString'\n\
    \                newChars.append(Character(char.lowercaseString))\n          \
    \                                ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp_ahlp4y0.swift:31:41:\
    \ error: type 'Character' has no member 'numberChar'\n            } else if char\
    \ == Character.numberChar {\n                              ~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp_ahlp4y0.swift:32:48: error: value of type 'Character' has no member 'uppercaseString'\n\
    \                newChars.append(Character(char.u"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let chars = s.characters\
    \ else { return \"\" }\n    \n    return String(chars.reversed())\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwzrem4fj.swift:15:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let chars = s.characters else { return \"\" }\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpwzrem4fj.swift:15:11: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    guard let chars = s.characters\
    \ else { return \"\" }\n          ^           ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\treturn s.reversed().map({Character($0).uppercased}).joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwa_e15ru.swift:15:37: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        return s.reversed().map({Character($0).uppercased}).joined()\n\
    \                                           ^\n                              \
    \             extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce(\"$0\") { $1\
    \ + \"$1\" }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp7qzx28k3.swift:15:29: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n    return s.reduce(\"\
    $0\") { $1 + \"$1\" }\n                            ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters\n     \
    \   .flatMap { c in \n            c != c.toLowercase() ? c..toUppercase() : c\n\
    \        }\n        .joinWithSeparator(\"\")\n        .reversed()\n        .joinWithSeparator(\"\
    \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3x1ckdbn.swift:17:37: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n            c != c.toLowercase() ? c..toUppercase() : c\n\
    \                                    ^~\n                                    ...\n\
    /tmp/tmp3x1ckdbn.swift:17:39: error: cannot find 'toUppercase' in scope\n    \
    \        c != c.toLowercase() ? c..toUppercase() : c\n                       \
    \               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reverse().map{\
    \ String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmps57pp92s.swift:15:25: error: value of type 'String' has no member\
    \ 'reverse'\n    return s.characters.reverse().map{ String($0) }.joined()\n  \
    \         ~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : s.chars().map({\
    \ c in\n        switch c {\n        case 'A': if c.isUpper() { return c } else\
    \ { return c.lowercased() }\n        case 'a': if c.isLower() { return c } else\
    \ { return c.uppercased() }\n        case '#': return c.lowercased()\n       \
    \ default: return c\n        }\n    }).joinWithSeparator(\"\").reversed()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpn7_rpocw.swift:17:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A': if c.isUpper() { return c } else { return c.lowercased()\
    \ }\n             ^~~\n             \"A\"\n/tmp/tmpn7_rpocw.swift:18:14: error:\
    \ single-quoted string literal found, use '\"'\n        case 'a': if c.isLower()\
    \ { return c } else { return c.uppercased() }\n             ^~~\n            \
    \ \"a\"\n/tmp/tmpn7_rpocw.swift:19:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '#': return c.lowercased()\n             ^~~\n      \
    \       \"#\"\n/tmp/tmpn7_rpocw.swift:15:30: error: value of type 'String' has\
    \ no member 'chars'\n    return s.isEmpty ? s : s.chars().map({ c in\n       \
    \                    ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newString = \"\"\n    for\
    \ s in s {\n        if s.isLetter() {\n            newString = s.lowercased()\
    \ + newString.lowercased()\n        } else if s.isUpper() {\n            newString\
    \ = s.uppercased() + newString.uppercased()\n        } else {\n            newString\
    \ = s + newString\n        }\n    }\n    return newString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2xvznqw4.swift:17:14: error: cannot call value of non-function\
    \ type 'Bool'\n        if s.isLetter() {\n             ^       ~~\n          \
    \           \n/tmp/tmp2xvznqw4.swift:19:21: error: value of type 'Character' has\
    \ no member 'isUpper'\n        } else if s.isUpper() {\n                  ~ ^~~~~~~\n\
    /tmp/tmp2xvznqw4.swift:22:25: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            newString = s + newString\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    \n    var newString = \"\"\n    let chars = s.characters\n   \
    \ for char in chars {\n        guard let letter = String(UnicodeScalar(UInt32(char)))\
    \ else { continue }\n        let isUpper = letter == String(UnicodeScalar(UInt32(\"\
    A\")))\n        let isLower = letter == String(UnicodeScalar(UInt32(\"a\")))\n\
    \        \n        switch isUpper {\n        case true:\n            newString\
    \ += String(UnicodeScalar(UInt32(\"A\")))\n        case false:\n            newString\
    \ += String(UnicodeScalar(UInt32(\"a\")))\n        }\n        \n        switch\
    \ isLower {\n        case true:\n            newString += String(UnicodeScalar(UInt32(\"\
    a\")))\n        case false:\n            newString += String(UnicodeScalar(UInt32(\"\
    A\")))\n        }\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpne8z69_r.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpne8z69_r.swift:22:49:\
    \ error: no exact matches in call to initializer \n        guard let letter =\
    \ String(UnicodeScalar(UInt32(char))) else { continue }\n                    \
    \                            ^\n/tmp/tmpne8z69_r.swift:22:49: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n       \
    \ guard let letter = String(UnicodeScalar(UInt32(char))) else { continue }\n \
    \                                               ^\n/tmp/tmpne8z69_r.swift:22:49:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \        guard let letter = String(UnicodeScalar(UInt32(char))) else { continue\
    \ }\n                                                ^\n/tmp/tmpne8z69_r.swift:22:49:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \        guard let letter = String(UnicodeScalar(UInt32(char))) else { continue\
    \ }\n                                                ^\n/tmp/tmpne8z69_r.swift:22:49:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \        guard let letter = String(UnicodeScalar(UInt32(char))) else { continue\
    \ }\n                                                ^\n/tmp/tmpne8z69_r.swift:22:49:\
    \ note: candidate expects value of type 'Builtin.Int32' for parameter #1 (got\
    \ 'Character')\n        guard let letter = String(UnicodeScalar(UInt32(char)))\
    \ else { continue }\n                                                ^\n/tmp/tmpne8z69_r.swift:22:49:\
    \ note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got\
    \ 'Character')\n        guard let letter = String(UnicodeScalar(UInt32(char)))\
    \ else { continue }\n                                                ^\n/tmp/tmpne8z69_r.swift:22:35:\
    \ error: value of optional type 'UnicodeScalar?' (aka 'Opt"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().compactMap\
    \ { String($0) }\n        .map { Character($0).isUppercase ? String($0).lowercased()\
    \ : String($0) }\n        .reduce(\"A\" + s)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5ec584st.swift:17:24: error: missing argument for parameter #2\
    \ in call\n        .reduce(\"A\" + s)\n                       ^\n            \
    \           , <#(String, String) throws -> String#>\nSwift.Sequence:2:28: note:\
    \ 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n"
  stdout: ''
  timestamp: 1659979406
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s == \"\" {\n        return\
    \ \"\"\n    }\n    var result = \"\"\n    for i in s.characters.reversed() {\n\
    \        if i.isLetter {\n            let x = i.lowercased()\n            var\
    \ y = x\n            if i.lowercased() != i {\n                y = i.uppercased()\n\
    \            }\n            result += y\n        } else {\n            result\
    \ += i\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd0hlhbpr.swift:19:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters.reversed() {\n              \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpd0hlhbpr.swift:23:34:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n            if i.lowercased() != i {\n             \
    \                    ^\n/tmp/tmpd0hlhbpr.swift:28:23: error: cannot convert value\
    \ of type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \            result += i\n                      ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let s = String(s.characters.reversed())\n\
    \    else {\n        return \"\"\n    }\n    return s.characters.reduce(\"\")\
    \ { $0 + String($1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb8yrcq74.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let s = String(s.characters.reversed())\n   \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpb8yrcq74.swift:15:11: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    guard let s = String(s.characters.reversed())\n\
    \          ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb8yrcq74.swift:19:14:\
    \ error: 'characters' is unavailable: Please use String directly\n    return s.characters.reduce(\"\
    \") { $0 + String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var reversed = \"\"\n    for\
    \ s in s.characters {\n        switch s {\n        case s.isLetter:\n        \
    \    reversed = s.lowercaseString + reversed\n        default:\n            reversed\
    \ = s + reversed\n        }\n    }\n    return reversed\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp819ezyov.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp819ezyov.swift:18:16:\
    \ error: expression pattern of type 'Bool' cannot match values of type 'Character'\n\
    \        case s.isLetter:\n             ~~^~~~~~~~\n/tmp/tmp819ezyov.swift:19:26:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   reversed = s.lowercaseString + reversed\n                       ~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp819ezyov.swift:21:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            reversed = s + reversed\n  \
    \                     ^\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var resultingString = \"\"\n\
    \    for i in s.characters {\n        switch i {\n        case let character as\
    \ Character:\n            switch character {\n            case let lowerLetter\
    \ as Character:\n                let upperLetter = Character(\"A\") + (lowerLetter\
    \ - Character.lowercase)\n                resultingString += String(uppercase(upperLetter))\n\
    \            case let upperLetter as Character:\n                let lowerLetter\
    \ = Character(\"a\") + (upperLetter - Character.uppercase)\n                resultingString\
    \ += String(lowercase(lowerLetter))\n            default:\n                resultingString\
    \ += String(i)\n            }\n        default:\n            resultingString +=\
    \ String(i)\n        }\n    }\n    return resultingString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpubqgvpwt.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpubqgvpwt.swift:18:28:\
    \ warning: 'as' test is always true\n        case let character as Character:\n\
    \                           ^\n/tmp/tmpubqgvpwt.swift:20:34: warning: 'as' test\
    \ is always true\n            case let lowerLetter as Character:\n           \
    \                      ^\n/tmp/tmpubqgvpwt.swift:23:34: warning: 'as' test is\
    \ always true\n            case let upperLetter as Character:\n              \
    \                   ^\n/tmp/tmpubqgvpwt.swift:21:77: error: type 'Character' has\
    \ no member 'lowercase'\n                let upperLetter = Character(\"A\") +\
    \ (lowerLetter - Character.lowercase)\n                                      \
    \                            ~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpubqgvpwt.swift:22:43:\
    \ error: cannot find 'uppercase' in scope\n                resultingString +=\
    \ String(uppercase(upperLetter))\n                                          ^~~~~~~~~\n\
    /tmp/tmpubqgvpwt.swift:24:77: error: type 'Character' has no member 'uppercase'\n\
    \                let lowerLetter = Character(\"a\") + (upperLetter - Character.uppercase)\n\
    \                                                                  ~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpubqgvpwt.swift:25:43: error: cannot find 'lowercase' in scope\n      \
    \          resultingString += String(lowercase(lowerLetter))\n               \
    \                           ^~~~~~~~~\n/tmp/tmpubqgvpwt.swift:23:18: warning:\
    \ case is already handled by previous patterns; consider removing it\n       \
    \     case let upperLetter as Character:\n                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce(\"\", combine:\
    \ { (acc, char) -> String in\n        if let ch = char.lowercased() {\n      \
    \      return acc.replacingOccurrences(of: ch, with: String(ch, count: 1, repeatedValue:\
    \ \"\"))\n        }\n        return acc.replacingOccurrences(of: char.uppercased()\
    \ as String, with: char)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpo60vt99_.swift:15:20: error: extraneous argument label 'combine:'\
    \ in call\n    return s.reduce(\"\", combine: { (acc, char) -> String in\n   \
    \                ^    ~~~~~~~~~\n                        \n/tmp/tmpo60vt99_.swift:17:24:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     return acc.replacingOccurrences(of: ch, with: String(ch, count: 1, repeatedValue:\
    \ \"\"))\n                   ~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo60vt99_.swift:17:95:\
    \ error: extra argument 'repeatedValue' in call\n            return acc.replacingOccurrences(of:\
    \ ch, with: String(ch, count: 1, repeatedValue: \"\"))\n                     \
    \                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce(\"\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwn3fwbon.swift:15:21: error: unterminated string literal\n    return\
    \ s.reduce(\"\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\n                    ^\n/tmp/tmpwn3fwbon.swift:15:20:\
    \ error: missing arguments for parameters #1, #2 in call\n    return s.reduce(\"\
    \\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\u{0000}\\\
    u{0000}\\u{0000}\\u{0000}\\"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let lower = s.lowercased()\
    \ else {\n        return s\n    }\n    let isLower = lower.contains(\"a\")\n \
    \   return lower.contains(isLower ? \"A\" : \"a\")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6yz7xqeg.swift:15:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let lower = s.lowercased()\
    \ else {\n          ^           ~~~~~~~~~~~~~~\n/tmp/tmp6yz7xqeg.swift:19:18:\
    \ error: cannot convert return expression of type 'Bool' to return type 'String'\n\
    \    return lower.contains(isLower ? \"A\" : \"a\")\n           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979402
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var strArr = Array(s.characters)\n\
    \    var resStr = \"\"\n    \n    for i in 0..<strArr.count {\n        if isLetter(strArr[i])\
    \ {\n            if strArr[i] >= 'A' && strArr[i] <= 'Z' {\n                strArr[i]\
    \ = strArr[i] - 'A' + 'a'\n            } else {\n                strArr[i] = strArr[i]\
    \ + 32\n            }\n        } else if strArr[i] >= 'a' && strArr[i] <= 'z'\
    \ {\n            strArr[i] = strArr[i] - 'a' + 'A'\n        }\n    }\n    \n \
    \   for i in 0..<strArr.count {\n        if strArr[i] > 0 {\n            resStr\
    \ += String(strArr[i])\n        }\n    }\n    \n    return resStr\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt7_hnbe.swift:20:29: error: single-quoted string literal found,\
    \ use '\"'\n            if strArr[i] >= 'A' && strArr[i] <= 'Z' {\n          \
    \                  ^~~\n                            \"A\"\n/tmp/tmpkt7_hnbe.swift:20:49:\
    \ error: single-quoted string literal found, use '\"'\n            if strArr[i]\
    \ >= 'A' && strArr[i] <= 'Z' {\n                                             \
    \   ^~~\n                                                \"Z\"\n/tmp/tmpkt7_hnbe.swift:21:41:\
    \ error: single-quoted string literal found, use '\"'\n                strArr[i]\
    \ = strArr[i] - 'A' + 'a'\n                                        ^~~\n     \
    \                                   \"A\"\n/tmp/tmpkt7_hnbe.swift:21:47: error:\
    \ single-quoted string literal found, use '\"'\n                strArr[i] = strArr[i]\
    \ - 'A' + 'a'\n                                              ^~~\n           \
    \                                   \"a\"\n/tmp/tmpkt7_hnbe.swift:25:32: error:\
    \ single-quoted string literal found, use '\"'\n        } else if strArr[i] >=\
    \ 'a' && strArr[i] <= 'z' {\n                               ^~~\n            \
    \                   \"a\"\n/tmp/tmpkt7_hnbe.swift:25:52: error: single-quoted\
    \ string literal found, use '\"'\n        } else if strArr[i] >= 'a' && strArr[i]\
    \ <= 'z' {\n                                                   ^~~\n         \
    \                                          \"z\"\n/tmp/tmpkt7_hnbe.swift:26:37:\
    \ error: single-quoted string literal found, use '\"'\n            strArr[i] =\
    \ strArr[i] - 'a' + 'A'\n                                    ^~~\n           \
    \                         \"a\"\n/tmp/tmpkt7_hnbe.swift:26:43: error: single-quoted\
    \ string literal found, use '\"'\n            strArr[i] = strArr[i] - 'a' + 'A'\n\
    \                                          ^~~\n                             \
    \             \"A\"\n/tmp/tmpkt7_hnbe.swift:15:26: error: 'characters' is unavailable:\
    \ Please use String directly\n    var strArr = Array(s.characters)\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n "
  stdout: ''
  timestamp: 1659979408
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let chars = s.characters\n\
    \    var result = [Character]()\n    \n    for i in 0..<s.count {\n        let\
    \ c = chars[i]\n        if c.isLetter() {\n            let convertedChar = c.lowercased()\
    \ \n            let oldChar = convertedChar.uppercased()\n            result.removeAll(where:\
    \ { $0 == oldChar })\n            result.append(convertedChar)\n        }\n  \
    \      \n        if c.isUppercased() {\n            let convertedChar = c.uppercased()\
    \ \n            result.removeAll(where: { $0 == convertedChar })\n           \
    \ result.append(convertedChar)\n        }\n    }\n    \n    return String(result.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpn69wo286.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpn69wo286.swift:19:17:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let c = chars[i]\n                ^~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpn69wo286.swift:20:14:\
    \ error: cannot call value of non-function type 'Bool'\n        if c.isLetter()\
    \ {\n             ^       ~~\n                     \n/tmp/tmpn69wo286.swift:23:42:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n            result.removeAll(where: { $0 == oldChar })\n     \
    \                                 ~~ ^  ~~~~~~~\n/tmp/tmpn69wo286.swift:23:42:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            result.removeAll(where:\
    \ { $0 == oldChar })\n                                         ^\n/tmp/tmpn69wo286.swift:24:20:\
    \ error: no exact matches in call to instance method 'append'\n            result.append(convertedChar)\n\
    \                   ^\nSwift.Array:7:37: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable public mutating func\
    \ append<S>(contentsOf newElements: __owned S) where Element == S.Element, S :\
    \ Sequence\n                                    ^\nSwift.RangeReplaceableCollection:5:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n\
    \    @inlinable public mutating func append<S>(contentsOf newElements: __owned\
    \ S) where S : Sequence, Self.Element == S.Element\n                         \
    \           ^\n/tmp/tmpn69wo286.swift:27:14: error: value of type 'Character'\
    \ has no member 'isUppercased'\n        if c.isUppercas"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.filter{\n        char\
    \ in letterCase\n    }.map{\n        char in letterCase\n            ? char.swapCase()\n\
    \            : char\n    }.join()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpefstti04.swift:16:17: error: cannot find 'letterCase' in scope\n\
    \        char in letterCase\n                ^~~~~~~~~~\n/tmp/tmpefstti04.swift:18:17:\
    \ error: cannot find 'letterCase' in scope\n        char in letterCase\n     \
    \           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return reverse(string: s.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx6bn2nub.swift:15:12: error: cannot find 'reverse' in scope\n \
    \   return reverse(string: s.lowercased())\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n\n    let len = s.count\n    var result = \"\"\n    var i = 0\n  \
    \  var c = s[0]\n\n    if !s.isEmpty {\n        // If it not the first char\n\
    \        if !s.isFirstChar() {\n            result.append(s)\n        }\n    \
    \    // If the first char is letter\n        if !s.isLetter() {\n            result.append(c)\n\
    \        }\n    }\n\n    if s.isFirstChar() {\n        if !s.isLetter() {\n  \
    \          result.append(s)\n        } else {\n            result.append(c)\n\
    \        }\n    } else if s.isLetter() {\n        for j in stride(from: 0, to:\
    \ len, by: 1) {\n            c =  c\n            result.append(c)\n        }\n\
    \        result.append(c)\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx6d1zg4y.swift:22:13: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var c = s[0]\n\
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpx6d1zg4y.swift:26:15: error: value of type 'String' has\
    \ no member 'isFirstChar'\n        if !s.isFirstChar() {\n            ~ ^~~~~~~~~~~\n\
    /tmp/tmpx6d1zg4y.swift:30:15: error: value of type 'String' has no member 'isLetter'\n\
    \        if !s.isLetter() {\n            ~ ^~~~~~~~\n/tmp/tmpx6d1zg4y.swift:35:10:\
    \ error: value of type 'String' has no member 'isFirstChar'\n    if s.isFirstChar()\
    \ {\n       ~ ^~~~~~~~~~~\n/tmp/tmpx6d1zg4y.swift:36:15: error: value of type\
    \ 'String' has no member 'isLetter'\n        if !s.isLetter() {\n            ~\
    \ ^~~~~~~~\n/tmp/tmpx6d1zg4y.swift:41:17: error: value of type 'String' has no\
    \ member 'isLetter'\n    } else if s.isLetter() {\n              ~ ^~~~~~~~\n\
    /tmp/tmpx6d1zg4y.swift:43:15: error: assigning a variable to itself\n        \
    \    c =  c\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var letters = \"\"\n    for\
    \ i in s.characters {\n        switch i {\n        case \"a\": letters += \"A\"\
    ; break;\n        case \"b\": letters += \"B\"; break;\n        case \"c\": letters\
    \ += \"C\"; break;\n        case \"d\": letters += \"D\"; break;\n        case\
    \ \"e\": letters += \"E\"; break;\n        case \"f\": letters += \"F\"; break;\n\
    \        case \"g\": letters += \"G\"; break;\n        case \"h\": letters +=\
    \ \"H\"; break;\n        case \"i\": letters += \"I\"; break;\n        case \"\
    j\": letters += \"J\"; break;\n        case \"k\": letters += \"K\"; break;\n\
    \        case \"l\": letters += \"L\"; break;\n        case \"m\": letters +=\
    \ \"M\"; break;\n        case \"n\": letters += \"N\"; break;\n        case \"\
    o\": letters += \"O\"; break;\n        case \"p\": letters += \"P\"; break;\n\
    \        case \"q\": letters += \"Q\"; break;\n        case \"r\": letters +=\
    \ \"R\"; break;\n        case \"s\": letters += \"S\"; break;\n        case \"\
    t\": letters += \"T\"; break;\n        case \"u\": letters += \"U\"; break;\n\
    \        case \"v\": letters += \"V\"; break;\n        case \"w\": letters +=\
    \ \"W\"; break;\n        case \"x\": letters += \"X\"; break;\n        case \"\
    y\": letters += \"Y\"; break;\n        case \"z\": letters += \"Z\"; break;\n\
    \        default: letters += String(i)\n        }\n    }\n    return letters.reversed().stringByReplacingOccurrencesOfString(\"\
    \", withString: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsssii1cc.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsssii1cc.swift:47:31:\
    \ error: reference to member 'stringByReplacingOccurrencesOfString' cannot be\
    \ resolved without a contextual type\n    return letters.reversed().stringByReplacingOccurrencesOfString(\"\
    \", withString: \"\")\n                              ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce { $0 + $1.capitalized\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb8mhr_81.swift:15:20: error: missing argument for parameter #1\
    \ in call\n    return s.reduce { $0 + $1.capitalized }\n                   ^\n\
    \                   (<#String#>)\nSwift.Sequence:2:28: note: 'reduce' declared\
    \ here\n    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmpb8mhr_81.swift:15:31: error: value of type\
    \ 'String.Element' (aka 'Character') has no member 'capitalized'\n    return s.reduce\
    \ { $0 + $1.capitalized }\n                           ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \\{$0}\\{\\}\").characters.map{String($0)}.joined()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptmn9477_.swift:15:45: error: invalid escape sequence in literal\n\
    \    return s.characters.reversed().reduce(\"\\{$0}\\{\\}\").characters.map{String($0)}.joined()\n\
    \                                            ^\n/tmp/tmptmn9477_.swift:15:50:\
    \ error: invalid escape sequence in literal\n    return s.characters.reversed().reduce(\"\
    \\{$0}\\{\\}\").characters.map{String($0)}.joined()\n                        \
    \                         ^\n/tmp/tmptmn9477_.swift:15:52: error: invalid escape\
    \ sequence in literal\n    return s.characters.reversed().reduce(\"\\{$0}\\{\\\
    }\").characters.map{String($0)}.joined()\n                                   \
    \                ^\n/tmp/tmptmn9477_.swift:15:42: error: missing arguments for\
    \ parameters #1, #2 in call\n    return s.characters.reversed().reduce(\"\\{$0}\\\
    {\\}\").characters.map{String($0)}.joined()\n                                \
    \         ^\n                                          <#_#>, <#(_, String.Element)\
    \ throws -> _#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable\
    \ public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_\
    \ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let chars = s.characters.sorted()\n\
    \    return chars.isEmpty ? s : String(cString: chars).reverse()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpuzubz3hq.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters.sorted()\n               \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpuzubz3hq.swift:16:32:\
    \ error: no exact matches in call to initializer \n    return chars.isEmpty ?\
    \ s : String(cString: chars).reverse()\n                               ^\n/tmp/tmpuzubz3hq.swift:16:32:\
    \ note: found candidate with type '([CChar]) -> String' (aka '(Array<Int8>) ->\
    \ String')\n    return chars.isEmpty ? s : String(cString: chars).reverse()\n\
    \                               ^\n/tmp/tmpuzubz3hq.swift:16:32: note: found candidate\
    \ with type '([UInt8]) -> String'\n    return chars.isEmpty ? s : String(cString:\
    \ chars).reverse()\n                               ^\n/tmp/tmpuzubz3hq.swift:16:55:\
    \ error: value of type 'String' has no member 'reverse'\n    return chars.isEmpty\
    \ ? s : String(cString: chars).reverse()\n                               ~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.map {\n\
    \        Character($0)\n    }.map {\n        if let char = Character($0) {\n \
    \           if char.isLetter() {\n                char.uppercased()\n        \
    \    } else {\n                char.lowercased()\n            }\n        } else\
    \ {\n            $0\n        }\n    }.reduce(\"\") {\n        if $1 == \"\" {\n\
    \            $0\n        } else {\n            $1 + $0\n        }\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz8cbyos3.swift:28:15: error: type '()' cannot conform to 'StringProtocol'\n\
    \        if $1 == \"\" {\n              ^\n/tmp/tmpz8cbyos3.swift:28:15: note:\
    \ only concrete types such as structs, enums and classes can conform to protocols\n\
    \        if $1 == \"\" {\n              ^\n/tmp/tmpz8cbyos3.swift:28:15: note:\
    \ required by referencing operator function '==' on 'StringProtocol' where 'Self'\
    \ = '()'\n        if $1 == \"\" {\n              ^\n/tmp/tmpz8cbyos3.swift:18:33:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      if let char = Character($0) {\n                                ^\n    \
    \                            extendedGraphemeClusterLiteral: \n/tmp/tmpz8cbyos3.swift:16:19:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      Character($0)\n                  ^\n                  extendedGraphemeClusterLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if let count = s.characters.count\
    \ {\n        return reverse(s.characters.dropLast())\n    }\n    return s\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpy41f3gcx.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    if let count = s.characters.count {\n             \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpy41f3gcx.swift:16:16:\
    \ error: cannot find 'reverse' in scope\n        return reverse(s.characters.dropLast())\n\
    \               ^~~~~~~\n/tmp/tmpy41f3gcx.swift:15:8: error: initializer for conditional\
    \ binding must have Optional type, not 'Int'\n    if let count = s.characters.count\
    \ {\n       ^           ~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return reverseString(string:\
    \ stringToArray(string: s)).joinWithSeparator(\"\") { $0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpl9hkpk_1.swift:15:12: error: cannot find 'reverseString' in scope\n\
    \    return reverseString(string: stringToArray(string: s)).joinWithSeparator(\"\
    \") { $0 }\n           ^~~~~~~~~~~~~\n/tmp/tmpl9hkpk_1.swift:15:34: error: cannot\
    \ find 'stringToArray' in scope\n    return reverseString(string: stringToArray(string:\
    \ s)).joinWithSeparator(\"\") { $0 }\n                                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = s\n    result.makeString()\n\
    \    for char in result {\n        if char.isLetter() {\n            let range:\
    \ NSRange = NSMakeRange(0, result.characters.count)\n            let lowerCaseRange\
    \ = result.rangeOfCharacter(from: CharacterSet.letters, options: .caseInsensitive,\
    \ range: range)\n            \n            if lowerCaseRange.location == NSNotFound\
    \ {\n                let upperCaseRange = result.rangeOfCharacter(from: CharacterSet.letters.inverted,\
    \ options: .caseInsensitive, range: range)\n                if upperCaseRange.location\
    \ == NSNotFound {\n                    result = result.stringByReplacingCharactersInRange(range,\
    \ with: char.lowercased())\n                } else {\n                    result\
    \ = result.stringByReplacingCharactersInRange(range, with: char.uppercased())\n\
    \                }\n            } else {\n                result = result.stringByReplacingCharactersInRange(range,\
    \ with: char.capitalized())\n            }\n        } else {\n            result\
    \ = result.stringByReplacingCharactersInRange(range, with: char)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzcg6ipsa.swift:16:12: error: value of type 'String' has no member\
    \ 'makeString'\n    result.makeString()\n    ~~~~~~ ^~~~~~~~~~\n/tmp/tmpzcg6ipsa.swift:18:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmpzcg6ipsa.swift:19:24:\
    \ error: cannot find type 'NSRange' in scope\n            let range: NSRange =\
    \ NSMakeRange(0, result.characters.count)\n                       ^~~~~~~\n/tmp/tmpzcg6ipsa.swift:20:64:\
    \ error: cannot find 'CharacterSet' in scope\n            let lowerCaseRange =\
    \ result.rangeOfCharacter(from: CharacterSet.letters, options: .caseInsensitive,\
    \ range: range)\n                                                            \
    \   ^~~~~~~~~~~~\n/tmp/tmpzcg6ipsa.swift:20:41: error: value of type 'String'\
    \ has no member 'rangeOfCharacter'\n            let lowerCaseRange = result.rangeOfCharacter(from:\
    \ CharacterSet.letters, options: .caseInsensitive, range: range)\n           \
    \                      ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpzcg6ipsa.swift:20:96:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \            let lowerCaseRange = result.rangeOfCharacter(from: CharacterSet.letters,\
    \ options: .caseInsensitive, range: range)\n                                 \
    \                                                             ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpzcg6ipsa.swift:22:43: error: cannot find 'NSNotFound' in scope\n     \
    \       if lowerCaseRange.location == NSNotFound {\n                         \
    \                 ^~~~~~~~~~\n/tmp/tmpzcg6ipsa.swift:23:68: error: cannot find\
    \ 'CharacterSet' in scope\n                let upperCaseRange = result.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted, options: .caseInsensitive, range: range)\n  \
    \                                                                 ^~~~~~~~~~~~\n\
    /tmp/tmpzcg6ipsa.swift:23:45: error: value of type 'String' has no member 'rangeOfCharacter'\n\
    \                let upperCaseRange = result.rangeOfCharacter(from: CharacterSet.letters.inverted,\
    \ options: .caseIns"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newStr = \"\"\n    for\
    \ ch in s {\n        newStr += String(ch, in: CharacterSet.lowercase)\n    }\n\
    \    if newStr.isEmpty {\n        return \"\"\n    }\n    let result = newStr.reversed()\n\
    \    return result.isEmpty ? newStr : result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpct3tkh28.swift:17:34: error: cannot find 'CharacterSet' in scope\n\
    \        newStr += String(ch, in: CharacterSet.lowercase)\n                  \
    \               ^~~~~~~~~~~~\n/tmp/tmpct3tkh28.swift:17:25: error: incorrect argument\
    \ labels in call (have '_:in:', expected 'repeating:count:')\n        newStr +=\
    \ String(ch, in: CharacterSet.lowercase)\n                        ^    ~~\n  \
    \                       repeating:  count\n/tmp/tmpct3tkh28.swift:23:27: error:\
    \ cannot convert return expression of type 'ReversedCollection<String>' to return\
    \ type 'String'\n    return result.isEmpty ? newStr : result\n           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return String(s.characters.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpurjzn2ys.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    return String(s.characters.reversed())\n          \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \") { $0 + \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".characters.first!.first!.contains{$0\
    \ == $1 ? $0 : $1.lowercased()}} ?? s\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqd881og.swift:15:47: error: contextual closure type '(String,\
    \ String.Element) throws -> String' (aka '(String, Character) throws -> String')\
    \ expects 2 arguments, but 1 was used in closure body\n    return s.characters.reversed().reduce(\"\
    \") { $0 + \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".characters.first!.first!.contains{$0\
    \ == $1 ? $0 : $1.lowercased()}} ?? s\n                                      \
    \        ^\n/tmp/tmpmqd881og.swift:15:127: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'first'\n    return s.characters.reversed().reduce(\"\
    \") { $0 + \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".characters.first!.first!.contains{$0\
    \ == $1 ? $0 : $1.lowercased()}} ?? s\n                                      \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1659979405
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ s = s\n    \n    for char in s {\n        if char.unicodeScalars.count > 0 {\n\
    \            let char = char.unicodeScalars.first!\n            let char = char.value\
    \ + char.value % 26\n            \n            switch char {\n            case\
    \ 65:\n                char = 65\n            case 66:\n                char =\
    \ 66\n            case 67:\n                char = 67\n            case 68:\n\
    \                char = 68\n            case 69:\n                char = 69\n\
    \            case 70:\n                char = 70\n            case 71:\n     \
    \           char = 71\n            case 72:\n                char = 72\n     \
    \       case 73:\n                char = 73\n            case 74:\n          \
    \      char = 74\n            case 75:\n                char = 75\n          \
    \  case 76:\n                char = 76\n            case 77:\n               \
    \ char = 77\n            case 78:\n                char = 78\n            case\
    \ 79:\n                char = 79\n            case 80:\n                char =\
    \ 80\n            case 81:\n                char = 81 \n            case 82:\n\
    \                char = 82 \n            case 83:\n                char = 83 \n\
    \            case 84:\n                char = 84 \n            case 85:\n    \
    \            char = 85 \n            case 86:\n                char = 86 \n  \
    \          case 87:\n                char = 87 \n            case 88:\n      \
    \          char = 88 \n            case 89:\n                char = 89 \n    \
    \        case 90:\n                char = 90 \n            case 91:\n        \
    \        char = 91 \n            case 92:\n                char = 92 \n      \
    \      case 93:\n                char = 93 \n            case 94:\n          \
    \      char = 94 \n            case 95:\n                char = 95 \n        \
    \    case 96:\n                char = 96 \n            case 97:\n            \
    \    char = 97 \n            case 98:\n                char = 98 \n          \
    \  case 99:\n                char = 99 \n            case 100:\n             \
    \   char = 100 \n            case 101:\n                char = 101 \n        \
    \    case 102:\n                char = 102 \n            case 103:\n         \
    \       char = 103 \n            case 104:\n                char = 104 \n    \
    \        case 105:\n                char = 105 \n            case 106:\n     \
    \           char = 106 \n            case 107:\n                char = 107 \n\
    \            case 108:\n                char = 108 \n            case 109:\n \
    \               char = 109 \n            case 110:\n                char = 110\
    \ \n            case 111:\n                char = 111 \n            case 112:\n\
    \                char = 112 \n            case 113:\n                char = 113\
    \ \n            case 114:\n                char = 114 \n            case 115:\n\
    \                char = 115 \n            case 116:\n                char = 116\
    \ \n            case 117:\n                char = 117 \n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcpznhyhl.swift:153:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmpcpznhyhl.swift:19:42: note: to match this opening '{'\n        if char.unicodeScalars.count\
    \ > 0 {\n                                         ^\n/tmp/tmpcpznhyhl.swift:153:35:\
    \ error: expected '}' at end of brace statement\nassert(solve(s: \"#ccc\") ==\
    \ \"#CCC\")\n                                  ^\n/tmp/tmpcpznhyhl.swift:18:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpcpznhyhl.swift:153:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmpcpznhyhl.swift:14:33: note: to match this opening '{'\nfunc solve(s: String)\
    \ -> String {\n                                ^\n/tmp/tmpcpznhyhl.swift:21:17:\
    \ error: invalid redeclaration of 'char'\n            let char = char.value +\
    \ char.value % 26\n                ^\n/tmp/tmpcpznhyhl.swift:20:17: note: 'char'\
    \ previously declared here\n            let char = char.unicodeScalars.first!\n\
    \                ^\n/tmp/tmpcpznhyhl.swift:134:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if let firstCharacter = s.first\
    \ {\n        if Character(firstCharacter).isUppercase {\n            return s.uppercased()\n\
    \        } else {\n            return s.lowercased()\n        }\n    } else {\n\
    \        return s.lowercased()\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptygnubvz.swift:16:12: error: no exact matches in call to initializer\
    \ \n        if Character(firstCharacter).isUppercase {\n           ^\nSwift.Character:5:23:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(extendedGraphemeClusterLiteral:)')\n\
    \    @inlinable public init(extendedGraphemeClusterLiteral value: Character)\n\
    \                      ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(unicodeScalarLiteral:)')\n\
    \    public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.map({ (letter)\
    \ -> String in\n        let uppercaseLetter = String.init(unicodeScalarLiteral:\
    \ letter).uppercased()\n        let lowercaseLetter = String.init(unicodeScalarLiteral:\
    \ letter).lowercased()\n        guard let a = uppercaseLetter.characters.first\
    \ else {\n            return lowercaseLetter\n        }\n        guard let b =\
    \ lowercaseLetter.characters.first else {\n            return uppercaseLetter\n\
    \        }\n        if a > b {\n            return uppercaseLetter\n        }\
    \ else {\n            return lowercaseLetter\n        }\n    }).reduce({ $0 +\
    \ $1 }, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwlwe3uw5.swift:16:65: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        let uppercaseLetter\
    \ = String.init(unicodeScalarLiteral: letter).uppercased()\n                 \
    \                                               ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \") { a, $0 + ($0.isLetter ? (String($0.unicodeScalars.filter { !$0.isControl\
    \ }).lowercased().joinWithSeparator(\"\") + String($0.unicodeScalars.filter {\
    \ $0.isControl }).uppercased().joinWithSeparator(\"\")) : ($0 + String($0.unicodeScalars.filter\
    \ { !$0.isControl }).lowercased().joinWithSeparator(\"\") + String($0.unicodeScalars.filter\
    \ { $0.isControl }).uppercased().joinWithSeparator(\"\")))  }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz3k3fqth.swift:15:39: error: consecutive statements on a line must\
    \ be separated by ';'\n    return s.characters.reduce(\"\") { a, $0 + ($0.isLetter\
    \ ? (String($0.unicodeScalars.filter { !$0.isControl }).lowercased().joinWithSeparator(\"\
    \") + String($0.unicodeScalars.filter { $0.isControl }).uppercased().joinWithSeparator(\"\
    \")) : ($0 + String($0.unicodeScalars.filter { !$0.isControl }).lowercased().joinWithSeparator(\"\
    \") + String($0.unicodeScalars.filter { $0.isControl }).uppercased().joinWithSeparator(\"\
    \")))  }\n                                      ^\n                          \
    \            ;\n/tmp/tmpz3k3fqth.swift:15:39: error: expected expression\n   \
    \ return s.characters.reduce(\"\") { a, $0 + ($0.isLetter ? (String($0.unicodeScalars.filter\
    \ { !$0.isControl }).lowercased().joinWithSeparator(\"\") + String($0.unicodeScalars.filter\
    \ { $0.isControl }).uppercased().joinWithSeparator(\"\")) : ($0 + String($0.unicodeScalars.filter\
    \ { !$0.isControl }).lowercased().joinWithSeparator(\"\") + String($0.unicodeScalars.filter\
    \ { $0.isControl }).uppercased().joinWithSeparator(\"\")))  }\n              \
    \                        ^\n/tmp/tmpz3k3fqth.swift:15:38: error: cannot find 'a'\
    \ in scope\n    return s.characters.reduce(\"\") { a, $0 + ($0.isLetter ? (String($0.unicodeScalars.filter\
    \ { !$0.isControl }).lowercased().joinWithSeparator(\"\") + String($0.unicodeScalars.filter\
    \ { $0.isControl }).uppercased().joinWithSeparator(\"\")) : ($0 + String($0.unicodeScalars.filter\
    \ { !$0.isControl }).lowercased().joinWithSeparator(\"\") + String($0.unicodeScalars.filter\
    \ { $0.isControl }).uppercased().joinWithSeparator(\"\")))  }\n              \
    \                       ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.map({ $0\
    \ < 'a' ? ($0 - 'a') + 10 + ($0 - 'A') : $0 }).reduce(\"\").reversed()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqfxmh1w9.swift:15:36: error: single-quoted string literal found,\
    \ use '\"'\n    return s.characters.map({ $0 < 'a' ? ($0 - 'a') + 10 + ($0 - 'A')\
    \ : $0 }).reduce(\"\").reversed()\n                                   ^~~\n  \
    \                                 \"a\"\n/tmp/tmpqfxmh1w9.swift:15:48: error:\
    \ single-quoted string literal found, use '\"'\n    return s.characters.map({\
    \ $0 < 'a' ? ($0 - 'a') + 10 + ($0 - 'A') : $0 }).reduce(\"\").reversed()\n  \
    \                                             ^~~\n                          \
    \                     \"a\"\n/tmp/tmpqfxmh1w9.swift:15:66: error: single-quoted\
    \ string literal found, use '\"'\n    return s.characters.map({ $0 < 'a' ? ($0\
    \ - 'a') + 10 + ($0 - 'A') : $0 }).reduce(\"\").reversed()\n                 \
    \                                                ^~~\n                       \
    \                                          \"A\"\n/tmp/tmpqfxmh1w9.swift:15:12:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    return s.characters.map({\
    \ $0 < 'a' ? ($0 - 'a') + 10 + ($0 - 'A') : $0 }).reduce(\"\").reversed()\n  \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979467
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = \"\"\n    var lastChar\
    \ = \"\"\n    var lastUpper = false\n    var lastLower = false\n    s.characters.forEach\
    \ {\n        switch $0 {\n        case \"a\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"A\": res += lastLower!; lastLower = !lastLower\n        case \"\
    #\": res += \"$\"; lastLower = !lastLower\n        case \"$\": res += \"$\"; lastUpper\
    \ = !lastUpper\n        case \"b\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"B\": res += lastLower!; lastLower = !lastLower\n        case \"\
    c\": res += lastLower!; lastLower = !lastLower\n        case \"C\": res += lastUpper!;\
    \ lastUpper = !lastUpper\n        case \"d\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"D\": res += lastLower!; lastLower = !lastLower\n        case \"\
    e\": res += lastLower!; lastLower = !lastLower\n        case \"F\": res += lastUpper!;\
    \ lastUpper = !lastUpper\n        case \"g\": res += lastLower!; lastLower = !lastLower\n\
    \        case \"G\": res += lastUpper!; lastUpper = !lastUpper\n        case \"\
    h\": res += lastUpper!; lastUpper = !lastUpper\n        case \"H\": res += lastLower!;\
    \ lastLower = !lastLower\n        case \"i\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"J\": res += lastUpper!; lastUpper = !lastUpper\n        case \"\
    k\": res += lastUpper!; lastUpper = !lastUpper\n        case \"K\": res += lastLower!;\
    \ lastLower = !lastLower\n        case \"l\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"L\": res += lastLower!; lastLower = !lastLower\n        case \"\
    m\": res += lastLower!; lastLower = !lastLower\n        case \"n\": res += lastLower!;\
    \ lastLower = !lastLower\n        case \"o\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"O\": res += lastLower!; lastLower = !lastLower\n        case \"\
    p\": res += lastUpper!; lastUpper = !lastUpper\n        case \"Q\": res += lastUpper!;\
    \ lastUpper = !lastUpper\n        case \"r\": res += lastLower!; lastLower = !lastLower\n\
    \        case \"R\": res += last\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpes8xli7y.swift:73:35: error: expected '}' at end of closure\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")\n                                  ^\n/tmp/tmpes8xli7y.swift:19:26:\
    \ note: to match this opening '{'\n    s.characters.forEach {\n              \
    \           ^\n/tmp/tmpes8xli7y.swift:73:35: error: expected '}' at end of brace\
    \ statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n                        \
    \          ^\n/tmp/tmpes8xli7y.swift:14:33: note: to match this opening '{'\n\
    func solve(s: String) -> String {\n                                ^\n/tmp/tmpes8xli7y.swift:50:26:\
    \ error: cannot find 'last' in scope\n        case \"R\": res += last\n      \
    \                   ^~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ letter in s {\n        if letter.isLetter() {\n            if letter.isUpper()\
    \ {\n                result = result.uppercased()\n            } else {\n    \
    \            result = result.lowercased()\n            }\n        } else {\n \
    \           result = result + letter\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqoxvmwt1.swift:17:19: error: cannot call value of non-function\
    \ type 'Bool'\n        if letter.isLetter() {\n                  ^       ~~\n\
    \                          \n/tmp/tmpqoxvmwt1.swift:18:23: error: value of type\
    \ 'Character' has no member 'isUpper'\n            if letter.isUpper() {\n   \
    \            ~~~~~~ ^~~~~~~\n/tmp/tmpqoxvmwt1.swift:24:31: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ = result + letter\n                              ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\treturn solveHelper(s)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgyymlnqz.swift:15:9: error: cannot find 'solveHelper' in scope\n\
    \        return solveHelper(s)\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var stringCopy = s\n    if\
    \ !s.isEmpty {\n        var upper = false\n        for _ in s.characters {\n \
    \           if let c = String(unicodeScalars: s) {\n                if c.isUppercase\
    \ {\n                    if upper {\n                        stringCopy = stringCopy.replacingCharacters(in:\
    \ NSRange(location: i, length: 1), with: c.lowercaseString)\n                \
    \    }\n                } else {\n                    upper = true\n         \
    \           stringCopy = stringCopy.replacingCharacters(in: NSRange(location:\
    \ i, length: 1), with: c.uppercaseString)\n                }\n            }\n\
    \            i += 1\n        }\n    }\n    return stringCopy\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqcnzgg4c.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n        for _ in s.characters {\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqcnzgg4c.swift:19:24:\
    \ error: no exact matches in call to initializer \n            if let c = String(unicodeScalars:\
    \ s) {\n                       ^\nSwift.String:4:23: note: incorrect labels for\
    \ candidate (have: '(unicodeScalars:)', expected: '(_:)')\n    @inlinable public\
    \ init<T>(_ value: T) where T : LosslessStringConvertible\n                  \
    \    ^\nSwift.String:3:12: note: incorrect labels for candidate (have: '(unicodeScalars:)',\
    \ expected: '(_:)')\n    public init<S>(_ other: S) where S : LosslessStringConvertible,\
    \ S : Sequence, S.Element == Character\n           ^\nSwift.String:4:12: note:\
    \ incorrect labels for candidate (have: '(unicodeScalars:)', expected: '(_:)')\n\
    \    public init<S>(_ characters: S) where S : Sequence, S.Element == Character\n\
    \           ^\nSwift.RangeReplaceableCollection:3:23: note: incorrect labels for\
    \ candidate (have: '(unicodeScalars:)', expected: '(_:)')\n    @inlinable public\
    \ init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element\n     \
    \                 ^\n/tmp/tmpqcnzgg4c.swift:22:73: error: cannot find 'NSRange'\
    \ in scope\n                        stringCopy = stringCopy.replacingCharacters(in:\
    \ NSRange(location: i, length: 1), with: c.lowercaseString)\n                \
    \                                                        ^~~~~~~\n/tmp/tmpqcnzgg4c.swift:22:91:\
    \ error: cannot find 'i' in scope\n                        stringCopy = stringCopy.replacingCharacters(in:\
    \ NSRange(location: i, length: 1), with: c.lowercaseString)\n                \
    \                                                                          ^\n\
    /tmp/tmpqcnzgg4c.swift:22:49: error: value of type 'String' has no member 'replacingCharacters'\n\
    \                        stringCopy = stringCopy.replacingCharacters(in: NSRange(location:\
    \ i, lengt"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ \"\"\n    }\n    if s.isUppercase {\n        let lower = Array(s.lowercased().charactersIgnoringCase)\n\
    \        return String(lower.reverse())\n    }\n    let upper = Array(s.uppercased().charactersIgnoringCase)\n\
    \    return String(upper.reverse())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9myqdcrk.swift:18:10: error: value of type 'String' has no member\
    \ 'isUppercase'\n    if s.isUppercase {\n       ~ ^~~~~~~~~~~\n/tmp/tmp9myqdcrk.swift:19:42:\
    \ error: value of type 'String' has no member 'charactersIgnoringCase'\n     \
    \   let lower = Array(s.lowercased().charactersIgnoringCase)\n               \
    \           ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9myqdcrk.swift:22:38:\
    \ error: value of type 'String' has no member 'charactersIgnoringCase'\n    let\
    \ upper = Array(s.uppercased().charactersIgnoringCase)\n                     \
    \ ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = s.characters.filter\
    \ { isLetter($0) }\n    return letters.count > 0 ? letters.reduce(\"\\u{0061}\\\
    u{0301}\\u{0306}\") { $0 + String($1) }.substring(to: s.count) : s\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpao1u9ub_.swift:15:41: error: cannot find 'isLetter' in scope\n\
    \    let letters = s.characters.filter { isLetter($0) }\n                    \
    \                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? \"#\" :\
    \ (s.count > 1 ? \"#\" : \"\") + s.lowercased().map { $0.uppercased() }.reduce(\"\
    \", { $0 + $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpaonmfz17/tmpaonmfz17.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b608afb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b608aca8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b608aca8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b608aca77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaonmfz17                        0x000055d658fe55f7 <unavailable> + 5623

    5    libc.so.6                          0x00002b608b19d460 __libc_start_main +
    245

    6    tmpaonmfz17                        0x000055d658fe5239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.map({ c\
    \ in\n        guard let c = c.unicodeScalars.first else {\n            return\
    \ c\n        }\n        switch c {\n        case .uppercase:\n            return\
    \ String(c).lowercaseString\n        case .lowercase:\n            return String(c).uppercaseString\n\
    \        default:\n            return c\n        }\n    }).reduce(\"\", { acc,\
    \ element in\n        if element == \"\" {\n            return acc\n        }\
    \ else {\n            return acc + element\n        }\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 6 (use -v to see invocation)\n\
    /tmp/tmpe81p3ff6.swift:27:26: error: unable to infer type of a closure parameter\
    \ 'element' in the current context\n    }).reduce(\"\", { acc, element in\n  \
    \                       ^\nswift-frontend: /home/build-user/swift/include/swift/Sema/ConstraintSystem.h:3595:\
    \ swift::Type swift::constraints::ConstraintSystem::getType(swift::ASTNode) const:\
    \ Assertion `hasType(node) && \"Expected type to have been set!\"' failed.\nPlease\
    \ submit a bug report (https://swift.org/contributing/#reporting-bugs) and include\
    \ the project and the crash backtrace.\nStack dump:\n0.\tProgram arguments: /work/arjunguha-research-group/swift-installation/swift-DEVELOPMENT-SNAPSHOT-2022-08-01-a-centos7/usr/bin/swift-frontend\
    \ -frontend -c -primary-file /tmp/tmpe81p3ff6.swift -target x86_64-unknown-linux-gnu\
    \ -disable-objc-interop -new-driver-path /work/arjunguha-research-group/swift-installation/swift-DEVELOPMENT-SNAPSHOT-2022-08-01-a-centos7/usr/bin/swift-driver\
    \ -empty-abi-descriptor -resource-dir /work/arjunguha-research-group/swift-installation/swift-DEVELOPMENT-SNAPSHOT-2022-08-01-a-centos7/usr/lib/swift\
    \ -module-name tmpe81p3ff6 -o /tmp/TemporaryDirectory.yO4Zml/tmpe81p3ff6-1.o\n\
    1.\tSwift version 5.8-dev (LLVM 07d14852a049e40, Swift 613b3223d9ec5f6)\n2.\t\
    Compiling with the current language version\n3.\tWhile evaluating request TypeCheckSourceFileRequest(source_file\
    \ \"/tmp/tmpe81p3ff6.swift\")\n4.\tWhile evaluating request TypeCheckFunctionBodyRequest(tmpe81p3ff6.(file).solve(s:)@/tmp/tmpe81p3ff6.swift:14:6)\n\
    5.\tWhile type-checking statement at [/tmp/tmpe81p3ff6.swift:14:33 - line:34:1]\
    \ RangeText=\"{\n    return s.characters.map({ c in\n        guard let c = c.unicodeScalars.first\
    \ else {\n            return c\n        }\n        switch c {\n        case .uppercase:\n\
    \            return String(c).lowercaseString\n        case .lowercase:\n    \
    \        return String(c).uppercaseString\n        default:\n            return\
    \ c\n        }\n    }).reduce(\"\", { acc, element in\n        if element == \"\
    \" {\n            r"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let lenght = s.characters.count\n\
    \    \n    if lenght == 0 {\n        return s\n    }\n    \n    var res = \"\"\
    \n    \n    if s.characters.first >= 65 {\n        let c = s.characters.first\n\
    \        res += String(c - 65) + String(c - 66)\n    } else {\n        res +=\
    \ s.characters.first!\n    }\n    \n    for i in 1...lenght {\n        \n    \
    \    if s.characters.first >= 65 {\n            let c = s.characters.first\n \
    \           res += String(c - 65) + String(c - 66)\n        } else if s.characters.first\
    \ >= 97 {\n            let c = s.characters.first\n            res += String(c\
    \ - 97) + String(c - 98)\n        } else if s.characters.first >= 123 {\n    \
    \        let c = s.characters.first\n            res += String(c - 123) + String(c\
    \ - 124)\n        } else {\n            res += s.characters.first!\n        }\n\
    \    }\n    \n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdbdjbh_c.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let lenght = s.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpdbdjbh_c.swift:23:27:\
    \ error: type '((String.Element) throws -> Bool) throws -> String.Element?' (aka\
    \ '((Character) throws -> Bool) throws -> Optional<Character>') cannot conform\
    \ to 'BinaryInteger'\n    if s.characters.first >= 65 {\n                    \
    \      ^\n/tmp/tmpdbdjbh_c.swift:23:27: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n    if s.characters.first >= 65\
    \ {\n                          ^\n/tmp/tmpdbdjbh_c.swift:23:27: note: required\
    \ by referencing operator function '>=' on 'BinaryInteger' where 'Self' = '((String.Element)\
    \ throws -> Bool) throws -> String.Element?' (aka '((Character) throws -> Bool)\
    \ throws -> Optional<Character>')\n    if s.characters.first >= 65 {\n       \
    \                   ^\n/tmp/tmpdbdjbh_c.swift:24:19: error: 'characters' is unavailable:\
    \ Please use String directly\n        let c = s.characters.first\n           \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpdbdjbh_c.swift:25:23:\
    \ error: cannot convert value of type 'String.Element?' (aka 'Optional<Character>')\
    \ to expected argument type 'Int'\n        res += String(c - 65) + String(c -\
    \ 66)\n                      ^\n/tmp/tmpdbdjbh_c.swift:25:40: error: cannot convert\
    \ value of type 'String.Element?' (aka 'Optional<Character>') to expected argument\
    \ type 'Int'\n        res += String(c - 65) + String(c - 66)\n               \
    \                        ^\n/tmp/tmpdbdjbh_c.swift:27:34: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        res += s.characters.first!\n                                 ^\n/tmp/tmpdbdjbh_c.swift:32:31:\
    \ error: type '((String.Element) throws ->"
  stdout: ''
  timestamp: 1659979409
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    \n    var reversedString = String(s.unicodeScalars)\n    guard\
    \ let characters = reversedString.unicodeScalars else {\n        return reversedString\n\
    \    }\n    \n    var resultString = \"\"\n    var index = 0\n    while index\
    \ < characters.count {\n        let nextCharacterIndex = index(characters, startIndex:\
    \ index) ?? characters.endIndex\n        let nextCharacterUnicodeScalar = characters[nextCharacterIndex]\n\
    \        \n        if case let .letter(unicodeScalar) = nextCharacterUnicodeScalar\
    \ {\n            resultString += String.UnicodeScalarView(unicodeScalar)\n   \
    \         \n            let rangeToRemove = nextCharacterIndex\n            let\
    \ rangeToInsert = nextCharacterIndex\n            if let endIndex = index(characters,\
    \ startIndex: rangeToRemove) {\n                let removeRange = Range<String.Index>(start:\
    \ rangeToRemove, end: endIndex)\n                reversedString.removeSubrange(removeRange)\n\
    \            }\n            \n            if let endIndex = index(characters,\
    \ startIndex: rangeToInsert) {\n                let insertRange = Range<String.Index>(start:\
    \ rangeToInsert, end: endIndex)\n                reversedString.insert(String.UnicodeScalarView(unicodeScalar),\
    \ at: insertRange)\n            }\n        }\n        \n        guard let nextCharacterUnicodeScalar\
    \ = characters[nextCharacterIndex] else {\n            break\n        }\n    \
    \    \n        guard case let .character(char) = nextCharacterUnicodeScalar else\
    \ {\n            break\n        }\n        \n        switch char {\n        case\
    \ \"A\"...\"Z\", \"a\"...\"z\", \"0\"...\"9\":\n            resultString += char\n\
    \        case \"a\"...\"z\", \"0\"...\"9\", \"A\"...\"Z\", \"a\"...\"z\":\n  \
    \          resultString += char.lowercased() + char.uppercased()\n        default:\n\
    \            break\n        }\n        \n        guard let nextCharacterIndex\
    \ = index(characters, startIndex: nextCharacterIndex + 1) else {\n           \
    \ break\n        }\n        \n        let nextCharacterUnicodeScalar = characters[nextCharacterIndex]\n\
    \        \n        if case let .character(char) = nextCharacterUnicodeScalar {\n\
    \            resultString += char\n        }\n        \n        guard case let\
    \ .character(char) = nextCharacterUnicodeScalar else {\n            break\n  \
    \      }\n        \n        switch char {\n        case \"A\"...\"Z\", \"a\"...\"\
    z\", \"0\"...\"9\":\n            resultString += char\n        case \"a\"...\"\
    z\", \"0\"...\"9\", \"A\"...\"Z\", \"a\"...\"z\":\n            resultString +=\
    \ char.lowercased() + char.uppercased()\n        default:\n            break\n\
    \        }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsvmo0qut.swift:107:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmpsvmo0qut.swift:14:33: note: to match this opening '{'\nfunc solve(s: String)\
    \ -> String {\n                                ^\n/tmp/tmpsvmo0qut.swift:20:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String.UnicodeScalarView'\n\
    \    guard let characters = reversedString.unicodeScalars else {\n          ^\
    \                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsvmo0qut.swift:27:34:\
    \ error: cannot call value of non-function type 'Int'\n        let nextCharacterIndex\
    \ = index(characters, startIndex: index) ?? characters.endIndex\n            \
    \                     ^\n/tmp/tmpsvmo0qut.swift:31:26: error: operator function\
    \ '+=' requires the types 'String.Element' (aka 'Character') and 'Unicode.Scalar'\
    \ be equivalent\n            resultString += String.UnicodeScalarView(unicodeScalar)\n\
    \                         ^\nSwift.RangeReplaceableCollection:4:35: note: where\
    \ 'Self.Element' = 'String.Element' (aka 'Character'), 'Other.Element' = 'Unicode.Scalar'\n\
    \    @inlinable public static func += <Other>(lhs: inout Self, rhs: Other) where\
    \ Other : Sequence, Self.Element == Other.Element\n                          \
    \        ^\n/tmp/tmpsvmo0qut.swift:35:31: error: cannot call value of non-function\
    \ type 'Int'\n            if let endIndex = index(characters, startIndex: rangeToRemove)\
    \ {\n                              ^\n/tmp/tmpsvmo0qut.swift:36:35: error: referencing\
    \ initializer 'init(_:)' on 'Range' requires that 'String.Index' conform to 'Strideable'\n\
    \                let removeRange = Range<String.Index>(start: rangeToRemove, end:\
    \ endIndex)\n                                  ^\nSwift.Range:1:11: note: where\
    \ 'Bound' = 'String.Index'\nextension Range where Bound : Strideable, Bound.Stride\
    \ : SignedInteger {\n          ^\n/tmp/tmpsvmo0qut.swift:36:82: error: extra argument\
    \ 'end' in call\n                let removeRange = Range<String.Index>(start:\
    \ rangeToRemove, end: endIndex)\n            "
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return solve(s, \"\", \"\"\
    , \"\", \"\", \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx89ba34y.swift:15:17: error: extra arguments at positions #2, #3,\
    \ #4, #5, #6 in call\n    return solve(s, \"\", \"\", \"\", \"\", \"\")\n    \
    \            ^\n/tmp/tmpx89ba34y.swift:14:6: note: 'solve(s:)' declared here\n\
    func solve(s: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ i in stride(from: 0, to: s.count, by: 1) {\n        let char = s[i]\n      \
    \  if char.isUppercase {\n            result += \"\\(char.lowercased())\"\n  \
    \      } else if char.isLowercase {\n            result += \"\\(char.uppercased())\"\
    \n        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpddgxdayz.swift:17:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = s[i]\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpddgxdayz.swift:23:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \") { result, nextChar in\n        switch (nextChar) {\n        case \"a\":\n\
    \            result = \"\\(result.uppercased())\\(nextChar)\"\n            break\n\
    \        case \"A\":\n            result = \"\\(result.lowercased())\\(nextChar)\"\
    \n            break\n        case \"#\":\n            result = \"\\(nextChar)\"\
    \n            break\n        default:\n            result = \"\\(result.lowercased())\\\
    (nextChar)\"\n        }\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3geu4iq6.swift:18:13: error: cannot assign to value: 'result' is\
    \ a 'let' constant\n            result = \"\\(result.uppercased())\\(nextChar)\"\
    \n            ^~~~~~\n/tmp/tmp3geu4iq6.swift:21:13: error: cannot assign to value:\
    \ 'result' is a 'let' constant\n            result = \"\\(result.lowercased())\\\
    (nextChar)\"\n            ^~~~~~\n/tmp/tmp3geu4iq6.swift:24:13: error: cannot\
    \ assign to value: 'result' is a 'let' constant\n            result = \"\\(nextChar)\"\
    \n            ^~~~~~\n/tmp/tmp3geu4iq6.swift:27:13: error: cannot assign to value:\
    \ 'result' is a 'let' constant\n            result = \"\\(result.lowercased())\\\
    (nextChar)\"\n            ^~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce(\"\") { (result,\
    \ rev) -> String in\n        if let range = result.range(of: rev) {\n        \
    \    \n            var temp = \"\"\n            \n            for char in result.reversed()\
    \ {\n                if char == rev {\n                    temp = char\n     \
    \           }\n                else {\n                    temp = String(char).lowercased()\n\
    \                }\n                \n                result.insert(temp, at:\
    \ range.lowerBound)\n            }\n            \n        }\n        return result.lowercased()\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp90yq42_h.swift:16:31: error: value of type 'String' has no member\
    \ 'range'\n        if let range = result.range(of: rev) {\n                  \
    \     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : s.characters.reversed().reduce(s)\
    \ {\n        switch $0 {\n        case .init:\n            return $0\n       \
    \ case .next(let c):\n            switch c {\n            case .letter:\n    \
    \            return String(Array($0.characters.prefix(1))).uppercased() + String(Array($0.characters.dropFirst()))\n\
    \            }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp85c01wsj.swift:15:62: error: contextual closure type '(String,\
    \ ReversedCollection<String>.Element) throws -> String' (aka '(String, Character)\
    \ throws -> String') expects 2 arguments, but 1 was used in closure body\n   \
    \ return s.isEmpty ? s : s.characters.reversed().reduce(s) {\n               \
    \                                              ^\n/tmp/tmp85c01wsj.swift:19:15:\
    \ error: type 'Substring' has no member 'next'\n        case .next(let c):\n \
    \            ~^~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newS = \"\"\n    let counts\
    \ = s.characters.reduce(into: [Character:Int](), { (result, character) in\n  \
    \      var count = result![character] ?? 0\n        count++\n        result![character]\
    \ = count\n    })\n    let maxCount = counts.values.max()!\n    for (_,v) in counts\
    \ {\n        if v == maxCount {\n            for (_,c) in counts {\n         \
    \       if c == maxCount {\n                    newS.append(c)\n             \
    \   }\n            }\n        }\n    }\n    if newS.isEmpty {\n        if s.isEmpty\
    \ {\n            return s\n        } else {\n            return s.uppercased()\n\
    \        }\n    } else {\n        return newS.reversed().uppercased()\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3ztkvyvo.swift:18:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        count++\n             ^~\n/tmp/tmp3ztkvyvo.swift:22:5:\
    \ error: failed to produce diagnostic for expression; please submit a bug report\
    \ (https://swift.org/contributing/#reporting-bugs) and include the project\n \
    \   for (_,v) in counts {\n    ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var ret = \"\"\n    var isAnUpper\
    \ = false\n    var isAnLower = false\n    for c in s {\n        switch c {\n \
    \       case \"A\":\n        case \"a\":\n            isAnUpper = true\n     \
    \   case \"B\":\n        case \"b\":\n            isAnUpper = true\n        case\
    \ \"C\":\n        case \"c\":\n            isAnUpper = true\n        case \"D\"\
    :\n        case \"d\":\n            isAnUpper = true\n        case \"E\":\n  \
    \      case \"e\":\n            isAnUpper = true\n        case \"F\":\n      \
    \  case \"f\":\n            isAnUpper = true\n        case \"G\":\n        case\
    \ \"g\":\n            isAnUpper = true\n        case \"H\":\n        case \"h\"\
    :\n            isAnUpper = true\n        case \"I\":\n        case \"i\":\n  \
    \          isAnUpper = true\n        case \"J\":\n        case \"j\":\n      \
    \      isAnUpper = true\n        case \"K\":\n        case \"k\":\n          \
    \  isAnUpper = true\n        case \"L\":\n        case \"l\":\n            isAnUpper\
    \ = true\n        case \"M\":\n        case \"m\":\n            isAnUpper = true\n\
    \        case \"N\":\n        case \"n\":\n            isAnUpper = true\n    \
    \    case \"O\":\n        case \"o\":\n            isAnUpper = true\n        case\
    \ \"P\":\n        case \"p\":\n            isAnUpper = true\n        case \"Q\"\
    :\n        case \"q\":\n            isAnUpper = true\n        case \"R\":\n  \
    \      case \"r\":\n            isAnUpper = true\n        case \"S\":\n      \
    \  case \"s\":\n            isAnUpper = true\n        case \"T\":\n        case\
    \ \"t\":\n            isAnUpper = true\n        case \"U\":\n        case \"u\"\
    :\n            isAnUpper = true\n        case \"V\":\n        case \"v\":\n  \
    \          isAnUpper = true\n        case \"W\":\n        case \"w\":\n      \
    \      isAnUpper = true\n        case \"X\":\n        case \"x\":\n          \
    \  isAnUpper = true\n        case \"Y\":\n        case \"y\":\n            isAnUpper\
    \ = true\n        case \"Z\":\n        case \"z\":\n            isAnUpper = true\n\
    \        default:\n            if isAnUpper {\n                ret += String(c)\n\
    \                isAnUpper = false\n            } else if isAnLower {\n      \
    \          ret += String(c)\n                isAnLower = false\n            }\
    \ else {\n                ret += String(c)\n            }\n        }\n    }\n\
    \    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9ibu3vvn.swift:20:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp9ibu3vvn.swift:23:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:26:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:29:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"F\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"G\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:41:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"H\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:44:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:47:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"J\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:50:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"K\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:53:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"L\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9ibu3vvn.swift:56:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \") { memo, char in\n        let lowerChar = char.lowercased\n        var upperChar\
    \ = char.uppercased\n        \n        if lowerChar == char {\n            upperChar\
    \ = upperChar.lowercased\n        } else {\n            upperChar = upperChar.uppercased\n\
    \        }\n\n        memo + String(upperChar) + String(lowerChar)\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0l2dx_a4.swift:19:12: error: cannot convert value of type '() ->\
    \ String' to expected argument type 'Character'\n        if lowerChar == char\
    \ {\n           ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let alphabet = Set(s.characters.map({\
    \ $0 }))\n    if alphabet.isEmpty {\n        return String(s.characters.reversed())\n\
    \    } else {\n        return String(s.characters.map {\n            switch $0\
    \ {\n            case letter, _ where letter.caseInsensitiveCompare(s.lowercased())\
    \ != .orderedSame:\n                letter.caseInsensitiveCompare(s.uppercased())\
    \ == .orderedSame ? $0.uppercased() : $0.lowercased()\n            case letter,\
    \ _ where letter.caseInsensitiveCompare(s.uppercased()) != .orderedSame:\n   \
    \             letter.caseInsensitiveCompare(s.lowercased()) == .orderedSame ?\
    \ $0.lowercased() : $0.uppercased()\n            case letter -> letter\n     \
    \       }\n        })\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8718lv3b.swift:25:34: error: expected ':' after 'case'\n      \
    \      case letter -> letter\n                                 ^\n/tmp/tmp8718lv3b.swift:15:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabet\
    \ = Set(s.characters.map({ $0 }))\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8718lv3b.swift:17:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        return String(s.characters.reversed())\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8718lv3b.swift:21:34: error: cannot find 'letter' in scope\n\
    \            case letter, _ where letter.caseInsensitiveCompare(s.lowercased())\
    \ != .orderedSame:\n                                 ^~~~~~\n/tmp/tmp8718lv3b.swift:22:17:\
    \ error: cannot find 'letter' in scope\n                letter.caseInsensitiveCompare(s.uppercased())\
    \ == .orderedSame ? $0.uppercased() : $0.lowercased()\n                ^~~~~~\n\
    /tmp/tmp8718lv3b.swift:23:34: error: cannot find 'letter' in scope\n         \
    \   case letter, _ where letter.caseInsensitiveCompare(s.uppercased()) != .orderedSame:\n\
    \                                 ^~~~~~\n/tmp/tmp8718lv3b.swift:24:17: error:\
    \ cannot find 'letter' in scope\n                letter.caseInsensitiveCompare(s.lowercased())\
    \ == .orderedSame ? $0.lowercased() : $0.uppercased()\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    \n    var res: String = \"\"\
    \n    \n    for char in s.characters{\n        if char.lowercased() != char {\n\
    \            res = res + String(char.uppercased())\n        } else {\n       \
    \     res = res + String(char)\n        }\n    }\n    \n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp92m1mtyw.swift:18:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters{\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp92m1mtyw.swift:19:33:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if char.lowercased() != char {\n                                ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ count = s.characters.count\n    for char in s.characters {\n        let isLetter\
    \ = Character.isLetter(char)\n        if isLetter {\n            let isUpper =\
    \ CharacterSet.isUppercase(char)\n            let newString = String(char).uppercased()\n\
    \            if isUpper != isLetter {\n                result = result.appending(newString)\n\
    \            } else {\n                result = result.appending(newString)\n\
    \            }\n        } else {\n            result = result.appending(char)\n\
    \        }\n    }\n    if count == 0 {\n        result = result.appending(String(s.characters.reversed()))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpq1rhxz1j.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var count = s.characters.count\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpq1rhxz1j.swift:17:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpq1rhxz1j.swift:18:34: error: cannot call value of non-function\
    \ type 'Bool'\n        let isLetter = Character.isLetter(char)\n             \
    \                    ^\n/tmp/tmpq1rhxz1j.swift:18:24: error: instance member 'isLetter'\
    \ cannot be used on type 'Character'; did you mean to use a value of this type\
    \ instead?\n        let isLetter = Character.isLetter(char)\n                \
    \       ^~~~~~~~~\n/tmp/tmpq1rhxz1j.swift:20:27: error: cannot find 'CharacterSet'\
    \ in scope\n            let isUpper = CharacterSet.isUppercase(char)\n       \
    \                   ^~~~~~~~~~~~\n/tmp/tmpq1rhxz1j.swift:23:33: error: value of\
    \ type 'String' has no member 'appending'\n                result = result.appending(newString)\n\
    \                         ~~~~~~ ^~~~~~~~~\n/tmp/tmpq1rhxz1j.swift:25:33: error:\
    \ value of type 'String' has no member 'appending'\n                result = result.appending(newString)\n\
    \                         ~~~~~~ ^~~~~~~~~\n/tmp/tmpq1rhxz1j.swift:28:29: error:\
    \ value of type 'String' has no member 'appending'\n            result = result.appending(char)\n\
    \                     ~~~~~~ ^~~~~~~~~\n/tmp/tmpq1rhxz1j.swift:32:25: error: value\
    \ of type 'String' has no member 'appending'\n        result = result.appending(String(s.characters.reversed()))\n\
    \                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let string = s.lowercased()\n\
    \    if string.characters.count == 0 { return string }\n    var result = \"\"\n\
    \    if let range = string.range(of: CharacterSet.letters.inverted) {\n      \
    \  let first = string[range]\n        let second = string[string.index(range.upperBound,\
    \ offsetBy: 1)]\n        result = first + String(second)\n    }\n    if string.characters.count\
    \ > 0 { return result }\n    return string.lowercased()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpba4mr6cp.swift:16:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count == 0 { return string }\n\
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpba4mr6cp.swift:18:37: error: cannot find 'CharacterSet' in scope\n\
    \    if let range = string.range(of: CharacterSet.letters.inverted) {\n      \
    \                              ^~~~~~~~~~~~\n/tmp/tmpba4mr6cp.swift:18:27: error:\
    \ value of type 'String' has no member 'range'\n    if let range = string.range(of:\
    \ CharacterSet.letters.inverted) {\n                   ~~~~~~ ^~~~~\n/tmp/tmpba4mr6cp.swift:23:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    if string.characters.count\
    \ > 0 { return result }\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \") { (result, char) -> String in\n        let upperCase = Character(char).isUppercase\n\
    \        let lowerCase = Character(char).isLowercase\n        if upperCase {\n\
    \            return result.uppercased()\n        } else if lowerCase {\n     \
    \       return result.lowercased()\n        } else {\n            return result\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp78njjl6i.swift:16:35: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        let upperCase = Character(char).isUppercase\n             \
    \                     ^\n                                  extendedGraphemeClusterLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var resultString = s\n    for\
    \ index in stride(from: s.count, to: 0, by: -1) {\n        guard let firstCharacter\
    \ = s[index].lowercased() else {\n            break\n        }\n        if let\
    \ secondCharacter = s[index + 1].lowercased() {\n            firstCharacter =\
    \ firstCharacter.uppercased()\n            resultString = (firstCharacter + secondCharacter\
    \ + resultString)\n        } else {\n            resultString = (firstCharacter\
    \ + resultString)\n        }\n    }\n    return resultString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqbpe39gt.swift:17:36: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        guard let\
    \ firstCharacter = s[index].lowercased() else {\n                            \
    \       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpqbpe39gt.swift:17:15: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n        guard let firstCharacter\
    \ = s[index].lowercased() else {\n              ^                    ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqbpe39gt.swift:20:34: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if let secondCharacter\
    \ = s[index + 1].lowercased() {\n                                 ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqbpe39gt.swift:21:13:\
    \ error: cannot assign to value: 'firstCharacter' is a 'let' constant\n      \
    \      firstCharacter = firstCharacter.uppercased()\n            ^~~~~~~~~~~~~~\n\
    /tmp/tmpqbpe39gt.swift:20:12: error: initializer for conditional binding must\
    \ have Optional type, not 'String'\n        if let secondCharacter = s[index +\
    \ 1].lowercased() {\n           ^                     ~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? \"\" : s.first!.reduce({\
    \ (result, ch) in\n        if ch.isLetter {\n            ch.isUpper = ch.isUpper\
    \ ? false : true\n        }\n        return result + String(ch)\n    }).reversed().reduce({\
    \ (result, ch) in\n        if !ch.isUpper {\n            ch.isUpper = true\n \
    \       }\n        return result + String(ch)\n    }).reversed().reduce({ (result,\
    \ ch) in\n        if !ch.isUpper {\n            ch.isUpper = true\n        }\n\
    \        return result + String(ch)\n    }).reversed()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpuiltlcqg.swift:15:38: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'reduce'\n    return s.isEmpty ? \"\" : s.first!.reduce({\
    \ (result, ch) in\n                            ~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979444
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ lastChar = \"\"\n    for ch in s.characters {\n        switch ch {\n       \
    \ case \"A\":\n        case \"a\": // To uppercase A to A or a\n            lastChar\
    \ = lastChar.capitalizingFirstLetter()\n        case \"B\":\n        case \"b\"\
    :\n            lastChar = lastChar.capitalizingFirstLetter()\n        case \"\
    C\":\n        case \"c\": // To uppercase C to C or c\n            lastChar =\
    \ lastChar.capitalizingFirstLetter()\n        case \"D\":\n        case \"d\"\
    :\n            lastChar = lastChar.capitalizingFirstLetter()\n        case \"\
    E\":\n        case \"e\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"F\":\n        case \"f\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"G\":\n        case \"g\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"H\":\n        case \"h\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"I\":\n        case \"i\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"J\":\n        case \"j\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"K\":\n        case \"k\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"L\":\n        case \"l\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"M\":\n        case \"m\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"N\":\n        case \"n\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"O\":\n        case \"o\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"P\":\n        case \"p\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"Q\":\n        case \"q\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"R\":\n        case \"r\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"S\":\n        case \"s\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"T\":\n        case \"t\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"U\":\n        case \"u\":\n            lastChar = lastChar.capitaliz\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp858w6na9.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp858w6na9.swift:22:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:25:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"F\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"G\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"H\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:43:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:46:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"J\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:49:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"K\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:52:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"L\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp858w6na9.swift:55:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if !s.isEmpty {\n        switch\
    \ s[0] {\n        case \"a\": return s.reversed\n        case \"A\": return s.lowercased\n\
    \        case \"b\": return s.reversed\n        case \"B\": return s.uppercased\n\
    \        case \"#\": return s.lowercased\n        case \"@\": return s.uppercased\n\
    \        default: return s\n        }\n    }\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppnlkcws_.swift:16:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        switch s[0]\
    \ {\n               ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmppnlkcws_.swift:17:28: error: no 'reversed' candidates produce\
    \ the expected contextual result type 'String'\n        case \"a\": return s.reversed\n\
    \                           ^\nSwift.Sequence:2:40: note: found candidate with\
    \ type '() -> [String.Element]' (aka '() -> Array<Character>')\n    @inlinable\
    \ public __consuming func reversed() -> [Self.Element]\n                     \
    \                  ^\nSwift.BidirectionalCollection:2:40: note: found candidate\
    \ with type '() -> ReversedCollection<String>'\n    @inlinable public __consuming\
    \ func reversed() -> ReversedCollection<Self>\n                              \
    \         ^\n/tmp/tmppnlkcws_.swift:18:28: error: function produces expected type\
    \ 'String'; did you mean to call it with '()'?\n        case \"A\": return s.lowercased\n\
    \                         ~~^~~~~~~~~~\n                                     ()\n\
    /tmp/tmppnlkcws_.swift:19:28: error: no 'reversed' candidates produce the expected\
    \ contextual result type 'String'\n        case \"b\": return s.reversed\n   \
    \                        ^\nSwift.Sequence:2:40: note: found candidate with type\
    \ '() -> [String.Element]' (aka '() -> Array<Character>')\n    @inlinable public\
    \ __consuming func reversed() -> [Self.Element]\n                            \
    \           ^\nSwift.BidirectionalCollection:2:40: note: found candidate with\
    \ type '() -> ReversedCollection<String>'\n    @inlinable public __consuming func\
    \ reversed() -> ReversedCollection<Self>\n                                   \
    \    ^\n/tmp/tmppnlkcws_.swift:20:28: error: function produces expected type 'String';\
    \ did you mean to call it with '()'?\n        case \"B\": return s.uppercased\n\
    \                         ~~^~~~~~~~~~\n                                     ()\n\
    /tmp/tmppnlkcws_.swift:2"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let chars = s.characters\n\
    \    var result = \"\"\n\n    for char in chars {\n        switch char {\n   \
    \     case let c where isLetter(c) {\n            result.append(isUpper(c) ? String(c).capitalized\
    \ : String(c))\n        default:\n            result.append(char)\n        }\n\
    \    }\n    result.reverse()\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdw0wtc1u.swift:22:9: error: 'default' label can only appear inside\
    \ a 'switch' statement\n        default:\n        ^\n/tmp/tmpdw0wtc1u.swift:24:10:\
    \ error: expected ':' after 'case'\n        }\n         ^\n/tmp/tmpdw0wtc1u.swift:51:35:\
    \ error: expected '}' at end of brace statement\nassert(solve(s: \"#ccc\") ==\
    \ \"#CCC\")\n                                  ^\n/tmp/tmpdw0wtc1u.swift:14:33:\
    \ note: to match this opening '{'\nfunc solve(s: String) -> String {\n       \
    \                         ^\n/tmp/tmpdw0wtc1u.swift:15:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    let chars = s.characters\n \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdw0wtc1u.swift:20:26: error: cannot find 'isLetter' in scope\n  \
    \      case let c where isLetter(c) {\n                         ^~~~~~~~\n/tmp/tmpdw0wtc1u.swift:21:27:\
    \ error: cannot find 'isUpper' in scope\n            result.append(isUpper(c)\
    \ ? String(c).capitalized : String(c))\n                          ^~~~~~~\n/tmp/tmpdw0wtc1u.swift:32:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n\n    for str\
    \ in str {\n        if str.lowercased() != str.uppercased() {\n            str\
    \ = str.lowercased()\n        }\n    }\n\n    return str\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpq51cs8qu.swift:19:13: error: cannot assign to value: 'str' is a\
    \ 'let' constant\n            str = str.lowercased()\n            ^~~\n/tmp/tmpq51cs8qu.swift:19:23:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  str = str.lowercased()\n                  ~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \") { result, char in\n        guard let i = s.index(of: char) else { return result\
    \ }\n        switch char {\n        case 'A'...'Z':\n            return result.uppercased().append(char)\n\
    \        default:\n            return result.append(char)\n        }\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppc5gguz8.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A'...'Z':\n             ^~~\n             \"A\"\n/tmp/tmppc5gguz8.swift:18:20:\
    \ error: single-quoted string literal found, use '\"'\n        case 'A'...'Z':\n\
    \                   ^~~\n                   \"Z\"\n/tmp/tmppc5gguz8.swift:19:40:\
    \ error: cannot use mutating member on immutable value: function call returns\
    \ immutable value\n            return result.uppercased().append(char)\n     \
    \              ~~~~~~~~~~~~~~~~~~~ ^\n/tmp/tmppc5gguz8.swift:19:40: error: cannot\
    \ convert return expression of type '()' to return type 'String'\n           \
    \ return result.uppercased().append(char)\n                   ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = [Character](count:\
    \ s.count, repeatedValue: Character())\n    for index in 0..<s.count {\n     \
    \   let letter = s[index].toLowercase()\n        let temp = str.last!\n      \
    \  if letter != nil {\n            let tempStr = String(temp) + String(letter!)\n\
    \            str.removeLast()\n            str.append(tempStr)\n        } else\
    \ {\n            let tempStr = String(temp)\n            str.removeLast()\n  \
    \          str.append(tempStr)\n        }\n    }\n    return String(str)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpld3_6f65.swift:15:68: error: missing argument for parameter #1\
    \ in call\n    var str = [Character](count: s.count, repeatedValue: Character())\n\
    \                                                                   ^\n      \
    \                                                             <#Unicode.Scalar#>\n\
    Swift.Character:2:23: note: 'init(_:)' declared here\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\n/tmp/tmpld3_6f65.swift:15:58:\
    \ error: extra argument 'repeatedValue' in call\n    var str = [Character](count:\
    \ s.count, repeatedValue: Character())\n                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n\
    /tmp/tmpld3_6f65.swift:15:27: error: missing argument for parameter 'repeating'\
    \ in call\n    var str = [Character](count: s.count, repeatedValue: Character())\n\
    \                          ^\n                          repeating: <#Character#>,\
    \ \nSwift.Array:4:23: note: 'init(repeating:count:)' declared here\n    @inlinable\
    \ public init(repeating repeatedValue: Element, count: Int)\n                \
    \      ^\n/tmp/tmpld3_6f65.swift:17:31: error: value of type 'Character' has no\
    \ member 'toLowercase'\n        let letter = s[index].toLowercase()\n        \
    \             ~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ char in s {\n        switch char {\n        case \"a\": result = \"b\" + result\n\
    \        case \"b\": result = \"a\" + result\n        case \"c\": result = \"\
    d\" + result\n        case \"d\": result = \"c\" + result\n        case \"e\"\
    : result = \"f\" + result\n        case \"f\": result = \"e\" + result\n     \
    \   case \"g\": result = \"h\" + result\n        case \"h\": result = \"g\" +\
    \ result\n        case \"i\": result = \"j\" + result\n        case \"j\": result\
    \ = \"i\" + result\n        case \"k\": result = \"l\" + result\n        case\
    \ \"l\": result = \"k\" + result\n        case \"m\": result = \"n\" + result\n\
    \        case \"n\": result = \"m\" + result\n        case \"o\": result = \"\
    p\" + result\n        case \"p\": result = \"o\" + result\n        case \"q\"\
    : result = \"r\" + result\n        case \"r\": result = \"q\" + result\n     \
    \   case \"s\": result = \"t\" + result\n        case \"t\": result = \"s\" +\
    \ result\n        case \"u\": result = \"v\" + result\n        case \"v\": result\
    \ = \"u\" + result\n        case \"w\": result = \"x\" + result\n        case\
    \ \"x\": result = \"w\" + result\n        case \"y\": result = \"z\" + result\n\
    \        case \"z\": result = \"y\" + result\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6vwludjl.swift:45:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.hasPrefix(\"a\") ?\
    \ s.toUpper() : s.hasPrefix(\"A\") ? s.toUpper() : s\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpuhi48ip3.swift:15:33: error: value of type 'String' has no member\
    \ 'toUpper'\n    return s.hasPrefix(\"a\") ? s.toUpper() : s.hasPrefix(\"A\")\
    \ ? s.toUpper() : s\n                              ~ ^~~~~~~\n/tmp/tmpuhi48ip3.swift:15:66:\
    \ error: value of type 'String' has no member 'toUpper'\n    return s.hasPrefix(\"\
    a\") ? s.toUpper() : s.hasPrefix(\"A\") ? s.toUpper() : s\n                  \
    \                                             ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \") { c, e in\n        guard e.isLetter else {\n            return c.reversed()\n\
    \        }\n        if c.isEmpty {\n            return e\n        } else {\n \
    \           let r = c\n            let c2 = c.capitalized\n            let e =\
    \ e.lowercased\n            return r.prefix(c2).append(e)\n        }\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppbhfjye4.swift:17:22: error: cannot convert return expression of\
    \ type 'ReversedCollection<String>' to return type 'String'\n            return\
    \ c.reversed()\n                   ~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let alphabets = CharacterSet.letters.inverted\n\
    \    let letters = s.filter {\n        !alphabets.contains($0)\n    }\n    return\
    \ String(letters.map { $0.capitalized })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpr5xovciv.swift:15:21: error: cannot find 'CharacterSet' in scope\n\
    \    let alphabets = CharacterSet.letters.inverted\n                    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ char in s.characters {\n        if char.isLower() {\n            char.uppercase\n\
    \        } else if char.isUpper() {\n            char.lowercase\n        } else\
    \ {\n            char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmps6kn4ra6.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmps6kn4ra6.swift:17:17:\
    \ error: value of type 'Character' has no member 'isLower'\n        if char.isLower()\
    \ {\n           ~~~~ ^~~~~~~\n/tmp/tmps6kn4ra6.swift:18:18: error: value of type\
    \ 'Character' has no member 'uppercase'\n            char.uppercase\n        \
    \    ~~~~ ^~~~~~~~~\n/tmp/tmps6kn4ra6.swift:19:24: error: value of type 'Character'\
    \ has no member 'isUpper'\n        } else if char.isUpper() {\n              \
    \    ~~~~ ^~~~~~~\n/tmp/tmps6kn4ra6.swift:20:18: error: value of type 'Character'\
    \ has no member 'lowercase'\n            char.lowercase\n            ~~~~ ^~~~~~~~~\n\
    /tmp/tmps6kn4ra6.swift:22:13: warning: expression of type 'Character' is unused\n\
    \            char\n            ^~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return String(s.map({ Character($0).isUppercase\
    \ ? \n        $0.capitalizingFirst() : $0 }))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6255fkqn.swift:16:12: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'capitalizingFirst'\n        $0.capitalizingFirst()\
    \ : $0 }))\n        ~~ ^~~~~~~~~~~~~~~~~\n/tmp/tmp6255fkqn.swift:15:37: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    return\
    \ String(s.map({ Character($0).isUppercase ? \n                              \
    \      ^\n                                    extendedGraphemeClusterLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    \n    var str = s.characters.map\
    \ {\n        \n        switch $0 {\n        case \".\": return nil\n        case\
    \ \"@\": return \"@\" // \"@\" will be converted into \"_\"\n        case \"#\"\
    : return \"#\" // \"#\" will be converted into \"#\"\n        default:\n     \
    \       return String($0)\n        }\n    }\n    \n    // Swap case\n    if str.count\
    \ == 0 {\n        return \"\"\n    }\n    \n    var index = 0\n    \n    // Reverse\
    \ all string and store in the new array str.\n    for index in 0 ..< str.count\
    \ {\n        str[index] = String((str.index(index, offsetBy: -1) + str.index(index,\
    \ offsetBy: 1)).unicodeScalars.first!)\n    }\n    \n    return str.map { (char)\
    \ -> String in\n        \n        if char == \"_\" {\n            return \"@\"\
    .unicodeScalars.first!\n        }\n        if char == \"@\" {\n            return\
    \ \"#\".unicodeScalars.first!\n        }\n        if char == \"#\" {\n       \
    \     return \"#\".unicodeScalars.first!\n        }\n        return char\n   \
    \ }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5hqkgyol.swift:19:26: error: 'nil' requires a contextual type\n\
    \        case \".\": return nil\n                         ^\n/tmp/tmp5hqkgyol.swift:42:44:\
    \ error: cannot convert return expression of type 'Unicode.Scalar' to return type\
    \ 'String'\n            return \"@\".unicodeScalars.first!\n                 \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    var result = [Character](repeating: \"\", count: s.count)\n  \
    \  for character in s.characters {\n        result[s.index(of: character) ?? 0]\
    \ = character // handle nil\n    }\n    return result.reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwyxsudt3.swift:18:41: error: cannot convert value of type 'String'\
    \ to expected argument type 'Character'\n    var result = [Character](repeating:\
    \ \"\", count: s.count)\n                                        ^\n/tmp/tmpwyxsudt3.swift:19:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    for character\
    \ in s.characters {\n                       ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpwyxsudt3.swift:20:39: error: binary operator\
    \ '??' cannot be applied to operands of type 'String.Index?' and 'Int'\n     \
    \   result[s.index(of: character) ?? 0] = character // handle nil\n          \
    \     ~~~~~~~~~~~~~~~~~~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.isEmpty == false else\
    \ {\n        return s\n    }\n    var s = s\n    if s.characters.count > 0 {\n\
    \        let char = s.characters.first\n        s = String(s.characters.dropFirst())\n\
    \        switch char {\n        case \"A\":\n            s = s.uppercased()\n\
    \        case \"B\":\n            s = s.lowercased()\n        default:\n     \
    \       s = s\n        }\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1vql4z_w.swift:19:10: error: 'characters' is unavailable: Please\
    \ use String directly\n    if s.characters.count > 0 {\n         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1vql4z_w.swift:20:22:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = s.characters.first\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp1vql4z_w.swift:21:22: error: 'characters'\
    \ is unavailable: Please use String directly\n        s = String(s.characters.dropFirst())\n\
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1vql4z_w.swift:28:15: error: assigning a variable to itself\n   \
    \         s = s\n            ~ ^ ~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  return s.reduce((\"\", \"\"))\
    \ { (acc, element) in\n    acc.1.isEmpty  ? acc.0 : (acc.1, String(element.uppercased()\
    \ != element.lowercased() ? element.uppercased() : element))\n  }.0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpewndcuow.swift:16:26: error: result values in '? :' expression\
    \ have mismatching types 'String' and '(String, String)'\n    acc.1.isEmpty  ?\
    \ acc.0 : (acc.1, String(element.uppercased() != element.lowercased() ? element.uppercased()\
    \ : element))\n                     ~~~~^\n/tmp/tmpewndcuow.swift:16:100: error:\
    \ result values in '? :' expression have mismatching types 'String' and 'String.Element'\
    \ (aka 'Character')\n    acc.1.isEmpty  ? acc.0 : (acc.1, String(element.uppercased()\
    \ != element.lowercased() ? element.uppercased() : element))\n               \
    \                                                                            ~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n\n    for\
    \ char in s { // go through every character\n        guard let letter = String.UnicodeScalar(unicodeScalar:\
    \ char) else {\n            // character is not an ASCII letter\n            continue\n\
    \        }\n\n        switch letter {\n        case .lowercase:\n            let\
    \ lowerCase = String.UnicodeScalar(unicodeScalar: char)\n            result +=\
    \ String.UnicodeScalar(unicodeScalar: lowerCase)\n        case .uppercase:\n \
    \           let upperCase = String.UnicodeScalar(unicodeScalar: char)\n      \
    \      result += String.UnicodeScalar(unicodeScalar: upperCase)\n        default:\n\
    \            result += String.UnicodeScalar(unicodeScalar: char) // keep original\
    \ case\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1498587l.swift:18:35: error: type 'String' has no member 'UnicodeScalar'\n\
    \        guard let letter = String.UnicodeScalar(unicodeScalar: char) else {\n\
    \                           ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp1498587l.swift:25:36:\
    \ error: type 'String' has no member 'UnicodeScalar'\n            let lowerCase\
    \ = String.UnicodeScalar(unicodeScalar: char)\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmp1498587l.swift:26:30: error: type 'String' has no member\
    \ 'UnicodeScalar'\n            result += String.UnicodeScalar(unicodeScalar: lowerCase)\n\
    \                      ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp1498587l.swift:28:36: error:\
    \ type 'String' has no member 'UnicodeScalar'\n            let upperCase = String.UnicodeScalar(unicodeScalar:\
    \ char)\n                            ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp1498587l.swift:29:30:\
    \ error: type 'String' has no member 'UnicodeScalar'\n            result += String.UnicodeScalar(unicodeScalar:\
    \ upperCase)\n                      ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp1498587l.swift:31:30:\
    \ error: type 'String' has no member 'UnicodeScalar'\n            result += String.UnicodeScalar(unicodeScalar:\
    \ char) // keep original case\n                      ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ i in s.characters {\n        let char = String(i)\n        let char1 = String(char.uppercased())\n\
    \        let char2 = String(char.lowercased())\n        \n        if char == char1\
    \ {\n            result += char2\n        }\n        if char == char2 {\n    \
    \        result += char1\n        }\n        else {\n            result += char\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv1vb5ts4.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.hasAlpha\n       \
    \ ? s.characters.reversed().map { $0.isUppercase ? $1.toUppercase : $1 }.reversed().joinWithSeparator(\"\
    \")\n        : s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3mc9hj98.swift:15:14: error: value of type 'String' has no member\
    \ 'hasAlpha'\n    return s.hasAlpha\n           ~ ^~~~~~~~\n/tmp/tmp3mc9hj98.swift:16:39:\
    \ error: contextual closure type '(ReversedCollection<String>.Element) throws\
    \ -> T' (aka '(Character) throws -> T') expects 1 argument, but 2 were used in\
    \ closure body\n        ? s.characters.reversed().map { $0.isUppercase ? $1.toUppercase\
    \ : $1 }.reversed().joinWithSeparator(\"\")\n                                \
    \      ^\n/tmp/tmp3mc9hj98.swift:16:91: error: value of type 'ReversedCollection<Array<_>>'\
    \ has no member 'joinWithSeparator'\n        ? s.characters.reversed().map { $0.isUppercase\
    \ ? $1.toUppercase : $1 }.reversed().joinWithSeparator(\"\")\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let firstChar = s[0]\n    return\
    \ firstChar == .some(\"a\") ? .some(s.map({$0.isUppercase() ? $0.lowercased()\
    \ : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"A\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"#\"\
    ) ? .some(s.map({$0.isUppercase() ? $0.lowercased() : $0}).joinWithSeparator(\"\
    \")) : firstChar == .some(\"@\") ? .some(s.map({$0.isUppercase() ? $0.lowercased()\
    \ : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"c\") ? .some(s.reversed())\
    \ : .some(s.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvh4v5e6f.swift:15:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    let firstChar\
    \ = s[0]\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpvh4v5e6f.swift:16:39: error: type 'String' has\
    \ no member 'some'\n    return firstChar == .some(\"a\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"A\"\
    ) ? .some(s.map({$0.isUppercase() ? $0.lowercased() : $0}).joinWithSeparator(\"\
    \")) : firstChar == .some(\"#\") ? .some(s.map({$0.isUppercase() ? $0.lowercased()\
    \ : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"@\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"c\"\
    ) ? .some(s.reversed()) : .some(s.reversed())\n                              \
    \       ~^~~~\n/tmp/tmpvh4v5e6f.swift:16:54: error: cannot call value of non-function\
    \ type 'Bool'\n    return firstChar == .some(\"a\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"A\"\
    ) ? .some(s.map({$0.isUppercase() ? $0.lowercased() : $0}).joinWithSeparator(\"\
    \")) : firstChar == .some(\"#\") ? .some(s.map({$0.isUppercase() ? $0.lowercased()\
    \ : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"@\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"c\"\
    ) ? .some(s.reversed()) : .some(s.reversed())\n                              \
    \                       ^          ~~\n                                      \
    \                          \n/tmp/tmpvh4v5e6f.swift:16:73: error: result values\
    \ in '? :' expression have mismatching types 'String' and 'String.Element' (aka\
    \ 'Character')\n    return firstChar == .some(\"a\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"A\"\
    ) ? .some(s.map({$0.isUppercase() ? $0.lowercased() : $0}).joinWithSeparator(\"\
    \")) : firstChar == .s"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = \"\"\n    for let\
    \ i = 0; i < s.characters.count; i++ {\n        if let c = s.character(at: i)\
    \ {\n            if isAlphabet(c) {\n                switch c {\n            \
    \    case \"A\":\n                    res += \"a\"\n                case \"B\"\
    :\n                    res += \"b\"\n                case \"C\":\n           \
    \         res += \"c\"\n                case \"D\":\n                    res +=\
    \ \"d\"\n                case \"E\":\n                    res += \"e\"\n     \
    \           case \"F\":\n                    res += \"f\"\n                case\
    \ \"G\":\n                    res += \"g\"\n                case \"H\":\n    \
    \                res += \"h\"\n                case \"I\":\n                 \
    \   res += \"i\"\n                case \"J\":\n                    res += \"j\"\
    \n                case \"K\":\n                    res += \"k\"\n            \
    \    case \"L\":\n                    res += \"l\"\n                case \"M\"\
    :\n                    res += \"m\"\n                case \"N\":\n           \
    \         res += \"n\"\n                case \"O\":\n                    res +=\
    \ \"o\"\n                case \"P\":\n                    res += \"p\"\n     \
    \           case \"Q\":\n                    res += \"q\"\n                case\
    \ \"R\":\n                    res += \"r\"\n                case \"S\":\n    \
    \                res += \"s\"\n                case \"T\":\n                 \
    \   res += \"t\"\n                case \"U\":\n                    res += \"u\"\
    \n                case \"V\":\n                    res += \"v\"\n            \
    \    case \"W\":\n                    res += \"w\"\n                case \"X\"\
    :\n                    res += \"x\"\n                case \"Y\":\n           \
    \         res += \"y\"\n                case \"Z\":\n                    res +=\
    \ \"z\"\n                default:\n                    res += c\n            \
    \    }\n            } else {\n                res += c\n            }\n      \
    \  }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz3h3lb91.swift:16:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for let i = 0; i < s.characters.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpz3h3lb91.swift:17:36: error: cannot find 'i' in scope\n        if let\
    \ c = s.character(at: i) {\n                                   ^\n/tmp/tmpz3h3lb91.swift:17:22:\
    \ error: value of type 'String' has no member 'character'\n        if let c =\
    \ s.character(at: i) {\n                   ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.flatMap { Character($0).isUppercase\n\
    \        ? String(Character($0).lowercased())\n        : String(Character($0).uppercased())\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpl4acyal5.swift:15:14: error: cannot convert return expression of\
    \ type '[String.Element]' to return type 'String'\n    return s.flatMap { Character($0).isUppercase\n\
    \           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl4acyal5.swift:15:34:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  return s.flatMap { Character($0).isUppercase\n                            \
    \     ^\n                                 extendedGraphemeClusterLiteral: \n/tmp/tmpl4acyal5.swift:16:28:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      ? String(Character($0).lowercased())\n                           ^\n  \
    \                         extendedGraphemeClusterLiteral: \n/tmp/tmpl4acyal5.swift:17:28:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      : String(Character($0).uppercased()) }\n                           ^\n\
    \                           extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let s = String(s).lowercased()\n\
    \n    var r = \"\"\n    s.enumerated().forEach { index, char in\n        switch\
    \ char {\n        case \"a\":\n            switch index {\n            case 0:\
    \ r += char\n            case 1: r += char.capitalized\n            case 2: r\
    \ += char.capitalized.capitalized\n            default: r += char.capitalized\n\
    \            }\n        case \"b\": r += char.capitalized\n        case \"c\"\
    : r += char.capitalized.capitalized\n        case \"d\": r += char.capitalized.capitalized.capitalized\n\
    \        case \"e\":\n            switch index {\n            case 0: r += char\n\
    \            case 1: r += char.capitalized\n            case 2: r += char.capitalized.capitalized\n\
    \            case 3: r += char.capitalized.capitalized.capitalized\n         \
    \   default: r += char.capitalized.capitalized\n            }\n        case \"\
    f\": r += char.capitalized.capitalized\n        case \"g\":\n            switch\
    \ index {\n            case 0: r += char\n            case 1: r += char.capitalized\n\
    \            case 2: r += char.capitalized.capitalized\n            case 3: r\
    \ += char.capitalized.capitalized.capitalized\n            case 4: r += char.capitalized.capitalized.capitalized.capitalized\n\
    \            default: r += char.capitalized.capitalized.capitalized\n        \
    \    }\n        case \"h\":\n            switch index {\n            case 0: r\
    \ += char\n            case 1: r += char.capitalized\n            case 2: r +=\
    \ char.capitalized.capitalized\n            case 3: r += char.capitalized.capitalized.capitalized\n\
    \            case 4: r += char.capitalized.capitalized.capitalized.capitalized\n\
    \            case 5: r += char.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            default: r += char.capitalized.capitalized.capitalized\n        \
    \    }\n        case \"i\": \n            switch index {\n            case 0:\
    \ r += char\n            case 1: r += char.capitalized\n            case 2: r\
    \ += char.capitalized.capitalized\n            case 3: r += char.capitalized.capitalized.capitalized\n\
    \            case 4: r += char.capitalized.capitalized.capitalized.capitalized\n\
    \            case 5: r += char.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 6: r += char.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 7: r += char.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 8: r += char.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 9\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwhv8dsat.swift:69:19: error: expected ':' after 'case'\n      \
    \      case 9\n                  ^\n/tmp/tmpwhv8dsat.swift:92:35: error: expected\
    \ '}' at end of 'switch' statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n \
    \                                 ^\n/tmp/tmpwhv8dsat.swift:19:21: note: to match\
    \ this opening '{'\n        switch char {\n                    ^\n/tmp/tmpwhv8dsat.swift:92:35:\
    \ error: expected '}' at end of closure\nassert(solve(s: \"#ccc\") == \"#CCC\"\
    )\n                                  ^\n/tmp/tmpwhv8dsat.swift:18:28: note: to\
    \ match this opening '{'\n    s.enumerated().forEach { index, char in\n      \
    \                     ^\n/tmp/tmpwhv8dsat.swift:92:35: error: expected '}' at\
    \ end of brace statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n           \
    \                       ^\n/tmp/tmpwhv8dsat.swift:14:33: note: to match this opening\
    \ '{'\nfunc solve(s: String) -> String {\n                                ^\n\
    /tmp/tmpwhv8dsat.swift:22:26: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n            case 0: r\
    \ += char\n                         ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpa4h7d29q.swift:15:25: error: no 'reversed' candidates produce the\
    \ expected contextual result type 'String'\n    return s.characters.reversed()\n\
    \                        ^\nSwift.Sequence:2:40: note: 'reversed()' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func reversed() -> [Self.Element]\n       \
    \                                ^\nSwift.BidirectionalCollection:2:40: note:\
    \ 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().map(String.init).reduce(\"\
    \", { $0 + String($1) + String($2)})\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3qd4_iv_.swift:15:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().map(String.init).reduce(\"\
    \", { $0 + String($1) + String($2)})\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979500
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.hasPrefix(\"#\") ?\
    \ s.reversed()! : s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptbzkr1vv.swift:15:29: error: cannot convert return expression of\
    \ type 'ReversedCollection<String>' to return type 'String'\n    return s.hasPrefix(\"\
    #\") ? s.reversed()! : s\n           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmptbzkr1vv.swift:15:43:\
    \ error: cannot force unwrap value of non-optional type 'ReversedCollection<String>'\n\
    \    return s.hasPrefix(\"#\") ? s.reversed()! : s\n                         \
    \     ~~~~~~~~~~~~^\n                                          \n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty\n        ?\
    \ s\n        : (s.first >= \"a\" && s.first <= \"z\")\n            ? s.stringByReplacingOccurrencesOfString(\"\
    a\", withString: \"A\")\n            : (s.first >= \"A\" && s.first <= \"Z\")\n\
    \                ? s.stringByReplacingOccurrencesOfString(\"A\", withString: \"\
    a\")\n                : s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph44ze4fq.swift:17:20: error: type '((String.Element) throws ->\
    \ Bool) throws -> String.Element?' (aka '((Character) throws -> Bool) throws ->\
    \ Optional<Character>') cannot conform to 'StringProtocol'\n        : (s.first\
    \ >= \"a\" && s.first <= \"z\")\n                   ^\n/tmp/tmph44ze4fq.swift:17:20:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        : (s.first >= \"a\" && s.first <= \"z\")\n              \
    \     ^\n/tmp/tmph44ze4fq.swift:17:20: note: required by referencing operator\
    \ function '>=' on 'StringProtocol' where 'Self' = '((String.Element) throws ->\
    \ Bool) throws -> String.Element?' (aka '((Character) throws -> Bool) throws ->\
    \ Optional<Character>')\n        : (s.first >= \"a\" && s.first <= \"z\")\n  \
    \                 ^\n/tmp/tmph44ze4fq.swift:17:38: error: type '((String.Element)\
    \ throws -> Bool) throws -> String.Element?' (aka '((Character) throws -> Bool)\
    \ throws -> Optional<Character>') cannot conform to 'StringProtocol'\n       \
    \ : (s.first >= \"a\" && s.first <= \"z\")\n                                 \
    \    ^\n/tmp/tmph44ze4fq.swift:17:38: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n        : (s.first >= \"a\" && s.first\
    \ <= \"z\")\n                                     ^\n/tmp/tmph44ze4fq.swift:17:38:\
    \ note: required by referencing operator function '<=' on 'StringProtocol' where\
    \ 'Self' = '((String.Element) throws -> Bool) throws -> String.Element?' (aka\
    \ '((Character) throws -> Bool) throws -> Optional<Character>')\n        : (s.first\
    \ >= \"a\" && s.first <= \"z\")\n                                     ^\n/tmp/tmph44ze4fq.swift:18:17:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \            ? s.stringByReplacingOccurrencesOfString(\"a\", withString: \"A\"\
    )\n              ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmph44ze4fq.swift:19:24:\
    \ error: type '((String.Element) throws -> Bool) throws -> String.Element?' (aka\
    \ '((Character) throws -> Bool) throws -> Optional<Character>') cannot conform\
    \ to 'StringProtocol'\n            :"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // write your code in Swift\
    \ 4.2 or later\n    \n    var result = s\n    for i in s.characters {\n      \
    \  if i.isUppercase {\n            result = result.replacingOccurrences(of: i.rawValue,\
    \ with: i.lowercased())\n        } else {\n            result = result.replacingOccurrences(of:\
    \ i.rawValue, with: i.uppercased())\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgup6uf_w.swift:18:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgup6uf_w.swift:20:29:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     result = result.replacingOccurrences(of: i.rawValue, with: i.lowercased())\n\
    \                     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgup6uf_w.swift:20:56:\
    \ error: value of type 'Character' has no member 'rawValue'\n            result\
    \ = result.replacingOccurrences(of: i.rawValue, with: i.lowercased())\n      \
    \                                               ~ ^~~~~~~~\n/tmp/tmpgup6uf_w.swift:22:29:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     result = result.replacingOccurrences(of: i.rawValue, with: i.uppercased())\n\
    \                     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgup6uf_w.swift:22:56:\
    \ error: value of type 'Character' has no member 'rawValue'\n            result\
    \ = result.replacingOccurrences(of: i.rawValue, with: i.uppercased())\n      \
    \                                               ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = ''\n\n    for\
    \ s in s.characters.reverse() {\n        if s.isLower{\n            result +=\
    \ s.capitalized\n        }else{\n            result += s\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppicfsiht.swift:15:18: error: single-quoted string literal found,\
    \ use '\"'\n    var result = ''\n                 ^~\n                 \"\"\n\
    /tmp/tmppicfsiht.swift:17:27: error: value of type 'String' has no member 'reverse'\n\
    \    for s in s.characters.reverse() {\n             ~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ i in s.characters {\n        switch i {\n        case 97..122:\n           \
    \ result += String(i - 32)\n        case 65..90:\n            result += String(i\
    \ + 32)\n        case 32:\n            break\n        default:\n            result\
    \ += String(i)\n        }\n    }\n    if result.characters.count == 0 {\n    \
    \    result = reverseString(s)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzgi5m9xc.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzgi5m9xc.swift:18:16:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        case\
    \ 97..122:\n               ^~\n               ...\n/tmp/tmpzgi5m9xc.swift:20:16:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        case\
    \ 65..90:\n               ^~\n               ...\n/tmp/tmpzgi5m9xc.swift:22:14:\
    \ error: expression pattern of type 'Int' cannot match values of type 'Character'\n\
    \        case 32:\n             ^~\n/tmp/tmpzgi5m9xc.swift:19:30: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Int'\n        \
    \    result += String(i - 32)\n                             ^\n/tmp/tmpzgi5m9xc.swift:21:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            result += String(i + 32)\n                             ^\n/tmp/tmpzgi5m9xc.swift:28:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    if result.characters.count\
    \ == 0 {\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpzgi5m9xc.swift:29:18: error: cannot find 'reverseString'\
    \ in scope\n        result = reverseString(s)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let result = s.characters.reversed().map{\
    \ String($0) }\n        .joined()\n    return result == s ? \"#\" + result : result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpym626a8v.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let result = s.characters.reversed().map{ String($0)\
    \ }\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // init result and result length\n\
    \    var result: String = \"\"\n    var resultLength = 0\n\n    // init stack\
    \ array\n    var stack = Array<String>()\n\n    // init char array\n    var charArray\
    \ = Array(s.characters)\n\n    for char in charArray {\n        switch char {\n\
    \        case 'a':\n        case 'A':\n        case 'b':\n        case 'B':\n\
    \        case 'c':\n        case 'C':\n        case 'd':\n        case 'D':\n\
    \        case 'e':\n        case 'E':\n        case 'f':\n        case 'F':\n\
    \        case 'g':\n        case 'G':\n        case 'h':\n        case 'H':\n\
    \        case 'i':\n        case 'I':\n        case 'j':\n        case 'J':\n\
    \        case 'k':\n        case 'K':\n        case 'l':\n        case 'L':\n\
    \        case 'm':\n        case 'M':\n        case 'n':\n        case 'N':\n\
    \        case 'o':\n        case 'O':\n        case 'p':\n        case 'P':\n\
    \        case 'q':\n        case 'Q':\n        case 'r':\n        case 'R':\n\
    \        case 's':\n        case 'S':\n        case 't':\n        case 'T':\n\
    \        case 'u':\n        case 'U':\n        case 'v':\n        case 'V':\n\
    \        case 'w':\n        case 'W':\n        case 'x':\n        case 'X':\n\
    \        case 'y':\n        case 'Y':\n        case 'z':\n        case 'Z':\n\
    \            stack.append(String(char))\n        default:\n            // append\
    \ char at the end of result\n            result += String(char)\n\n          \
    \  // update result length\n            resultLength += 1\n        }\n    }\n\n\
    \    // reverse stack\n    stack.reverse()\n\n    // append stack with result\n\
    \    for char in stack {\n        result += char\n    }\n\n    // return result\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpanrdegas.swift:27:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpanrdegas.swift:27:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpanrdegas.swift:28:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'A':\n   \
    \          ^~~\n             \"A\"\n/tmp/tmpanrdegas.swift:28:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmpanrdegas.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpanrdegas.swift:29:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'b':\n        ^~~~~~~~~\n                  break\n/tmp/tmpanrdegas.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'B':\n   \
    \          ^~~\n             \"B\"\n/tmp/tmpanrdegas.swift:30:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'B':\n        ^~~~~~~~~\n                  break\n/tmp/tmpanrdegas.swift:31:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmpanrdegas.swift:31:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'c':\n        ^~~~~~~~~\n                  break\n/tmp/tmpanrdegas.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'C':\n   \
    \          ^~~\n             \"C\"\n/tmp/tmpanrdegas.swift:32:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'C':\n        ^~~~~~~~~\n                  break\n/tmp/tmpanrdegas.swift:33:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'd':\n   \
    \          ^~~\n             \"d\"\n/tmp/tmpanrdegas.swift:33:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        "
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty{\n        return\
    \ s\n    }\n    let reversedString = s.map { character -> String in\n        switch\
    \ character {\n        case \"A\"..\"Z\": return \"a\" + character\n        case\
    \ \"a\"..\"z\": return character + character.capitalized\n        default: return\
    \ String(character)\n        }\n    }.reduce(\"\") { $0 + String($1) }\n    return\
    \ reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5jifu1z7.swift:20:37: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        case \"A\"..\"\
    Z\": return \"a\" + character\n                                    ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if isLetterString(s) {\n  \
    \      return s.characters.reversed()\n    }\n    else {\n        return String(s.characters.reversed())\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpj4ygtn8n.swift:15:8: error: cannot find 'isLetterString' in scope\n\
    \    if isLetterString(s) {\n       ^~~~~~~~~~~~~~\n/tmp/tmpj4ygtn8n.swift:16:29:\
    \ error: no 'reversed' candidates produce the expected contextual result type\
    \ 'String'\n        return s.characters.reversed()\n                         \
    \   ^\nSwift.Sequence:2:40: note: 'reversed()' produces '[String.Element]' (aka\
    \ 'Array<Character>'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func reversed() -> [Self.Element]\n                     \
    \                  ^\nSwift.BidirectionalCollection:2:40: note: 'reversed()' produces\
    \ 'ReversedCollection<String>', not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n/tmp/tmpj4ygtn8n.swift:19:25: error:\
    \ 'characters' is unavailable: Please use String directly\n        return String(s.characters.reversed())\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.count < 1 { return \"\"\
    \ }\n    var result = \"\"\n    for i in 0..<s.count {\n        let c = s[i]\n\
    \        if c == Character(\"a\") { result = result + Character(\"A\") }\n   \
    \     else if c == Character(\"b\") { result = result + Character(\"B\") }\n \
    \       else if c == Character(\"c\") { result = result + Character(\"C\") }\n\
    \        else if c == Character(\"d\"){ result = result + Character(\"D\") }\n\
    \        else if c == Character(\"e\") { result = result + Character(\"E\") }\n\
    \        else if c == Character(\"f\") { result = result + Character(\"F\") }\n\
    \        else if c == Character(\"g\") { result = result + Character(\"G\") }\n\
    \        else if c == Character(\"h\") { result = result + Character(\"H\") }\n\
    \        else if c == Character(\"i\") { result = result + Character(\"I\") }\n\
    \        else if c == Character(\"j\") { result = result + Character(\"J\") }\n\
    \        else if c == Character(\"k\") { result = result + Character(\"K\") }\n\
    \        else if c == Character(\"l\") { result = result + Character(\"L\") }\n\
    \        else if c == Character(\"m\") { result = result + Character(\"M\") }\n\
    \        else if c == Character(\"n\") { result = result + Character(\"N\") }\n\
    \        else if c == Character(\"o\") { result = result + Character(\"O\") }\n\
    \        else if c == Character(\"p\") { result = result + Character(\"P\") }\n\
    \        else if c == Character(\"q\") { result = result + Character(\"Q\") }\n\
    \        else if c == Character(\"r\") { result = result + Character(\"R\") }\n\
    \        else if c == Character(\"s\") { result = result + Character(\"S\") }\n\
    \        else if c == Character(\"t\") { result = result + Character(\"T\") }\n\
    \        else if c == Character(\"u\") { result = result + Character(\"U\") }\n\
    \        else if c == Character(\"v\") { result = result + Character(\"V\") }\n\
    \        else if c == Character(\"w\") { result = result + Character(\"W\") }\n\
    \        else if c == Character(\"x\") { result = result + Character(\"X\") }\n\
    \        else if c == Character(\"y\") { result = result + Character(\"Y\") }\n\
    \        else if c == Character(\"z\") { result = result + Character(\"Z\") }\n\
    \        else { result = result + c }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwxx18zgi.swift:18:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let c = s[i]\n\
    \                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwxx18zgi.swift:19:52: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n        if c == Character(\"\
    a\") { result = result + Character(\"A\") }\n                                \
    \                   ^\n/tmp/tmpwxx18zgi.swift:20:57: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n        else if c ==\
    \ Character(\"b\") { result = result + Character(\"B\") }\n                  \
    \                                      ^\n/tmp/tmpwxx18zgi.swift:21:57: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        else if c == Character(\"c\") { result = result + Character(\"C\") }\n\
    \                                                        ^\n/tmp/tmpwxx18zgi.swift:22:56:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        else if c == Character(\"d\"){ result = result + Character(\"D\") }\n\
    \                                                       ^\n/tmp/tmpwxx18zgi.swift:23:57:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        else if c == Character(\"e\") { result = result + Character(\"E\") }\n\
    \                                                        ^\n/tmp/tmpwxx18zgi.swift:24:57:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        else if c == Character(\"f\") { result = result + Character(\"F\") }\n\
    \                                                        ^\n/tmp/tmpwxx18zgi.swift:25:57:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        else if c == Character(\"g\") { result = result + Character(\"G\") }\n\
    \                                                        ^\n/tmp/tmpwxx18zgi.swift:26:57"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let newS = s.characters.map\
    \ { c in\n        switch c {\n        case Character(\"a\"):\n            return\
    \ Character(\"A\")\n        case Character(\"A\"):\n            return Character(\"\
    a\")\n        default:\n            return c\n        }\n    }.joined()\n    return\
    \ newS\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp44sc_ycr.swift:18:20: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n            return Character(\"A\"\
    )\n                   ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n\n    var result = \"\"\n\n    var characters: [String] = []\n\n \
    \   for i in s.characters {\n        let character = Character(i)\n        if\
    \ !characters.contains(character) {\n            characters.append(character)\n\
    \        }\n    }\n\n    if characters.isEmpty {\n        result = s\n    } else\
    \ if characters.count == 1 {\n        result = characters.reduce(\"\", { $0 +\
    \ $1 })\n    } else {\n        var characterIndex = 0\n        var characterRange\
    \ = NSRange(location: 0, length: characters.count)\n\n        var reversedString\
    \ = characters\n        reversedString.reverse()\n\n        for i in reversedString\
    \ {\n            if i >= 97 && i <= 122 {\n                characterIndex += 1\n\
    \                characterRange.location += characterIndex\n                characterRange.length\
    \ -= characterIndex\n            }\n        }\n\n        result.replacingOccurrences(of:\
    \ characters, with: \"\")\n        result.replacingCharacters(in: characterRange,\
    \ with: \"\")\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2_ijdus.swift:23:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpg2_ijdus.swift:24:25:\
    \ error: no exact matches in call to initializer \n        let character = Character(i)\n\
    \                        ^\nSwift.Character:5:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(extendedGraphemeClusterLiteral:)')\n    @inlinable\
    \ public init(extendedGraphemeClusterLiteral value: Character)\n             \
    \         ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(unicodeScalarLiteral:)')\n \
    \   public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)\n\
    \           ^\n/tmp/tmpg2_ijdus.swift:36:30: error: cannot find 'NSRange' in scope\n\
    \        var characterRange = NSRange(location: 0, length: characters.count)\n\
    \                             ^~~~~~~\n/tmp/tmpg2_ijdus.swift:42:16: error: cannot\
    \ convert value of type 'String' to expected argument type 'Int'\n           \
    \ if i >= 97 && i <= 122 {\n               ^\n/tmp/tmpg2_ijdus.swift:42:27: error:\
    \ cannot convert value of type 'String' to expected argument type 'Int'\n    \
    \        if i >= 97 && i <= 122 {\n                          ^\n/tmp/tmpg2_ijdus.swift:49:16:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result.replacingOccurrences(of: characters, with: \"\")\n        ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpg2_ijdus.swift:50:16: error: value of type 'String' has no member 'replacingCharacters'\n\
    \        result.replacingCharacters(in: characterRange, with: \"\")\n        ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // 1\n    var rev = \"\"\n\
    \    \n    // 2\n    for char in s.characters {\n        \n        // 3\n    \
    \    guard let uppercaseChar = String(char).uppercased() else { continue }\n \
    \       \n        // 4\n        let charIndex = rev.index(of: uppercaseChar)\n\
    \        \n        // 5\n        if charIndex == nil {\n            rev += uppercaseChar\n\
    \        } else {\n            // 6\n            rev = rev[..<charIndex!]\n  \
    \          rev = rev + String(uppercaseChar)\n        }\n    }\n    \n    // 7\n\
    \    return rev\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpunnacs1l.swift:19:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpunnacs1l.swift:22:15:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \        guard let uppercaseChar = String(char).uppercased() else { continue }\n\
    \              ^                   ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpunnacs1l.swift:25:39:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let charIndex = rev.index(of: uppercaseChar)\n  \
    \                                    ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let chars = s.characters\n\
    \    var newS = s\n    \n    for i in 0..<s.count {\n        if chars[i] == Character(UnicodeScalar(\"\
    A\")) {\n            newS = newS.replacingCharacters(in: Range<String.Index>(start:\
    \ i, end: i+1), with: Character(UnicodeScalar(\"a\")))\n        } else if chars[i]\
    \ == Character(UnicodeScalar(\"a\")) {\n            newS = newS.replacingCharacters(in:\
    \ Range<String.Index>(start: i, end: i+1), with: Character(UnicodeScalar(\"A\"\
    )))\n        } else {\n            newS = newS.replacingCharacters(in: Range<String.Index>(start:\
    \ i, end: i+1), with: chars[i])\n        }\n    }\n    \n    return newS\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjh7b06tm.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjh7b06tm.swift:19:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if chars[i] == Character(UnicodeScalar(\"\
    A\")) {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpjh7b06tm.swift:20:25: error: value of type 'String'\
    \ has no member 'replacingCharacters'\n            newS = newS.replacingCharacters(in:\
    \ Range<String.Index>(start: i, end: i+1), with: Character(UnicodeScalar(\"a\"\
    )))\n                   ~~~~ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpjh7b06tm.swift:20:49:\
    \ error: referencing initializer 'init(_:)' on 'Range' requires that 'String.Index'\
    \ conform to 'Strideable'\n            newS = newS.replacingCharacters(in: Range<String.Index>(start:\
    \ i, end: i+1), with: Character(UnicodeScalar(\"a\")))\n                     \
    \                           ^\nSwift.Range:1:11: note: where 'Bound' = 'String.Index'\n\
    extension Range where Bound : Strideable, Bound.Stride : SignedInteger {\n   \
    \       ^\n/tmp/tmpjh7b06tm.swift:20:85: error: extra argument 'end' in call\n\
    \            newS = newS.replacingCharacters(in: Range<String.Index>(start: i,\
    \ end: i+1), with: Character(UnicodeScalar(\"a\")))\n                        \
    \                                           ~~~~~~~~~~~~~~~~~^~~\n/tmp/tmpjh7b06tm.swift:20:76:\
    \ error: cannot convert value of type 'Int' to expected argument type 'ClosedRange<String.Index>'\n\
    \            newS = newS.replacingCharacters(in: Range<String.Index>(start: i,\
    \ end: i+1), with: Character(UnicodeScalar(\"a\")))\n                        \
    \                                                   ^\n/tmp/tmpjh7b06tm.swift:21:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    \n \
    \   for c in self.chars {\n        if c == s.first {\n            if s.first ==\
    \ s.last {\n                result.append(String(c))\n            }\n        \
    \    else if s.first != s.last {\n                var first = String(c)\n    \
    \            first = first!.capitalized\n                var last = s.last!.capitalized\n\
    \                result.append(first)\n                result.append(last)\n \
    \           }\n        }\n        else if c.isLetter {\n            if let first\
    \ = s.first?.capitalized, let last = s.last?.capitalized {\n                result.append(first)\n\
    \                result.append(last)\n            }\n        }\n    }\n    \n\
    \    if result.count == 0 {\n        result.append(s)\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp02641r.swift:17:14: error: cannot find 'self' in scope; did you\
    \ mean to use it in a type or extension context?\n    for c in self.chars {\n\
    \             ^~~~\n/tmp/tmpcp02641r.swift:25:36: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'capitalized'\n                var last = s.last!.capitalized\n\
    \                           ~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpcp02641r.swift:31:37:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'capitalized'\n\
    \            if let first = s.first?.capitalized, let last = s.last?.capitalized\
    \ {\n                           ~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpcp02641r.swift:31:69:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'capitalized'\n\
    \            if let first = s.first?.capitalized, let last = s.last?.capitalized\
    \ {\n                                                            ~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // write your code in JavaScript\
    \ (Node.js 8.9.4)\n    \n    // Write your code here\n    \n    return s;\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp0nbh8vul/tmp0nbh8vul.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2227f66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2227c5db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2227c5d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2227c5c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0nbh8vul                        0x00005566c3de0307 <unavailable> + 4871

    5    libc.so.6                          0x00002b2228152460 __libc_start_main +
    245

    6    tmp0nbh8vul                        0x00005566c3ddff49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? \"#\" +\
    \ solve(s.droped(while: {$0 == \" \"}.last!)) : s.lowercased()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5ju7j8sd.swift:15:38: error: value of type 'String' has no member\
    \ 'droped'\n    return s.isEmpty ? \"#\" + solve(s.droped(while: {$0 == \" \"\
    }.last!)) : s.lowercased()\n                                   ~ ^~~~~~\n/tmp/tmp5ju7j8sd.swift:15:36:\
    \ error: missing argument label 's:' in call\n    return s.isEmpty ? \"#\" + solve(s.droped(while:\
    \ {$0 == \" \"}.last!)) : s.lowercased()\n                                   ^\n\
    \                                   s: \n/tmp/tmp5ju7j8sd.swift:15:64: error:\
    \ value of type '(String) -> Bool' has no member 'last'\n    return s.isEmpty\
    \ ? \"#\" + solve(s.droped(while: {$0 == \" \"}.last!)) : s.lowercased()\n   \
    \                                                ~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce(\"\") { $0.isLetter()\
    \ ? $0.toUppercased().append($1.toLowercased()) : $0.append($1); } \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp664954et.swift:15:20: error: missing argument label 'into:' in\
    \ call\n    return s.reduce(\"\") { $0.isLetter() ? $0.toUppercased().append($1.toLowercased())\
    \ : $0.append($1); } \n                   ^\n                    into: \n/tmp/tmp664954et.swift:15:14:\
    \ error: cannot convert return expression of type '(_, _) -> _' to return type\
    \ 'String'\n    return s.reduce(\"\") { $0.isLetter() ? $0.toUppercased().append($1.toLowercased())\
    \ : $0.append($1); } \n           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp664954et.swift:15:21: error: cannot convert value of type 'String' to\
    \ expected argument type '(inout @escaping (_, _) -> _, String.Element) throws\
    \ -> ()' (aka '(inout @escaping (_, _) -> _, Character) throws -> ()')\n    return\
    \ s.reduce(\"\") { $0.isLetter() ? $0.toUppercased().append($1.toLowercased())\
    \ : $0.append($1); } \n                    ^\n"
  stdout: ''
  timestamp: 1659979403
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? \"#a@C\"\
    \ : s.isCaseSensitive ? reverse(s.lowercased()) : reverse(s.uppercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5y0xiuhu.swift:15:53: error: cannot find 'reverse' in scope\n \
    \   return s.isEmpty ? \"#a@C\" : s.isCaseSensitive ? reverse(s.lowercased())\
    \ : reverse(s.uppercased())\n                                                \
    \    ^~~~~~~\n/tmp/tmp5y0xiuhu.swift:15:79: error: cannot find 'reverse' in scope\n\
    \    return s.isEmpty ? \"#a@C\" : s.isCaseSensitive ? reverse(s.lowercased())\
    \ : reverse(s.uppercased())\n                                                \
    \                              ^~~~~~~\n/tmp/tmp5y0xiuhu.swift:15:35: error: value\
    \ of type 'String' has no member 'isCaseSensitive'\n    return s.isEmpty ? \"\
    #a@C\" : s.isCaseSensitive ? reverse(s.lowercased()) : reverse(s.uppercased())\n\
    \                                ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    \n    var result = \"\"\n \
    \   for char in s {\n        if char.isLetter() {\n            switch char {\n\
    \            case \"A\", \"a\", \"B\", \"b\", \"C\", \"c\", \"D\", \"d\", \"E\"\
    , \"e\", \"F\", \"f\", \"G\", \"g\", \"H\", \"h\", \"I\", \"i\", \"J\", \"j\"\
    , \"K\", \"k\", \"L\", \"l\", \"M\", \"m\", \"N\", \"n\", \"O\", \"o\", \"P\"\
    , \"p\", \"Q\", \"q\", \"R\", \"r\", \"S\", \"s\", \"T\", \"t\", \"U\", \"u\"\
    , \"V\", \"v\", \"W\", \"w\", \"X\", \"x\", \"Y\", \"y\", \"Z\", \"z\": result\
    \ = char.lowercaseString\n            default: result = char\n            }\n\
    \        }\n        else {\n            result = char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4xzjyu2.swift:18:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpw4xzjyu2.swift:20:292: error: value of type 'Character'\
    \ has no member 'lowercaseString'\n            case \"A\", \"a\", \"B\", \"b\"\
    , \"C\", \"c\", \"D\", \"d\", \"E\", \"e\", \"F\", \"f\", \"G\", \"g\", \"H\"\
    , \"h\", \"I\", \"i\", \"J\", \"j\", \"K\", \"k\", \"L\", \"l\", \"M\", \"m\"\
    , \"N\", \"n\", \"O\", \"o\", \"P\", \"p\", \"Q\", \"q\", \"R\", \"r\", \"S\"\
    , \"s\", \"T\", \"t\", \"U\", \"u\", \"V\", \"v\", \"W\", \"w\", \"X\", \"x\"\
    , \"Y\", \"y\", \"Z\", \"z\": result = char.lowercaseString\n                \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                          ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpw4xzjyu2.swift:21:31:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  default: result = char\n                              ^~~~\n/tmp/tmpw4xzjyu2.swift:25:22:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  result = char\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let arr = [s.characters.reversed()]\n\
    \    return arr.map({ $0.isUppercase() ? $0.lowercased() : $0 }).joinWithSeparator(\"\
    \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg8eq34a4.swift:15:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = [s.characters.reversed()]\n             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpg8eq34a4.swift:16:65:\
    \ error: value of type '[ReversedCollection<String>]' has no member 'joinWithSeparator'\n\
    \    return arr.map({ $0.isUppercase() ? $0.lowercased() : $0 }).joinWithSeparator(\"\
    \")\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmpg8eq34a4.swift:16:25: error: value of type 'ReversedCollection<String>'\
    \ has no member 'isUppercase'\n    return arr.map({ $0.isUppercase() ? $0.lowercased()\
    \ : $0 }).joinWithSeparator(\"\")\n                     ~~ ^~~~~~~~~~~\n/tmp/tmpg8eq34a4.swift:16:44:\
    \ error: value of type 'ReversedCollection<String>' has no member 'lowercased'\n\
    \    return arr.map({ $0.isUppercase() ? $0.lowercased() : $0 }).joinWithSeparator(\"\
    \")\n                                        ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let chars = s.characters\n\
    \    let result = \"\"\n    for c in chars {\n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n            if ch.isEmpty {\n                result += ch\n  \
    \          } else {\n                let lower = ch.lowercased()\n           \
    \     let upper = ch.uppercased()\n                if upper == lower {\n     \
    \               result += upper\n                } else {\n                  \
    \  result += lower\n                }\n            }\n        } else {\n     \
    \       result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcb_p0lxz.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcb_p0lxz.swift:18:42:\
    \ error: no exact matches in call to initializer \n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n                                         ^\n/tmp/tmpcb_p0lxz.swift:18:42:\
    \ note: found candidate with type '(Float16) -> UInt32'\n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n                                         ^\n/tmp/tmpcb_p0lxz.swift:18:42:\
    \ note: found candidate with type '(Float) -> UInt32'\n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n                                         ^\n/tmp/tmpcb_p0lxz.swift:18:42:\
    \ note: found candidate with type '(Double) -> UInt32'\n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n                                         ^\n/tmp/tmpcb_p0lxz.swift:18:42:\
    \ note: found candidate with type '(Float80) -> UInt32'\n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n                                         ^\n/tmp/tmpcb_p0lxz.swift:18:42:\
    \ note: found candidate with type '(Builtin.Int32) -> UInt32'\n        if let\
    \ ch = String(UnicodeScalar(UInt32(c)).value as String) {\n                  \
    \                       ^\n/tmp/tmpcb_p0lxz.swift:18:42: note: found candidate\
    \ with type '(Unicode.Scalar) -> UInt32'\n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n                                         ^\n/tmp/tmpcb_p0lxz.swift:18:59:\
    \ error: cannot convert value of type 'UInt32' to type 'String' in coercion\n\
    \        if let ch = String(UnicodeScalar(UInt32(c)).value as String) {\n    \
    \                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpcb_p0lxz.swift:31:20:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String' and\
    \ 'Character'\n            res"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ ch in s.characters.reverse() {\n        switch ch {\n        case \"a\":\n \
    \           result = \"A\"\n        case \"b\":\n            result = \"b\"\n\
    \        case \"c\":\n            result = \"c\"\n        case \"d\":\n      \
    \      result = \"d\"\n        case \"e\":\n            result = \"e\"\n     \
    \   case \"f\":\n            result = \"f\"\n        case \"g\":\n           \
    \ result = \"g\"\n        case \"h\":\n            result = \"h\"\n        case\
    \ \"i\":\n            result = \"i\"\n        case \"j\":\n            result\
    \ = \"j\"\n        case \"k\":\n            result = \"k\"\n        case \"l\"\
    :\n            result = \"l\"\n        case \"m\":\n            result = \"m\"\
    \n        case \"n\":\n            result = \"n\"\n        case \"o\":\n     \
    \       result = \"o\"\n        case \"p\":\n            result = \"p\"\n    \
    \    case \"q\":\n            result = \"q\"\n        case \"r\":\n          \
    \  result = \"r\"\n        case \"s\":\n            result = \"s\"\n        case\
    \ \"t\":\n            result = \"t\"\n        case \"u\":\n            result\
    \ = \"u\"\n        case \"v\":\n            result = \"v\"\n        case \"w\"\
    :\n            result = \"w\"\n        case \"x\":\n            result = \"x\"\
    \n        case \"y\":\n            result = \"y\"\n        case \"z\":\n     \
    \       result = \"z\"\n        default:\n            result = ch\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppume_wze.swift:16:28: error: value of type 'String' has no member\
    \ 'reverse'\n    for ch in s.characters.reverse() {\n              ~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce(\"\", { $0\
    \ + $1 + Character($0[$0.startIndex].lowercased() + $0[$0.startIndex].uppercased())\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2k_vcqmn.swift:15:35: error: binary operator '+' cannot be applied\
    \ to operands of type 'String' and 'Character'\n    return s.reduce(\"\", { $0\
    \ + $1 + Character($0[$0.startIndex].lowercased() + $0[$0.startIndex].uppercased())\
    \ })\n                          ~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979439
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(into:\
    \ \"\") { $0.append(Character($1)) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8h1_exn6.swift:15:75: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    return s.characters.reversed().reduce(into: \"\") { $0.append(Character($1))\
    \ }\n                                                                        \
    \  ^\n                                                                       \
    \   extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var a = s.characters\n    for\
    \ i:= 0..<s.characters.count {\n        if s[i] == a[i] {\n            if s[i].isLowercase\
    \ {\n                a[i] = a[i].uppercased()\n            } else {\n        \
    \        a[i] = a[i].lowercased()\n            }\n        }\n    }\n    return\
    \ String.fromChars(a)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg4_28ogf.swift:16:11: error: expected type\n    for i:= 0..<s.characters.count\
    \ {\n          ^\n           <#type#>\n/tmp/tmpg4_28ogf.swift:16:11: error: expected\
    \ 'in' after for-each pattern\n    for i:= 0..<s.characters.count {\n        \
    \  ^\n/tmp/tmpg4_28ogf.swift:16:11: error: expected Sequence expression for for-each\
    \ loop\n    for i:= 0..<s.characters.count {\n          ^\n/tmp/tmpg4_28ogf.swift:15:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    var a =\
    \ s.characters\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpg4_28ogf.swift:25:19: error: type 'String' has no member\
    \ 'fromChars'\n    return String.fromChars(a)\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = s\n    for i in\
    \ s.characters {\n        if i.isLetter {\n            switch i.unicodeScalars.first?.unicodeScalars.first\
    \ {\n            case .uppercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"A\"\n \
    \               case .lowercase:\n                    result += \"a\"\n      \
    \          }\n            case .lowercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"a\"\n \
    \               case .lowercase:\n                    result += \"A\"\n      \
    \          }\n            }\n        } else {\n            switch i.unicodeScalars.first?.unicodeScalars.first\
    \ {\n            case .uppercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"a\"\n \
    \               case .lowercase:\n                    result += \"A\"\n      \
    \          }\n            case .lowercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"A\"\n \
    \               case .lowercase:\n                    result += \"a\"\n      \
    \          }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmprcghdtd1.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprcghdtd1.swift:18:59:\
    \ error: type of expression is ambiguous without more context\n            switch\
    \ i.unicodeScalars.first?.unicodeScalars.first {\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmprcghdtd1.swift:20:68: error: type of expression is ambiguous without more\
    \ context\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmprcghdtd1.swift:27:68: error: type of expression is ambiguous without more\
    \ context\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmprcghdtd1.swift:35:59: error: type of expression is ambiguous without more\
    \ context\n            switch i.unicodeScalars.first?.unicodeScalars.first {\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmprcghdtd1.swift:37:68:\
    \ error: type of expression is ambiguous without more context\n              \
    \  switch result.unicodeScalars.first?.unicodeScalars.first {\n              \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmprcghdtd1.swift:44:68:\
    \ error: type of expression is ambiguous without more context\n              \
    \  switch result.unicodeScalars.first?.unicodeScalars.first {\n              \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reduce(\"\
    \\(self)\", { $0 + String($1) + String($2).lowercased() })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_sswp0so.swift:15:35: error: cannot find 'self' in scope; did you\
    \ mean to use it in a type or extension context?\n    return s.characters.reduce(\"\
    \\(self)\", { $0 + String($1) + String($2).lowercased() })\n                 \
    \                 ^~~~\n/tmp/tmp_sswp0so.swift:15:43: error: contextual closure\
    \ type '(String, String.Element) throws -> String' (aka '(String, Character) throws\
    \ -> String') expects 2 arguments, but 3 were used in closure body\n    return\
    \ s.characters.reduce(\"\\(self)\", { $0 + String($1) + String($2).lowercased()\
    \ })\n                                          ^\n"
  stdout: ''
  timestamp: 1659979407
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.map { Character(((($0\
    \ >= 'a' && $0 <= 'z') ? ($0 - 'a' + 'A') : (($0 >= 'A' && $0 <= 'Z') ? ($0 -\
    \ 'A' + 'a') : $0)))) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcj3_ltc5.swift:15:50: error: single-quoted string literal found,\
    \ use '\"'\n    return s.characters.map { Character(((($0 >= 'a' && $0 <= 'z')\
    \ ? ($0 - 'a' + 'A') : (($0 >= 'A' && $0 <= 'Z') ? ($0 - 'A' + 'a') : $0)))) }.joined()\n\
    \                                                 ^~~\n                      \
    \                           \"a\"\n/tmp/tmpcj3_ltc5.swift:15:63: error: single-quoted\
    \ string literal found, use '\"'\n    return s.characters.map { Character(((($0\
    \ >= 'a' && $0 <= 'z') ? ($0 - 'a' + 'A') : (($0 >= 'A' && $0 <= 'Z') ? ($0 -\
    \ 'A' + 'a') : $0)))) }.joined()\n                                           \
    \                   ^~~\n                                                    \
    \          \"z\"\n/tmp/tmpcj3_ltc5.swift:15:76: error: single-quoted string literal\
    \ found, use '\"'\n    return s.characters.map { Character(((($0 >= 'a' && $0\
    \ <= 'z') ? ($0 - 'a' + 'A') : (($0 >= 'A' && $0 <= 'Z') ? ($0 - 'A' + 'a') :\
    \ $0)))) }.joined()\n                                                        \
    \                   ^~~\n                                                    \
    \                       \"a\"\n/tmp/tmpcj3_ltc5.swift:15:82: error: single-quoted\
    \ string literal found, use '\"'\n    return s.characters.map { Character(((($0\
    \ >= 'a' && $0 <= 'z') ? ($0 - 'a' + 'A') : (($0 >= 'A' && $0 <= 'Z') ? ($0 -\
    \ 'A' + 'a') : $0)))) }.joined()\n                                           \
    \                                      ^~~\n                                 \
    \                                                \"A\"\n/tmp/tmpcj3_ltc5.swift:15:97:\
    \ error: single-quoted string literal found, use '\"'\n    return s.characters.map\
    \ { Character(((($0 >= 'a' && $0 <= 'z') ? ($0 - 'a' + 'A') : (($0 >= 'A' && $0\
    \ <= 'Z') ? ($0 - 'A' + 'a') : $0)))) }.joined()\n                           \
    \                                                                     ^~~\n  \
    \                                                                            \
    \                  \"A\"\n/tmp/tmpcj3_ltc5.swift:15:110: error: single-quoted\
    \ string literal found, use '\"'\n    return s.characters.map { "
  stdout: ''
  timestamp: 1659979555
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if let chars = s.characters\
    \ {\n        var reversedString = \"\"\n        for char in chars {\n        \
    \    switch char {\n            case 'a':\n                reversedString.append(char)\n\
    \            case 'A':\n                reversedString.append(char.uppercase)\n\
    \            case 'b':\n                reversedString.append(char)\n        \
    \    case 'B':\n                reversedString.append(char.lowercase)\n      \
    \      default:\n                reversedString.append(char)\n            }\n\
    \        }\n        return reversedString\n    }\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsp2n6rss.swift:19:18: error: single-quoted string literal found,\
    \ use '\"'\n            case 'a':\n                 ^~~\n                 \"a\"\
    \n/tmp/tmpsp2n6rss.swift:21:18: error: single-quoted string literal found, use\
    \ '\"'\n            case 'A':\n                 ^~~\n                 \"A\"\n\
    /tmp/tmpsp2n6rss.swift:23:18: error: single-quoted string literal found, use '\"\
    '\n            case 'b':\n                 ^~~\n                 \"b\"\n/tmp/tmpsp2n6rss.swift:25:18:\
    \ error: single-quoted string literal found, use '\"'\n            case 'B':\n\
    \                 ^~~\n                 \"B\"\n/tmp/tmpsp2n6rss.swift:15:22: error:\
    \ 'characters' is unavailable: Please use String directly\n    if let chars =\
    \ s.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpsp2n6rss.swift:22:44: error: value of type 'Character'\
    \ has no member 'uppercase'\n                reversedString.append(char.uppercase)\n\
    \                                      ~~~~ ^~~~~~~~~\n/tmp/tmpsp2n6rss.swift:26:44:\
    \ error: value of type 'Character' has no member 'lowercase'\n               \
    \ reversedString.append(char.lowercase)\n                                    \
    \  ~~~~ ^~~~~~~~~\n/tmp/tmpsp2n6rss.swift:15:8: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    if let chars = s.characters\
    \ {\n       ^           ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let res = \"\\(s)\"\n    if\
    \ s.isEmpty {\n        return res\n    }\n\n    var chars = [Character]()\n  \
    \  for i in s.characters {\n        if Character(i).isLetter {\n            chars.append(i)\n\
    \        } else {\n            chars.append(Character(i))\n        }\n    }\n\n\
    \    if chars.count > 0 {\n        let charsAsStrings = chars.map { String($0)\
    \ }\n        let reversed = charsAsStrings.map { String($0.reversed()) }\n   \
    \     let res = String.init(stringInterpolationSegments: reversed)\n        return\
    \ res\n    } else {\n        return String(s.reversed())\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmprubl0swk.swift:21:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprubl0swk.swift:22:12:\
    \ error: no exact matches in call to initializer \n        if Character(i).isLetter\
    \ {\n           ^\nSwift.Character:5:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(extendedGraphemeClusterLiteral:)')\n    @inlinable\
    \ public init(extendedGraphemeClusterLiteral value: Character)\n             \
    \         ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(unicodeScalarLiteral:)')\n \
    \   public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)\n\
    \           ^\n/tmp/tmprubl0swk.swift:25:36: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n            chars.append(Character(i))\n                          \
    \         ^\n                                   extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmprubl0swk.swift:32:26: error: no exact matches in call to initializer\
    \ \n        let res = String.init(stringInterpolationSegments: reversed)\n   \
    \                      ^\n/tmp/tmprubl0swk.swift:32:26: note: found candidate\
    \ with type '([String]) -> String'\n        let res = String.init(stringInterpolationSegments:\
    \ reversed)\n                         ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(stringInterpolationSegments:)', expected: '(describing:)')\n\
    \    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:3:23:\
    \ note: incorrect labels for candidate (have: '(stringInterpolationSegments:)',\
    \ expected: '(describing:)')\n    @inlinable public init<Subject>(describing instance:\
    \ Subject) where Subject : CustomStringConvertible\n                      ^\n\
    Swift.String:6:12: note: incorrect labels for candidate (have: '(stringInterpolationSegments:)',\
    \ expected: '(reflecting:)')\n    public i"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.map{ str\
    \ in\n        let result = str.lowercased().capitalized \n        return result\
    \ == str ? str : result\n    }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5_qt9qwg.swift:16:39: error: value of type 'String' has no member\
    \ 'capitalized'\n        let result = str.lowercased().capitalized \n        \
    \             ~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if !s.isEmpty {\n        let\
    \ alphabet = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\")\n    \
    \    let upperCases = CharacterSet(charactersIn: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n        \n        var resultString = s\n        if resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive) != nil {\n            resultString = resultString.replacingCharacters(in:\
    \ resultString.rangeOfCharacter(from: alphabet, options: .caseInsensitive), with:\
    \ \"\").replacingCharacters(in: resultString.rangeOfCharacter(from: upperCases,\
    \ options: .caseInsensitive), with: \"\")\n        }\n        if resultString.rangeOfCharacter(from:\
    \ upperCases, options: .caseInsensitive) != nil {\n            resultString =\
    \ resultString.replacingCharacters(in: resultString.rangeOfCharacter(from: upperCases,\
    \ options: .caseInsensitive), with: \"\").replacingCharacters(in: resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive), with: \"\")\n        }\n        return\
    \ resultString\n    }\n    else {\n        return s\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9n8_su_c.swift:16:24: error: cannot find 'CharacterSet' in scope\n\
    \        let alphabet = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\"\
    )\n                       ^~~~~~~~~~~~\n/tmp/tmp9n8_su_c.swift:17:26: error: cannot\
    \ find 'CharacterSet' in scope\n        let upperCases = CharacterSet(charactersIn:\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n                         ^~~~~~~~~~~~\n/tmp/tmp9n8_su_c.swift:20:25:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n        if resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive) != nil {\n           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp9n8_su_c.swift:20:68: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        if resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive) != nil {\n                            \
    \                                      ~^~~~~~~~~~~~~~~\n/tmp/tmp9n8_su_c.swift:21:41:\
    \ error: value of type 'String' has no member 'replacingCharacters'\n        \
    \    resultString = resultString.replacingCharacters(in: resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive), with: \"\").replacingCharacters(in: resultString.rangeOfCharacter(from:\
    \ upperCases, options: .caseInsensitive), with: \"\")\n                      \
    \     ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9n8_su_c.swift:21:78: error: value\
    \ of type 'String' has no member 'rangeOfCharacter'\n            resultString\
    \ = resultString.replacingCharacters(in: resultString.rangeOfCharacter(from: alphabet,\
    \ options: .caseInsensitive), with: \"\").replacingCharacters(in: resultString.rangeOfCharacter(from:\
    \ upperCases, options: .caseInsensitive), with: \"\")\n                      \
    \                                          ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp9n8_su_c.swift:21:121:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \            resultString = resultString.replacingCharacters(in: resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive), with: \"\").replacingCharacters(in: resultString.rang"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    var reverseString = \"\"\n    for i in 0..<s.count {\n       \
    \ var nextChar = s[i]\n        if nextChar.isLetter() {\n            nextChar\
    \ = nextChar.capitalized\n        }\n        reverseString += nextChar\n    }\n\
    \    return reverseString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5n_v3pyw.swift:20:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        var nextChar\
    \ = s[i]\n                       ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp5n_v3pyw.swift:21:21: error: cannot\
    \ call value of non-function type 'Bool'\n        if nextChar.isLetter() {\n \
    \                   ^       ~~\n                            \n/tmp/tmp5n_v3pyw.swift:22:33:\
    \ error: value of type 'Character' has no member 'capitalized'\n            nextChar\
    \ = nextChar.capitalized\n                       ~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp5n_v3pyw.swift:24:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        reverseString += nextChar\n                         ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = \"\"\n    for i in\
    \ s { \n        if i.isUppercase {\n            res = i.lowercased() + res\n \
    \       } else if i.isLowercase {\n            res = i.uppercased() + res\n  \
    \      } else {\n            res = i + res\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmprx0bhemi.swift:22:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            res = i + res\n            \
    \      ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = s\n    s.characters.forEach\
    \ { (c) in\n        switch c {\n        case Character(UnicodeScalar(\"a\".unicodeScalars.first!))\
    \ where isUpper(c):\n            res.lowercased()\n        case Character(UnicodeScalar(\"\
    A\".unicodeScalars.first!)) where isLower(c):\n            res.uppercased()\n\
    \        default:\n            res = s\n        }\n    }\n    return res\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpl8vq240i.swift:18:72: error: cannot find 'isUpper' in scope\n \
    \       case Character(UnicodeScalar(\"a\".unicodeScalars.first!)) where isUpper(c):\n\
    \                                                                       ^~~~~~~\n\
    /tmp/tmpl8vq240i.swift:20:72: error: cannot find 'isLower' in scope\n        case\
    \ Character(UnicodeScalar(\"A\".unicodeScalars.first!)) where isLower(c):\n  \
    \                                                                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var sArray = [Character](s)\n\
    \    var ans = \"\"\n    if let index = sArray.index(of: \"@\") {\n        sArray.removeSubrange(index..<sArray.endIndex)\n\
    \        ans += sArray.map({ String($0) }).joined()\n    }\n    if let index =\
    \ sArray.index(of: \"#\") {\n        sArray.removeSubrange(index..<sArray.endIndex)\n\
    \        ans += sArray.map({ String($0) }).joined()\n    }\n    ans += sArray.joined()\n\
    \    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdxqg5i93.swift:17:27: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    if let index = sArray.index(of: \"@\") {\n       \
    \                   ^\n/tmp/tmpdxqg5i93.swift:17:27: note: use 'firstIndex(of:)'\
    \ instead\n    if let index = sArray.index(of: \"@\") {\n                    \
    \      ^~~~~\n                          firstIndex\n/tmp/tmpdxqg5i93.swift:21:27:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    if let\
    \ index = sArray.index(of: \"#\") {\n                          ^\n/tmp/tmpdxqg5i93.swift:21:27:\
    \ note: use 'firstIndex(of:)' instead\n    if let index = sArray.index(of: \"\
    #\") {\n                          ^~~~~\n                          firstIndex\n\
    /tmp/tmpdxqg5i93.swift:25:19: error: no exact matches in call to instance method\
    \ 'joined'\n    ans += sArray.joined()\n                  ^\nSwift.Sequence:1:11:\
    \ note: candidate requires that 'Character' conform to 'StringProtocol' (requirement\
    \ specified as 'Self.Element' : 'StringProtocol')\nextension Sequence where Self.Element\
    \ : StringProtocol {\n          ^\nSwift.BidirectionalCollection:1:11: note: candidate\
    \ requires that the types 'Character' and 'String' be equivalent (requirement\
    \ specified as 'Self.Element' == 'String')\nextension BidirectionalCollection\
    \ where Self.Element == String {\n          ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newStr = \"\"\n    for\
    \ var i = 0; i < s.characters.count; i++ {\n        if let c = s.characters.element(at:\
    \ i).uppercase {\n            newStr += String(c.lowercase)\n        } else {\n\
    \            newStr += String(s.characters.element(at: i))\n        }\n    }\n\
    \    return newStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm4hrm0w6.swift:16:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < s.characters.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm4hrm0w6.swift:17:33: error: value of type 'String' has no member 'element'\n\
    \        if let c = s.characters.element(at: i).uppercase {\n                \
    \   ~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return solution(s)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpujkfghuj.swift:15:12: error: cannot find 'solution' in scope\n\
    \    return solution(s)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var chars = s.characters\n\
    \    for index in 0..<chars.count {\n        var char = chars[index]\n       \
    \ if char >= 'a' && char <= 'z' {\n            chars[index] = char.lowercased()\
    \ + char.uppercased()\n        } else if char >= 'A' && char <= 'Z' {\n      \
    \      chars[index] = char.uppercased() + char.lowercased()\n        } else {\n\
    \            chars[index] = char\n        }\n    }\n    return String(chars)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyw29v1v2.swift:18:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= 'a' && char <= 'z' {\n                   ^~~\n\
    \                   \"a\"\n/tmp/tmpyw29v1v2.swift:18:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= 'a' && char <= 'z' {\n  \
    \                                ^~~\n                                  \"z\"\n\
    /tmp/tmpyw29v1v2.swift:20:27: error: single-quoted string literal found, use '\"\
    '\n        } else if char >= 'A' && char <= 'Z' {\n                          ^~~\n\
    \                          \"A\"\n/tmp/tmpyw29v1v2.swift:20:42: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char >= 'A' && char <= 'Z'\
    \ {\n                                         ^~~\n                          \
    \               \"Z\"\n/tmp/tmpyw29v1v2.swift:15:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    var chars = s.characters\n                 \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpyw29v1v2.swift:17:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        var char = chars[index]\n             \
    \      ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpyw29v1v2.swift:19:18: error: cannot assign through subscript:\
    \ subscript is get-only\n            chars[index] = char.lowercased() + char.uppercased()\n\
    \            ~~~~~^~~~~~~\n/tmp/tmpyw29v1v2.swift:19:46: error: cannot assign\
    \ value of type 'String' to subscript of type 'Character'\n            chars[index]\
    \ = char.lowercased() + char.uppercased()\n                           ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyw29v1v2.swift:21:18: error: cannot assign through subscript: subscript\
    \ is get-only\n            chars[index] = char.uppercased() + char.lowercased()\n\
    \            ~~~~~^~~~~~~\n/tmp/tmpyw29v1v2.swift:21:46: error: cannot assign\
    \ v"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \", combine: { (result, char) in\n        guard let char = Character(char) else\
    \ {\n            return result\n        }\n        switch char {\n        case\
    \ 'A', 'B', 'C', 'D':\n            return result + String(char).lowercased\n \
    \       default:\n            return result + String(char)\n        }\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_c63bj_9.swift:20:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A', 'B', 'C', 'D':\n             ^~~\n             \"\
    A\"\n/tmp/tmp_c63bj_9.swift:20:19: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A', 'B', 'C', 'D':\n                  ^~~\n        \
    \          \"B\"\n/tmp/tmp_c63bj_9.swift:20:24: error: single-quoted string literal\
    \ found, use '\"'\n        case 'A', 'B', 'C', 'D':\n                       ^~~\n\
    \                       \"C\"\n/tmp/tmp_c63bj_9.swift:20:29: error: single-quoted\
    \ string literal found, use '\"'\n        case 'A', 'B', 'C', 'D':\n         \
    \                   ^~~\n                            \"D\"\n/tmp/tmp_c63bj_9.swift:15:42:\
    \ error: extraneous argument label 'combine:' in call\n    return s.characters.reversed().reduce(\"\
    \", combine: { (result, char) in\n                                         ^ \
    \   ~~~~~~~~~\n                                              \n/tmp/tmp_c63bj_9.swift:16:36:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      guard let char = Character(char) else {\n                             \
    \      ^\n                                   extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.map({ \n        if\
    \ $0.isLetter {\n            let upper = String($0.unicodeScalars.filter({ !$0.isSpace\
    \ }).map { $0.value })\n            let lower = String($0.unicodeScalars.filter({\
    \ $0.isSpace }).map { $0.value })\n            return String(format: \"%C%@\"\
    , upper, lower)\n        } else {\n            return $0\n        }\n    }).joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6civofi_.swift:17:25: error: no exact matches in call to initializer\
    \ \n            let upper = String($0.unicodeScalars.filter({ !$0.isSpace }).map\
    \ { $0.value })\n                        ^\n/tmp/tmp6civofi_.swift:17:25: note:\
    \ found candidate with type '([UInt32]) -> String'\n            let upper = String($0.unicodeScalars.filter({\
    \ !$0.isSpace }).map { $0.value })\n                        ^\n/tmp/tmp6civofi_.swift:17:25:\
    \ note: found candidate with type '([UInt32]) -> String'\n            let upper\
    \ = String($0.unicodeScalars.filter({ !$0.isSpace }).map { $0.value })\n     \
    \                   ^\n/tmp/tmp6civofi_.swift:17:25: note: found candidate with\
    \ type '([UInt32]) -> String'\n            let upper = String($0.unicodeScalars.filter({\
    \ !$0.isSpace }).map { $0.value })\n                        ^\n/tmp/tmp6civofi_.swift:17:63:\
    \ error: value of type 'Unicode.Scalar' has no member 'isSpace'\n            let\
    \ upper = String($0.unicodeScalars.filter({ !$0.isSpace }).map { $0.value })\n\
    \                                                           ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    s.forEach\
    \ {\n        guard let char = UnicodeScalar($0) else {\n            print(\"Invalid\
    \ Character\")\n            return \"\"\n        }\n        switch char {\n  \
    \      case let letter as UnicodeScalar:\n            switch letter {\n      \
    \      case let upperCase as UnicodeScalar:\n                result += String(unicodeScalars.filter({\
    \ $0.isUpperCase }).map { $0.value })\n            case let lowerCase as UnicodeScalar:\n\
    \                result += String(unicodeScalars.filter({ $0.isLowerCase }).map\
    \ { $0.value })\n            default:\n                result += String(letter.value)\n\
    \            }\n        default:\n            result += String(char.value)\n \
    \       }\n    }\n    if result == \"\" {\n        return result.reversed()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8mpm0cok.swift:25:34: error: cannot find 'unicodeScalars' in scope\n\
    \                result += String(unicodeScalars.filter({ $0.isUpperCase }).map\
    \ { $0.value })\n                                 ^~~~~~~~~~~~~~\n/tmp/tmp8mpm0cok.swift:27:34:\
    \ error: cannot find 'unicodeScalars' in scope\n                result += String(unicodeScalars.filter({\
    \ $0.isLowerCase }).map { $0.value })\n                                 ^~~~~~~~~~~~~~\n\
    /tmp/tmp8mpm0cok.swift:36:23: error: no 'reversed' candidates produce the expected\
    \ contextual result type 'String'\n        return result.reversed()\n        \
    \              ^\nSwift.Sequence:2:40: note: 'reversed()' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func reversed() -> [Self.Element]\n       \
    \                                ^\nSwift.BidirectionalCollection:2:40: note:\
    \ 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    \n    let result = \"\"\n \
    \   var newString = \"\"\n    for ch in s { \n        let isLetter = Character(ch).isLetter\n\
    \        if isLetter { \n            newString.append(String(Character(String(ch)!).reversed()))\n\
    \        } else {\n            newString.append(String(ch))\n        }\n    }\n\
    \    result = newString\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxl4080ca.swift:19:24: error: no exact matches in call to initializer\
    \ \n        let isLetter = Character(ch).isLetter\n                       ^\n\
    Swift.Character:5:23: note: incorrect labels for candidate (have: '(_:)', expected:\
    \ '(extendedGraphemeClusterLiteral:)')\n    @inlinable public init(extendedGraphemeClusterLiteral\
    \ value: Character)\n                      ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(unicodeScalarLiteral:)')\n\
    \    public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)\n\
    \           ^\n/tmp/tmpxl4080ca.swift:21:60: error: value of type 'Character'\
    \ has no member 'reversed'\n            newString.append(String(Character(String(ch)!).reversed()))\n\
    \                                    ~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpxl4080ca.swift:26:5:\
    \ error: cannot assign to value: 'result' is a 'let' constant\n    result = newString\n\
    \    ^~~~~~\n/tmp/tmpxl4080ca.swift:16:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \") { $0 + String($1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiysp4gii.swift:15:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824623
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\ts = s.characters.reduce(\"\"\
    ) { memo, character in\n\t\tif let c = Character(character) {\n\t\t\tif let upperCase\
    \ = c.uppercased() {\n\t\t\t\tmemo += String(c) + upperCase\n\t\t\t} else {\n\t\
    \t\t\tmemo += String(c) + c.lowercased()\n\t\t\t}\n\t\t}\n\t\treturn memo\n\t\
    }\n\t\n\tif s.isEmpty {\n\t\treturn s\n\t}\n\t\n\treturn s.characters.reduce(\"\
    \") { memo, character in\n\t\tif let c = Character(character) {\n\t\t\tif let\
    \ upperCase = c.uppercased() {\n\t\t\t\tmemo += String(upperCase) + String(c)\n\
    \t\t\t} else {\n\t\t\t\tmemo += String(c) + String(upperCase)\n\t\t\t}\n\t\t}\n\
    \t\treturn memo\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz7ihzdqs.swift:15:2: error: cannot assign to value: 's' is a 'let'\
    \ constant\n        s = s.characters.reduce(\"\") { memo, character in\n     \
    \   ^\n/tmp/tmpz7ihzdqs.swift:16:24: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n                if let c = Character(character) {\n               \
    \                      ^\n                                     extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpz7ihzdqs.swift:35:32: error: cannot find 'upperCase' in scope\n  \
    \                              memo += String(c) + String(upperCase)\n       \
    \                                                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let resultString = s.characters.reduce(\"\
    \", { $0.isLetter ? $0.caseInsensitive\n        ?? $0.lowercased() + $0.uppercased()\n\
    \        : $0.lowercased() + $0 })\n    if s.isEmpty {\n        return resultString\n\
    \    }\n    return solve(resultString, s: String(s.characters.reverse()))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzt3lx5k9.swift:16:28: error: binary operator '+' cannot be applied\
    \ to operands of type 'Optional<_>' and '_'\n        ?? $0.lowercased() + $0.uppercased()\n\
    \           ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~\n/tmp/tmpzt3lx5k9.swift:15:48: error:\
    \ contextual closure type '(_, String.Element) throws -> _' (aka '(_, Character)\
    \ throws -> _') expects 2 arguments, but 1 was used in closure body\n    let resultString\
    \ = s.characters.reduce(\"\", { $0.isLetter ? $0.caseInsensitive\n           \
    \                                    ^\n/tmp/tmpzt3lx5k9.swift:21:55: error: value\
    \ of type 'String' has no member 'reverse'\n    return solve(resultString, s:\
    \ String(s.characters.reverse()))\n                                         ~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpzt3lx5k9.swift:21:18: error: extra argument in call\n    return\
    \ solve(resultString, s: String(s.characters.reverse()))\n                ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979415
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    var res = \"\"\n    for c in s.characters {\n        if c.isLetter()\
    \ {\n            var reversed = String(c).reversed()\n            var first =\
    \ c.isUpper() ? c : reversed\n            var second = c.isUpper() ? reversed\
    \ : c\n            switch first {\n            case \"A\": res += \"b\"\n    \
    \        case \"B\": res += \"a\"\n            case \"C\": res += \"c\"\n    \
    \        case \"D\": res += \"d\"\n            case \"E\": res += \"e\"\n    \
    \        case \"F\": res += \"f\"\n            case \"G\": res += \"g\"\n    \
    \        case \"H\": res += \"h\"\n            case \"I\": res += \"i\"\n    \
    \        case \"J\": res += \"j\"\n            case \"K\": res += \"k\"\n    \
    \        case \"L\": res += \"l\"\n            case \"M\": res += \"m\"\n    \
    \        case \"N\": res += \"n\"\n            case \"O\": res += \"o\"\n    \
    \        case \"P\": res += \"p\"\n            case \"Q\": res += \"q\"\n    \
    \        case \"R\": res += \"r\"\n            case \"S\": res += \"s\"\n    \
    \        case \"T\": res += \"t\"\n            case \"U\": res += \"u\"\n    \
    \        case \"V\": res += \"v\"\n            case \"W\": res += \"w\"\n    \
    \        case \"X\": res += \"x\"\n            case \"Y\": res += \"y\"\n    \
    \        case \"Z\": res += \"z\"\n            default:\n                switch\
    \ second {\n                case \"a\": res += \"b\"\n                case \"\
    b\": res += \"a\"\n                case \"c\": res += \"c\"\n                case\
    \ \"d\": res += \"d\"\n                case \"e\": res += \"e\"\n            \
    \    case \"f\": res += \"f\"\n                case \"g\": res += \"g\"\n    \
    \            case \"h\": res += \"h\"\n                case \"i\": res += \"i\"\
    \n                case \"j\": res += \"j\"\n                case \"k\": res +=\
    \ \"k\"\n                case \"l\": res += \"l\"\n                case \"m\"\
    : res += \"m\"\n                case \"n\": res += \"n\"\n                case\
    \ \"o\": res += \"o\"\n                case \"p\": res += \"p\"\n            \
    \    case \"q\": res += \"q\"\n                case \"r\": res += \"r\"\n    \
    \            case \"s\": res += \"s\"\n                case \"t\": res += \"t\"\
    \n                \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpen8lpy3r.swift:96:35: error: expected '}' at end of 'switch' statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmpen8lpy3r.swift:24:26: note: to match this opening '{'\n            switch\
    \ first {\n                         ^\n/tmp/tmpen8lpy3r.swift:96:35: error: expected\
    \ '}' at end of brace statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n    \
    \                              ^\n/tmp/tmpen8lpy3r.swift:20:25: note: to match\
    \ this opening '{'\n        if c.isLetter() {\n                        ^\n/tmp/tmpen8lpy3r.swift:96:35:\
    \ error: expected '}' at end of brace statement\nassert(solve(s: \"#ccc\") ==\
    \ \"#CCC\")\n                                  ^\n/tmp/tmpen8lpy3r.swift:19:27:\
    \ note: to match this opening '{'\n    for c in s.characters {\n             \
    \             ^\n/tmp/tmpen8lpy3r.swift:96:35: error: expected '}' at end of brace\
    \ statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n                        \
    \          ^\n/tmp/tmpen8lpy3r.swift:14:33: note: to match this opening '{'\n\
    func solve(s: String) -> String {\n                                ^\n/tmp/tmpen8lpy3r.swift:19:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpen8lpy3r.swift:20:14: error: cannot call value of non-function\
    \ type 'Bool'\n        if c.isLetter() {\n             ^       ~~\n          \
    \           \n/tmp/tmpen8lpy3r.swift:22:27: error: value of type 'Character' has\
    \ no member 'isUpper'\n            var first = c.isUpper() ? c : reversed\n  \
    \                      ~ ^~~~~~~\n/tmp/tmpen8lpy3r.swift:22:39: error: result\
    \ values in '? :' expression have mismatching types 'Character' and 'ReversedCollection<String>'\n\
    \            var first = c.isUpper() ? c : reversed\n                        \
    \              ^\n/tmp/tmpen8lpy3r.swift:23:28: error: value of type 'Character'\
    \ has no member 'isUpper'\n            var second = c.isUpper() ? reversed : c\n\
    \        "
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? \"#\" +\
    \ s : s.map {\n        Character($0) != nil ? String(Character($0).lowercased().uppercased())!\
    \ + String(Character($0).uppercased())! : String($0)\n    }.reduce(\"\") { $0\
    \ + $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwc2g061b.swift:16:19: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        Character($0) != nil ? String(Character($0).lowercased().uppercased())!\
    \ + String(Character($0).uppercased())! : String($0)\n                  ^\n  \
    \                extendedGraphemeClusterLiteral: \n/tmp/tmpwc2g061b.swift:16:39:\
    \ error: missing argument label 'validatingUTF8:' in call\n        Character($0)\
    \ != nil ? String(Character($0).lowercased().uppercased())! + String(Character($0).uppercased())!\
    \ : String($0)\n                                      ^\n                    \
    \                  validatingUTF8: \n/tmp/tmpwc2g061b.swift:16:49: error: missing\
    \ argument label 'extendedGraphemeClusterLiteral:' in call\n        Character($0)\
    \ != nil ? String(Character($0).lowercased().uppercased())! + String(Character($0).uppercased())!\
    \ : String($0)\n                                                ^\n          \
    \                                      extendedGraphemeClusterLiteral: \n/tmp/tmpwc2g061b.swift:16:90:\
    \ error: missing argument label 'validatingUTF8:' in call\n        Character($0)\
    \ != nil ? String(Character($0).lowercased().uppercased())! + String(Character($0).uppercased())!\
    \ : String($0)\n                                                             \
    \                            ^\n                                             \
    \                                            validatingUTF8: \n/tmp/tmpwc2g061b.swift:16:100:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      Character($0) != nil ? String(Character($0).lowercased().uppercased())!\
    \ + String(Character($0).uppercased())! : String($0)\n                       \
    \                                                                            ^\n\
    \                                                                            \
    \                       extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659979441
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if !s.isEmpty {\n        let\
    \ firstChar = s[0]\n        if firstChar.isUppercase {\n            return s.toUpper()\n\
    \        } else if firstChar.isLowercase {\n            return s.toLower()\n \
    \       } else {\n            return s\n        }\n    } else {\n        return\
    \ s\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu_smoa4h.swift:16:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let firstChar\
    \ = s[0]\n                        ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu_smoa4h.swift:18:22: error: value\
    \ of type 'String' has no member 'toUpper'\n            return s.toUpper()\n \
    \                  ~ ^~~~~~~\n/tmp/tmpu_smoa4h.swift:20:22: error: value of type\
    \ 'String' has no member 'toLower'\n            return s.toLower()\n         \
    \          ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty{\n        return\
    \ s\n    }\n    var str = s\n    for i in 0..<str.count{\n        if str[i] ==\
    \ String(aCharToUpper){\n            str = str.lowercased\n        }else{\n  \
    \          str = str.uppercased\n        }\n    }\n    return str\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3j6ref0n.swift:20:29: error: cannot find 'aCharToUpper' in scope\n\
    \        if str[i] == String(aCharToUpper){\n                            ^~~~~~~~~~~~\n\
    /tmp/tmp3j6ref0n.swift:20:15: error: no exact matches in call to subscript \n\
    \        if str[i] == String(aCharToUpper){\n              ^\n/tmp/tmp3j6ref0n.swift:20:15:\
    \ note: found candidate with type '(Range<String.Index>) -> Substring'\n     \
    \   if str[i] == String(aCharToUpper){\n              ^\n/tmp/tmp3j6ref0n.swift:20:15:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> String.SubSequence'\
    \ (aka '((UnboundedRange_) -> ()) -> Substring')\n        if str[i] == String(aCharToUpper){\n\
    \              ^\n/tmp/tmp3j6ref0n.swift:21:23: error: function produces expected\
    \ type 'String'; did you mean to call it with '()'?\n            str = str.lowercased\n\
    \                  ~~~~^~~~~~~~~~\n                                ()\n/tmp/tmp3j6ref0n.swift:23:23:\
    \ error: function produces expected type 'String'; did you mean to call it with\
    \ '()'?\n            str = str.uppercased\n                  ~~~~^~~~~~~~~~\n\
    \                                ()\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ s in s.characters {\n        if s.isUppercase {\n            result.append(s.lowercaseString)\n\
    \        } else {\n            result.append(s)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjw4myshx.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjw4myshx.swift:18:29:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result.append(s.lowercaseString)\n                          ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let res = \"\"\n    let rev\
    \ = s.reversed()\n    let isLetter = s.contains(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    let len = s.characters.count\n    let mut i = 0\n    while i < len {\n\
    \        let c = s.characters.subscript((i))\n        if isLetter {\n        \
    \    let cased = c.uppercased()\n            if i < len - 1 {\n              \
    \  res = res + cased\n                i++\n            } else {\n            \
    \    res = res + c\n            }\n        } else {\n            if i < len -\
    \ 1 {\n                res = res + c\n                i++\n            } else\
    \ {\n                res = res + c.lowercased()\n            }\n        }\n  \
    \  }\n    if let index = rev.index(of: \"\") {\n        res = res[index..<rev.endIndex]\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu5q4odl3.swift:19:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut i = 0\n\
    \            ^\n/tmp/tmpu5q4odl3.swift:19:13: note: join the identifiers together\n\
    \    let mut i = 0\n        ~~~~^\n        muti\n/tmp/tmpu5q4odl3.swift:19:13:\
    \ note: join the identifiers together with camel-case\n    let mut i = 0\n   \
    \     ~~~~^\n        mutI\n/tmp/tmpu5q4odl3.swift:18:17: error: 'characters' is\
    \ unavailable: Please use String directly\n    let len = s.characters.count\n\
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpu5q4odl3.swift:20:11: error: cannot find 'i' in scope\n    while\
    \ i < len {\n          ^\n/tmp/tmpu5q4odl3.swift:21:41: error: cannot find 'i'\
    \ in scope\n        let c = s.characters.subscript((i))\n                    \
    \                    ^\n/tmp/tmpu5q4odl3.swift:21:30: error: no exact matches\
    \ in call to subscript \n        let c = s.characters.subscript((i))\n       \
    \                      ^\n/tmp/tmpu5q4odl3.swift:21:30: note: found candidate\
    \ with type '(String.Index) -> Character'\n        let c = s.characters.subscript((i))\n\
    \                             ^\n/tmp/tmpu5q4odl3.swift:21:30: note: found candidate\
    \ with type '(Range<String.Index>) -> Substring'\n        let c = s.characters.subscript((i))\n\
    \                             ^\n/tmp/tmpu5q4odl3.swift:24:16: error: cannot find\
    \ 'i' in scope\n            if i < len - 1 {\n               ^\n/tmp/tmpu5q4odl3.swift:25:17:\
    \ error: cannot assign to value: 'res' is a 'let' constant\n                res\
    \ = res + cased\n                ^~~\n/tmp/tmpu5q4odl3.swift:15:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let res = \"\"\n    ^~~\n    var\n/tmp/tmpu5q4odl3.swift:26:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      i++\n                 ^~\n/tmp/tmpu5q4odl3.swift:26:17: error: cannot find\
    \ 'i' in scope\n                i++\n                ^\n/tmp/tmpu5q4odl3.swift:28:17:\
    \ error: cann"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // TODO: check if s is empty\n\
    \    return s.characters.reversed().reduce(\"\") {\n        (res, item) in\n \
    \       if item == Character(UnicodeScalar(97)) {\n            if let index =\
    \ res.index(of: item == Character(UnicodeScalar(97) ? UnicodeScalar(65) : UnicodeScalar(97)))\
    \ {\n                return res.replacingCharacters(in: Range<String.Index>(start:\
    \ index, end: res.endIndex), with: String(UnicodeScalar(32), radix: 16))\n   \
    \         }\n            return res\n        }\n        return res.replacingCharacters(in:\
    \ Range<String.Index>(start: res.endIndex, end: res.endIndex.advancedBy(1)), with:\
    \ String(UnicodeScalar(item), radix: 16))\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppv1_qfz1.swift:19:47: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'String.Element' (aka 'Character')\n            if\
    \ let index = res.index(of: item == Character(UnicodeScalar(97) ? UnicodeScalar(65)\
    \ : UnicodeScalar(97))) {\n                                              ^\n/tmp/tmppv1_qfz1.swift:19:60:\
    \ error: optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') cannot\
    \ be used as a boolean; test for '!= nil' instead\n            if let index =\
    \ res.index(of: item == Character(UnicodeScalar(97) ? UnicodeScalar(65) : UnicodeScalar(97)))\
    \ {\n                                                           ^\n          \
    \                                                 (                 != nil)\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let length = s.characters.count\n\
    \    var result = \"\"\n    var firstLetter = true\n\n    for i in 0...length\
    \ {\n        if let c = s[i]{\n            if firstLetter {\n                result\
    \ += \"\\(c)\"\n                firstLetter = false\n            } else {\n  \
    \              result += \"\\(c)\"\n            }\n        } else {\n        \
    \    result += \"\\(i)\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmps0ncacft.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = s.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmps0ncacft.swift:20:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if let c = s[i]{\n                   ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps0ncacft.swift:20:12:\
    \ error: initializer for conditional binding must have Optional type, not 'Character'\n\
    \        if let c = s[i]{\n           ^       ~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let count = s.count\n    var\
    \ i = 0\n    var reversedString = \"\"\n    for _ in 0..<count {\n        switch\
    \ s[i] {\n            case \"a\":\n                i += 2\n                reversedString\
    \ += \"A\"\n            case \"b\":\n                i += 2\n                reversedString\
    \ += \"b\"\n            case \"c\":\n                i += 2\n                reversedString\
    \ += \"C\"\n            case \"d\":\n                i += 2\n                reversedString\
    \ += \"d\"\n            case \"e\":\n                i += 2\n                reversedString\
    \ += \"E\"\n            case \"f\":\n                i += 2\n                reversedString\
    \ += \"f\"\n            case \"g\":\n                i += 2\n                reversedString\
    \ += \"g\"\n            case \"h\":\n                i += 2\n                reversedString\
    \ += \"H\"\n            case \"i\":\n                i += 2\n                reversedString\
    \ += \"I\"\n            case \"j\":\n                i += 2\n                reversedString\
    \ += \"J\"\n            case \"k\":\n                i += 2\n                reversedString\
    \ += \"K\"\n            case \"l\":\n                i += 2\n                reversedString\
    \ += \"L\"\n            case \"m\":\n                i += 2\n                reversedString\
    \ += \"m\"\n            case \"n\":\n                i += 2\n                reversedString\
    \ += \"N\"\n            case \"o\":\n                i += 2\n                reversedString\
    \ += \"O\"\n            case \"p\":\n                i += 2\n                reversedString\
    \ += \"P\"\n            case \"q\":\n                i += 2\n                reversedString\
    \ += \"Q\"\n            case \"r\":\n                i += 2\n                reversedString\
    \ += \"R\"\n            case \"s\":\n                i += 2\n                reversedString\
    \ += \"s\"\n            case \"t\":\n                i += 2\n                reversedString\
    \ += \"T\"\n            case \"u\":\n                i += 2\n                reversedString\
    \ += \"U\"\n            case \"v\":\n                i += 2\n                reversedString\
    \ += \"V\"\n            case \"w\":\n                i += 2\n                reversedString\
    \ += \"W\"\n            case \"x\":\n                i += 2\n                reversedString\
    \ += \"X\"\n            case \"y\":\n                i += 2\n                reversedString\
    \ += \"Y\"\n            case \"z\":\n                i += 2\n                reversedString\
    \ += \"Z\"\n            default:\n                reversedString = s\n       \
    \ }\n    }\n    return reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyv9v7rcz.swift:19:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        switch s[i]\
    \ {\n               ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplvnxhi98.swift:15:36: error: no exact matches in call to instance\
    \ method 'joined'\n    return s.characters.reversed().joined()\n             \
    \                      ^\nSwift.Sequence:1:11: note: candidate requires that 'String.Element'\
    \ (aka 'Character') conform to 'StringProtocol' (requirement specified as 'Self.Element'\
    \ : 'StringProtocol')\nextension Sequence where Self.Element : StringProtocol\
    \ {\n          ^\nSwift.BidirectionalCollection:1:11: note: candidate requires\
    \ that the types 'String.Element' (aka 'Character') and 'String' be equivalent\
    \ (requirement specified as 'Self.Element' == 'String')\nextension BidirectionalCollection\
    \ where Self.Element == String {\n          ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let str = s.filter {\
    \ !$0.isLetter, !$0.isDigit  else {\n        return s.lowercased()\n    }\n  \
    \  return str.map { Character($0).isLower ? String(Character($0).toUpper) : String(Character($0).toLower)\
    \ }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb1_liu5r.swift:15:30: error: expected 'else' after 'guard' condition\n\
    \    guard let str = s.filter { !$0.isLetter, !$0.isDigit  else {\n          \
    \                   ^\n                             else \n/tmp/tmpb1_liu5r.swift:15:33:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ str = s.filter { !$0.isLetter, !$0.isDigit  else {\n                       \
    \         ^\n/tmp/tmpb1_liu5r.swift:15:44: error: consecutive statements on a\
    \ line must be separated by ';'\n    guard let str = s.filter { !$0.isLetter,\
    \ !$0.isDigit  else {\n                                           ^\n        \
    \                                   ;\n/tmp/tmpb1_liu5r.swift:15:44: error: expected\
    \ expression\n    guard let str = s.filter { !$0.isLetter, !$0.isDigit  else {\n\
    \                                           ^\n/tmp/tmpb1_liu5r.swift:41:35: error:\
    \ expected '}' at end of brace statement\nassert(solve(s: \"#ccc\") == \"#CCC\"\
    )\n                                  ^\n/tmp/tmpb1_liu5r.swift:14:33: note: to\
    \ match this opening '{'\nfunc solve(s: String) -> String {\n                \
    \                ^\n/tmp/tmpb1_liu5r.swift:18:12: error: cannot find 'str' in\
    \ scope\n    return str.map { Character($0).isLower ? String(Character($0).toUpper)\
    \ : String(Character($0).toLower) }.joined()\n           ^~~\n/tmp/tmpb1_liu5r.swift:18:36:\
    \ error: value of type 'Character' has no member 'isLower'\n    return str.map\
    \ { Character($0).isLower ? String(Character($0).toUpper) : String(Character($0).toLower)\
    \ }.joined()\n                     ~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpb1_liu5r.swift:18:67:\
    \ error: value of type 'Character' has no member 'toUpper'\n    return str.map\
    \ { Character($0).isLower ? String(Character($0).toUpper) : String(Character($0).toLower)\
    \ }.joined()\n                                                    ~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpb1_liu5r.swift:18:99: error: value of type 'Character' has\
    \ no member 'toLower'\n    return str.map { Character($0).isLower ? String(Character($0).toUpper)\
    \ : String(Character($0).toLower) }.joined()\n                           "
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters\n     \
    \   .reduce(\"\") { $0 + String($1) }\n        .reduce(\"\") { $0 + String($1.swapped())\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsb4jyvgo.swift:17:38: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'swapped'\n        .reduce(\"\") { $0 + String($1.swapped())\
    \ }\n                                  ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979406
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let length = s.characters.count\
    \ else { return \"\" }\n    let reversedString = StringBuilder(length: length)\n\
    \    for char in s.characters {\n        let uppercaseOrLowercasedChar = char.uppercased()\n\
    \        guard let index = uppercaseOrLowercasedChar.unicodeScalars.firstIndex(of:\
    \ char) else {\n            reversedString.append(char)\n            continue\n\
    \        }\n        let reversedChar = uppercaseOrLowercasedChar.unicodeScalars[index].value\n\
    \        if char == reversedChar {\n            reversedString.append(char)\n\
    \            continue\n        }\n        reversedString.append(reversedChar)\n\
    \    }\n    return reversedString.reversed().toString()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsdprdlkz.swift:15:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let length = s.characters.count else { return\
    \ \"\" }\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpsdprdlkz.swift:15:11: error: initializer for conditional\
    \ binding must have Optional type, not 'Int'\n    guard let length = s.characters.count\
    \ else { return \"\" }\n          ^            ~~~~~~~~~~~~~~~~~~\n/tmp/tmpsdprdlkz.swift:16:26:\
    \ error: cannot find 'StringBuilder' in scope\n    let reversedString = StringBuilder(length:\
    \ length)\n                         ^~~~~~~~~~~~~\n/tmp/tmpsdprdlkz.swift:17:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpsdprdlkz.swift:19:83: error: cannot convert value of\
    \ type 'Character' to expected argument type 'Unicode.Scalar'\n        guard let\
    \ index = uppercaseOrLowercasedChar.unicodeScalars.firstIndex(of: char) else {\n\
    \                                                                            \
    \      ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var resultString = \"\"\n \
    \   var isUpper = false\n    var isLower = false\n    \n    for char in s {\n\
    \        switch char {\n        case \"a\":\n        case \"A\":\n           \
    \ isUpper = !isUpper\n        case \"b\":\n        case \"B\":\n            isUpper\
    \ = !isUpper\n        case \"c\":\n        case \"C\":\n            isUpper =\
    \ !isUpper\n        case \"d\":\n        case \"D\":\n            isUpper = !isUpper\n\
    \        case \"e\":\n        case \"E\":\n            isUpper = !isUpper\n  \
    \      case \"f\":\n        case \"F\":\n            isUpper = !isUpper\n    \
    \    case \"g\":\n        case \"G\":\n            isUpper = !isUpper\n      \
    \  case \"h\":\n        case \"H\":\n            isUpper = !isUpper\n        case\
    \ \"i\":\n        case \"I\":\n            isUpper = !isUpper\n        case \"\
    j\":\n        case \"J\":\n            isUpper = !isUpper\n        case \"k\"\
    :\n        case \"K\":\n            isUpper = !isUpper\n        case \"l\":\n\
    \        case \"L\":\n            isUpper = !isUpper\n        case \"m\":\n  \
    \      case \"M\":\n            isUpper = !isUpper\n        case \"n\":\n    \
    \    case \"N\":\n            isUpper = !isUpper\n        case \"o\":\n      \
    \  case \"O\":\n            isUpper = !isUpper\n        case \"p\":\n        case\
    \ \"P\":\n            isUpper = !isUpper\n        case \"q\":\n        case \"\
    Q\":\n            isUpper = !isUpper\n        case \"r\":\n        case \"R\"\
    :\n            isUpper = !isUpper\n        case \"s\":\n        case \"S\":\n\
    \            isUpper = !isUpper\n        case \"t\":\n        case \"T\":\n  \
    \          isUpper = !isUpper\n        case \"u\":\n        case \"U\":\n    \
    \        isUpper = !isUpper\n        case \"v\":\n        case \"V\":\n      \
    \      isUpper = !isUpper\n        case \"w\":\n        case \"W\":\n        \
    \    isUpper = !isUpper\n        case \"x\":\n        case \"X\":\n          \
    \  isUpper = !isUpper\n        case \"y\":\n        case \"Y\":\n            isUpper\
    \ = !isUpper\n        case \"z\":\n        case \"Z\":\n            isUpper =\
    \ !isUpper\n        case \"0\":\n        case \"1\":\n        case \"2\":\n  \
    \      case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"\
    6\":\n        case \"7\":\n        case \"8\":\n        case \"9\":\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1s9vlyae.swift:21:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp1s9vlyae.swift:24:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:27:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:42:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:45:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:48:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:51:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:54:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1s9vlyae.swift:57:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    \n    var result = \"\"\n \
    \   for character in s {\n        let index = s.index(of: character)\n       \
    \ let isLetter = index < s.count\n        let newChar = s.isUpper(index: index)\
    \ ? s.substring(from: index + 1) : s.substring(from: index! + 1)\n        let\
    \ newChar = isLetter ? newChar.capitalizedString : newChar\n        result +=\
    \ newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplmqase_o.swift:18:23: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = s.index(of: character)\n         \
    \             ^\n/tmp/tmplmqase_o.swift:18:23: note: use 'firstIndex(of:)' instead\n\
    \        let index = s.index(of: character)\n                      ^~~~~\n   \
    \                   firstIndex\n/tmp/tmplmqase_o.swift:19:30: error: binary operator\
    \ '<' cannot be applied to operands of type 'String.Index?' and 'Int'\n      \
    \  let isLetter = index < s.count\n                       ~~~~~ ^ ~~~~~~~\n/tmp/tmplmqase_o.swift:19:30:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        let isLetter = index < s.count\n                       \
    \      ^\n/tmp/tmplmqase_o.swift:20:25: error: value of type 'String' has no member\
    \ 'isUpper'\n        let newChar = s.isUpper(index: index) ? s.substring(from:\
    \ index + 1) : s.substring(from: index! + 1)\n                      ~ ^~~~~~~\n\
    /tmp/tmplmqase_o.swift:20:51: error: value of type 'String' has no member 'substring'\n\
    \        let newChar = s.isUpper(index: index) ? s.substring(from: index + 1)\
    \ : s.substring(from: index! + 1)\n                                          \
    \      ~ ^~~~~~~~~\n/tmp/tmplmqase_o.swift:20:67: error: cannot convert value\
    \ of type 'String.Index?' to expected argument type 'Int'\n        let newChar\
    \ = s.isUpper(index: index) ? s.substring(from: index + 1) : s.substring(from:\
    \ index! + 1)\n                                                              \
    \    ^\n/tmp/tmplmqase_o.swift:20:82: error: value of type 'String' has no member\
    \ 'substring'\n        let newChar = s.isUpper(index: index) ? s.substring(from:\
    \ index + 1) : s.substring(from: index! + 1)\n                               \
    \                                                ~ ^~~~~~~~~\n/tmp/tmplmqase_o.swift:20:103:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newChar = s.isUpper(index: index) ? s.substring(from: index\
    \ + 1) : s.substring(from: index! + 1)\n                                     \
    \           "
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if let s = s.characters.first\
    \ {\n        return s.hasUppercase ? s.withLowercase() : s.withUppercase()\n \
    \   } else {\n        return s.characters.reverse().joinWithSeparator(\"\")\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpq75psga9.swift:15:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    if let s = s.characters.first {\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpq75psga9.swift:16:18:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'hasUppercase'\n\
    \        return s.hasUppercase ? s.withLowercase() : s.withUppercase()\n     \
    \          ~ ^~~~~~~~~~~~\n/tmp/tmpq75psga9.swift:16:35: error: value of type\
    \ 'String.Element' (aka 'Character') has no member 'withLowercase'\n        return\
    \ s.hasUppercase ? s.withLowercase() : s.withUppercase()\n                   \
    \             ~ ^~~~~~~~~~~~~\n/tmp/tmpq75psga9.swift:16:55: error: value of type\
    \ 'String.Element' (aka 'Character') has no member 'withUppercase'\n        return\
    \ s.hasUppercase ? s.withLowercase() : s.withUppercase()\n                   \
    \                                 ~ ^~~~~~~~~~~~~\n/tmp/tmpq75psga9.swift:18:29:\
    \ error: value of type 'String' has no member 'reverse'\n        return s.characters.reverse().joinWithSeparator(\"\
    \")\n               ~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n\n    var reversedString = \"\"\n    for character in s {\n      \
    \  if character == \"a\" || character == \"A\" {\n            reversedString +=\
    \ String((character, lowercase))\n        } else if character == \"b\" || character\
    \ == \"B\" {\n            reversedString += String((character, uppercase))\n \
    \       } else {\n            reversedString += character\n        }\n    }\n\
    \    return reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6nlz1c2x.swift:22:50: error: cannot find 'lowercase' in scope\n\
    \            reversedString += String((character, lowercase))\n              \
    \                                   ^~~~~~~~~\n/tmp/tmp6nlz1c2x.swift:22:31: error:\
    \ no exact matches in call to initializer \n            reversedString += String((character,\
    \ lowercase))\n                              ^\n/tmp/tmp6nlz1c2x.swift:22:31:\
    \ note: found candidate with type '((Character, _)) -> String'\n            reversedString\
    \ += String((character, lowercase))\n                              ^\n/tmp/tmp6nlz1c2x.swift:22:31:\
    \ note: found candidate with type '((Character, _), Int, Bool) -> String'\n  \
    \          reversedString += String((character, lowercase))\n                \
    \              ^\n/tmp/tmp6nlz1c2x.swift:22:31: note: found candidate with type\
    \ '((Character, _)) -> String'\n            reversedString += String((character,\
    \ lowercase))\n                              ^\n/tmp/tmp6nlz1c2x.swift:22:31:\
    \ note: found candidate with type '((Character, _)) -> String'\n            reversedString\
    \ += String((character, lowercase))\n                              ^\n/tmp/tmp6nlz1c2x.swift:24:50:\
    \ error: cannot find 'uppercase' in scope\n            reversedString += String((character,\
    \ uppercase))\n                                                 ^~~~~~~~~\n/tmp/tmp6nlz1c2x.swift:24:31:\
    \ error: no exact matches in call to initializer \n            reversedString\
    \ += String((character, uppercase))\n                              ^\n/tmp/tmp6nlz1c2x.swift:24:31:\
    \ note: found candidate with type '((Character, _)) -> String'\n            reversedString\
    \ += String((character, uppercase))\n                              ^\n/tmp/tmp6nlz1c2x.swift:24:31:\
    \ note: found candidate with type '((Character, _), Int, Bool) -> String'\n  \
    \          reversedString += String((character, uppercase))\n                \
    \              ^\n/tmp/tmp6nlz1c2x.swift:24:31: note: found candidate with type\
    \ '((Character, _)) -> String'\n            reversedString += String((character,\
    \ uppercase))\n                              ^\n/tmp/tmp6nlz1c2x"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ lastIsLetter = false\n    for c in s.characters {\n        if isLetter(c) {\n\
    \            lastIsLetter = true\n        } else {\n            if lastIsLetter\
    \ {\n                result += c.lowercaseString\n            } else {\n     \
    \           result += c.uppercaseString\n            }\n            lastIsLetter\
    \ = false\n        }\n    }\n    if lastIsLetter {\n        result += s.lowercaseString\n\
    \    } else {\n        result += s.uppercaseString\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6cz3b45t.swift:17:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6cz3b45t.swift:18:12:\
    \ error: cannot find 'isLetter' in scope\n        if isLetter(c) {\n         \
    \  ^~~~~~~~\n/tmp/tmp6cz3b45t.swift:22:29: error: value of type 'Character' has\
    \ no member 'lowercaseString'\n                result += c.lowercaseString\n \
    \                         ~ ^~~~~~~~~~~~~~~\n/tmp/tmp6cz3b45t.swift:24:29: error:\
    \ value of type 'Character' has no member 'uppercaseString'\n                result\
    \ += c.uppercaseString\n                          ~ ^~~~~~~~~~~~~~~\n/tmp/tmp6cz3b45t.swift:30:21:\
    \ error: value of type 'String' has no member 'lowercaseString'\n        result\
    \ += s.lowercaseString\n                  ~ ^~~~~~~~~~~~~~~\n/tmp/tmp6cz3b45t.swift:32:21:\
    \ error: value of type 'String' has no member 'uppercaseString'\n        result\
    \ += s.uppercaseString\n                  ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var ret = s\n    if s.isEmpty\
    \ { return ret }\n    for char in s.characters {\n        if char >= \"A\" &&\
    \ char <= \"Z\" { ret += char.lowercased() }\n        else if char >= \"a\" &&\
    \ char <= \"z\" { ret += char.uppercased() }\n        else { ret += char }\n \
    \   }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyxzzqhsj.swift:17:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyxzzqhsj.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        else { ret += char }\n                      ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    \n    if let firstLetter =\
    \ s.first {\n        let secondLetter = s.last\n        \n        if firstLetter\
    \ == secondLetter {\n            return s.reversed()\n        }\n        \n  \
    \      return s.reversed()\n    }\n    \n    return s.reversed()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb1q3obh0.swift:20:22: error: no 'reversed' candidates produce the\
    \ expected contextual result type 'String'\n            return s.reversed()\n\
    \                     ^\nSwift.Sequence:2:40: note: 'reversed()' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func reversed() -> [Self.Element]\n       \
    \                                ^\nSwift.BidirectionalCollection:2:40: note:\
    \ 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n/tmp/tmpb1q3obh0.swift:23:18: error:\
    \ no 'reversed' candidates produce the expected contextual result type 'String'\n\
    \        return s.reversed()\n                 ^\nSwift.Sequence:2:40: note: 'reversed()'\
    \ produces '[String.Element]' (aka 'Array<Character>'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> [Self.Element]\n\
    \                                       ^\nSwift.BidirectionalCollection:2:40:\
    \ note: 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n/tmp/tmpb1q3obh0.swift:26:14: error:\
    \ no 'reversed' candidates produce the expected contextual result type 'String'\n\
    \    return s.reversed()\n             ^\nSwift.Sequence:2:40: note: 'reversed()'\
    \ produces '[String.Element]' (aka 'Array<Character>'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> [Self.Element]\n\
    \                                       ^\nSwift.BidirectionalCollection:2:40:\
    \ note: 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard let start = s.index(of:\
    \ CharacterSet.letters.first!) else {\n        return s\n    }\n    let end =\
    \ s.index(of: CharacterSet.letters.last!, in: start..<s.endIndex)\n    \n    let\
    \ reverse = s[start..<end].reversed()\n    return reversed + String(s[end..<s.startIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0li1zr2w.swift:15:35: error: cannot find 'CharacterSet' in scope\n\
    \    guard let start = s.index(of: CharacterSet.letters.first!) else {\n     \
    \                             ^~~~~~~~~~~~\n/tmp/tmp0li1zr2w.swift:18:27: error:\
    \ cannot find 'CharacterSet' in scope\n    let end = s.index(of: CharacterSet.letters.last!,\
    \ in: start..<s.endIndex)\n                          ^~~~~~~~~~~~\n/tmp/tmp0li1zr2w.swift:18:64:\
    \ error: extra argument 'in' in call\n    let end = s.index(of: CharacterSet.letters.last!,\
    \ in: start..<s.endIndex)\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n\
    /tmp/tmp0li1zr2w.swift:21:12: error: cannot find 'reversed' in scope\n    return\
    \ reversed + String(s[end..<s.startIndex])\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979404
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.characters.reversed().reduce(\"\
    \\(s.first!)\", { $0.isUppercase ? \"\\(String($0.capitalized()))\" : String($0)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph03rdwn8.swift:15:58: error: contextual closure type '(String,\
    \ String.Element) throws -> String' (aka '(String, Character) throws -> String')\
    \ expects 2 arguments, but 1 was used in closure body\n    return s.characters.reversed().reduce(\"\
    \\(s.first!)\", { $0.isUppercase ? \"\\(String($0.capitalized()))\" : String($0)\
    \ })\n                                                         ^\n/tmp/tmph03rdwn8.swift:15:63:\
    \ error: value of type 'String' has no member 'isUppercase'\n    return s.characters.reversed().reduce(\"\
    \\(s.first!)\", { $0.isUppercase ? \"\\(String($0.capitalized()))\" : String($0)\
    \ })\n                                                           ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979405
