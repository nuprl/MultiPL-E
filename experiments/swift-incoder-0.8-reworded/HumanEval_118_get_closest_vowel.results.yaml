language: swift
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  // init\
    \ vowels\n  var vowels = [\"\", \"a\", \"e\", \"i\", \"o\", \"u\"]\n  // init\
    \ start\n  var start = vowels.count\n  // init end\n  var end = start\n  // init\
    \ start2\n  var start2 = start\n  // init end2\n  var end2 = start2\n  // init\
    \ index\n  var index = start\n  // init result\n  var result = \"\"\n  // init\
    \ flag\n  var flag = true\n  // loop\n  for index in word.characters.reverse().startIndex..<word.characters.endIndex\
    \ {\n    if flag {\n      // check left\n      if index < vowels.count {\n   \
    \     if vowels[index] == \"\" {\n          flag = false\n          continue\n\
    \        }\n        result = result + vowels[index]\n        index--\n       \
    \ continue\n      }\n    }\n    // check right\n    if index > word.characters.endIndex\
    \ {\n      if index < vowels.count {\n        if vowels[word.characters.endIndex]\
    \ == \"\" {\n          flag = false\n          continue\n        }\n        result\
    \ = result + vowels[word.characters.endIndex]\n        index++\n        continue\n\
    \      }\n    }\n    // check left2\n    if index < vowels.count {\n      if vowels[index]\
    \ == \"\" {\n        flag = false\n        continue\n      }\n      result = result\
    \ + vowels[index]\n      index--\n      continue\n    }\n    // check right2\n\
    \    if index > word.characters.endIndex {\n      if index < vowels.count {\n\
    \        if vowels[word.characters.endIndex] == \"\" {\n          flag = false\n\
    \          continue\n        }\n        result = result + vowels[word.characters.endIndex]\n\
    \        index++\n        continue\n      }\n    }\n    break\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8hdydbf.swift:34:32: error: value of type 'String' has no member\
    \ 'reverse'\n  for index in word.characters.reverse().startIndex..<word.characters.endIndex\
    \ {\n               ~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpk8hdydbf.swift:34:52: error:\
    \ protocol 'Sequence' requires that 'String.Index' conform to 'Strideable'\n \
    \ for index in word.characters.reverse().startIndex..<word.characters.endIndex\
    \ {\n                                                   ^\nSwift.Range:1:11: note:\
    \ requirement from conditional conformance of 'Range<String.Index>' to 'Sequence'\n\
    extension Range : Sequence where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n/tmp/tmpk8hdydbf.swift:34:52: error: referencing instance method\
    \ 'makeIterator()' on 'Range' requires that 'String.Index' conform to 'Strideable'\n\
    \  for index in word.characters.reverse().startIndex..<word.characters.endIndex\
    \ {\n                                                   ^\nSwift.Range:1:11: note:\
    \ requirement from conditional conformance of 'Range<String.Index>' to 'Collection'\n\
    extension Range : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n<unknown>:0:\
    \ error: referencing instance method 'next()' on 'Range' requires that 'String.Index'\
    \ conform to 'Strideable'\nSwift.Range:1:11: note: requirement from conditional\
    \ conformance of 'Range<String.Index>' to 'Collection'\nextension Range : Collection,\
    \ BidirectionalCollection, RandomAccessCollection where Bound : Strideable, Bound.Stride\
    \ : SignedInteger {\n          ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.characters.count == 0 {\n        return \"\"\n    }\n    var vowels = [String]()\n\
    \    let vowelA = \"A\".characters.map { (c) -> String in\n        if let idx\
    \ = word.startIndex.advancedBy(c - 1) {\n            let ch = word[idx]\n    \
    \        if ch != \"a\" && ch != \"e\" && ch != \"i\" && ch != \"o\" && ch !=\
    \ \"u\" {\n                return \"\"\n            }\n            return String(ch)\n\
    \        }\n        return \"\"\n    }\n    vowels.append(contentsOf: vowelA)\n\
    \    let vowelE = \"E\".characters.map { (c) -> String in\n        if let idx\
    \ = word.startIndex.advancedBy(c - 1) {\n            let ch = word[idx]\n    \
    \        if ch != \"a\" && ch != \"e\" && ch != \"i\" && ch != \"o\" && ch !=\
    \ \"u\" {\n                return \"\"\n            }\n            return String(ch)\n\
    \        }\n        return \"\"\n    }\n    vowels.append(contentsOf: vowelE)\n\
    \    let vowelI = \"I\".characters.map { (c) -> String in\n        if let idx\
    \ = word.startIndex.advancedBy(c - 1) {\n            let ch = word[idx]\n    \
    \        if ch != \"a\" && ch != \"e\" && ch != \"i\" && ch != \"o\" && ch !=\
    \ \"u\" {\n                return \"\"\n            }\n            return String(ch)\n\
    \        }\n        return \"\"\n    }\n    vowels.append(contentsOf: vowelI)\n\
    \    let vowelO = \"O\".characters.map { (c) -> String in\n        if let idx\
    \ = word.startIndex.advancedBy(c - 1) {\n            let ch = word[idx]\n    \
    \        if ch != \"a\" && ch != \"e\" && ch != \"i\" && ch != \"o\" && ch !=\
    \ \"u\" {\n                return \"\"\n            }\n            return String(ch)\n\
    \        }\n        return \"\"\n    }\n    vowels.append(contentsOf: vowelO)\n\
    \    let vowelU = \"U\".characters.map { (c) -> String in\n        if let idx\
    \ = word.startIndex.advancedBy(c - 1) {\n            let ch = word[idx]\n    \
    \        if ch != \"a\" && ch != \"e\" && ch != \"i\" && ch != \"o\" && ch !=\
    \ \"u\" {\n                return \"\"\n            }\n            return String(ch)\n\
    \        }\n        return \"\"\n    }\n    vowels.append(contentsOf: vowelU)\n\
    \    vowels.append(contentsOf: \"a\".characters.map { (c) -> String in\n     \
    \   if let idx = word.startIndex.advancedBy(c - 1) {\n            let ch = word[idx]\n\
    \            if ch != \"e\" && ch != \"i\" && ch != \"o\" && ch != \"u\" {\n \
    \               return \"\"\n            }\n            return String(ch)\n  \
    \      }\n        return \"\"\n    })\n    vowels.append(contentsOf: \"e\".characters.map\
    \ {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\"\
    ) == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplwo1g208.swift:90:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmplwo1g208.swift:86:18:\
    \ note: to match this opening '('\n    vowels.append(contentsOf: \"e\".characters.map\
    \ {\n                 ^\n/tmp/tmplwo1g208.swift:114:48: error: expected '}' at\
    \ end of brace statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n\
    \                                               ^\n/tmp/tmplwo1g208.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmplwo1g208.swift:17:13:\
    \ error: 'characters' is unavailable: Please use String directly\n    if word.characters.count\
    \ == 0 {\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplwo1g208.swift:22:38: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n        if let idx = word.startIndex.advancedBy(c - 1)\
    \ {\n                     ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmplwo1g208.swift:22:49:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'Int'\n        if let idx = word.startIndex.advancedBy(c - 1)\
    \ {\n                                                ^\n/tmp/tmplwo1g208.swift:33:38:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        if let\
    \ idx = word.startIndex.advancedBy(c - 1) {\n                     ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmplwo1g208.swift:33:49: error: cannot convert value of type\
    \ 'String.Element' (aka 'Character') to expected argument type 'Int'\n       \
    \ if let idx = word.startIndex.advancedBy(c - 1) {\n                         \
    \                       ^\n/tmp/tmplwo1g208.swift:44:38: error: value of type\
    \ 'String.Index' has no member 'advancedBy'\n        if let idx = word.startIndex.advancedBy(c\
    \ - 1) {\n                     ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmplwo1g208.swift:44:49:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character'"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.characters.count == 0 {\n        return \"\"\n    }\n\n    // Find right\
    \ side of word.\n    var index = word.characters.count - 1\n    while index >=\
    \ 0 && word.characters[index].isUppercase {\n        index--\n    }\n\n    if\
    \ index >= 0 {\n        var closestVowel = vowels[word.characters.count]\n   \
    \     for vowel in vowels[(index + 1)..word.characters.count] {\n            if\
    \ vowel.isLowercase {\n                continue\n            }\n            var\
    \ distance = min(distance(vowel, closestVowel), distance(vowel, word.characters[index]))\n\
    \            if distance == 0 {\n                closestVowel = vowel\n      \
    \      }\n        }\n        return closestVowel\n    } else {\n        return\
    \ \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyaluw_m.swift:17:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count == 0 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbyaluw_m.swift:22:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    var index\
    \ = word.characters.count - 1\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpbyaluw_m.swift:23:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    while index >= 0 && word.characters[index].isUppercase {\n              \
    \          ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbyaluw_m.swift:23:30: error: 'characters' is\
    \ unavailable: Please use String directly\n    while index >= 0 && word.characters[index].isUppercase\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbyaluw_m.swift:24:14: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n        index--\n             ^~\n/tmp/tmpbyaluw_m.swift:28:28:\
    \ error: cannot find 'vowels' in scope\n        var closestVowel = vowels[word.characters.count]\n\
    \                           ^~~~~~\n/tmp/tmpbyaluw_m.swift:29:22: error: cannot\
    \ find 'vowels' in scope\n        for vowel in vowels[(index + 1)..word.characters.count]\
    \ {\n                     ^~~~~~\n/tmp/tmpbyaluw_m.swift:29:40: error: cannot\
    \ find operator '..' in scope; did you mean '...'?\n        for vowel in vowels[(index\
    \ + 1)..word.characters.count] {\n                                       ^~\n\
    \                                       ...\n/tmp/tmpbyaluw_m.swift:33:32: error:\
    \ use of local variable 'distance' be"
  stdout: ''
  timestamp: 1660030474
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    if word == \"\" {\n        return \"\"\n    }\n    \n    var strArr = [String]()\n\
    \    var count = 0\n    \n    for i in 0..<word.count {\n        strArr.append(String(i))\n\
    \    }\n    \n    for char in strArr {\n        if char.hasPrefix(\"A\") && (char.hasSuffix(\"\
    E\") || char.hasSuffix(\"I\") || char.hasSuffix(\"O\") || char.hasSuffix(\"U\"\
    )) {\n            count += 1\n        }\n    }\n    \n    if count == 0 {\n  \
    \      return \"\"\n    }\n    \n    var vowels = \"\"\n    \n    for char in\
    \ strArr {\n        if char.hasSuffix(\"A\") || char.hasSuffix(\"I\") || char.hasSuffix(\"\
    O\") || char.hasSuffix(\"U\") {\n            vowels += char\n        }\n    }\n\
    \    \n    if vowels == \"\" {\n        return \"\"\n    }\n    \n    return vowels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpk1mqlh9b/tmpk1mqlh9b.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abe10712c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe10409b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abe10409988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abe104087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk1mqlh9b                        0x00005651ea6a3917 <unavailable> + 6423

    5    libc.so.6                          0x00002abe108fe460 __libc_start_main +
    245

    6    tmpk1mqlh9b                        0x00005651ea6a3559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = \"aeiouAEIOU\".characters.map(String.init) else {\n        return\
    \ \"\"\n    }\n    \n    var closestVowel = vowels.first\n    \n    guard let\
    \ firstIndex = word.startIndex else {\n        return \"\"\n    }\n    guard let\
    \ lastIndex = word.endIndex else {\n        return \"\"\n    }\n    \n    for\
    \ i in word.characters.reverse() {\n        if vowels.contains(i) {\n        \
    \    if firstIndex <= i && i <= lastIndex {\n                closestVowel = i\n\
    \            }\n            break\n        }\n    }\n    \n    return closestVowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp387lcknt.swift:17:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let vowels = \"aeiouAEIOU\".characters.map(String.init)\
    \ else {\n                                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp387lcknt.swift:17:11: error: initializer\
    \ for conditional binding must have Optional type, not '[String]'\n    guard let\
    \ vowels = \"aeiouAEIOU\".characters.map(String.init) else {\n          ^    \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp387lcknt.swift:23:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String.Index'\n\
    \    guard let firstIndex = word.startIndex else {\n          ^              \
    \  ~~~~~~~~~~~~~~~\n/tmp/tmp387lcknt.swift:26:11: error: initializer for conditional\
    \ binding must have Optional type, not 'String.Index'\n    guard let lastIndex\
    \ = word.endIndex else {\n          ^               ~~~~~~~~~~~~~\n/tmp/tmp387lcknt.swift:30:30:\
    \ error: value of type 'String' has no member 'reverse'\n    for i in word.characters.reverse()\
    \ {\n             ~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp387lcknt.swift:39:12: error:\
    \ value of optional type 'String?' must be unwrapped to a value of type 'String'\n\
    \    return closestVowel\n           ^\n/tmp/tmp387lcknt.swift:39:12: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return closestVowel\n           ^\n                        ?? <#default value#>\n\
    /tmp/tmp387lcknt.swift:39:12: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    return closestVowel\n           ^\n\
    \                       !\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel = \"\"\n    if word.contains(\"a\") {\n        vowel = \"a\"\n    } else\
    \ if word.contains(\"e\") {\n        vowel = \"e\"\n    } else if word.contains(\"\
    i\") {\n        vowel = \"i\"\n    } else if word.contains(\"o\") {\n        vowel\
    \ = \"o\"\n    } else if word.contains(\"u\") {\n        vowel = \"u\"\n    }\
    \ else if word.contains(\"y\") {\n        vowel = \"y\"\n    } else if word.contains(\"\
    u\") {\n        vowel = \"u\"\n    }\n    if vowel == \"\" {\n        return \"\
    \"\n    }\n    \n    var consonant = \"\"\n    \n    if word.contains(\"a\") {\n\
    \        consonant = \"a\"\n    } else if word.contains(\"e\") {\n        consonant\
    \ = \"e\"\n    } else if word.contains(\"i\") {\n        consonant = \"i\"\n \
    \   } else if word.contains(\"o\") {\n        consonant = \"o\"\n    } else if\
    \ word.contains(\"u\") {\n        consonant = \"u\"\n    } else if word.contains(\"\
    y\") {\n        consonant = \"y\"\n    }\n    \n    if consonant == \"\" {\n \
    \       return \"\"\n    }\n    \n    var strArr : [String] = []\n    strArr.append(word.substringToIndex(word.startIndex.advancedBy(-1)))\n\
    \    strArr.append(word.substringToIndex(word.startIndex.advancedBy(-1)))\n  \
    \  \n    return vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgv75j_7j.swift:58:24: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    strArr.append(word.substringToIndex(word.startIndex.advancedBy(-1)))\n\
    \                  ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpgv75j_7j.swift:58:57: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    strArr.append(word.substringToIndex(word.startIndex.advancedBy(-1)))\n\
    \                                        ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpgv75j_7j.swift:59:24:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    strArr.append(word.substringToIndex(word.startIndex.advancedBy(-1)))\n\
    \                  ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpgv75j_7j.swift:59:57: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    strArr.append(word.substringToIndex(word.startIndex.advancedBy(-1)))\n\
    \                                        ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ 1\n    var index = 0\n    var result: Int = 0\n    var firstLetter = word[index]\n\
    \n    // 2\n    while index < word.count {\n        switch firstLetter {\n   \
    \     case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\"\
    :\n        case \"u\":\n            // 3\n            if index+1 < word.count\
    \ {\n                firstLetter = word[index + 1]\n            } else {\n   \
    \             firstLetter = firstLetter\n            }\n        case \"A\":\n\
    \        case \"E\":\n        case \"I\":\n        case \"O\":\n        case \"\
    U\":\n            // 4\n            if index+2 < word.count {\n              \
    \  firstLetter = word[index + 2]\n            } else {\n                firstLetter\
    \ = firstLetter\n            }\n        default:\n            break\n        }\n\
    \n        // 5\n        result += word.distance(from: word.startIndex, to: index)\n\
    \        index += 1\n    }\n\n    // 6\n    if result < 0 {\n        result =\
    \ 0\n    }\n\n    // 7\n    return String()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp6rh_fcc7.swift:25:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp6rh_fcc7.swift:26:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp6rh_fcc7.swift:27:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6rh_fcc7.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6rh_fcc7.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6rh_fcc7.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6rh_fcc7.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6rh_fcc7.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"O\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6rh_fcc7.swift:20:23:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    var firstLetter = word[index]\n           \
    \           ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6rh_fcc7.swift:32:31: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       firstLetter = word[index + 1]\n                              ^~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = word.characters.filter({ $0 != \"a\" && $0 != \"e\" && $0 != \"\
    i\" && $0 != \"o\" && $0 != \"u\" && $0 != \"A\" && $0 != \"E\" && $0 != \"I\"\
    \ && $0 != \"O\" && $0 != \"U\" }) else {\n        return \"\"\n    }\n    let\
    \ minCount = vowels.count - 2\n    if vowels.count > 0 {\n        if vowels.count\
    \ == 1 {\n            if vowels.last == \"a\" || vowels.last == \"e\" || vowels.last\
    \ == \"i\" || vowels.last == \"o\" || vowels.last == \"u\" {\n               \
    \ return vowels.last\n            }\n        }\n        if vowels.count == 2 {\n\
    \            if vowels.last == \"a\" || vowels.last == \"e\" || vowels.last ==\
    \ \"i\" || vowels.last == \"o\" {\n                return vowels.last\n      \
    \      } else if vowels.last == \"a\" || vowels.last == \"e\" || vowels.last ==\
    \ \"i\" || vowels.last == \"u\" {\n                return vowels.last\n      \
    \      }\n        }\n    }\n    if vowels.count == 3 {\n        if vowels.last\
    \ == \"a\" || vowels.last == \"e\" || vowels.last == \"i\" || vowels.last == \"\
    o\" || vowels.last == \"u\" {\n            return vowels.last\n        } else\
    \ if vowels.last == \"a\" || vowels.last == \"e\" || vowels.last == \"i\" || vowels.last\
    \ == \"u\" {\n            return vowels.last\n        } else if vowels.last ==\
    \ \"a\" || vowels.last == \"e\" || vowels.last == \"o\" || vowels.last == \"u\"\
    \ {\n            return vowels.last\n        } else if vowels.last == \"a\" ||\
    \ vowels.last == \"e\" || vowels.last == \"o\" || vowels.last == \"u\" {\n   \
    \         return vowels.last\n        } else if vowels.last == \"a\" || vowels.last\
    \ == \"i\" || vowels.last == \"o\" || vowels.last == \"u\" {\n            return\
    \ vowels.last\n        } else if vowels.last == \"a\" || vowels.last == \"i\"\
    \ || vowels.last == \"u\" {\n            return vowels.last\n        }\n    }\n\
    \    if vowels.count == 4 {\n        if vowels.last == \"a\" || vowels.last ==\
    \ \"e\" || vowels.last == \"i\" || vowels.last == \"o\" || vowels.last == \"u\"\
    \ {\n            return vowels.last\n        } else if vowels.last == \"a\" ||\
    \ vowels.last == \"e\" || vowels.last == \"i\" || vowels.last == \"o\" || vowels.last\
    \ == \"u\" {\n            return vowels.last\n        } else if vowels.last \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpog0c8zi9.swift:55:30: error: expected '{' after 'if' condition\n\
    \        } else if vowels.last \n                             ^\n/tmp/tmpog0c8zi9.swift:83:48:\
    \ error: expected '}' at end of brace statement\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")\n                                               ^\n/tmp/tmpog0c8zi9.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmpog0c8zi9.swift:17:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard let\
    \ vowels = word.characters.filter({ $0 != \"a\" && $0 != \"e\" && $0 != \"i\"\
    \ && $0 != \"o\" && $0 != \"u\" && $0 != \"A\" && $0 != \"E\" && $0 != \"I\" &&\
    \ $0 != \"O\" && $0 != \"U\" }) else {\n                            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpog0c8zi9.swift:17:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    guard let vowels = word.characters.filter({ $0 != \"a\" && $0 != \"e\" &&\
    \ $0 != \"i\" && $0 != \"o\" && $0 != \"u\" && $0 != \"A\" && $0 != \"E\" && $0\
    \ != \"I\" && $0 != \"O\" && $0 != \"U\" }) else {\n          ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpog0c8zi9.swift:24:31: error: cannot convert return expression of type\
    \ 'String.Element?' (aka 'Optional<Character>') to return type 'String'\n    \
    \            return vowels.last\n                       ~~~~~~~^~~~\n/tmp/tmpog0c8zi9.swift:29:31:\
    \ error: cannot convert return expression of type 'String.Element?' (aka 'Optional<Character>')\
    \ to return type 'String'\n                return vowels.last\n              \
    \         ~~~~~~~^~~~\n/tmp/tmpog0c8zi9.swift:31:31: error: cannot convert return\
    \ expression of type 'String.Element?' (aka 'Optional<Character>') to return type\
    \ 'String'\n                return vowels.last\n                       ~~~~~~~^~~~\n\
    /tmp/tmpo"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    \n    if word == \"\" {\n        return \"\"\n\
    \    }\n    \n    let vowelIndex = word.startIndex.distanceTo(word.endIndex.startIndex)\n\
    \    let vowelLength = word.characters.count\n    \n    if vowelIndex == 0 ||\
    \ vowelIndex == vowelLength-1 {\n        return \"\"\n    }\n    \n    var closestVowelIndex\
    \ = vowelIndex\n    var closestVowelLength = 0\n    \n    for index in 0 ..< vowelLength\
    \ {\n        let char = word.characters[index]\n        let isVowel = vowels.contains(char)\n\
    \        if isVowel {\n            if index == 0 || index == vowelLength-1 {\n\
    \                continue\n            }\n            \n            let distance\
    \ = word.characters.count-index-1\n            if distance < closestVowelLength\
    \ {\n                closestVowelLength = distance\n                closestVowelIndex\
    \ = index\n            }\n        }\n    }\n    \n    return vowels[closestVowelIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfqo42kxk.swift:23:38: error: value of type 'String.Index' has no\
    \ member 'distanceTo'\n    let vowelIndex = word.startIndex.distanceTo(word.endIndex.startIndex)\n\
    \                     ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpfqo42kxk.swift:23:63:\
    \ error: value of type 'String.Index' has no member 'startIndex'\n    let vowelIndex\
    \ = word.startIndex.distanceTo(word.endIndex.startIndex)\n                   \
    \                             ~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpfqo42kxk.swift:24:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    let vowelLength\
    \ = word.characters.count\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpfqo42kxk.swift:34:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char = word.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfqo42kxk.swift:34:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = word.characters[index]\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpfqo42kxk.swift:41:33: error: 'characters'\
    \ is unavailable: Please use String directly\n            let distance = word.characters.count-index-1\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getVowels(word).min(by: { (vowel) -> Bool in\n        let c = vowel.unicodeScalars.last!\n\
    \        let nextC = c.nextCharacter\n        return nextC == Character(\"A\"\
    ) || nextC == Character(\"E\") || nextC == Character(\"I\") || nextC == Character(\"\
    O\") || nextC == Character(\"U\")\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmph02zs02y.swift:17:12: error: cannot find 'getVowels' in scope\n\
    \    return getVowels(word).min(by: { (vowel) -> Bool in\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvowels:\
    \ [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\t\n\tlet vowelIndex = word.characters.reverse().index(of:\
    \ \"o\")!\n\tlet index = word.characters.index(of: \"u\")!\n\tlet nextIndex =\
    \ word.characters.index(of: \"a\")!\n\tlet vowel = vowels[(vowelIndex + nextIndex)\
    \ % vowels.count]\n\treturn vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpobazi__3.swift:17:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        vowels: [String] = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n              ^\n              ;\n/tmp/tmpobazi__3.swift:17:8: error:\
    \ expected expression\n        vowels: [String] = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n              ^\n/tmp/tmpobazi__3.swift:17:2: error: cannot find 'vowels'\
    \ in scope\n        vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n \
    \       ^~~~~~\n/tmp/tmpobazi__3.swift:19:35: error: value of type 'String' has\
    \ no member 'reverse'\n        let vowelIndex = word.characters.reverse().index(of:\
    \ \"o\")!\n                         ~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpobazi__3.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ index = word.characters.index(of: \"u\")!\n                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpobazi__3.swift:20:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = word.characters.index(of: \"u\")!\n                                \
    \    ^\n/tmp/tmpobazi__3.swift:20:30: note: use 'firstIndex(of:)' instead\n  \
    \      let index = word.characters.index(of: \"u\")!\n                       \
    \             ^~~~~\n                                    firstIndex\n/tmp/tmpobazi__3.swift:21:23:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ nextIndex = word.characters.index(of: \"a\")!\n                            \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpobazi__3.swift:21:34:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ nextIndex = word.characters.index(of: \"a\")!\n                            \
    \            ^\n/tmp/tmpobazi__3.swift:21:34: note: use 'firstIndex(of:)' instead\n\
    \        let nextIndex = word.characters.index(of: \"a\")!\n                 \
    \                       ^~~~~\n                             "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    \n    for let letter : Character in word {\n \
    \       if let index = vowels.index(where: { $0 == letter }) {\n            vowels.remove(at:\
    \ index)\n            vowels.insert(letter, at: vowels.count - 1)\n        }\n\
    \    }\n    \n    return vowels.isEmpty ? \"\" : vowels.joined(separator: \"\"\
    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4e28he6o.swift:19:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let letter : Character in word {\n\
    \        ^\n/tmp/tmp4e28he6o.swift:20:31: warning: 'index(where:)' is deprecated:\
    \ renamed to 'firstIndex(where:)'\n        if let index = vowels.index(where:\
    \ { $0 == letter }) {\n                              ^\n/tmp/tmp4e28he6o.swift:20:31:\
    \ note: use 'firstIndex(where:)' instead\n        if let index = vowels.index(where:\
    \ { $0 == letter }) {\n                              ^~~~~\n                 \
    \             firstIndex\n/tmp/tmp4e28he6o.swift:26:41: error: no exact matches\
    \ in call to instance method 'joined'\n    return vowels.isEmpty ? \"\" : vowels.joined(separator:\
    \ \"\")\n                                        ^\nSwift.Sequence:1:11: note:\
    \ candidate requires that 'Character' conform to 'StringProtocol' (requirement\
    \ specified as 'Self.Element' : 'StringProtocol')\nextension Sequence where Self.Element\
    \ : StringProtocol {\n          ^\nSwift.BidirectionalCollection:1:11: note: candidate\
    \ requires that the types 'Character' and 'String' be equivalent (requirement\
    \ specified as 'Self.Element' == 'String')\nextension BidirectionalCollection\
    \ where Self.Element == String {\n          ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels(for: word) else { return \"\" }\n    if vowels.count ==\
    \ 0 { return \"\" }\n    \n    let rightSide = word.index(word.startIndex, offsetBy:\
    \ word.characters.count - 1)\n    guard let rightSideLetter = letterForIndex(rightSide,\
    \ in: word) else { return \"\" }\n    guard !vowels.contains(rightSideLetter)\
    \ else { return \"\" }\n    \n    let index = vowels.index(of: rightSideLetter)\n\
    \    return vowels[index - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp9mj5bjr0.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels(for: word) else { return \"\" }\n               \
    \        ^~~~~~\n/tmp/tmp9mj5bjr0.swift:20:64: error: 'characters' is unavailable:\
    \ Please use String directly\n    let rightSide = word.index(word.startIndex,\
    \ offsetBy: word.characters.count - 1)\n                                     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9mj5bjr0.swift:21:33: error: cannot find 'letterForIndex'\
    \ in scope\n    guard let rightSideLetter = letterForIndex(rightSide, in: word)\
    \ else { return \"\" }\n                                ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  return\
    \ get_closest_vowel_advanced(word: word, baseIndex: word.endIndex)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpiw3exdto.swift:17:10: error: cannot find 'get_closest_vowel_advanced'\
    \ in scope\n  return get_closest_vowel_advanced(word: word, baseIndex: word.endIndex)\n\
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet count\
    \ = word.characters.count\n\tvar letters = Array(word)\n\tletters = letters.filter({$0\
    \ != \"A\" && $0 != \"E\" && $0 != \"I\" && $0 != \"O\" && $0 != \"U\" && $0 !=\
    \ \"a\" && $0 != \"e\" && $0 != \"i\" && $0 != \"o\" && $0 != \"u\"})\n\tif count\
    \ == 0 {\n\t\treturn \"\"\n\t}\n\tletters = letters.reverse()\n\tif letters.count\
    \ == 0 {\n\t\treturn \"\"\n\t}\n\tfor i : Int in 0..<count {\n\t\tlet letter =\
    \ letters[i]\n\t\tif letter != \"A\" && letter != \"E\" && letter != \"I\" &&\
    \ letter != \"O\" && letter != \"U\" && letter != \"a\" && letter != \"e\" &&\
    \ letter != \"i\" && letter != \"o\" && letter != \"u\" {\n\t\t\treturn \"\"\n\
    \t\t}\n\t\tif i == (count-1) {\n\t\t\tif letter != \"A\" && letter != \"e\" &&\
    \ letter != \"i\" && letter != \"o\" && letter != \"u\" {\n\t\t\t\treturn letter\n\
    \t\t\t}\n\t\t}\n\t\tif i == (count-2) {\n\t\t\tif letter != \"A\" && letter !=\
    \ \"I\" && letter != \"o\" && letter != \"u\" {\n\t\t\t\treturn letter\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpx5m83bz9.swift:17:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        let count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx5m83bz9.swift:23:20: error: cannot assign value of type '()' to\
    \ type '[String.Element]' (aka 'Array<Character>')\n        letters = letters.reverse()\n\
    \                  ~~~~~~~~^~~~~~~~~\n/tmp/tmpx5m83bz9.swift:34:12: error: cannot\
    \ convert return expression of type 'String.Element' (aka 'Character') to return\
    \ type 'String'\n                                return letter\n             \
    \                          ^~~~~~\n/tmp/tmpx5m83bz9.swift:39:12: error: cannot\
    \ convert return expression of type 'String.Element' (aka 'Character') to return\
    \ type 'String'\n                                return letter\n             \
    \                          ^~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar vowels:\
    \ [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tlet lastConsonantIndex = word.count\
    \ - 1\n\tlet lastIndexOfVowel: Int? = vowels.firstIndex(of: word[lastConsonantIndex])\n\
    \tguard let vowelIndex = lastIndexOfVowel else { return \"\" }\n\tlet index =\
    \ lastConsonantIndex - 1\n\tlet currentVowel = vowels[index]\n\twhile index >\
    \ 0 {\n\t\tindex -= 1\n\t\tif word[index] == \"a\" || word[index] == \"e\" ||\
    \ word[index] == \"i\" || word[index] == \"o\" || word[index] == \"u\" {\n\t\t\
    \tvowels.remove(at: index)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn vowels.firstIndex(of:\
    \ currentVowel) ?? \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpoqvptc3j.swift:19:57: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        let lastIndexOfVowel: Int? = vowels.firstIndex(of:\
    \ word[lastConsonantIndex])\n                                                \
    \               ^\n/tmp/tmpoqvptc3j.swift:24:9: error: left side of mutating operator\
    \ isn't mutable: 'index' is a 'let' constant\n                index -= 1\n   \
    \             ~~~~~ ^\n/tmp/tmpoqvptc3j.swift:21:2: note: change 'let' to 'var'\
    \ to make it mutable\n        let index = lastConsonantIndex - 1\n        ^~~\n\
    \        var\n/tmp/tmpoqvptc3j.swift:25:6: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       if word[index] == \"a\" || word[index] == \"e\" || word[index] == \"i\"\
    \ || word[index] == \"o\" || word[index] == \"u\" {\n                   ^~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpoqvptc3j.swift:25:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if word[index] == \"a\" || word[index]\
    \ == \"e\" || word[index] == \"i\" || word[index] == \"o\" || word[index] == \"\
    u\" {\n                                         ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpoqvptc3j.swift:25:50:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if word[index] == \"a\" || word[index]\
    \ == \"e\" || word[index] == \"i\" || word[index] == \"o\" || word[index] == \"\
    u\" {\n                                                               ^~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpoqvptc3j.swift:25:72:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    guard let vowelsArray = vowels.split(separator: \",\") else {\n        return\
    \ \"\"\n    }\n    var index = vowels.characters.count\n    var vowel = \"\"\n\
    \    \n    while index > 0 {\n        let char = vowels.characters[index]\n  \
    \      if vowelsArray.contains(char) {\n            vowel = char\n        }\n\
    \        index -= 1\n    }\n    return vowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp20djsr64.swift:18:29: error: cannot find 'vowels' in scope\n  \
    \  guard let vowelsArray = vowels.split(separator: \",\") else {\n           \
    \                 ^~~~~~\n/tmp/tmp20djsr64.swift:21:17: error: cannot find 'vowels'\
    \ in scope\n    var index = vowels.characters.count\n                ^~~~~~\n\
    /tmp/tmp20djsr64.swift:25:20: error: cannot find 'vowels' in scope\n        let\
    \ char = vowels.characters[index]\n                   ^~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowelsCount = vowels.map { $0.lowercaseString }.count\n    if vowelsCount ==\
    \ 0 {\n        return \"\"\n    }\n    let wordArray = word.characters\n    var\
    \ firstConsonantIndex = wordArray.count - 1\n    var secondConsonantIndex = wordArray.count\
    \ - 1\n    let letter = \"a\"\n    while let characters = wordArray[firstConsonantIndex..<secondConsonantIndex]\
    \ {\n        if let letter = characters.filter({ vowels.contains($0.lowercaseString)\
    \ }).first {\n            return letter\n        } else {\n            firstConsonantIndex\
    \ -= 1\n            secondConsonantIndex -= 1\n        }\n    }\n    return \"\
    \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\"\
    ) == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvc780m3q.swift:17:23: error: cannot find 'vowels' in scope\n  \
    \  let vowelsCount = vowels.map { $0.lowercaseString }.count\n               \
    \       ^~~~~~\n/tmp/tmpvc780m3q.swift:21:26: error: 'characters' is unavailable:\
    \ Please use String directly\n    let wordArray = word.characters\n          \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvc780m3q.swift:25:28: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \    while let characters = wordArray[firstConsonantIndex..<secondConsonantIndex]\
    \ {\n                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpvc780m3q.swift:26:45: error: cannot\
    \ find 'vowels' in scope\n        if let letter = characters.filter({ vowels.contains($0.lowercaseString)\
    \ }).first {\n                                            ^~~~~~\n/tmp/tmpvc780m3q.swift:25:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    while let characters = wordArray[firstConsonantIndex..<secondConsonantIndex]\
    \ {\n          ^                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getVowels(word).maxElement()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmphnl3r6p0.swift:17:12: error: cannot find 'getVowels' in scope\n\
    \    return getVowels(word).maxElement()\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = Set(\"aeiouAEIOU\")\n    \n    guard let characters = word.characters.reversed()\
    \ else { return \"\" }\n    \n    let consonants = characters.filter { c in\n\
    \        let range = characters.startIndex..<characters.endIndex\n        return\
    \ range.contains(c)\n    }\n    \n    let rightSide = consonants.map { $0.unicodeScalars.last!.value\
    \ - 1 }\n    \n    var result = \"\"\n    \n    if rightSide.contains(0) {\n \
    \       \n        let closestCharacter = characters.enumerated().map { (index,\
    \ character) in\n            let index = index\n            let consonant = character\
    \ == UnicodeScalar(\"C\")\n            \n            let range = characters.startIndex..<characters.endIndex\n\
    \            let characterIndex = range.index(range.startIndex, offsetBy: index)\n\
    \            let character = characters[characterIndex]\n            \n      \
    \      if character == UnicodeScalar(\"A\") {\n                return (\n    \
    \                characters.startIndex + index >= rightSide.endIndex ? consonant\
    \ : character == UnicodeScalar(\"I\") ? character == UnicodeScalar(\"U\") : character\
    \ == UnicodeScalar(\"o\") ? character == UnicodeScalar(\"O\") : character == UnicodeScalar(\"\
    e\")\n                ) ? UnicodeScalar(\"u\") : \"\"\n            }\n       \
    \     \n            if character == UnicodeScalar(\"O\") {\n                return\
    \ (\n                    characters.startIndex + index >= rightSide.endIndex ?\
    \ consonant : character == UnicodeScalar(\"a\") ? character == UnicodeScalar(\"\
    i\") || character == UnicodeScalar(\"u\") : character == UnicodeScalar(\"o\")\
    \ ? character == UnicodeScalar(\"e\") : character == UnicodeScalar(\"e\")\n  \
    \              ) ? UnicodeScalar(\"u\") : \"\"\n            }\n            \n\
    \            if character == UnicodeScalar(\"u\") {\n                return (\n\
    \                    characters.startIndex + index >= rightSide.endIndex ? consonant\
    \ : character == UnicodeScalar(\"o\") ? character == UnicodeScalar(\"i\") || character\
    \ == UnicodeScalar(\"u\") : character == UnicodeScalar(\"u\") ? character == UnicodeScalar(\"\
    e\") : character == UnicodeScalar(\"i\")\n                ) ? UnicodeScalar(\"\
    U\") : \"\"\n            }\n            \n            if character == UnicodeScalar(\"\
    i\") {\n                return (\n                    characters.startIndex +\
    \ index >= rightSide.endIndex ? consonant : character == UnicodeScalar(\"u\")\
    \ ? character == UnicodeScalar(\"a\") || character == UnicodeScalar(\"u\") : character\
    \ == UnicodeScalar(\"i\") ? character == UnicodeScalar(\"e\") : character == UnicodeScalar(\"\
    e\")\n                ) ? UnicodeScalar(\"i\") : \"\"\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3am35p6n.swift:91:48: error: expected '}' at end of closure\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")\n                                               ^\n/tmp/tmp3am35p6n.swift:33:60:\
    \ note: to match this opening '{'\n        let closestCharacter = characters.enumerated().map\
    \ { (index, character) in\n                                                  \
    \         ^\n/tmp/tmp3am35p6n.swift:91:48: error: expected '}' at end of brace\
    \ statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n           \
    \                                    ^\n/tmp/tmp3am35p6n.swift:31:30: note: to\
    \ match this opening '{'\n    if rightSide.contains(0) {\n                   \
    \          ^\n/tmp/tmp3am35p6n.swift:91:48: error: expected '}' at end of brace\
    \ statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n           \
    \                                    ^\n/tmp/tmp3am35p6n.swift:16:48: note: to\
    \ match this opening '{'\nfunc get_closest_vowel(word: String) -> String {\n \
    \                                              ^\n/tmp/tmp3am35p6n.swift:20:33:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard let\
    \ characters = word.characters.reversed() else { return \"\" }\n             \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3am35p6n.swift:20:11: error: initializer for conditional binding\
    \ must have Optional type, not 'ReversedCollection<String>'\n    guard let characters\
    \ = word.characters.reversed() else { return \"\" }\n          ^             \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3am35p6n.swift:24:31: error: cannot convert\
    \ value of type 'ReversedCollection<String>.Element' (aka 'Character') to expected\
    \ argument type 'ReversedCollection<String>.Index'\n        return range.contains(c)\n\
    \                              ^\n/tmp/tmp3am35p6n.swift:35:39: error: binary\
    \ operator '==' cannot be applied to operands of type 'ReversedCollection<String>.Element'\
    \ (aka 'Character') and 'UnicodeScalar' (aka 'Unicode.Scalar')\n           "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvowel\
    \ := \"\"\n\tfor i := len(word) - 1; i >= 0; i-- {\n\t\tif word[i] == \"a\" ||\
    \ word[i] == \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i] == \"u\"\
    \ {\n\t\t\tvowel = word[i]\n\t\t\tbreak\n\t\t}\n\t}\n\treturn vowel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfv71dzbz.swift:17:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        vowel := \"\"\n             ^\n             ;\n\
    /tmp/tmpfv71dzbz.swift:17:8: error: expected expression\n        vowel := \"\"\
    \n              ^\n/tmp/tmpfv71dzbz.swift:18:9: error: expected type\n       \
    \ for i := len(word) - 1; i >= 0; i-- {\n               ^\n                <#type#>\n\
    /tmp/tmpfv71dzbz.swift:18:9: error: expected 'in' after for-each pattern\n   \
    \     for i := len(word) - 1; i >= 0; i-- {\n               ^\n/tmp/tmpfv71dzbz.swift:18:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := len(word)\
    \ - 1; i >= 0; i-- {\n               ^\n/tmp/tmpfv71dzbz.swift:17:2: error: cannot\
    \ find 'vowel' in scope\n        vowel := \"\"\n        ^~~~~\n/tmp/tmpfv71dzbz.swift:24:9:\
    \ error: cannot find 'vowel' in scope\n        return vowel\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = \"aeiouAEIOU\"\n\tlet vowelsIndex = [vowels.startIndex, vowels.endIndex]\n\
    \t\n\tlet firstLetter = word[0]\n\t\n\tvar rightVowelIndex = vowelsIndex\n\trightVowelIndex[0]\
    \ = vowels.endIndex\n\trightVowelIndex[1] = vowels.startIndex\n\t\n\tvar leftVowelIndex\
    \ = vowelsIndex\n\tleftVowelIndex[0] = vowels.startIndex\n\tleftVowelIndex[1]\
    \ = vowels.endIndex\n\t\n\t\n\tvar leftVowel = String()\n\tvar rightVowel = String()\n\
    \t\n\t\n\tfor index in rightVowelIndex {\n\t\tlet currentChar = String(word.suffix(from:\
    \ index))\n\t\t\n\t\tif vowels.contains(currentChar) {\n\t\t\trightVowel = currentChar\n\
    \t\t\tbreak\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tfor index in leftVowelIndex {\n\t\tlet\
    \ currentChar = String(word.prefix(from: index))\n\t\t\n\t\tif vowels.contains(currentChar)\
    \ {\n\t\t\tleftVowel = currentChar\n\t\t\tbreak\n\t\t}\n\t\t\n\t}\n\t\n\tif leftVowel\
    \ == \"\" && rightVowel == \"\" {\n\t\treturn \"\"\n\t} else if leftVowel == \"\
    \" {\n\t\treturn rightVowel\n\t} else if rightVowel == \"\" {\n\t\treturn leftVowel\n\
    \t} else {\n\t\tif leftVowel == rightVowel {\n\t\t\treturn leftVowel\n\t\t} else\
    \ {\n\t\t\tif leftVowel < rightVowel {\n\t\t\t\treturn leftVowel\n\t\t\t} else\
    \ {\n\t\t\t\treturn rightVowel\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp08t9qt6o.swift:20:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let firstLetter\
    \ = word[0]\n                          ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp08t9qt6o.swift:47:33: error: no exact\
    \ matches in call to instance method 'prefix'\n                let currentChar\
    \ = String(word.prefix(from: index))\n                                       \
    \       ^\nSwift.Collection:9:40: note: incorrect labels for candidate (have:\
    \ '(from:)', expected: '(upTo:)')\n    @inlinable public __consuming func prefix(upTo\
    \ end: Self.Index) -> Self.SubSequence\n                                     \
    \  ^\nSwift.Collection:11:40: note: incorrect labels for candidate (have: '(from:)',\
    \ expected: '(through:)')\n    @inlinable public __consuming func prefix(through\
    \ position: Self.Index) -> Self.SubSequence\n                                \
    \       ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ words.filter{ \n        word[$0] != \"\" && word[$0].hasPrefix(\"A\") && word[$0].hasSuffix(\"\
    a\") \n    }.sorted{ $0.hasPrefix(\"A\") && !($0.hasSuffix(\"a\")) }.last\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpuadghzv7.swift:17:12: error: cannot find 'words' in scope\n   \
    \ return words.filter{ \n           ^~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ write your code in geeksforgeeks\n    \n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp4s0st7s1/tmp4s0st7s1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba52e102c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba52ddf9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba52ddf9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba52ddf87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4s0st7s1                        0x00005581983ed307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba52e2ee460 __libc_start_main +
    245

    6    tmp4s0st7s1                        0x00005581983ecf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    vowels = vowels.characters.map(String.init).sorted()\n\
    \    var newVowel = \"\"\n    var index = 0\n    let stringArr = word.characters.map\
    \ { $0 }\n    for vowel in vowels {\n        index = stringArr.index(of: vowel)\n\
    \        let newArr: [String] = stringArr[index...].sorted()\n        for char\
    \ in newArr {\n            if char == vowel.uppercased() {\n                newVowel\
    \ = vowel\n                break\n            }\n        }\n    }\n    return\
    \ newVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpzbuv8ev0.swift:18:49: error: cannot assign value of type '[String]'\
    \ to type 'String'\n    vowels = vowels.characters.map(String.init).sorted()\n\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpzbuv8ev0.swift:21:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let stringArr\
    \ = word.characters.map { $0 }\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzbuv8ev0.swift:23:27: error: value of\
    \ optional type 'Array<String.Element>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<String.Element>.Index' (aka 'Int')\n        index\
    \ = stringArr.index(of: vowel)\n                          ^\n/tmp/tmpzbuv8ev0.swift:23:27:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        index = stringArr.index(of: vowel)\n                        \
    \  ^\n                                           ?? <#default value#>\n/tmp/tmpzbuv8ev0.swift:23:27:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        index = stringArr.index(of: vowel)\n                        \
    \  ^\n                                          !\n/tmp/tmpzbuv8ev0.swift:24:52:\
    \ error: cannot assign value of type '[String.Element]' (aka 'Array<Character>')\
    \ to type '[String]'\n        let newArr: [String] = stringArr[index...].sorted()\n\
    \                                                   ^\n/tmp/tmpzbuv8ev0.swift:24:52:\
    \ note: arguments to generic parameter 'Element' ('String.Element' (aka 'Character')\
    \ and 'String') are expected to be equal\n        let newArr: [String] = stringArr[index...].sorted()\n\
    \                                                   ^\n/tmp/tmpzbuv8ev0.swift:27:28:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      newVowel = vowel\n                           ^~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  // write\
    \ your code in geeksforgeeks.org\n  let vowelsArray = NSCharacterSet.letterCharacters().inverted()\n\
    \  let rangeOfVowels = word.rangeOfCharacterFromSet(vowelsArray)\n  \n  if rangeOfVowels.location\
    \ != NSNotFound {\n    let vowel = word.substringFromIndex(rangeOfVowels.location)\n\
    \    \n    if vowel.isLowercase {\n      return vowel\n    }\n  }\n  \n  return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdnmjnntm.swift:18:21: error: cannot find 'NSCharacterSet' in scope\n\
    \  let vowelsArray = NSCharacterSet.letterCharacters().inverted()\n          \
    \          ^~~~~~~~~~~~~~\n/tmp/tmpdnmjnntm.swift:19:28: error: value of type\
    \ 'String' has no member 'rangeOfCharacterFromSet'\n  let rangeOfVowels = word.rangeOfCharacterFromSet(vowelsArray)\n\
    \                      ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdnmjnntm.swift:21:32:\
    \ error: cannot find 'NSNotFound' in scope\n  if rangeOfVowels.location != NSNotFound\
    \ {\n                               ^~~~~~~~~~\n/tmp/tmpdnmjnntm.swift:22:22:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n    let vowel\
    \ = word.substringFromIndex(rangeOfVowels.location)\n                ~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet charsIndex\
    \ = word.characters.reverse()\n\tlet vowels = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYz\"\
    .characters.reverse()\n\tlet vowIndex = (charsIndex.index(of: vowels.joined())\
    \ + vowels.count) % (vowels.count)\n\t\n\tif vowIndex >= 0 {\n\t\treturn vowels[vowIndex]\n\
    \t}\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpsnfk9ny0.swift:17:35: error: value of type 'String' has no member\
    \ 'reverse'\n        let charsIndex = word.characters.reverse()\n            \
    \             ~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpsnfk9ny0.swift:18:80: error: value\
    \ of type 'String' has no member 'reverse'\n        let vowels = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYz\"\
    .characters.reverse()\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    guard let chars = word.unicodeScalars.filter{$0.isLower}.joined(),\
    \ chars.isEmpty else { return \"\" }\n    let start = String.index(of: chars.dropLast())!\n\
    \    let end = start.advanced(by: word.unicodeScalars.count - chars.count)\n \
    \   return word.unicodeScalars[end.successor()...].isEmpty ? \"\" : String(word.unicodeScalars[end.successor()...])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpjysdu8sg.swift:18:53: error: value of type 'Unicode.Scalar' has\
    \ no member 'isLower'\n    guard let chars = word.unicodeScalars.filter{$0.isLower}.joined(),\
    \ chars.isEmpty else { return \"\" }\n                                       \
    \          ~~ ^~~~~~~\n/tmp/tmpjysdu8sg.swift:19:17: error: instance member 'index'\
    \ cannot be used on type 'String'; did you mean to use a value of this type instead?\n\
    \    let start = String.index(of: chars.dropLast())!\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"a\",\"e\",\"i\",\"o\",\"u\"\n    for vowel in vowels.reversed() {\n\
    \        if word.starts.index(vowel.lowercased(), options: .backward) != nil {\n\
    \            return vowel\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpynrdiwtp.swift:17:22: error: expected pattern\n    let vowels =\
    \ \"a\",\"e\",\"i\",\"o\",\"u\"\n                     ^\n/tmp/tmpynrdiwtp.swift:19:12:\
    \ error: generic parameter 'PossiblePrefix' could not be inferred\n        if\
    \ word.starts.index(vowel.lowercased(), options: .backward) != nil {\n       \
    \    ^\nSwift.Sequence:2:28: note: in call to function 'starts(with:by:)'\n  \
    \  @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix,\
    \ by areEquivalent: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows\
    \ -> Bool where PossiblePrefix : Sequence\n                           ^\n/tmp/tmpynrdiwtp.swift:19:24:\
    \ error: reference to member 'index' cannot be resolved without a contextual type\n\
    \        if word.starts.index(vowel.lowercased(), options: .backward) != nil {\n\
    \                       ^\n/tmp/tmpynrdiwtp.swift:19:60: error: cannot infer contextual\
    \ base in reference to member 'backward'\n        if word.starts.index(vowel.lowercased(),\
    \ options: .backward) != nil {\n                                             \
    \             ~^~~~~~~~\n/tmp/tmpynrdiwtp.swift:20:20: error: cannot convert return\
    \ expression of type 'String.Element' (aka 'Character') to return type 'String'\n\
    \            return vowel\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word: word, vowels: vowels, consonants: consonants)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8yberolv.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word: word, vowels: vowels, consonants: consonants)\n\
    \           ^~~~~~~~~~~~~~~\n/tmp/tmp8yberolv.swift:17:48: error: cannot find\
    \ 'vowels' in scope\n    return getClosestVowel(word: word, vowels: vowels, consonants:\
    \ consonants)\n                                               ^~~~~~\n/tmp/tmp8yberolv.swift:17:68:\
    \ error: cannot find 'consonants' in scope\n    return getClosestVowel(word: word,\
    \ vowels: vowels, consonants: consonants)\n                                  \
    \                                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"];\n    var vowel_left = vowel.filter({\
    \ (vowel: Character) -> Bool in\n        let char = Character(vowel)\n       \
    \ return word.characters.contains(char)\n    })\n    \n    var vowel_right = vowel.filter({\
    \ (vowel: Character) -> Bool in\n        let char = Character(vowel)\n       \
    \ return !word.characters.contains(char)\n    })\n    \n    let min_distance =\
    \ word.characters.map { (char: Character) -> Character in\n        if vowel_left.contains(char)\
    \ {\n            return char\n        } else if vowel_right.contains(char) {\n\
    \            return char\n        } else {\n            return char\n        }\n\
    \    }.min()\n    \n    return String(min_distance)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpzhc6h4gm.swift:18:35: error: cannot convert value of type '(Character)\
    \ -> Bool' to expected argument type '(String) throws -> Bool'\n    var vowel_left\
    \ = vowel.filter({ (vowel: Character) -> Bool in\n                           \
    \       ^\n/tmp/tmpzhc6h4gm.swift:19:30: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        let char = Character(vowel)\n                             ^\n\
    \                             extendedGraphemeClusterLiteral: \n/tmp/tmpzhc6h4gm.swift:23:36:\
    \ error: cannot convert value of type '(Character) -> Bool' to expected argument\
    \ type '(String) throws -> Bool'\n    var vowel_right = vowel.filter({ (vowel:\
    \ Character) -> Bool in\n                                   ^\n/tmp/tmpzhc6h4gm.swift:24:30:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      let char = Character(vowel)\n                             ^\n         \
    \                    extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar lastConsonant\
    \ : Character = \"\"\n\tfor consonant : Character in word {\n\t\tswitch consonant.unicodeScalars.count\
    \ {\n\t\tcase 0:\n\t\t\treturn \"\"\n\t\tcase 1:\n\t\t\tlastConsonant = consonant\n\
    \t\tcase 2:\n\t\t\tif lastConsonant.unicodeScalars.first >= 'A' && lastConsonant.unicodeScalars.first\
    \ <= 'Z' {\n\t\t\t\tif lastConsonant.unicodeScalars.first < 'a' || lastConsonant.unicodeScalars.first\
    \ > 'z' {\n\t\t\t\t\treturn \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lastConsonant.unicodeScalars.first!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkvci0fp6.swift:25:45: error: single-quoted string literal found,\
    \ use '\"'\n                        if lastConsonant.unicodeScalars.first >= 'A'\
    \ && lastConsonant.unicodeScalars.first <= 'Z' {\n                           \
    \                                      ^~~\n                                 \
    \                                \"A\"\n/tmp/tmpkvci0fp6.swift:25:90: error: single-quoted\
    \ string literal found, use '\"'\n                        if lastConsonant.unicodeScalars.first\
    \ >= 'A' && lastConsonant.unicodeScalars.first <= 'Z' {\n                    \
    \                                                                            \
    \              ^~~\n                                                         \
    \                                                     \"Z\"\n/tmp/tmpkvci0fp6.swift:26:45:\
    \ error: single-quoted string literal found, use '\"'\n                      \
    \          if lastConsonant.unicodeScalars.first < 'a' || lastConsonant.unicodeScalars.first\
    \ > 'z' {\n                                                                  \
    \      ^~~\n                                                                 \
    \       \"a\"\n/tmp/tmpkvci0fp6.swift:26:89: error: single-quoted string literal\
    \ found, use '\"'\n                                if lastConsonant.unicodeScalars.first\
    \ < 'a' || lastConsonant.unicodeScalars.first > 'z' {\n                      \
    \                                                                            \
    \                  ^~~\n                                                     \
    \                                                               \"z\"\n/tmp/tmpkvci0fp6.swift:17:34:\
    \ error: cannot convert value of type 'String' to specified type 'Character'\n\
    \        var lastConsonant : Character = \"\"\n                              \
    \          ^~\n/tmp/tmpkvci0fp6.swift:25:42: error: type '((Unicode.Scalar) throws\
    \ -> Bool) throws -> Unicode.Scalar?' cannot conform to 'StringProtocol'\n   \
    \                     if lastConsonant.unicodeScalars.first >= 'A' && lastConsonant.unicodeScalars.first\
    \ <= 'Z' {\n                                            "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar vowels:[String]\
    \ = []\n\tfor vowel in vowels{\n\t\tif word.rangeOfString(vowel) != nil {\n\t\t\
    \tvowels.append(vowel)\n\t\t}\n\t}\n\tvowels.sort()\n\tvowels.reverse()\n\tfor\
    \ vowel in vowels{\n\t\tif word.rangeOfString(vowel) != nil {\n\t\t\treturn vowel\n\
    \t\t}\n\t}\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpsqx5qh24.swift:19:11: error: value of type 'String' has no member\
    \ 'rangeOfString'\n                if word.rangeOfString(vowel) != nil {\n   \
    \                ~~~~ ^~~~~~~~~~~~~\n/tmp/tmpsqx5qh24.swift:26:11: error: value\
    \ of type 'String' has no member 'rangeOfString'\n                if word.rangeOfString(vowel)\
    \ != nil {\n                   ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ strings.find_first(word, false, func(i int, _ chr int) bool {\n        return\
    \ isVowel(chr) || chr == ':'\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_vuvu46_.swift:17:44: error: expected expression in list of expressions\n\
    \    return strings.find_first(word, false, func(i int, _ chr int) bool {\n  \
    \                                         ^\n/tmp/tmp_vuvu46_.swift:17:48: error:\
    \ expected identifier in function declaration\n    return strings.find_first(word,\
    \ false, func(i int, _ chr int) bool {\n                                     \
    \          ^\n/tmp/tmp_vuvu46_.swift:18:39: error: single-quoted string literal\
    \ found, use '\"'\n        return isVowel(chr) || chr == ':'\n               \
    \                       ^~~\n                                      \":\"\n/tmp/tmp_vuvu46_.swift:17:12:\
    \ error: cannot find 'strings' in scope\n    return strings.find_first(word, false,\
    \ func(i int, _ chr int) bool {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = \"aeiouAEIOU\".characters, word.characters.count > 0 else {\n \
    \       return \"\"\n    }\n    var startIndex = 0\n    var endIndex = word.characters.count-1\n\
    \    guard word.characters.count >= 3 else {\n        return \"\"\n    }\n   \
    \ guard let first = word.characters.first else { return \"\" }\n    guard let\
    \ last = word.characters.last else { return \"\" }\n    while startIndex <= endIndex\
    \ {\n        let start = vowels.indexOf(first!)\n        let end = vowels.indexOf(last!)\n\
    \        if start <= end {\n            return word[startIndex..<startIndex+1]\n\
    \        }\n        startIndex += 1\n        endIndex -= 1\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp396sbpkc.swift:17:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let vowels = \"aeiouAEIOU\".characters, word.characters.count\
    \ > 0 else {\n                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp396sbpkc.swift:17:54: error: 'characters'\
    \ is unavailable: Please use String directly\n    guard let vowels = \"aeiouAEIOU\"\
    .characters, word.characters.count > 0 else {\n                              \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp396sbpkc.swift:17:11: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    guard let vowels = \"aeiouAEIOU\"\
    .characters, word.characters.count > 0 else {\n          ^            ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp396sbpkc.swift:21:25: error: 'characters' is unavailable: Please use String\
    \ directly\n    var endIndex = word.characters.count-1\n                     \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp396sbpkc.swift:22:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard word.characters.count\
    \ >= 3 else {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp396sbpkc.swift:25:28: error: 'characters' is unavailable:\
    \ Please use String directly\n    guard let first = word.characters.first else\
    \ { return \"\" }\n                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp396sbpkc.swift:26:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    guard let last = word.characters.last\
    \ else { return \"\" }\n                          ^~"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tguard\
    \ word.characters.count >= 1 else {\n\t\treturn \"\"\n\t}\n\n\t// 1. Find Vowel\
    \ in the end\n\tlet lastVowel = word.characters.reversed()\n\t\t\t\t\t\t .first{\
    \ $0.isUppercaseASCII }\n\t\t\t\t\t\t ?? \"\"\n\n\t// 2. Find Vowel in the middle\
    \ of string\n\tlet middleVowel = lastVowel\n\t\t\t\t\t\t  .last(for: word.characters.count)\n\
    \t\t\t\t\t\t  .first{ $0.isUppercaseASCII }\n\t\t\t\t\t\t  ?? \"\"\n\n\t// 3.\
    \ Find Vowel in the beginning of string\n\tlet firstVowel = middleVowel\n\t\t\t\
    \t\t\t.first(for: word.characters.count)\n\t\t\t\t\t\t.first{ $0.isUppercaseASCII\
    \ }\n\t\t\t\t\t\t?? \"\"\n\n\treturn firstVowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqoevi36c.swift:17:13: error: 'characters' is unavailable: Please\
    \ use String directly\n        guard word.characters.count >= 1 else {\n     \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqoevi36c.swift:24:8: error: binary operator '??' cannot be applied\
    \ to operands of type 'String.Element?' (aka 'Optional<Character>') and 'String'\n\
    \                                                 ?? \"\"\n                  \
    \                               ^  ~~\n/tmp/tmpqoevi36c.swift:23:19: error: value\
    \ of type 'String.Element' (aka 'Character') has no member 'isUppercaseASCII'\n\
    \                                                 .first{ $0.isUppercaseASCII\
    \ }\n                                                         ~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    \n    for s in word.characters{\n        var temp = \"\"\n\
    \        var vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n        \n        switch\
    \ s {\n        case \"a\":\n            temp = \"A\"\n            break\n    \
    \    case \"e\":\n            temp = \"E\"\n            break\n        case \"\
    i\":\n            temp = \"I\"\n            break\n        case \"o\":\n     \
    \       temp = \"O\"\n            break\n        case \"u\":\n            temp\
    \ = \"U\"\n            break\n        default:\n            continue\n       \
    \ }\n        \n        vowels = vowels.filter{ $0.lowercased() != temp }\n   \
    \     \n        if vowels.count > 0 {\n            let start = word.index(after:\
    \ word.endIndex).successor()\n            let end = word.index(before: word.startIndex).predecessor()\n\
    \            \n            if start > word.startIndex {\n                start\
    \ = word.startIndex\n            }\n            if end < word.endIndex {\n   \
    \             end = word.endIndex\n            }\n            \n            if\
    \ end - start == 1 {\n                result += \"\\(vowels[word.index(start,\
    \ offsetBy: 1)])\"\n            } else {\n                result += \"\\(vowels[word.index(start,\
    \ offsetBy: 1)])\"\n            }\n            result += \"-\"\n            if\
    \ word.index(end, offsetBy: -1) > word.endIndex {\n                result += \"\
    \ \"\n                result += vowels[word.index(end, offsetBy: -1)]\n      \
    \      }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_e7js8nq.swift:19:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in word.characters{\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_e7js8nq.swift:46:58:\
    \ error: value of type 'String.Index' has no member 'successor'\n            let\
    \ start = word.index(after: word.endIndex).successor()\n                     \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp_e7js8nq.swift:47:59:\
    \ error: value of type 'String.Index' has no member 'predecessor'\n          \
    \  let end = word.index(before: word.startIndex).predecessor()\n             \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp_e7js8nq.swift:56:28:\
    \ error: binary operator '==' cannot be applied to operands of type 'Duration'\
    \ and 'Int'\n            if end - start == 1 {\n               ~~~~~~~~~~~ ^ \
    \ ~\n/tmp/tmp_e7js8nq.swift:56:28: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Duration, Duration), (Int, Int)\n            if end\
    \ - start == 1 {\n                           ^\n/tmp/tmp_e7js8nq.swift:57:36:\
    \ error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \                result += \"\\(vowels[word.index(start, offsetBy: 1)])\"\n  \
    \                                 ^\nSwift.MutableCollection:2:23: note: where\
    \ 'R' = 'String.Index'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n/tmp/tmp_e7js8nq.swift:59:36: error: subscript 'subscript(_:)' requires\
    \ that 'String.Index' conform to 'RangeExpression'\n                result +=\
    \ \"\\(vowels[word.index(start, offsetBy: 1)])\"\n                           \
    \        ^\nSwift.MutableCollection:2:23: note: where 'R' = 'String.Index'\n \
    \   @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get set }\n                      ^\n/tmp/tmp_e7js8nq.swift:64:39:\
    \ error: cannot"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ wordsDict.filter{ $0.contains(word)}\n        .map({ $0.substring(word.count,\
    \ word.count+2) })\n        .flatMap({ $0.contains(\"e\") || $0.contains(\"a\"\
    ) || $0.contains(\"i\") || $0.contains(\"u\") })\n        .first\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpw3980hk7.swift:17:12: error: cannot find 'wordsDict' in scope\n\
    \    return wordsDict.filter{ $0.contains(word)}\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" || word.isEmpty {\n        return \"\"\n    }\n\n    let vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\n    let resultSet = Set<String>()\n\
    \    for c in word.unicodeScalars {\n        if let x = vowels.first(where: {$0\
    \ == c.value}) {\n            resultSet.add(x)\n        }\n    }\n\n    if resultSet.count\
    \ == 0 {\n        return \"\"\n    }\n    let result = resultSet.sorted().reversed()\n\
    \    return String(result[0])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp9yp5i0uw.swift:25:44: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'UInt32'\n        if let x = vowels.first(where:\
    \ {$0 == c.value}) {\n                                        ~~ ^  ~~~~~~~\n\
    /tmp/tmp9yp5i0uw.swift:25:44: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (String, String), (UInt32, UInt32)\n        if let\
    \ x = vowels.first(where: {$0 == c.value}) {\n                               \
    \            ^\n/tmp/tmp9yp5i0uw.swift:26:23: error: value of type 'Set<String>'\
    \ has no member 'add'\n            resultSet.add(x)\n            ~~~~~~~~~ ^~~\n\
    /tmp/tmp9yp5i0uw.swift:34:26: error: cannot convert value of type 'Int' to expected\
    \ argument type 'ReversedCollection<[String]>.Index'\n    return String(result[0])\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, isVowel: isVowel(word))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp9p9zt35n.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, isVowel: isVowel(word))\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmp9p9zt35n.swift:17:43: error: cannot find 'isVowel' in scope\n    return\
    \ getClosestVowel(word, isVowel: isVowel(word))\n                            \
    \              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ firstLetter = word[word.startIndex]\n    let endLetter = word[word.endIndex-1]\n\
    \    let vowels = Set(\"aeiou\")\n    if firstLetter != endLetter && !vowels.contains(firstLetter)\
    \ && !vowels.contains(endLetter) {\n        return \"\"\n    }\n    if firstLetter\
    \ != endLetter && !vowels.contains(firstLetter) {\n        return endLetter\n\
    \    }\n    if firstLetter != endLetter && !vowels.contains(endLetter) {\n   \
    \     return firstLetter\n    }\n    if firstLetter != endLetter && vowels.contains(firstLetter)\
    \ && vowels.contains(endLetter) {\n        return \"\"\n    }\n    return \"\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpl58w6i4e.swift:18:31: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    let endLetter = word[word.endIndex-1]\n\
    \                              ^\n/tmp/tmpl58w6i4e.swift:27:16: error: cannot\
    \ convert return expression of type 'Character' to return type 'String'\n    \
    \    return firstLetter\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"\", \"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n    if let index\
    \ = vowels.firstIndex(of: word.first!.lowercased()) {\n        return vowels[index]\n\
    \    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp7x85oy3d/tmp7x85oy3d.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba51bd03c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba51b9fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba51b9fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba51b9f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7x85oy3d                        0x0000564fddafa707 <unavailable> + 5895

    5    libc.so.6                          0x00002ba51beef460 __libc_start_main +
    245

    6    tmp7x85oy3d                        0x0000564fddafa349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660030474
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmphcn2_g7m/tmphcn2_g7m.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e52a57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e5274eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e5274e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e5274d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphcn2_g7m                        0x0000556822ac6307 <unavailable> + 4871

    5    libc.so.6                          0x00002b1e52c43460 __libc_start_main +
    245

    6    tmphcn2_g7m                        0x0000556822ac5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplchr4zq6.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, vowels: vowels)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmplchr4zq6.swift:17:42: error: cannot find 'vowels' in scope\n    return\
    \ getClosestVowel(word, vowels: vowels)\n                                    \
    \     ^~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    var currentVowel = \"\"\n    \n    for char in\
    \ word.lowercased().characters {\n        if char == char.unicodeScalars.first\
    \ {\n            currentVowel = vowels.first\n        } else {\n            currentVowel\
    \ = vowels.last\n        }\n        let index = vowels.startIndex.advanced(by:\
    \ vowels.distance(from: char, in: vowels, limitedBy: currentVowel))\n        let\
    \ candidate = String(currentVowel, at: index)\n        if candidate == \"a\" {\n\
    \            if currentVowel == \"a\" {\n                return \"\"\n       \
    \     }\n        } else {\n            return candidate\n        }\n    }\n  \
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfo2u14a1.swift:20:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.lowercased().characters {\n      \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfo2u14a1.swift:21:40: error: cannot convert value of\
    \ type 'Unicode.Scalar?' to expected argument type 'Character'\n        if char\
    \ == char.unicodeScalars.first {\n                                       ^\n/tmp/tmpfo2u14a1.swift:22:35:\
    \ error: cannot assign value of type 'String.Element?' (aka 'Optional<Character>')\
    \ to type 'String'\n            currentVowel = vowels.first\n                \
    \           ~~~~~~~^~~~~\n/tmp/tmpfo2u14a1.swift:24:35: error: cannot assign value\
    \ of type 'String.Element?' (aka 'Optional<Character>') to type 'String'\n   \
    \         currentVowel = vowels.last\n                           ~~~~~~~^~~~\n\
    /tmp/tmpfo2u14a1.swift:26:59: error: no exact matches in call to instance method\
    \ 'distance'\n        let index = vowels.startIndex.advanced(by: vowels.distance(from:\
    \ char, in: vowels, limitedBy: currentVowel))\n                              \
    \                            ^\n/tmp/tmpfo2u14a1.swift:26:59: note: found candidate\
    \ with type '(String.Index, String.Index) -> Int'\n        let index = vowels.startIndex.advanced(by:\
    \ vowels.distance(from: char, in: vowels, limitedBy: currentVowel))\n        \
    \                                                  ^\n/tmp/tmpfo2u14a1.swift:26:39:\
    \ error: value of type 'String.Index' has no member 'advanced'\n        let index\
    \ = vowels.startIndex.advanced(by: vowels.distance(from: char, in: vowels, limitedBy:\
    \ currentVowel))\n                    ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpfo2u14a1.swift:27:31:\
    \ error: incorrect argument labels in call (have '_:at:', expected 'repeating:count:')\n\
    \        let candidate = String(currentVowel, at: index)\n                   \
    \           ^              ~~\n                               repeating:    count\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    word\
    \ = word.lowercased()\n    var vowelIndexStart = 0\n    var vowelIndexEnd = word.count-1\n\
    \    var vowelFound = false\n    var nextVowelIndex: Int = 0\n    while vowelIndexEnd\
    \ >= vowelIndexStart && !vowelFound {\n        let nextVowelIndex = word.index(word[vowelIndexEnd],\
    \ offsetBy: nextVowelIndex)\n        if nextVowelIndex == 0 || vowelIndexEnd ==\
    \ word.count-1 {\n            vowelFound = true\n        } else {\n          \
    \  vowelIndexStart = nextVowelIndex - 1\n        }\n    }\n    var vowel = \"\"\
    \n    if vowelIndexStart != 0 {\n        vowel = String(word[vowelIndexStart]).lowercased()\n\
    \    }\n    if vowelIndexEnd != word.count-1 {\n        if vowelIndexEnd == word.count-1\
    \ {\n            vowel += String(word[vowelIndexEnd])\n        } else {\n    \
    \        vowel += String(word[vowelIndexEnd]).lowercased()\n        }\n    }\n\
    \    return vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpijkbnmqp.swift:17:5: error: cannot assign to value: 'word' is a\
    \ 'let' constant\n    word = word.lowercased()\n    ^~~~\n/tmp/tmpijkbnmqp.swift:23:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        let nextVowelIndex = word.index(word[vowelIndexEnd], offsetBy: nextVowelIndex)\n\
    \                                            ^\n/tmp/tmpijkbnmqp.swift:32:24:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        vowel = String(word[vowelIndexStart]).lowercased()\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpijkbnmqp.swift:36:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            vowel += String(word[vowelIndexEnd])\n                          \
    \  ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpijkbnmqp.swift:38:29: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   vowel += String(word[vowelIndexEnd]).lowercased()\n                      \
    \      ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = \"AEIOUaeiou\".characters.map { String($0) }\n\tlet consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    .characters.map { String($0) }\n\tlet vowelCount = vowels.filter({ (vowel) ->\
    \ Bool in\n\t\tif word.range(of: vowel, options: .caseInsensitive) != nil {\n\t\
    \t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\tlet consonantCount = consonants.filter({\
    \ (consonant) -> Bool in\n\t\tif word.range(of: consonant, options: .caseInsensitive)\
    \ != nil {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\tlet result = vowelCount.min()!\
    \ < consonantCount.min()!\n\tif result {\n\t\treturn vowelCount.min()!\n\t} else\
    \ {\n\t\treturn consonantCount.min()!\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ogm8l_v.swift:17:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        let vowels = \"AEIOUaeiou\".characters.map { String($0)\
    \ }\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_ogm8l_v.swift:18:64: error: 'characters' is unavailable:\
    \ Please use String directly\n        let consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    .characters.map { String($0) }\n                                             \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp_ogm8l_v.swift:20:11: error: value of type 'String' has\
    \ no member 'range'\n                if word.range(of: vowel, options: .caseInsensitive)\
    \ != nil {\n                   ~~~~ ^~~~~\n/tmp/tmp_ogm8l_v.swift:20:38: error:\
    \ cannot infer contextual base in reference to member 'caseInsensitive'\n    \
    \            if word.range(of: vowel, options: .caseInsensitive) != nil {\n  \
    \                                                ~^~~~~~~~~~~~~~~\n/tmp/tmp_ogm8l_v.swift:26:11:\
    \ error: value of type 'String' has no member 'range'\n                if word.range(of:\
    \ consonant, options: .caseInsensitive) != nil {\n                   ~~~~ ^~~~~\n\
    /tmp/tmp_ogm8l_v.swift:26:42: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n                if word.range(of: consonant, options:\
    \ .caseInsensitive) != nil {\n                                               \
    \       ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result: String = String()\n\n    let vowels: Set<String> = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n\n    for char in word.unicodeScalars.reversed() {\n     \
    \   if vowels.contains(char) {\n            if result.isEmpty {\n            \
    \    result = String(char)\n            } else if result == String(char) {\n \
    \               result = String(char)\n            } else if char.value > result.unicodeScalars.last!.value\
    \ {\n                result = String(char)\n            }\n        }\n    }\n\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ruq3fho.swift:22:12: error: instance method 'contains' requires\
    \ that 'Unicode.Scalar' conform to 'Collection'\n        if vowels.contains(char)\
    \ {\n           ^\n_StringProcessing.Collection:3:17: note: where 'C' = 'Unicode.Scalar'\n\
    \    public func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element\
    \ == C.Element\n                ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowelIndex1 = -1\n    var vowelIndex2 = -1\n    var vowelLength = 0\n    \n\
    \    for index in 0..<word.characters.count {\n        \n        if word.characters[index]\
    \ != \"a\" {\n            if vowelIndex1 < 0 {\n                vowelIndex1 =\
    \ index\n                vowelLength = 1\n                continue\n         \
    \   }\n            if word.characters[index] != word.characters[vowelIndex1 +\
    \ vowelLength] {\n                vowelLength += 1\n                continue\n\
    \            }\n            if word.characters[index] == word.characters[vowelIndex1\
    \ + vowelLength] {\n                vowelLength += 1\n            } else {\n \
    \               vowelLength -= 1\n            }\n        } else {\n          \
    \  if vowelIndex2 < 0 {\n                vowelIndex2 = index\n               \
    \ vowelLength = 1\n                continue\n            }\n            if word.characters[index]\
    \ != word.characters[vowelIndex2 + vowelLength] {\n                vowelLength\
    \ += 1\n                continue\n            }\n            if word.characters[index]\
    \ == word.characters[vowelIndex2 + vowelLength] {\n                vowelLength\
    \ += 1\n            } else {\n                vowelLength -= 1\n            }\n\
    \        }\n        \n        if vowelLength == 0 {\n            return \"\"\n\
    \        }\n    }\n    return word.characters[vowelIndex2 + vowelLength]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnxlyrl5s.swift:21:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<word.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpnxlyrl5s.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if word.characters[index]\
    \ != \"a\" {\n           ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpnxlyrl5s.swift:23:17: error: 'characters'\
    \ is unavailable: Please use String directly\n        if word.characters[index]\
    \ != \"a\" {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpnxlyrl5s.swift:29:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if word.characters[index] != word.characters[vowelIndex1 + vowelLength] {\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpnxlyrl5s.swift:29:21: error: 'characters'\
    \ is unavailable: Please use String directly\n            if word.characters[index]\
    \ != word.characters[vowelIndex1 + vowelLength] {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpnxlyrl5s.swift:29:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if word.characters[index] != word.characters[vowelIndex1\
    \ + vowelLength] {\n                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has be"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels = \"aeiou\"\n    var index : Int = word.characters.count-1\n \
    \   \n    while index >= 0 {\n        \n        let charToCheck = word.characters.last!\n\
    \        \n        if vowels.contains(charToCheck) {\n            return charToCheck\n\
    \        }\n        \n        index -= 1\n    }\n    \n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpprs0w54g.swift:19:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    var index : Int = word.characters.count-1\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpprs0w54g.swift:23:32: error: 'characters' is unavailable: Please\
    \ use String directly\n        let charToCheck = word.characters.last!\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpprs0w54g.swift:26:20: error: cannot convert return expression\
    \ of type 'String.Element' (aka 'Character') to return type 'String'\n       \
    \     return charToCheck\n                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  \n  var\
    \ result = [String]()\n  var len = word.characters.count\n  \n  guard word.characters.count\
    \ > 1 else { return \"\" }\n  \n  for index in stride(from: word.characters.count\
    \ - 1, through: 0, by: -1) {\n    let char = word.characters[index]\n    let char\
    \ = char.lowercased()\n    if char == Character(letter: \"a\"...\"i\") {\n   \
    \   \n      if index < len - 1 {\n        let nextChar = word.characters[index\
    \ + 1].lowercased()\n        if nextChar != Character(letter: \"a\"...\"i\") {\n\
    \          result.append(nextChar)\n        } else {\n          \n          result.append(char.uppercased())\n\
    \          break\n        }\n      } else {\n        result.append(char.uppercased())\n\
    \        break\n      }\n    }\n  }\n  \n  return result.isEmpty ? \"\" : result[0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp64x300gk.swift:19:18: error: 'characters' is unavailable: Please\
    \ use String directly\n  var len = word.characters.count\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp64x300gk.swift:21:14:\
    \ error: 'characters' is unavailable: Please use String directly\n  guard word.characters.count\
    \ > 1 else { return \"\" }\n             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp64x300gk.swift:23:34: error: 'characters'\
    \ is unavailable: Please use String directly\n  for index in stride(from: word.characters.count\
    \ - 1, through: 0, by: -1) {\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp64x300gk.swift:24:16: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    let char = word.characters[index]\n               ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp64x300gk.swift:24:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    let char\
    \ = word.characters[index]\n                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp64x300gk.swift:25:9: error: invalid redeclaration\
    \ of 'char'\n    let char = char.lowercased()\n        ^\n/tmp/tmp64x300gk.swift:24:9:\
    \ note: 'char' previously declared here\n    let char = word.characters[index]\n\
    \        ^\n/tmp/tmp64x300gk.swift:26:16: error: no exact matches in call to initializer\
    \ \n    if char == Character(letter: \"a\"...\"i\") {\n               ^\n/tmp/tmp64x300gk.swift:26:16:\
    \ note: found candidate with type '(Unicode.Scalar) -> Character'\n    if char\
    \ == C"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowelsSet(word: word) else { return \"\" }\n    \n    let letters\
    \ = word.characters.reversed()\n    for i in 0..<letters.count {\n        if let\
    \ letter = letters[i], vowels.contains(letter) {\n            return letter\n\
    \        }\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp__tc0ey5.swift:17:24: error: cannot find 'vowelsSet' in scope\n\
    \    guard let vowels = vowelsSet(word: word) else { return \"\" }\n         \
    \              ^~~~~~~~~\n/tmp/tmp__tc0ey5.swift:19:24: error: 'characters' is\
    \ unavailable: Please use String directly\n    let letters = word.characters.reversed()\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp__tc0ey5.swift:21:32: error: no exact matches in call to\
    \ subscript \n        if let letter = letters[i], vowels.contains(letter) {\n\
    \                               ^\nSwift.ReversedCollection:9:23: note: candidate\
    \ expects value of type 'ReversedCollection<String>.Index' for parameter #1 (got\
    \ 'Int')\n    @inlinable public subscript(position: ReversedCollection<Base>.Index)\
    \ -> ReversedCollection<Base>.Element { get }\n                      ^\nSwift.Collection:2:23:\
    \ note: candidate expects value of type 'Range<ReversedCollection<String>.Index>'\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Self.Index>)\
    \ -> Slice<Self> { get }\n                      ^\nSwift.Collection:3:23: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpufwr47il/tmpufwr47il.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86c44bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86c41b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86c41b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86c41b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpufwr47il                        0x000056320ca69307 <unavailable> + 4871

    5    libc.so.6                          0x00002b86c46ab460 __libc_start_main +
    245

    6    tmpufwr47il                        0x000056320ca68f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"\
    O\", \"U\"]\n    \n    let words = word.characters\n    let endIndex = words.endIndex\n\
    \    let vowelsIndex = words.count - 1\n    \n    if words.count < 2 {\n     \
    \   return \"\"\n    }\n    \n    var closestVowelIndex = -1\n    \n    for index\
    \ in 0 ..< vowels.count {\n        if vowelsIndex < 0 {\n            break\n \
    \       }\n        \n        let vowel = words[vowelsIndex]\n        \n      \
    \  if words[vowelsIndex - 1] != vowel {\n            continue\n        }\n   \
    \     \n        let nextVowelIndex = vowelsIndex - 1\n        let nextVowel =\
    \ words[nextVowelIndex]\n        \n        if vowel.lowercased() == nextVowel.lowercased()\
    \ {\n            closestVowelIndex = nextVowelIndex\n            break\n     \
    \   }\n        \n        if vowel == nextVowel {\n            closestVowelIndex\
    \ = nextVowelIndex\n        }\n    }\n    \n    if closestVowelIndex == -1 {\n\
    \        return \"\"\n    }\n    \n    let vowel = words[closestVowelIndex]\n\
    \    let consonantIndex = closestVowelIndex + 1\n    \n    if words[consonantIndex]\
    \ != vowel {\n        return \"\"\n    }\n    \n    return vowel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpe1hnwq2f.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let words = word.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe1hnwq2f.swift:35:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let vowel = words[vowelsIndex]\n      \
    \              ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpe1hnwq2f.swift:37:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if words[vowelsIndex - 1] != vowel {\n           ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpe1hnwq2f.swift:42:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let nextVowel = words[nextVowelIndex]\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpe1hnwq2f.swift:58:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    let vowel = words[closestVowelIndex]\n                ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpe1hnwq2f.swift:61:8:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    if words[consonantIndex] != vowel {\n     \
    \  ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscr"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tguard\
    \ let vowels = vowels.characters else { return \"\" }\n\tguard let vowelIndexes\
    \ = vowelIndexes.characters else { return \"\" }\n\tlet wordChars = word.characters\n\
    \tlet wordIndexes = word.characters\n\t\n\tlet vowelIndex = wordIndexes.index(of:\
    \ vowels.last!)\n\t\n\tguard vowelIndex != nil else { return \"\" }\n\tguard let\
    \ lastVowelIndex = wordIndexes.index(of: vowels.last!, offsetBy: 1) else { return\
    \ \"\" }\n\t\n\tlet firstVowelIndex = wordIndexes.index(of: vowels.first!, offsetBy:\
    \ 1)\n\t\n\tif lastVowelIndex == firstVowelIndex { // if last and first vowel\
    \ is the same\n\t\treturn wordChars[vowelIndex!] // return the last consonant\n\
    \t}\n\t\n\tguard let firstVowelIndex = wordIndexes.index(of: vowels.first!) else\
    \ { return \"\" }\n\t\n\tif vowelIndex < firstVowelIndex {\n\t\treturn wordChars[vowelIndex!]\n\
    \t}\n\t\n\treturn wordChars[lastVowelIndex!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpew7qc5wq.swift:17:21: error: cannot find 'vowels' in scope\n  \
    \      guard let vowels = vowels.characters else { return \"\" }\n           \
    \                ^~~~~~\n/tmp/tmpew7qc5wq.swift:18:27: error: cannot find 'vowelIndexes'\
    \ in scope\n        guard let vowelIndexes = vowelIndexes.characters else { return\
    \ \"\" }\n                                 ^~~~~~~~~~~~\n/tmp/tmpew7qc5wq.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ wordChars = word.characters\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpew7qc5wq.swift:20:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        let wordIndexes = word.characters\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpew7qc5wq.swift:25:41: error: no exact matches in call\
    \ to instance method 'index'\n        guard let lastVowelIndex = wordIndexes.index(of:\
    \ vowels.last!, offsetBy: 1) else { return \"\" }\n                          \
    \                     ^\n/tmp/tmpew7qc5wq.swift:25:41: note: found candidate with\
    \ type '(String.Index, Int) -> String.Index'\n        guard let lastVowelIndex\
    \ = wordIndexes.index(of: vowels.last!, offsetBy: 1) else { return \"\" }\n  \
    \                                             ^\n/tmp/tmpew7qc5wq.swift:27:36:\
    \ error: no exact matches in call to instance method 'index'\n        let firstVowelIndex\
    \ = wordIndexes.index(of: vowels.first!, offsetBy: 1)\n                      \
    \                    ^\n/tmp/tmpew7qc5wq.swift:27:36: note: found candidate with\
    \ type '(String.Index, Int) -> String.Index'\n        let firstVowelIndex = wordIndexes.index(of:\
    \ vowels.first!, offsetBy: 1)\n                                          ^\n/tmp/tmpew7qc5wq.swift:30:19:\
    \ error: no 'subscript' candidates produce the expected contextual result type\
    \ 'String'\n                return wordChars[vow"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n\n    let vowelStrings\
    \ = word.split(separator: CharacterSet.letters.inverted)\n\n    for word in vowelStrings\
    \ {\n        if vowels.contains { word == \"y\" || word == \"u\" || word == \"\
    a\" } { return word }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbu42ev1y.swift:17:18: error: no exact matches in call to initializer\
    \ \n    var vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n         \
    \        ^\nSwift.Set:2:23: note: incorrect labels for candidate (have: '(_:_:_:_:_:_:)',\
    \ expected: '(arrayLiteral:_:_:_:_:_:)')\n    @inlinable public init(arrayLiteral\
    \ elements: Element...)\n                      ^\nSwift.SetAlgebra:2:23: note:\
    \ incorrect labels for candidate (have: '(_:_:_:_:_:_:)', expected: '(arrayLiteral:_:_:_:_:_:)')\n\
    \    @inlinable public init(arrayLiteral: Self.Element...)\n                 \
    \     ^\n/tmp/tmpbu42ev1y.swift:19:46: error: cannot find 'CharacterSet' in scope\n\
    \    let vowelStrings = word.split(separator: CharacterSet.letters.inverted)\n\
    \                                             ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ O(n) time\n    if word.isEmpty { return \"\" }\n    \n    var vowels: [String]\
    \ = []\n    var vowelCount = 0\n    var vowelIndex = 0\n    \n    for i in stride(from:\
    \ word.count, to: -1, by: -1) {\n        let char: Character\n        switch word.unicodeScalars.first!.value\
    \ {\n        case 0xE0: char = \"a\" // \"\u0101\"\n        case 0xE1: char =\
    \ \"e\" // \"\u0113\"\n        case 0xE2: char = \"i\" // \"\u012B\"\n       \
    \ case 0xE3: char = \"o\" // \"\u014D\"\n        case 0xE4: char = \"u\" // \"\
    \u016B\"\n        case 0xE5: char = \"y\" // \"\u016B\"\n        case 0xE6: char\
    \ = \"i\" // \"\u012B\"\n        case 0xE7: char = \"a\" // \"\u0101\"\n     \
    \   case 0xE8: char = \"e\" // \"\u0113\"\n        case 0xE9: char = \"i\" //\
    \ \"\u012B\"\n        case 0xEA: char = \"o\" // \"\u014D\"\n        case 0xEB:\
    \ char = \"u\" // \"\u016B\"\n        case 0xEC: char = \"y\" // \"\u016B\"\n\
    \        case 0xED: char = \"a\" // \"\u0101\"\n        case 0xEE: char = \"e\"\
    \ // \"\u0113\"\n        case 0xEF: char = \"i\" // \"\u012B\"\n        case 0xF0:\
    \ char = \"o\" // \"\u014D\"\n        case 0xF1: char = \"u\" // \"\u016B\"\n\
    \        case 0xF2: char = \"y\" // \"\u016B\"\n        case 0xF3: char = \"i\"\
    \ // \"\u012B\"\n        case 0xF4: char = \"a\" // \"\u0101\"\n        case 0xF5:\
    \ char = \"e\" // \"\u0113\"\n        case 0xF6: char = \"i\" // \"\u012B\"\n\
    \        case 0xF7: char = \"o\" // \"\u014D\"\n        case 0xF8: char = \"u\"\
    \ // \"\u016B\"\n        case 0xF9: char = \"y\" // \"\u016B\"\n        case 0xFA:\
    \ char = \"a\" // \"\u0101\"\n        case 0xFB: char = \"e\" // \"\u0113\"\n\
    \        case 0xFC: char = \"i\" // \"\u012B\"\n        case 0xFD: char = \"o\"\
    \ // \"\u014D\"\n        case 0xFE: char = \"u\" // \"\u016B\"\n        case 0xFF:\
    \ char = \"y\" // \"\u016B\"\n        default:\n            char\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpe5badccj.swift:88:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpe5badccj.swift:24:55: note: to match this opening\
    \ '{'\n    for i in stride(from: word.count, to: -1, by: -1) {\n             \
    \                                         ^\n/tmp/tmpe5badccj.swift:88:48: error:\
    \ expected '}' at end of brace statement\nassert(get_closest_vowel(word: \"Above\"\
    ) == \"o\")\n                                               ^\n/tmp/tmpe5badccj.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmpe5badccj.swift:60:13:\
    \ warning: variable is unused\n            char\n            ^~~~\n/tmp/tmpe5badccj.swift:64:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpe5badccj.swift:20:9:\
    \ warning: variable 'vowels' was never used; consider replacing with '_' or removing\
    \ it\n    var vowels: [String] = []\n        ^~~~~~\n        _\n/tmp/tmpe5badccj.swift:21:9:\
    \ warning: initialization of variable 'vowelCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelCount = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe5badccj.swift:22:9: warning: initialization of variable 'vowelIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe5badccj.swift:24:9:\
    \ warning: immutable value 'i' was never used; consider replacing with '_' or\
    \ removing it\n    for i in stride(from: word.count, to: -1, by: -1) {\n     \
    \   ^\n        _\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\".characters\n    var closestVowelIndex = -1\n    var\
    \ closestVowel: String = \"\"\n    let closestVowelDistance = Int64(0)\n    for\
    \ i in 0..<word.characters.count {\n        if vowels.contains(word.characters.suffix(from:\
    \ i).first!) {\n            closestVowelIndex = i\n            closestVowelDistance\
    \ = abs(i - word.characters.index(word.characters.suffix(from: i).first!))\n \
    \           closestVowel = word.characters.suffix(from: i).first!\n        }\n\
    \    }\n    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgfut9bb5.swift:17:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowels = \"aeiouAEIOU\".characters\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgfut9bb5.swift:21:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<word.characters.count {\n            \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpgfut9bb5.swift:22:57: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n        if vowels.contains(word.characters.suffix(from:\
    \ i).first!) {\n                                                        ^\n/tmp/tmpgfut9bb5.swift:24:13:\
    \ error: cannot assign to value: 'closestVowelDistance' is a 'let' constant\n\
    \            closestVowelDistance = abs(i - word.characters.index(word.characters.suffix(from:\
    \ i).first!))\n            ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgfut9bb5.swift:20:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let closestVowelDistance\
    \ = Int64(0)\n    ^~~\n    var\n/tmp/tmpgfut9bb5.swift:24:36: error: cannot assign\
    \ value of type 'Int' to type 'Int64'\n            closestVowelDistance = abs(i\
    \ - word.characters.index(word.characters.suffix(from: i).first!))\n         \
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                   Int64(                                   \
    \                             )\n/tmp/tmpgfut9bb5.swift:24:60: error: cannot convert\
    \ value of type 'String.Index?' to expected argument type 'Int'\n            closestVowelDistance\
    \ = abs(i - word.characters.index(word.characters.suffix(from: i).first!))\n \
    \                                                          ^\n/tmp/tmpgfut9bb5.swift:24:66:\
    \ error: missing argument label 'of:' in call\n            closestVowelDistance\
    \ = abs(i - word.characters.index(word.char"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n   var\
    \ index = 0\n   var vowels = Set([\"a\", \"e\", \"i\", \"o\", \"u\"])\n   var\
    \ count = 0\n   for char in word.characters {\n      if vowels.contains(char)\
    \ {\n         count += 1\n         if count > 1 {\n            index = count -\
    \ 1\n            break\n         }\n      }\n   }\n   return String(word.characters.dropFirst(index))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpif4mbhat.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n   for char in word.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpif4mbhat.swift:21:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \      if vowels.contains(char) {\n                         ^\n/tmp/tmpif4mbhat.swift:29:23:\
    \ error: 'characters' is unavailable: Please use String directly\n   return String(word.characters.dropFirst(index))\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ findVowel(word: word, fromRight: true)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplt0o4ph2.swift:17:12: error: cannot find 'findVowel' in scope\n\
    \    return findVowel(word: word, fromRight: true)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ chars = word.characters.map{ String($0) }\n    if chars.count < 2 {\n      \
    \  return \"\"\n    }\n\n    let vowels = [\"A\", \"E\", \"I\", \"O\", \"U\",\
    \ \"a\",\"e\", \"i\", \"o\", \"u\"]\n    var currentIndex = 0\n\n    if chars.count\
    \ > 3 {\n        if chars.last == \"e\" || chars.last == \"i\" {\n           \
    \ currentIndex = chars.count - 2\n        } else {\n            currentIndex =\
    \ chars.count - 1\n        }\n    } else {\n        return \"\"\n    }\n    \n\
    \    var nextIndex = 0\n    if chars.last == \"e\" || chars.last == \"i\" {\n\
    \        nextIndex = 1\n    }\n\n    var closest = \"\"\n    var maxDistance =\
    \ currentIndex - nextIndex\n\n    for c in chars[currentIndex...] {\n        let\
    \ index = vowels.firstIndex(of: c)!\n        let distance = currentIndex - index\n\
    \n        if distance > maxDistance {\n            maxDistance = distance\n  \
    \          closest = vowels[index]\n        }\n    }\n    return closest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ccpdm1o.swift:17:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = word.characters.map{ String($0) }\n   \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tword\
    \ = word.lowercased()\n\tlet vowels = \"aeiou\"\n\tlet count = 0\n\tlet index\
    \ = word.count\n\n\tfor i in 0...index {\n\t\tif word[i] == \"a\" || word[i] ==\
    \ \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n\t\t\t\
    count += 1\n\t\t}\n\t}\n\n\tif count == index {\n\t\treturn \"\"\n\t}\n\n\tlet\
    \ start = count - count/2\n\tlet end = count + count/2\n\tvar index = start\n\n\
    \tfor char in vowels.characters {\n\t\tif index < end {\n\t\t\tif word[index]\
    \ == char {\n\t\t\t\treturn String(char)\n\t\t\t}\n\t\t\tindex += 1\n\t\t}\n\t\
    }\n\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmps27t7eye.swift:17:2: error: cannot assign to value: 'word' is a\
    \ 'let' constant\n        word = word.lowercased()\n        ^~~~\n/tmp/tmps27t7eye.swift:23:6:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if word[i] == \"a\" || word[i]\
    \ == \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n   \
    \                ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmps27t7eye.swift:23:24: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i]\
    \ == \"o\" || word[i] == \"u\" {\n                                     ^~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps27t7eye.swift:23:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if word[i] == \"a\" || word[i]\
    \ == \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n   \
    \                                                    ^~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps27t7eye.swift:23:60:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if word[i] == \"a\" || word[i]\
    \ == \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n   \
    \                                                                      ^~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps27t7eye.swift:23:78:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n      "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"AEIOUaeiou\".lowercased())\n    let vowels_count = word.characters.map({\
    \ vowels.contains($0) }).max()!\n    \n    if vowels_count == 0 {\n        return\
    \ \"\"\n    }\n    \n    var index = word.startIndex\n    \n    while index <\
    \ word.endIndex {\n        let substr = word.substring(to: index)\n        let\
    \ len = substr.characters.count\n        let vowel_index = substr.characters.map({\
    \ vowels.contains($0) }).index(true, offsetBy: len - 1)\n        let vowel = vowels[vowel_index]!\n\
    \        if vowels_count != 1 {\n            return vowel\n        }\n       \
    \ \n        index = index + 1\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgao4_3yl.swift:18:40: error: type '()' cannot conform to 'Comparable'\n\
    \    let vowels_count = word.characters.map({ vowels.contains($0) }).max()!\n\
    \                                       ^\n/tmp/tmpgao4_3yl.swift:18:40: note:\
    \ only concrete types such as structs, enums and classes can conform to protocols\n\
    \    let vowels_count = word.characters.map({ vowels.contains($0) }).max()!\n\
    \                                       ^\n/tmp/tmpgao4_3yl.swift:18:40: note:\
    \ required by referencing instance method 'max()' on 'Sequence' where 'Self.Element'\
    \ = '()'\n    let vowels_count = word.characters.map({ vowels.contains($0) }).max()!\n\
    \                                       ^\n/tmp/tmpgao4_3yl.swift:27:27: error:\
    \ value of type 'String' has no member 'substring'\n        let substr = word.substring(to:\
    \ index)\n                     ~~~~ ^~~~~~~~~\n/tmp/tmpgao4_3yl.swift:35:23: error:\
    \ binary operator '+' cannot be applied to operands of type 'String.Index' and\
    \ 'Int'\n        index = index + 1\n                ~~~~~ ^ ~\n/tmp/tmpgao4_3yl.swift:35:23:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        index = index + 1\n                      ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  var result:\
    \ String = \"\"\n  let vowel = \"aeiouAEIOU\"\n  for i in word.characters.reverse()\
    \ {\n    if vowel.contains(String(i)) {\n      result = vowel.index(of: i).map{\
    \ vowel[$0] }\n      return result\n    }\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpw8uia5r_.swift:19:28: error: value of type 'String' has no member\
    \ 'reverse'\n  for i in word.characters.reverse() {\n           ~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let word = word.lowercased()\n    let vowels = vowels.lowercased()\n    var\
    \ idx = 0\n    \n    if word.count != vowels.count {\n        return \"\"\n  \
    \  }\n    \n    for (idx, c) in word.enumerated() {\n        \n        if c ==\
    \ vowels.last {\n            return vowels[idx]\n        }\n        \n       \
    \ if idx == word.count - 1 && c == vowels.first {\n            return vowels.last\n\
    \        }\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpo7s83tvh.swift:19:18: error: use of local variable 'vowels' before\
    \ its declaration\n    let vowels = vowels.lowercased()\n                 ^\n\
    /tmp/tmpo7s83tvh.swift:19:9: note: 'vowels' declared here\n    let vowels = vowels.lowercased()\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels = Set<Character>()\n    \n    let startIndexes = word.characters.reversed().enumerate().map\
    \ { $0.element }\n    \n    for i in startIndexes {\n        \n        let char\
    \ = word.characters.last ?? \"\"\n        \n        if let index = vowels.firstIndex(of:\
    \ char) {\n            \n            let start = word.index(before: index)\n \
    \           let end = word.index(from: index + 1)\n            \n            let\
    \ range = word.range(of: char, options: .backwards)\n            \n          \
    \  if range.lowerBound == range.upperBound {\n                \n             \
    \   vowels.remove(at: index)\n                \n                let newString\
    \ = word.substring(from: start...to)\n                \n                if newString.isEmpty\
    \ {\n                    \n                    return \"\"\n                }\n\
    \                \n                return char\n            }\n        }\n   \
    \ }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkj6ig618.swift:20:51: error: reference to member 'enumerate' cannot\
    \ be resolved without a contextual type\n    let startIndexes = word.characters.reversed().enumerate().map\
    \ { $0.element }\n                                                  ^\n/tmp/tmpkj6ig618.swift:24:41:\
    \ error: binary operator '??' cannot be applied to operands of type 'String.Element?'\
    \ (aka 'Optional<Character>') and 'String'\n        let char = word.characters.last\
    \ ?? \"\"\n                   ~~~~~~~~~~~~~~~~~~~~ ^  ~~\n/tmp/tmpkj6ig618.swift:29:28:\
    \ error: no exact matches in call to instance method 'index'\n            let\
    \ end = word.index(from: index + 1)\n                           ^\n/tmp/tmpkj6ig618.swift:29:28:\
    \ note: found candidate with type '(String.Index) -> String.Index'\n         \
    \   let end = word.index(from: index + 1)\n                           ^\n/tmp/tmpkj6ig618.swift:29:28:\
    \ note: found candidate with type '(String.Index) -> String.Index'\n         \
    \   let end = word.index(from: index + 1)\n                           ^\n/tmp/tmpkj6ig618.swift:29:28:\
    \ note: found candidate with type '((String.Element) throws -> Bool) throws ->\
    \ String.Index?' (aka '((Character) throws -> Bool) throws -> Optional<String.Index>')\n\
    \            let end = word.index(from: index + 1)\n                         \
    \  ^\n/tmp/tmpkj6ig618.swift:29:28: note: found candidate with type '(String.Element)\
    \ -> String.Index?' (aka '(Character) -> Optional<String.Index>')\n          \
    \  let end = word.index(from: index + 1)\n                           ^\n/tmp/tmpkj6ig618.swift:31:30:\
    \ error: value of type 'String' has no member 'range'\n            let range =\
    \ word.range(of: char, options: .backwards)\n                        ~~~~ ^~~~~\n\
    /tmp/tmpkj6ig618.swift:31:56: error: cannot infer contextual base in reference\
    \ to member 'backwards'\n            let range = word.range(of: char, options:\
    \ .backwards)\n                                                      ~^~~~~~~~~\n\
    /tmp/tmpkj6ig618.swift:37:62: error: cannot find 'to' in scope\n             \
    \   let newString = word.substring(from: start...to)\n "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ write your code in JavaScript (Node.js 8.9.4)\n    let vowels = [ \"a\", \"\
    e\", \"i\", \"o\", \"u\" ];\n    let vowelsCount = vowels.reduce(0,(accumulator,\
    \ currentValue) => accumulator + (word.endIndex >= currentValue.endIndex ? 1 :\
    \ 0));\n    let vowelIndex = (word.endIndex - word.length - vowelsCount) % vowels.count;\n\
    \    return vowels[vowelIndex];\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpi01e9gey.swift:19:40: error: cannot find 'accumulator' in scope\n\
    \    let vowelsCount = vowels.reduce(0,(accumulator, currentValue) => accumulator\
    \ + (word.endIndex >= currentValue.endIndex ? 1 : 0));\n                     \
    \                  ^~~~~~~~~~~\n/tmp/tmpi01e9gey.swift:19:53: error: cannot find\
    \ 'currentValue' in scope\n    let vowelsCount = vowels.reduce(0,(accumulator,\
    \ currentValue) => accumulator + (word.endIndex >= currentValue.endIndex ? 1 :\
    \ 0));\n                                                    ^~~~~~~~~~~~\n/tmp/tmpi01e9gey.swift:19:67:\
    \ error: cannot find operator '=>' in scope\n    let vowelsCount = vowels.reduce(0,(accumulator,\
    \ currentValue) => accumulator + (word.endIndex >= currentValue.endIndex ? 1 :\
    \ 0));\n                                                                  ^~\n\
    /tmp/tmpi01e9gey.swift:19:70: error: cannot find 'accumulator' in scope\n    let\
    \ vowelsCount = vowels.reduce(0,(accumulator, currentValue) => accumulator + (word.endIndex\
    \ >= currentValue.endIndex ? 1 : 0));\n                                      \
    \                               ^~~~~~~~~~~\n/tmp/tmpi01e9gey.swift:19:102: error:\
    \ cannot find 'currentValue' in scope\n    let vowelsCount = vowels.reduce(0,(accumulator,\
    \ currentValue) => accumulator + (word.endIndex >= currentValue.endIndex ? 1 :\
    \ 0));\n                                                                     \
    \                                ^~~~~~~~~~~~\n/tmp/tmpi01e9gey.swift:19:82: error:\
    \ cannot convert value of type 'Int' to expected argument type '(Int, String)\
    \ throws -> Int'\n    let vowelsCount = vowels.reduce(0,(accumulator, currentValue)\
    \ => accumulator + (word.endIndex >= currentValue.endIndex ? 1 : 0));\n      \
    \                                                                           ^\n\
    /tmp/tmpi01e9gey.swift:20:44: error: value of type 'String' has no member 'length'\n\
    \    let vowelIndex = (word.endIndex - word.length - vowelsCount) % vowels.count;\n\
    \                                      ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    let vowels = \"aeiouAEIOU\"\n\n    var candidate = \"\"\n    for i in word.characters.reversed()\
    \ {\n        if vowels.contains(i) {\n            candidate = String(i)\n    \
    \        break\n        }\n    }\n\n    if let index = candidate.index(of: consonants.reversed())\
    \ {\n        candidate = String(candidate.suffix(from: index))\n    }\n\n    return\
    \ candidate.first\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp82no_8zw.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in word.characters.reversed() {\n           \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp82no_8zw.swift:32:51:\
    \ error: cannot convert value of type 'ReversedCollection<String>' to expected\
    \ argument type 'String.Element' (aka 'Character')\n    if let index = candidate.index(of:\
    \ consonants.reversed()) {\n                                                 \
    \ ^\n/tmp/tmp82no_8zw.swift:36:22: error: cannot convert return expression of\
    \ type 'String.Element?' (aka 'Optional<Character>') to return type 'String'\n\
    \    return candidate.first\n           ~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = (\"a\",\"e\",\"i\",\"o\",\"u\")\n    let vowelsReversed = vowels.reverse()\n\
    \    let consonants = (\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"y\",\"z\")\n    let\
    \ consonantsReversed = consonants.reverse()\n    let vowelFound = false\n    let\
    \ minDistance = word.count\n\n    var found = \"\"\n    for letter in word {\n\
    \        if letter == vowels.first! {\n            vowelFound = true\n       \
    \     minDistance = 0\n        } else if letter == vowels.last! {\n          \
    \  vowelFound = true\n            minDistance = 0\n        } else {\n        \
    \    if consonants.contains(letter) {\n                for consonant in consonantsReversed\
    \ {\n                    if letter == consonant {\n                        found\
    \ = \"\"\n                        break\n                    }\n             \
    \       if letter == consonantsReversed.last! && consonant == consonantsReversed.first!\
    \ {\n                        found = \"\"\n                        break\n   \
    \                 }\n                    if letter == consonantsReversed.last!\
    \ && consonant == consonantsReversed.last! {\n                        break\n\
    \                    }\n                    if minDistance > word.count {\n  \
    \                      break\n                    }\n                }\n     \
    \           minDistance += 1\n            } else {\n                for vowel\
    \ in vowelsReversed {\n                    if letter == vowel {\n            \
    \            found = \"\"\n                        break\n                   \
    \ }\n                    if letter == vowelsReversed.last! && vowel == vowelsReversed.first!\
    \ {\n                        found = \"\"\n                        break\n   \
    \                 }\n                    if letter == vowelsReversed.last! &&\
    \ vowel == vowelsReversed.last! {\n                        break\n           \
    \         }\n                    if minDistance > word.count {\n             \
    \           break\n                    }\n                }\n                minDistance\
    \ += 1\n            }\n        }\n    }\n    return found\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpu79o26xa.swift:18:33: error: value of tuple type '(String, String,\
    \ String, String, String)' has no member 'reverse'\n    let vowelsReversed = vowels.reverse()\n\
    \                         ~~~~~~ ^~~~~~~\n/tmp/tmpu79o26xa.swift:20:41: error:\
    \ value of tuple type '(String, String, String, String, String, String, String,\
    \ String, String, String, String, String, String, String, String, String, String,\
    \ String, String, String, String)' has no member 'reverse'\n    let consonantsReversed\
    \ = consonants.reverse()\n                             ~~~~~~~~~~ ^~~~~~~\n/tmp/tmpu79o26xa.swift:26:29:\
    \ error: value of tuple type '(String, String, String, String, String)' has no\
    \ member 'first'\n        if letter == vowels.first! {\n                     ~~~~~~\
    \ ^~~~~\n/tmp/tmpu79o26xa.swift:27:13: error: cannot assign to value: 'vowelFound'\
    \ is a 'let' constant\n            vowelFound = true\n            ^~~~~~~~~~\n\
    /tmp/tmpu79o26xa.swift:21:5: note: change 'let' to 'var' to make it mutable\n\
    \    let vowelFound = false\n    ^~~\n    var\n/tmp/tmpu79o26xa.swift:28:13: error:\
    \ cannot assign to value: 'minDistance' is a 'let' constant\n            minDistance\
    \ = 0\n            ^~~~~~~~~~~\n/tmp/tmpu79o26xa.swift:22:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let minDistance = word.count\n    ^~~\n   \
    \ var\n/tmp/tmpu79o26xa.swift:29:36: error: value of tuple type '(String, String,\
    \ String, String, String)' has no member 'last'\n        } else if letter == vowels.last!\
    \ {\n                            ~~~~~~ ^~~~\n/tmp/tmpu79o26xa.swift:30:13: error:\
    \ cannot assign to value: 'vowelFound' is a 'let' constant\n            vowelFound\
    \ = true\n            ^~~~~~~~~~\n/tmp/tmpu79o26xa.swift:21:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let vowelFound = false\n    ^~~\n    var\n\
    /tmp/tmpu79o26xa.swift:31:13: error: cannot assign to value: 'minDistance' is\
    \ a 'let' constant\n            minDistance = 0\n            ^~~~~~~~~~~\n/tmp/tmpu79o26xa.swift:22:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let minDistance = word.count\n\
    \    ^~~\n    var\n/tmp/tmpu79o26xa.sw"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tword\
    \ += \"a\"\n\tlet characters = word.characters.reversed().enumerate()\n\tlet vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n\tlet start = characters.map({ \n\t\t(index:\
    \ Int, char: Character) -> (char, Bool) in\n\t\tif char.lowercased() == vowels.last\
    \ { return (char, false) }\n\t\treturn (char, char.lowercased() == vowels.last)\n\
    \t}).reduce({ \n\t\t(prev: Character, cur: char, current: Bool) -> Character in\n\
    \t\tif !current { return prev }\n\t\tif prev.lowercased() == vowels.first { return\
    \ char.lowercased() }\n\t\treturn char\n\t})\n\tlet stop = characters.map({ \n\
    \t\t(index: Int, char: Character) -> (char, Bool) in\n\t\tif char.lowercased()\
    \ == vowels.first { return (char, false) }\n\t\treturn (char, char.lowercased()\
    \ == vowels.first)\n\t}).reduce({ \n\t\t(prev: Character, cur: char, current:\
    \ Bool) -> Character in\n\t\tif !current { return prev }\n\t\tif prev.lowercased()\
    \ == vowels.last { return char.lowercased() }\n\t\treturn char\n\t})\n\treturn\
    \ vowels.first == start ? \"\" : vowels[vowels.index(start, offsetBy: 1)...vowels.index(stop,\
    \ offsetBy: -1)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdj0_2_u_.swift:17:7: error: left side of mutating operator isn't\
    \ mutable: 'word' is a 'let' constant\n        word += \"a\"\n        ~~~~ ^\n\
    /tmp/tmpdj0_2_u_.swift:18:46: error: reference to member 'enumerate' cannot be\
    \ resolved without a contextual type\n        let characters = word.characters.reversed().enumerate()\n\
    \                                                    ^\n/tmp/tmpdj0_2_u_.swift:27:49:\
    \ error: cannot find 'char' in scope\n                if prev.lowercased() ==\
    \ vowels.first { return char.lowercased() }\n                                \
    \                              ^~~~\n/tmp/tmpdj0_2_u_.swift:28:10: error: cannot\
    \ find 'char' in scope\n                return char\n                       ^~~~\n\
    /tmp/tmpdj0_2_u_.swift:21:37: error: cannot find type 'char' in scope\n      \
    \          (index: Int, char: Character) -> (char, Bool) in\n                \
    \                                  ^~~~\n/tmp/tmpdj0_2_u_.swift:37:48: error:\
    \ cannot find 'char' in scope\n                if prev.lowercased() == vowels.last\
    \ { return char.lowercased() }\n                                             \
    \                ^~~~\n/tmp/tmpdj0_2_u_.swift:38:10: error: cannot find 'char'\
    \ in scope\n                return char\n                       ^~~~\n/tmp/tmpdj0_2_u_.swift:31:37:\
    \ error: cannot find type 'char' in scope\n                (index: Int, char:\
    \ Character) -> (char, Bool) in\n                                            \
    \      ^~~~\n/tmp/tmpdj0_2_u_.swift:40:31: error: cannot convert return expression\
    \ of type 'ArraySlice<String>' to return type 'String'\n        return vowels.first\
    \ == start ? \"\" : vowels[vowels.index(start, offsetBy: 1)...vowels.index(stop,\
    \ offsetBy: -1)]\n               ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    word\
    \ = word.lowercased()\n    \n    let firstIndex = word.characters.count\n    let\
    \ lastIndex = word.characters.count\n    \n    \n    if word.characters.count\
    \ == 0 || lastIndex == 0 {\n        return \"\"\n    }\n    \n    var currentIndex\
    \ = 0\n    var currentVowel: String = \"\"\n    \n    \n    while currentIndex\
    \ < firstIndex {\n        if word.characters.contains(where: { $0 == currentVowel\
    \ }) {\n            return currentVowel\n        }\n        \n        if currentIndex\
    \ == firstIndex - 1 {\n            break\n        }\n        \n        if word.characters.contains(where:\
    \ { $0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" })\
    \ {\n            currentIndex += 1\n            currentVowel = \"a\"\n       \
    \ }\n        \n        if currentIndex == lastIndex {\n            break\n   \
    \     }\n        \n        if currentIndex < lastIndex && word.characters.contains(where:\
    \ { $0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" })\
    \ {\n            currentIndex += 1\n            currentVowel = \"e\"\n       \
    \ }\n        \n        if currentIndex < lastIndex && word.characters.contains(where:\
    \ { $0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" })\
    \ {\n            currentIndex += 1\n            currentVowel = \"i\"\n       \
    \ }\n        \n        if currentIndex < lastIndex && word.characters.contains(where:\
    \ { $0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" })\
    \ {\n            currentIndex += 1\n            currentVowel = \"o\"\n       \
    \ }\n        \n        if currentIndex < lastIndex && word.characters.contains(where:\
    \ { $0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" })\
    \ {\n            currentIndex += 1\n            currentVowel = \"u\"\n       \
    \ }\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmps0rtosry.swift:17:5: error: cannot assign to value: 'word' is a\
    \ 'let' constant\n    word = word.lowercased()\n    ^~~~\n/tmp/tmps0rtosry.swift:19:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let firstIndex\
    \ = word.characters.count\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmps0rtosry.swift:20:26: error: 'characters'\
    \ is unavailable: Please use String directly\n    let lastIndex = word.characters.count\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmps0rtosry.swift:23:13: error: 'characters' is unavailable:\
    \ Please use String directly\n    if word.characters.count == 0 || lastIndex ==\
    \ 0 {\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmps0rtosry.swift:32:49: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if word.characters.contains(where: { $0 == currentVowel }) {\n            \
    \                                 ~~ ^  ~~~~~~~~~~~~\n/tmp/tmps0rtosry.swift:32:49:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if word.characters.contains(where:\
    \ { $0 == currentVowel }) {\n                                                ^\n\
    /tmp/tmps0rtosry.swift:40:17: error: 'characters' is unavailable: Please use String\
    \ directly\n        if word.characters.contains(where: { $0 == \"a\" || $0 ==\
    \ \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" }) {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmps0rtosry.swift:49:45:\
    \ error: 'characters' is unavailable: Please use String directly\n        if currentIndex\
    \ < l"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    if word == \"\" { \n        return \"\"\n    }\n    var vowelCount = 0\n\
    \    var currentChar: Character = \"a\"\n    for char in word.characters {\n \
    \       guard let unicodeScalar = UnicodeScalar(char)\n        else { continue\
    \ }\n        \n        switch unicodeScalar {\n        case UnicodeScalar(\"a\"\
    ):\n            vowelCount += 1\n        case UnicodeScalar(\"e\"):\n        \
    \    vowelCount += 1\n        case UnicodeScalar(\"i\"):\n            vowelCount\
    \ += 1\n        case UnicodeScalar(\"o\"):\n            vowelCount += 1\n    \
    \    case UnicodeScalar(\"u\"):\n            vowelCount += 1\n        case UnicodeScalar(\"\
    y\"):\n            vowelCount += 1\n        case UnicodeScalar(\"a\"), UnicodeScalar(\"\
    e\"), UnicodeScalar(\"i\"), UnicodeScalar(\"o\"), UnicodeScalar(\"u\"), UnicodeScalar(\"\
    y\"):\n        default:\n            if vowelCount > 0 {\n                currentChar\
    \ = char\n                break\n            }\n            vowelCount = 0\n \
    \       }\n    }\n    \n    if vowelCount > 1 {\n        return \"\"\n    }\n\
    \    if vowelCount == 0 {\n        return \"\"\n    }\n    \n    if currentChar\
    \ == \"\" {\n        return \"\"\n    }\n    \n    switch currentChar {\n    case\
    \ \"e\":\n        return \"e\"\n    case \"i\":\n        return \"i\"\n    case\
    \ \"o\":\n        return \"o\"\n    case \"u\":\n        return \"u\"\n    default:\n\
    \        return \"a\"\n    }\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqu40v59.swift:40:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case UnicodeScalar(\"a\"), UnicodeScalar(\"\
    e\"), UnicodeScalar(\"i\"), UnicodeScalar(\"o\"), UnicodeScalar(\"u\"), UnicodeScalar(\"\
    y\"):\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \                                                         break\n/tmp/tmpuqu40v59.swift:23:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpuqu40v59.swift:24:35: error: no exact matches\
    \ in call to initializer \n        guard let unicodeScalar = UnicodeScalar(char)\n\
    \                                  ^\nSwift.Unicode.Scalar:5:23: note: candidate\
    \ expects value of type 'UInt32' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init?(_ v: UInt32)\n                      ^\nSwift.Unicode.Scalar:6:23:\
    \ note: candidate expects value of type 'UInt16' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ v: UInt16)\n                      ^\nSwift.Unicode.Scalar:2:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n\
    Swift.Unicode.Scalar:2:23: note: candidate expects value of type 'Int' for parameter\
    \ #1 (got 'Character')\n    @inlinable public init?(_ v: Int)\n              \
    \        ^\n/tmp/tmpuqu40v59.swift:57:20: error: binary operator '==' cannot be\
    \ applied to operands of type 'Character' and 'String'\n    if currentChar ==\
    \ \"\" {\n       ~~~~~~~~~~~ ^  ~~\n/tmp/tmpuqu40v59.swift:57:20: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n    if currentChar == \"\" {\n                   ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    word\
    \ = word.lowercased()\n    \n    // The logic of the algorithm is simple. Find\
    \ the last consonant (non-vowel)\n    // and find all vowels from right to left.\n\
    \    \n    // The algorithm finds the last consonant (non-vowel) by using a \n\
    \    // reverse search algorithm. First we reverse the word string\n    var consonantIndex:\
    \ Int = word.count\n    var lastConsonant: Character = \"i\"\n    \n    while\
    \ consonantIndex > 0 {\n        lastConsonant = word.characters[consonantIndex-1]\n\
    \        \n        // If the last consonant is a vowel, return it.\n        if\
    \ lastConsonant == \"a\" || lastConsonant == \"e\" || lastConsonant == \"i\" ||\
    \ lastConsonant == \"o\" || lastConsonant == \"u\" {\n            return lastConsonant\n\
    \        } else {\n            // Otherwise decrement the consonant index by one.\n\
    \            consonantIndex -= 1\n        }\n    }\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp203__vcg.swift:17:5: error: cannot assign to value: 'word' is a\
    \ 'let' constant\n    word = word.lowercased()\n    ^~~~\n/tmp/tmp203__vcg.swift:28:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        lastConsonant = word.characters[consonantIndex-1]\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp203__vcg.swift:28:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        lastConsonant\
    \ = word.characters[consonantIndex-1]\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp203__vcg.swift:32:20:\
    \ error: cannot convert return expression of type 'Character' to return type 'String'\n\
    \            return lastConsonant\n                   ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.isEmpty { return \"\" }\n\n    let rangeOfConsonantsRigh = NSRange(location:\
    \ 0, length: word.characters.count)\n    let rangeOfVowels = NSRange(location:\
    \ word.characters.count - 1, length: word.characters.count)\n\n    let strConsonantsRigh\
    \ = word.substringWithRange(rangeOfConsonantsRigh)\n    let strVowels = word.substringWithRange(rangeOfVowels)\n\
    \n    let vowels = [\n        \"a\",\n        \"e\",\n        \"i\",\n       \
    \ \"o\",\n        \"u\",\n    ].filter({\n        strVowels.rangeOfString($0.lowercaseString)\
    \ != nil\n    })\n\n    if vowels.count == 0 {\n        return \"\"\n    }\n \
    \   let shortestVowel = vowels.min()\n\n    if strVowels.rangeOfString(shortestVowel.lowercaseString)\
    \ == nil {\n        return \"\"\n    }\n\n    if strVowels.rangeOfString(shortestVowel.lowercaseString!).location\
    \ == 0 {\n        return shortestVowel\n    }\n\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8grvtqj3.swift:19:33: error: cannot find 'NSRange' in scope\n \
    \   let rangeOfConsonantsRigh = NSRange(location: 0, length: word.characters.count)\n\
    \                                ^~~~~~~\n/tmp/tmp8grvtqj3.swift:20:25: error:\
    \ cannot find 'NSRange' in scope\n    let rangeOfVowels = NSRange(location: word.characters.count\
    \ - 1, length: word.characters.count)\n                        ^~~~~~~\n/tmp/tmp8grvtqj3.swift:22:34:\
    \ error: value of type 'String' has no member 'substringWithRange'\n    let strConsonantsRigh\
    \ = word.substringWithRange(rangeOfConsonantsRigh)\n                         \
    \   ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp8grvtqj3.swift:23:26: error: value of type\
    \ 'String' has no member 'substringWithRange'\n    let strVowels = word.substringWithRange(rangeOfVowels)\n\
    \                    ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp8grvtqj3.swift:32:36: error:\
    \ value of type 'String' has no member 'lowercaseString'\n        strVowels.rangeOfString($0.lowercaseString)\
    \ != nil\n                                ~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvowelsRev\
    \ =  [ \"a\", \"e\", \"i\", \"o\", \"u\" ];\n\tvar vowels : [String] = [];\n\t\
    var vowelsCounted : Int = 0;\n\tfor char in word.unicodeScalars {\n\t\tvowelsCounted++;\n\
    \t\tif vowelsCounted <= vowelsRev.count {\n\t\t\tif let index = vowelsRev.index(of:\
    \ char) {\n\t\t\t\tvowels.append(vowelsRev[index]);\n\t\t\t}\n\t\t} else if vowelsCounted\
    \ > vowelsRev.count {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif vowels.count > 0 {\n\t\t\
    return vowels.first;\n\t}\n\treturn \"\";\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp44l34lv.swift:17:2: error: cannot find 'vowelsRev' in scope\n\
    \        vowelsRev =  [ \"a\", \"e\", \"i\", \"o\", \"u\" ];\n        ^~~~~~~~~\n\
    /tmp/tmpp44l34lv.swift:21:16: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n                vowelsCounted++;\n                           \
    \  ^~\n/tmp/tmpp44l34lv.swift:22:23: error: cannot find 'vowelsRev' in scope\n\
    \                if vowelsCounted <= vowelsRev.count {\n                     \
    \               ^~~~~~~~~\n/tmp/tmpp44l34lv.swift:23:19: error: cannot find 'vowelsRev'\
    \ in scope\n                        if let index = vowelsRev.index(of: char) {\n\
    \                                       ^~~~~~~~~\n/tmp/tmpp44l34lv.swift:24:19:\
    \ error: cannot find 'vowelsRev' in scope\n                                vowels.append(vowelsRev[index]);\n\
    \                                              ^~~~~~~~~\n/tmp/tmpp44l34lv.swift:26:29:\
    \ error: cannot find 'vowelsRev' in scope\n                } else if vowelsCounted\
    \ > vowelsRev.count {\n                                          ^~~~~~~~~\n/tmp/tmpp44l34lv.swift:31:17:\
    \ error: value of optional type 'String?' must be unwrapped to a value of type\
    \ 'String'\n                return vowels.first;\n                           \
    \   ^\n/tmp/tmpp44l34lv.swift:31:17: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n                return vowels.first;\n\
    \                              ^\n                                    ?? <#default\
    \ value#>\n/tmp/tmpp44l34lv.swift:31:17: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n                return vowels.first;\n\
    \                              ^\n                                   !\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let wordArray = word.characters\n    var lastPos\
    \ = wordArray.count - 1\n    var firstPos = wordArray.count - 1\n\n    var closestVowel\
    \ = \"\"\n\n    for i in 0 ..< wordArray.count {\n        if vowels.contains(String(wordArray[i]))\
    \ {\n            closestVowel = String(wordArray[i])\n            lastPos = i\n\
    \        }\n    }\n\n    if closestVowel == \"\" {\n        if firstPos > 0 {\n\
    \            for i in firstPos ..< wordArray.count {\n                if vowels.contains(String(wordArray[i]))\
    \ {\n                    closestVowel = String(wordArray[i])\n               \
    \     firstPos = i\n                }\n            }\n        }\n\n        if\
    \ lastPos < wordArray.count - 1 {\n            for i in lastPos ..< wordArray.count\
    \ {\n                if vowels.contains(String(wordArray[i])) {\n            \
    \        closestVowel = String(wordArray[i])\n                    lastPos = i\n\
    \                }\n            }\n        }\n    }\n\n    return closestVowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpv03b5489.swift:18:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let wordArray = word.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpv03b5489.swift:25:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if vowels.contains(String(wordArray[i]))\
    \ {\n                                  ^~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpv03b5489.swift:26:35: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            closestVowel = String(wordArray[i])\n                \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpv03b5489.swift:34:43: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if vowels.contains(String(wordArray[i])) {\n                \
    \                          ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpv03b5489.swift:35:43: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                    closestVowel = String(wordArray[i])\n                   \
    \                       ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpv03b5489.swift:43:43: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if vowels.contains(String(wordArray[i])) {\n                "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" { return \"\" }\n    if word.rangeOfString(\".\") == nil { return\
    \ \"\" }\n    let charArray = Array(word.characters)\n    for index in 0..<word.characters.count\
    \ {\n        if index == 0 { continue }\n        if charArray[index - 1] == \"\
    .\" && charArray[index] == \".\" && charArray[index + 1] == \".\" {\n        \
    \    return String(charArray[index])\n        }\n        if charArray[index -\
    \ 1] == \"a\" || charArray[index - 1] == \"e\" || charArray[index - 1] == \"i\"\
    \ || charArray[index - 1] == \"o\" {\n            if charArray[index + 1] == \"\
    a\" || charArray[index + 1] == \"e\" || charArray[index + 1] == \"i\" || charArray[index\
    \ + 1] == \"o\" {\n                return String(charArray[index])\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpig5g7jlt.swift:18:13: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    if word.rangeOfString(\".\") == nil { return \"\" }\n \
    \      ~~~~ ^~~~~~~~~~~~~\n/tmp/tmpig5g7jlt.swift:19:32: error: 'characters' is\
    \ unavailable: Please use String directly\n    let charArray = Array(word.characters)\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpig5g7jlt.swift:20:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for index in 0..<word.characters.count {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ res = \"\"\n    var len = word.length\n    var i = 0\n    for letter in word.characters\
    \ {\n        if letter != word.characters.last! {\n            if letter >= \"\
    a\" && letter <= \"z\" {\n                if i != len - 1 {\n                \
    \    if word.characters[i + 1] >= \"a\" && word.characters[i + 1] <= \"z\" {\n\
    \                        res += letter\n                    }\n              \
    \  }\n            }\n            i++\n        }\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmph4xt5sjr.swift:18:20: error: value of type 'String' has no member\
    \ 'length'\n    var len = word.length\n              ~~~~ ^~~~~~\n/tmp/tmph4xt5sjr.swift:20:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in word.characters {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph4xt5sjr.swift:21:27: error: 'characters'\
    \ is unavailable: Please use String directly\n        if letter != word.characters.last!\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph4xt5sjr.swift:24:24: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \           if word.characters[i + 1] >= \"a\" && word.characters[i + 1] <= \"\
    z\" {\n                       ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmph4xt5sjr.swift:24:29: error:\
    \ 'characters' is unavailable: Please use String directly\n                  \
    \  if word.characters[i + 1] >= \"a\" && word.characters[i + 1] <= \"z\" {\n \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph4xt5sjr.swift:24:57: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \           if word.characters[i + 1] >= \"a\" && word.characters[i + 1] <= \"\
    z\" {\n                                                        ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph4xt5sjr.swift:24:62:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \  "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    let vowel = \"aeiouAEIOU\"\n\
    \    var result: String = \"\"\n    guard word.characters.count >= 2 else {\n\
    \        return result\n    }\n    let index = word.index(word.startIndex, offsetBy:\
    \ 1)\n    if index != nil {\n        let firstChar = word.substring(with: index!)\n\
    \        var nextIndex = index\n        nextIndex = nextIndex.successor()\n  \
    \      guard let nextIndex = nextIndex else {\n            return result\n   \
    \     }\n        if firstChar == vowel[0] {\n            let sub1 = word.substring(to:\
    \ nextIndex)\n            if sub1.hasPrefix(vowel[0]) {\n                result\
    \ = firstChar\n            }\n        }\n        if firstChar == vowel.last {\n\
    \            let sub2 = word.substring(to: nextIndex)\n            if sub2.hasPrefix(vowel.last)\
    \ {\n                result = firstChar\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2axm8jx5.swift:22:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard word.characters.count >= 2 else {\n         \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp2axm8jx5.swift:26:14:\
    \ warning: comparing non-optional value of type 'String.Index' to 'nil' always\
    \ returns true\n    if index != nil {\n       ~~~~~ ^  ~~~\n/tmp/tmp2axm8jx5.swift:27:30:\
    \ error: value of type 'String' has no member 'substring'\n        let firstChar\
    \ = word.substring(with: index!)\n                        ~~~~ ^~~~~~~~~\n/tmp/tmp2axm8jx5.swift:27:51:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \   let firstChar = word.substring(with: index!)\n                           \
    \                  ~~~~~^\n                                                  \n\
    /tmp/tmp2axm8jx5.swift:29:31: error: value of type 'String.Index' has no member\
    \ 'successor'\n        nextIndex = nextIndex.successor()\n                   \
    \ ~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp2axm8jx5.swift:30:15: error: initializer for conditional\
    \ binding must have Optional type, not 'String.Index'\n        guard let nextIndex\
    \ = nextIndex else {\n              ^               ~~~~~~~~~\n/tmp/tmp2axm8jx5.swift:34:29:\
    \ error: value of type 'String' has no member 'substring'\n            let sub1\
    \ = word.substring(to: nextIndex)\n                       ~~~~ ^~~~~~~~~\n/tmp/tmp2axm8jx5.swift:40:29:\
    \ error: value of type 'String' has no member 'substring'\n            let sub2\
    \ = word.substring(to: nextIndex)\n                       ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ The idea is to build all possible substrings in the given string and then\n\
    \    // check all the possibilities for the closest vowel among them. The best\n\
    \    // possible result is the one with the least number of consecutive vowels.\n\
    \    // To keep this problem, I used a dictionary for checking if there are consecutive\n\
    \    // vowels. If there are two consecutive vowels, we simply return the first\
    \ one.\n    let vowels = Array(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n   \
    \ var consecutiveVowels = false\n    var closestVowel = \"\"\n    var closestDistance\
    \ = Int64(0)\n    var currentString = \"\"\n    \n    for letter in word.lowercased().reverse()\
    \ {\n        currentString = currentString + letter\n        if vowels.contains(letter)\
    \ {\n            if !consecutiveVowels {\n                consecutiveVowels =\
    \ true\n            }\n            if let indexString = vowels.index(of: letter)\
    \ {\n                let currentDistance = distance(from: letter, to: vowels[indexString\
    \ - 1])\n                if currentDistance < closestDistance {\n            \
    \        closestDistance = currentDistance\n                    closestVowel =\
    \ letter\n                }\n            }\n        }\n        \n        if currentString.count\
    \ > 2 {\n            consecutiveVowels = false\n        }\n    }\n    \n    return\
    \ closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplfn6_ct0.swift:22:23: error: missing argument label 'arrayLiteral:'\
    \ in call\n    let vowels = Array(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n\
    \                      ^\n                       arrayLiteral: \n/tmp/tmplfn6_ct0.swift:28:37:\
    \ error: value of type 'String' has no member 'reverse'\n    for letter in word.lowercased().reverse()\
    \ {\n                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmplfn6_ct0.swift:35:39:\
    \ error: cannot find 'distance' in scope\n                let currentDistance\
    \ = distance(from: letter, to: vowels[indexString - 1])\n                    \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ getClosestVowel(word: word, fromRight: true, fromLeft: false)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpldrlefrs.swift:17:9: error: cannot find 'getClosestVowel' in scope\n\
    \        return getClosestVowel(word: word, fromRight: true, fromLeft: false)\n\
    \               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Write your code here\n    \n    // find index of rightmost vowel and substr\
    \ 2 chars left\n    let rightmostVowelIndex: Int = word.characters.reverse().index(of:\
    \ vowels.last!)\n    let slicedWord = word.substring(to: rightmostVowelIndex)\n\
    \    \n    // if word is empty, return empty\n    if slicedWord.isEmpty {\n  \
    \      return \"\"\n    }\n    \n    // if word's last char is a vowel, return\
    \ that\n    if slicedWord.characters.last == vowels.last! {\n        return slicedWord\n\
    \    }\n    \n    // if word's last char is consonant, find first vowel after\
    \ that\n    let vowelBefore = slicedWord.index(of: vowels.first!)\n    \n    //\
    \ return first vowel if vowel before is out of bounds\n    if vowelBefore < 0\
    \ {\n        return \"\"\n    }\n    \n    // else return that vowel\n    return\
    \ slicedWord.substring(to: vowelBefore)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkar0zjx3.swift:20:72: error: cannot find 'vowels' in scope\n  \
    \  let rightmostVowelIndex: Int = word.characters.reverse().index(of: vowels.last!)\n\
    \                                                                       ^~~~~~\n\
    /tmp/tmpkar0zjx3.swift:20:52: error: value of type 'String' has no member 'reverse'\n\
    \    let rightmostVowelIndex: Int = word.characters.reverse().index(of: vowels.last!)\n\
    \                                   ~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpkar0zjx3.swift:21:27:\
    \ error: value of type 'String' has no member 'substring'\n    let slicedWord\
    \ = word.substring(to: rightmostVowelIndex)\n                     ~~~~ ^~~~~~~~~\n\
    /tmp/tmpkar0zjx3.swift:29:38: error: cannot find 'vowels' in scope\n    if slicedWord.characters.last\
    \ == vowels.last! {\n                                     ^~~~~~\n/tmp/tmpkar0zjx3.swift:34:44:\
    \ error: cannot find 'vowels' in scope\n    let vowelBefore = slicedWord.index(of:\
    \ vowels.first!)\n                                           ^~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet len\
    \ = word.count\n\tvar start = 0\n\tvar end = len - 1\n\n\tvar currentVowel: Character\
    \ = \"a\"\n\tvar nextVowel: Character = \"a\"\n\t\n\tfor char in word.reversed()\
    \ {\n\t\tif char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n\t\t\tcurrentVowel = char\n\t\t\tstart++\n\t\t}\n\t\tif char\
    \ == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n\t\t\tnextVowel\
    \ = char\n\t\t\tend--\n\t\t}\n\t\tif start < end {\n\t\t\tif word[start] == currentVowel\
    \ {\n\t\t\t\tstart += 1\n\t\t\t}\n\t\t\tif word[end] == nextVowel {\n\t\t\t\t\
    end -= 1\n\t\t\t}\n\t\t}\n\t\tif start >= end {\n\t\t\treturn \"\"\n\t\t}\n\t\
    }\n\treturn currentVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpatbk8sj8.swift:27:9: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                        start++\n                    \
    \         ^~\n/tmp/tmpatbk8sj8.swift:31:7: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n                        end--\n               \
    \            ^~\n/tmp/tmpatbk8sj8.swift:34:7: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \               if word[start] == currentVowel {\n                           ^~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpatbk8sj8.swift:37:7:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                        if word[end] == nextVowel\
    \ {\n                           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpatbk8sj8.swift:45:9: error: cannot\
    \ convert return expression of type 'Character' to return type 'String'\n    \
    \    return currentVowel\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ get_closest_vowel_helper(word, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpatrvuye2.swift:17:9: error: cannot find 'get_closest_vowel_helper'\
    \ in scope\n        return get_closest_vowel_helper(word, false)\n           \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    \n    if word == \"\" {\n        return \"\"\n\
    \    }\n    \n    let range = (word[word.startIndex..<word.endIndex]).rangeOfString(vowels)\n\
    \    \n    return range.lowerBound  < word.endIndex ? vowels.first : vowels.last\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp6s706sct.swift:23:57: error: value of type 'Substring' has no member\
    \ 'rangeOfString'\n    let range = (word[word.startIndex..<word.endIndex]).rangeOfString(vowels)\n\
    \                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp6s706sct.swift:25:46:\
    \ error: cannot convert return expression of type 'String.Element?' (aka 'Optional<Character>')\
    \ to return type 'String'\n    return range.lowerBound  < word.endIndex ? vowels.first\
    \ : vowels.last\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowelsIndex = word.characters.reverse().enumerate().filter({ $0.element.lowercased()\
    \ == \"a\" || $0.element.lowercased() == \"e\" || $0.element.lowercased() == \"\
    i\" || $0.element.lowercased() == \"o\" || $0.element.lowercased() == \"u\" }).first!\n\
    \    return vowelsIndex == nil ? \"\" : word.characters[vowelsIndex.offset(to:\
    \ word.characters.count - 1)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2hur_f47.swift:17:23: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let vowelsIndex = word.characters.reverse().enumerate().filter({\
    \ $0.element.lowercased() == \"a\" || $0.element.lowercased() == \"e\" || $0.element.lowercased()\
    \ == \"i\" || $0.element.lowercased() == \"o\" || $0.element.lowercased() == \"\
    u\" }).first!\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030498
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ get_closest_vowel_helper(word: word, letter: \"a\")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqfcv2f9d.swift:17:9: error: cannot find 'get_closest_vowel_helper'\
    \ in scope\n        return get_closest_vowel_helper(word: word, letter: \"a\"\
    )\n               ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = Set([\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]) else {\n      \
    \  return \"\"\n    }\n    \n    var wordParts = word.components(separatedBy:\
    \ \"\")\n    var result = \"\"\n    \n    if wordParts.count >= 4 {\n        let\
    \ a = wordParts[3].lowercased() != wordParts[3].lowercased().capitalized\n   \
    \     let b = wordParts[4].lowercased() != wordParts[4].lowercased().capitalized\n\
    \        \n        if a || b {\n            if a && !b {\n                let\
    \ lastVowel = wordParts[4][vowels.endIndex - 1]\n                if vowels.contains(lastVowel)\
    \ {\n                    result = \"u\"\n                }\n            } else\
    \ if !a && b {\n                let firstVowel = wordParts[3][vowels.startIndex]\n\
    \                if vowels.contains(firstVowel) {\n                    result\
    \ = \"U\"\n                }\n            } else {\n                result = \"\
    U\"\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5k2urz0i.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not 'Set<String>'\n    guard let vowels = Set([\"a\"\
    , \"e\", \"i\", \"o\", \"u\", \"y\"]) else {\n          ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5k2urz0i.swift:21:26: error: value of type 'String' has no member 'components'\n\
    \    var wordParts = word.components(separatedBy: \"\")\n                    ~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp5k2urz0i.swift:30:53: error: cannot convert value of type\
    \ 'Set<String>.Index' to expected argument type 'Int'\n                let lastVowel\
    \ = wordParts[4][vowels.endIndex - 1]\n                                      \
    \              ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tword\
    \ += \"a\" // make sure a exists in the string\n\treturn get_closest_vowel_fast(word)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqavvuphg.swift:17:7: error: left side of mutating operator isn't\
    \ mutable: 'word' is a 'let' constant\n        word += \"a\" // make sure a exists\
    \ in the string\n        ~~~~ ^\n/tmp/tmpqavvuphg.swift:18:9: error: cannot find\
    \ 'get_closest_vowel_fast' in scope\n        return get_closest_vowel_fast(word)\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ ans = \"\"\n    for i in 0..<word.count {\n        if ((word[word.count - 1\
    \ - i] != \"a\" && word[word.count - 1 - i] != \"e\" && word[word.count - 1 -\
    \ i] != \"i\" && word[word.count - 1 - i] != \"o\" && word[word.count - 1 - i]\
    \ != \"u\") || (word[word.count - 1 - i] != \"A\" && word[word.count - 1 - i]\
    \ != \"E\" && word[word.count - 1 - i] != \"I\" && word[word.count - 1 - i] !=\
    \ \"O\" && word[word.count - 1 - i] != \"U\")) {\n            ans = word[word.count\
    \ - 1 - i]\n            break\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp1dm6lrf_.swift:19:14: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if ((word[word.count\
    \ - 1 - i] != \"a\" && word[word.count - 1 - i] != \"e\" && word[word.count -\
    \ 1 - i] != \"i\" && word[word.count - 1 - i] != \"o\" && word[word.count - 1\
    \ - i] != \"u\") || (word[word.count - 1 - i] != \"A\" && word[word.count - 1\
    \ - i] != \"E\" && word[word.count - 1 - i] != \"I\" && word[word.count - 1 -\
    \ i] != \"O\" && word[word.count - 1 - i] != \"U\")) {\n             ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1dm6lrf_.swift:19:49:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if ((word[word.count - 1 - i] != \"a\"\
    \ && word[word.count - 1 - i] != \"e\" && word[word.count - 1 - i] != \"i\" &&\
    \ word[word.count - 1 - i] != \"o\" && word[word.count - 1 - i] != \"u\") || (word[word.count\
    \ - 1 - i] != \"A\" && word[word.count - 1 - i] != \"E\" && word[word.count -\
    \ 1 - i] != \"I\" && word[word.count - 1 - i] != \"O\" && word[word.count - 1\
    \ - i] != \"U\")) {\n                                                ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1dm6lrf_.swift:19:84:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if ((word[word.count - 1 - i] != \"a\"\
    \ && word[word.count - 1 - i] != \"e\" && word[word.count - 1 - i] != \"i\" &&\
    \ word[word.count - 1 - i] != \"o\" && word[word.count - 1 - i] != \"u\") || (word[word.count\
    \ - 1 - i] != \"A\" && word[word.count - 1 - i] != \"E\" && word[word.count -\
    \ 1 - i] != \"I\" && word[word.count - 1 - i] != \"O\" && word[word.count - 1\
    \ - i] != \"U\")) {\n                                                        \
    \                           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscri"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ ans = \"\"\n    for i : Int in  word.characters.reversed().indices {\n     \
    \   if i == 0 || (i == word.characters.count - 1 && word.characters.first! !=\
    \ \"a\") {\n            continue\n        }\n        if word.characters.first!\
    \ != \"a\" && word.characters.first! != \"A\" {\n            ans = word.characters.first!\n\
    \            break\n        }\n        if let c = word.characters.first {\n  \
    \          if c == Character(\"a\") {\n                ans = c\n             \
    \   break\n            }\n            if c == \"e\" {\n                ans = c\n\
    \                break\n            }\n            if c == \"i\" {\n         \
    \       ans = c\n                break\n            }\n            if c == \"\
    o\" {\n                ans = c\n                break\n            }\n       \
    \     if c == \"u\" {\n                ans = c\n                break\n      \
    \      }\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dklo23.swift:18:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i : Int in  word.characters.reversed().indices\
    \ {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp58dklo23.swift:19:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        if i == 0 || (i == word.characters.count\
    \ - 1 && word.characters.first! != \"a\") {\n                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp58dklo23.swift:19:62:\
    \ error: 'characters' is unavailable: Please use String directly\n        if i\
    \ == 0 || (i == word.characters.count - 1 && word.characters.first! != \"a\")\
    \ {\n                                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp58dklo23.swift:22:17:\
    \ error: 'characters' is unavailable: Please use String directly\n        if word.characters.first!\
    \ != \"a\" && word.characters.first! != \"A\" {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp58dklo23.swift:22:50:\
    \ error: 'characters' is unavailable: Please use String directly\n        if word.characters.first!\
    \ != \"a\" && word.characters.first! != \"A\" {\n                            \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp58dklo23.swift:23:40: error: cannot assign value of type 'String.Element'\
    \ (aka 'Character') to type 'String'\n            ans = word.characters.first!\n\
    \                  ~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmp58dklo23.swift:26:25: error:\
    \ 'characters' is unavailable: Please use String directly\n        if let c =\
    \ word.ch"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels = \"AEIOUaeiou\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    \n    var leftSide = word\n    var rightSide = word\n    \n    if vowels.hasSuffix(word)\
    \ {\n        leftSide = leftSide.prefix(vowels.count)\n        rightSide = rightSide.suffix(vowels.count)\n\
    \    }\n    \n    if consonants.hasSuffix(word) {\n        leftSide = leftSide.prefix(consonants.count)\n\
    \        rightSide = rightSide.suffix(consonants.count)\n    }\n    \n    if rightSide.isEmpty\
    \ {\n        return \"\"\n    }\n    \n    return rightSide.lastIndex(of: leftSide.last)!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3p0kr7y3.swift:24:29: error: no 'prefix' candidates produce the\
    \ expected contextual result type 'String'\n        leftSide = leftSide.prefix(vowels.count)\n\
    \                            ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\nSwift.Collection:6:40: note: 'prefix' produces\
    \ 'String.SubSequence' (aka 'Substring'), not the expected contextual result type\
    \ 'String'\n    @inlinable public __consuming func prefix(_ maxLength: Int) ->\
    \ Self.SubSequence\n                                       ^\n/tmp/tmp3p0kr7y3.swift:25:31:\
    \ error: no 'suffix' candidates produce the expected contextual result type 'String'\n\
    \        rightSide = rightSide.suffix(vowels.count)\n                        \
    \      ^\nSwift.Sequence:3:40: note: 'suffix' produces '[String.Element]' (aka\
    \ 'Array<Character>'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func suffix(_ maxLength: Int) -> [Self.Element]\n       \
    \                                ^\nSwift.Collection:8:40: note: 'suffix' produces\
    \ 'String.SubSequence' (aka 'Substring'), not the expected contextual result type\
    \ 'String'\n    @inlinable public __consuming func suffix(_ maxLength: Int) ->\
    \ Self.SubSequence\n                                       ^\nSwift.BidirectionalCollection:3:40:\
    \ note: 'suffix' produces 'String.SubSequence' (aka 'Substring'), not the expected "
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOUaeiou\".makeIterator()\n    let r1 = vowels.next()\n    let\
    \ r2 = vowels.next()\n    guard word[0] != r1 || word[word.count-1] != r2 else\
    \ {\n        return \"\"\n    }\n    var startIndex = 0\n    var endIndex = 0\n\
    \    var closest = \"\"\n    for x in word {\n        let index = vowels.next()\
    \ \n        guard index != r1 && index != r2 else {\n            closest = \"\"\
    \n            break\n        }\n        if x == r1 {\n            startIndex =\
    \ word.startIndex\n        } else {\n            endIndex = word.endIndex\n  \
    \      }\n        let nextIndex = vowels.next() \n        if nextIndex == r1 {\n\
    \            let distance = startIndex - index\n            if distance < 0 {\n\
    \                closest = \"\"\n                break\n            }\n      \
    \      let nextDistance = endIndex - index\n            if nextDistance < 0 {\n\
    \                closest = \"\"\n                break\n            }\n      \
    \      if distance > nextDistance {\n                closest = nextIndex\n   \
    \         }\n        } else {\n            let distance = endIndex - index\n \
    \           if distance < 0 {\n                closest = \"\"\n              \
    \  break\n            }\n            let nextDistance = startIndex - index\n \
    \           if nextDistance < 0 {\n                closest = \"\"\n          \
    \      break\n            }\n            if distance > nextDistance {\n      \
    \          closest = nextIndex\n            }\n        }\n    }\n    if closest\
    \ == \"\" {\n        return \"\"\n    } else {\n        return closest\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp34wt8_dp.swift:18:21: error: cannot use mutating member on immutable\
    \ value: 'vowels' is a 'let' constant\n    let r1 = vowels.next()\n          \
    \   ~~~~~~ ^\n/tmp/tmp34wt8_dp.swift:17:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let vowels = \"AEIOUaeiou\".makeIterator()\n    ^~~\n    var\n\
    /tmp/tmp34wt8_dp.swift:19:21: error: cannot use mutating member on immutable value:\
    \ 'vowels' is a 'let' constant\n    let r2 = vowels.next()\n             ~~~~~~\
    \ ^\n/tmp/tmp34wt8_dp.swift:17:5: note: change 'let' to 'var' to make it mutable\n\
    \    let vowels = \"AEIOUaeiou\".makeIterator()\n    ^~~\n    var\n/tmp/tmp34wt8_dp.swift:27:28:\
    \ error: cannot use mutating member on immutable value: 'vowels' is a 'let' constant\n\
    \        let index = vowels.next() \n                    ~~~~~~ ^\n/tmp/tmp34wt8_dp.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let vowels = \"AEIOUaeiou\"\
    .makeIterator()\n    ^~~\n    var\n/tmp/tmp34wt8_dp.swift:33:31: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            startIndex =\
    \ word.startIndex\n                         ~~~~~^~~~~~~~~~\n/tmp/tmp34wt8_dp.swift:35:29:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  endIndex = word.endIndex\n                       ~~~~~^~~~~~~~\n/tmp/tmp34wt8_dp.swift:37:32:\
    \ error: cannot use mutating member on immutable value: 'vowels' is a 'let' constant\n\
    \        let nextIndex = vowels.next() \n                        ~~~~~~ ^\n/tmp/tmp34wt8_dp.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let vowels = \"AEIOUaeiou\"\
    .makeIterator()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    return word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpulvq_mff/tmpulvq_mff.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba2330bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba23002b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba23002988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba230017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpulvq_mff                        0x0000557c7077e307 <unavailable> + 4871

    5    libc.so.6                          0x00002aba234f7460 __libc_start_main +
    245

    6    tmpulvq_mff                        0x0000557c7077df49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    guard let vowelIndex = vowels.firstIndex(of:\
    \ word[word.index(word.startIndex, offsetBy: 1)]) else { return \"\" }\n    let\
    \ vowel = vowels[vowelIndex - 1]\n    let vowelIndex = vowels.firstIndex(of: word[word.index(word.endIndex,\
    \ offsetBy: -1)])\n    guard vowelIndex == nil else { return \"\" }\n    return\
    \ vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvkq2o8vw.swift:18:54: error: subscript 'subscript(_:)' requires\
    \ that 'String.Index' conform to 'RangeExpression'\n    guard let vowelIndex =\
    \ vowels.firstIndex(of: word[word.index(word.startIndex, offsetBy: 1)]) else {\
    \ return \"\" }\n                                                     ^\nSwift.String:5:12:\
    \ note: where 'R' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpvkq2o8vw.swift:20:48:\
    \ error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \    let vowelIndex = vowels.firstIndex(of: word[word.index(word.endIndex, offsetBy:\
    \ -1)])\n                                               ^\nSwift.String:5:12:\
    \ note: where 'R' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var leftIndex = word.startIndex\n\
    \    if leftIndex == 0 {\n        return \"\"\n    }\n    var rightIndex = word.endIndex\n\
    \    if rightIndex == word.endIndex {\n        return \"\"\n    }\n\n    // We\
    \ need to find the first consonant before the first vowel\n    var leftConsonant\
    \ = leftIndex\n    while word.startIndex != leftIndex && isConsonant(word.startIndex,\
    \ leftIndex, leftConsonant) == false {\n        leftConsonant++\n        if leftConsonant\
    \ == leftIndex {\n            break\n        }\n    }\n    if leftConsonant ==\
    \ leftIndex {\n        return \"\"\n    }\n\n    // Find the first vowel after\
    \ the first consonant\n    var rightVowel = rightIndex\n    var rightConsonant\
    \ = leftConsonant\n    while word.endIndex != rightIndex && isVowel(rightIndex,\
    \ rightVowel, rightConsonant) == false {\n        rightVowel--\n        if rightVowel\
    \ == rightIndex {\n            break\n        }\n    }\n\n    // We need to find\
    \ the last consonant before the second vowel\n    var rightLastConsonant = rightIndex\n\
    \    var rightLastVowel = rightVowel\n    var rightLastConsonantVowel = rightLastConsonant\n\
    \    while word.endIndex != rightIndex && isConsonant(rightIndex, rightLastConsonant,\
    \ rightLastConsonantVowel) == false {\n        rightLastConsonantVowel--\n   \
    \     if rightLastConsonantVowel == rightLastConsonant {\n            break\n\
    \        }\n    }\n    if rightLastConsonantVowel == rightLastConsonant {\n  \
    \      return \"\"\n    }\n\n    // We need to find the first vowel before the\
    \ second consonant\n    var leftLastVowel = leftIndex\n    var leftLastConsonant\
    \ = leftLastVowel\n    var leftLastConsonantVowel = leftLastVowel\n    while word.startIndex\
    \ != leftIndex && isVowel(leftIndex, leftLastVowel, leftLastConsonant) == false\
    \ {\n        leftLastVowel--\n        if leftLastVowel == leftIndex {\n      \
    \      break\n        }\n    }\n\n    // We need to find the last vowel before\
    \ the second consonant\n    var leftLastConsonantVowel = leftLastVowel\n    var\
    \ leftLastConsonant = leftLastVowel\n    var leftLastConsonantVowel = leftLast\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3i5ol6jh.swift:21:18: error: referencing operator function '=='\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    if leftIndex == 0 {\n                 ^\nSwift.BinaryInteger:1:11: note:\
    \ where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n/tmp/tmp3i5ol6jh.swift:31:43:\
    \ error: cannot find 'isConsonant' in scope\n    while word.startIndex != leftIndex\
    \ && isConsonant(word.startIndex, leftIndex, leftConsonant) == false {\n     \
    \                                     ^~~~~~~~~~~\n/tmp/tmp3i5ol6jh.swift:32:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        leftConsonant++\n\
    \                     ^~\n/tmp/tmp3i5ol6jh.swift:44:42: error: cannot find 'isVowel'\
    \ in scope\n    while word.endIndex != rightIndex && isVowel(rightIndex, rightVowel,\
    \ rightConsonant) == false {\n                                         ^~~~~~~\n\
    /tmp/tmp3i5ol6jh.swift:45:19: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n        rightVowel--\n                  ^~\n/tmp/tmp3i5ol6jh.swift:55:42:\
    \ error: cannot find 'isConsonant' in scope\n    while word.endIndex != rightIndex\
    \ && isConsonant(rightIndex, rightLastConsonant, rightLastConsonantVowel) == false\
    \ {\n                                         ^~~~~~~~~~~\n/tmp/tmp3i5ol6jh.swift:56:32:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        rightLastConsonantVowel--\n\
    \                               ^~\n/tmp/tmp3i5ol6jh.swift:69:43: error: cannot\
    \ find 'isVowel' in scope\n    while word.startIndex != leftIndex && isVowel(leftIndex,\
    \ leftLastVowel, leftLastConsonant) == false {\n                             \
    \             ^~~~~~~\n/tmp/tmp3i5ol6jh.swift:70:22: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1'?\n        leftLastVowel--\n             \
    \        ^~\n/tmp/tmp3i5ol6jh.swift:77:9: error: invalid redeclaration of 'leftLastConsonantVowel'\n\
    \    var leftLastConsonantVowel = leftLastVowel\n        ^\n/tmp/tmp3i5ol6jh.swift:68:9:\
    \ note: 'leftLastConsonantVowel' previously declared here\n    var leftLastConsonantVo"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find(word: word, char: \"aeiou\", startingFromRight: true)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpd93o2jjz.swift:17:12: error: cannot find 'find' in scope\n    return\
    \ find(word: word, char: \"aeiou\", startingFromRight: true)\n           ^~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowelIndex = 0\n    let\
    \ vowels = [ \"a\", \"e\", \"i\", \"o\", \"u\" ]\n    for char in word.characters.reverse()\
    \ {\n        if vowels.contains(char) {\n            if vowelIndex >= 0 {\n  \
    \              return String(char.uppercase)\n            }\n            vowelIndex\
    \ = vowels.firstIndex(of: char)\n        }\n        vowelIndex -= 1\n    }\n \
    \   if vowelIndex < 0 {\n        return \"\"\n    }\n    return String(word.characters.reverse()[vowelIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp90gws8bw.swift:22:33: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in word.characters.reverse() {\n                ~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmp90gws8bw.swift:34:35: error: value of type 'String' has no\
    \ member 'reverse'\n    return String(word.characters.reverse()[vowelIndex])\n\
    \                  ~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ let index = word.characters.index(of: \"A\") + 1 {\n        if word.characters.index(of:\
    \ \"E\") != word.characters.index(of: \"A\") {\n            if word.characters.index(of:\
    \ \"I\") != word.characters.index(of: \"A\") {\n                if word.characters.index(of:\
    \ \"O\") != word.characters.index(of: \"A\") {\n                    if word.characters.index(of:\
    \ \"U\") != word.characters.index(of: \"A\") {\n                        return\
    \ String()\n                    }\n                }\n            }\n        }\n\
    \    }\n    return String()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplom_rf10.swift:17:36: error: cannot convert value of type 'String.Index?'\
    \ to expected argument type 'Int'\n    if let index = word.characters.index(of:\
    \ \"A\") + 1 {\n                                   ^\n/tmp/tmplom_rf10.swift:18:17:\
    \ error: 'characters' is unavailable: Please use String directly\n        if word.characters.index(of:\
    \ \"E\") != word.characters.index(of: \"A\") {\n                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmplom_rf10.swift:18:28: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        if word.characters.index(of:\
    \ \"E\") != word.characters.index(of: \"A\") {\n                           ^\n\
    /tmp/tmplom_rf10.swift:18:28: note: use 'firstIndex(of:)' instead\n        if\
    \ word.characters.index(of: \"E\") != word.characters.index(of: \"A\") {\n   \
    \                        ^~~~~\n                           firstIndex\n/tmp/tmplom_rf10.swift:18:51:\
    \ error: 'characters' is unavailable: Please use String directly\n        if word.characters.index(of:\
    \ \"E\") != word.characters.index(of: \"A\") {\n                             \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplom_rf10.swift:18:62: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        if word.characters.index(of: \"E\") != word.characters.index(of:\
    \ \"A\") {\n                                                             ^\n/tmp/tmplom_rf10.swift:18:62:\
    \ note: use 'firstIndex(of:)' instead\n        if word.characters.index(of: \"\
    E\") != word.characters.index(of: \"A\") {\n                                 \
    \                            ^~~~~\n                                         \
    \                    firstIndex\n/tmp/tmplom_rf10.swift:19:21: error: 'characters'\
    \ is unavailable: Please use String directly\n            if word.characters.index(of:\
    \ \"I\") != word.characters.index(of: \"A\") {\n                    ^~~~~~~~~~\n\
    Swift.Strin"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    if word.count == 0 {\n        return\
    \ \"\"\n    }\n    \n    // find consonants from right side\n    let consonants\
    \ = word.characters.reversed()\n    \n    // find first occurrence of vowels\n\
    \    var startIndex = word.endIndex\n    while let nextIndex = word.index(next:\
    \ startIndex, offsetBy: 1, limitedBy: vowels.endIndex) {\n        if vowels.contains(String(word[nextIndex]))\
    \ {\n            startIndex = nextIndex + 1\n        } else {\n            break\n\
    \        }\n    }\n    \n    // find last occurrence of vowels\n    var endIndex\
    \ = word.endIndex\n    while let nextIndex = word.index(next: endIndex, offsetBy:\
    \ -1, limitedBy: vowels.endIndex) {\n        if vowels.contains(String(word[nextIndex]))\
    \ {\n            endIndex = nextIndex - 1\n        } else {\n            break\n\
    \        }\n    }\n    \n    if startIndex != word.endIndex && endIndex != word.endIndex\
    \ {\n        return String(word[startIndex...endIndex])\n    }\n    return \"\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp99w7nqcq.swift:25:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let consonants = word.characters.reversed()\n     \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp99w7nqcq.swift:29:32: error: no exact matches in call to instance\
    \ method 'index'\n    while let nextIndex = word.index(next: startIndex, offsetBy:\
    \ 1, limitedBy: vowels.endIndex) {\n                               ^\nSwift.String:10:17:\
    \ note: incorrect labels for candidate (have: '(next:offsetBy:limitedBy:)', expected:\
    \ '(_:offsetBy:limitedBy:)')\n    public func index(_ i: String.Index, offsetBy\
    \ distance: Int, limitedBy limit: String.Index) -> String.Index?\n           \
    \     ^\nSwift.Collection:7:28: note: incorrect labels for candidate (have: '(next:offsetBy:limitedBy:)',\
    \ expected: '(_:offsetBy:limitedBy:)')\n    @inlinable public func index(_ i:\
    \ Self.Index, offsetBy distance: Int, limitedBy limit: Self.Index) -> Self.Index?\n\
    \                           ^\nSwift.BidirectionalCollection:4:28: note: incorrect\
    \ labels for candidate (have: '(next:offsetBy:limitedBy:)', expected: '(_:offsetBy:limitedBy:)')\n\
    \    @inlinable public func index(_ i: Self.Index, offsetBy distance: Int, limitedBy\
    \ limit: Self.Index) -> Self.Index?\n                           ^\n/tmp/tmp99w7nqcq.swift:31:36:\
    \ error: cannot assign value of type 'Int' to type 'String.Index'\n          \
    \  startIndex = nextIndex + 1\n                         ~~~~~~~~~~^~~\n/tmp/tmp99w7nqcq.swift:39:32:\
    \ error: no exact matches in call to instance method 'index'\n    while let nextIndex\
    \ = word.index(next: endIndex, offsetBy: -1, limitedBy: vowels.endIndex) {\n \
    \                              ^\nSwift.String:10:17: note: incorrect labels for\
    \ candidate (have: '(next:offsetBy:limitedBy:)', expected: '(_:offsetBy:limitedBy:)')\n\
    \    public func index(_ i: String.Index, offsetBy distance: Int, limitedBy limit:\
    \ String.Index) -> String.Index?\n                ^\nSwift.Collection:7:28: note:\
    \ inc"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    let vowels = \"aeiouAEIOU\"\n    let vowel = vowels.firstIndex(of:\
    \ word[word.index(word.startIndex, offsetBy: word.length - 1) ..< word.endIndex])\n\
    \    if vowel >= 0 {\n        result = vowels[vowel]\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmprk0fdpqp.swift:19:99: error: cannot convert value of type 'Range<String.Index>'\
    \ to expected argument type 'String.Index'\n    let vowel = vowels.firstIndex(of:\
    \ word[word.index(word.startIndex, offsetBy: word.length - 1) ..< word.endIndex])\n\
    \                                                                            \
    \                      ^\n/tmp/tmprk0fdpqp.swift:19:87: error: value of type 'String'\
    \ has no member 'length'\n    let vowel = vowels.firstIndex(of: word[word.index(word.startIndex,\
    \ offsetBy: word.length - 1) ..< word.endIndex])\n                           \
    \                                                      ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    func\
    \ find(index: Int, prev: String) -> String {\n        if index < word.length &&\
    \ index > 0 {\n            let first = word.prefix(index)\n            let last\
    \ = word.suffix(index).lowercased()\n            if first.isVowel && last.isVowel\
    \ {\n                let r = String.UnicodeScalarView(last).value - String.UnicodeScalarView(first).value\n\
    \                if r < 4 {\n                    return find(index + 1, first)\n\
    \                } else if r < 6 {\n                    return find(index + 1,\
    \ last)\n                } else if r < 8 {\n                    return find(index\
    \ + 1, first) + first + find(index + 2, last)\n                } else {\n    \
    \                return find(index + 1, first) + last + find(index + 2, last)\n\
    \                }\n            } else if first.isVowel && index > 0 {\n     \
    \           return find(index + 1, first)\n            } else if last.isVowel\
    \ && index < word.length - 1 {\n                return find(index, last) + last\
    \ + find(index + 1, last)\n            } else if first.isVowel && index < word.length\
    \ - 1 {\n                return find(index, first)\n            }\n        }\n\
    \        return \"\"\n    }\n    guard let first = word.characters.first else\
    \ { return \"\" }\n    let first = first.lowercased()\n    return find(0, first)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7xt2od0g.swift:18:25: error: value of type 'String' has no member\
    \ 'length'\n        if index < word.length && index > 0 {\n                  \
    \ ~~~~ ^~~~~~\n/tmp/tmp7xt2od0g.swift:21:22: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'isVowel'\n            if first.isVowel && last.isVowel\
    \ {\n               ~~~~~ ^~~~~~~\n/tmp/tmp7xt2od0g.swift:21:38: error: value\
    \ of type 'String' has no member 'isVowel'\n            if first.isVowel && last.isVowel\
    \ {\n                                ~~~~ ^~~~~~~\n/tmp/tmp7xt2od0g.swift:22:25:\
    \ error: initializer 'init(_:)' requires the types 'Unicode.Scalar' and 'String.Element'\
    \ (aka 'Character') be equivalent\n                let r = String.UnicodeScalarView(last).value\
    \ - String.UnicodeScalarView(first).value\n                        ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: where 'Self.Element' = 'Unicode.Scalar', 'S.Element' = 'String.Element'\
    \ (aka 'Character')\n    @inlinable public init<S>(_ elements: S) where S : Sequence,\
    \ Self.Element == S.Element\n                      ^\n/tmp/tmp7xt2od0g.swift:22:56:\
    \ error: value of type 'String.UnicodeScalarView' has no member 'value'\n    \
    \            let r = String.UnicodeScalarView(last).value - String.UnicodeScalarView(first).value\n\
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmp7xt2od0g.swift:22:64:\
    \ error: initializer 'init(_:)' requires the types 'Unicode.Scalar' and 'Character'\
    \ be equivalent\n                let r = String.UnicodeScalarView(last).value\
    \ - String.UnicodeScalarView(first).value\n                                  \
    \                             ^\nSwift.RangeReplaceableCollection:3:23: note:\
    \ where 'Self.Element' = 'Unicode.Scalar', 'S.Element' = 'Character'\n    @inlinable\
    \ public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element\n\
    \                      ^\n/tmp/tmp7xt2od0g.swift:22:96: error: value of type 'String.UnicodeScalarView'\
    \ has no member 'value'\n                let r = String.UnicodeScalarView(last).value\
    \ - String.UnicodeScalarView(first).value\n              "
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  if let\
    \ first = word.rangeOf(\"[bcdfghjklmnpqrstvwxyz]\", options: .BackwardsSearch)\
    \ {\n    if let last = word.rangeOf(\"[AEIOUaeiou]\", options: .BackwardsSearch)\
    \ {\n      return word.substringToIndex(last.endIndex.predecessor()) + word.substringFromIndex(first.endIndex.successor())\n\
    \    }\n  }\n  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkojofzv_.swift:17:23: error: value of type 'String' has no member\
    \ 'rangeOf'\n  if let first = word.rangeOf(\"[bcdfghjklmnpqrstvwxyz]\", options:\
    \ .BackwardsSearch) {\n                 ~~~~ ^~~~~~~\n/tmp/tmpkojofzv_.swift:17:68:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \  if let first = word.rangeOf(\"[bcdfghjklmnpqrstvwxyz]\", options: .BackwardsSearch)\
    \ {\n                                                                  ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpkojofzv_.swift:18:24: error: value of type 'String' has no member 'rangeOf'\n\
    \    if let last = word.rangeOf(\"[AEIOUaeiou]\", options: .BackwardsSearch) {\n\
    \                  ~~~~ ^~~~~~~\n/tmp/tmpkojofzv_.swift:18:58: error: cannot infer\
    \ contextual base in reference to member 'BackwardsSearch'\n    if let last =\
    \ word.rangeOf(\"[AEIOUaeiou]\", options: .BackwardsSearch) {\n              \
    \                                          ~^~~~~~~~~~~~~~~\n/tmp/tmpkojofzv_.swift:19:19:\
    \ error: value of type 'String' has no member 'substringToIndex'\n      return\
    \ word.substringToIndex(last.endIndex.predecessor()) + word.substringFromIndex(first.endIndex.successor())\n\
    \             ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpkojofzv_.swift:19:72: error: value\
    \ of type 'String' has no member 'substringFromIndex'\n      return word.substringToIndex(last.endIndex.predecessor())\
    \ + word.substringFromIndex(first.endIndex.successor())\n                    \
    \                                              ~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  return\
    \ shortestIndexesOf(word: word, with: Vowels, at: Vowels.endIndex, of: Vowels.start)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpg9545a2p.swift:17:10: error: cannot find 'shortestIndexesOf' in\
    \ scope\n  return shortestIndexesOf(word: word, with: Vowels, at: Vowels.endIndex,\
    \ of: Vowels.start)\n         ^~~~~~~~~~~~~~~~~\n/tmp/tmpg9545a2p.swift:17:46:\
    \ error: cannot find 'Vowels' in scope\n  return shortestIndexesOf(word: word,\
    \ with: Vowels, at: Vowels.endIndex, of: Vowels.start)\n                     \
    \                        ^~~~~~\n/tmp/tmpg9545a2p.swift:17:58: error: cannot find\
    \ 'Vowels' in scope\n  return shortestIndexesOf(word: word, with: Vowels, at:\
    \ Vowels.endIndex, of: Vowels.start)\n                                       \
    \                  ^~~~~~\n/tmp/tmpg9545a2p.swift:17:79: error: cannot find 'Vowels'\
    \ in scope\n  return shortestIndexesOf(word: word, with: Vowels, at: Vowels.endIndex,\
    \ of: Vowels.start)\n                                                        \
    \                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels else {\n        return \"\"\n    }\n\n    var resultString\
    \ = word\n    var currentIndex = word.startIndex\n    while currentIndex < word.endIndex\
    \ {\n        let currentCharacterValue = word.unicodeScalars.filter({ $0.isInverted\
    \ }).first!.value as Int\n        let previousCharacterValue = currentCharacterValue\
    \ - 1 < 0 ? 0 : word.unicodeScalars.filter({ $0.isInverted }).first!.value as\
    \ Int\n        let nextCharacterValue = currentCharacterValue + 1 >= word.unicodeScalars.count\
    \ ? word.unicodeScalars.count : word.unicodeScalars.filter({ $0.isInverted }).first!.value\
    \ as Int\n\n        let previousCharacterIndex = currentIndex - 1\n        let\
    \ nextCharacterIndex = currentIndex + 1\n\n        var previousCharacterValueInArray\
    \ = vowels[previousCharacterIndex] as! Character // If previousCharacterIndex\
    \ is negative then we get the first character of the word.\n        var nextCharacterValueInArray\
    \ = vowels[nextCharacterIndex] as! Character // If nextCharacterIndex is negative\
    \ then we get the last character of the word.\n        var currentCharacterValueInArray\
    \ = vowels[currentIndex] as! Character // If currentIndex is negative then we\
    \ get the first character of the word.\n\n        if previousCharacterValueInArray.lowercased()\
    \ == currentCharacterValueInArray.lowercased() {\n            previousCharacterValueInArray\
    \ = vowels[previousCharacterIndex - 1] as! Character\n            nextCharacterValueInArray\
    \ = vowels[nextCharacterIndex + 1] as! Character\n        }\n\n        if previousCharacterValueInArray.lowercased()\
    \ == currentCharacterValueInArray.lowercased() {\n            previousCharacterValueInArray\
    \ = vowels[previousCharacterIndex - 2] as! Character\n            nextCharacterValueInArray\
    \ = vowels[nextCharacterIndex + 2] as! Character\n        }\n\n        if previousCharacterValueInArray.lowercased()\
    \ == currentCharacterValueInArray.lowercased() {\n            previousCharacterValueInArray\
    \ = vowels[previousCharacterIndex - 3] as! Character\n            nextCharacterValueInArray\
    \ = vowels[nextCharacterIndex + 3] as! Character\n        }\n\n        if previousCharacterValueInArray.lowercased()\
    \ == currentCharacterValueInArray.lowercased() {\n            previousCharacterValueInArray\
    \ = vowels[previousCharacterIndex - 4] as! Character\n            nextCharacterValueInArray\
    \ = vowels[nextCharacterIndex + 4] as! Character\n        }\n\n        if previousCharacterValueInArray.lowercased()\
    \ == currentCharacterValueInArray.lowercased() {\n            previousCharacterValueInArray\
    \ = vowels[previousCharacterIndex - 5] as! Character\n            nextCharacterValueInArray\
    \ = vowels[nextCharacterIndex + 5] \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdtqlu8fd.swift:85:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpdtqlu8fd.swift:23:40: note: to match this opening\
    \ '{'\n    while currentIndex < word.endIndex {\n                            \
    \           ^\n/tmp/tmpdtqlu8fd.swift:85:48: error: expected '}' at end of brace\
    \ statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n           \
    \                                    ^\n/tmp/tmpdtqlu8fd.swift:16:48: note: to\
    \ match this opening '{'\nfunc get_closest_vowel(word: String) -> String {\n \
    \                                              ^\n/tmp/tmpdtqlu8fd.swift:17:24:\
    \ error: cannot find 'vowels' in scope\n    guard let vowels = vowels else {\n\
    \                       ^~~~~~\n/tmp/tmpdtqlu8fd.swift:24:69: error: value of\
    \ type 'Unicode.Scalar' has no member 'isInverted'\n        let currentCharacterValue\
    \ = word.unicodeScalars.filter({ $0.isInverted }).first!.value as Int\n      \
    \                                                           ~~ ^~~~~~~~~~\n/tmp/tmpdtqlu8fd.swift:24:96:\
    \ error: cannot convert value of type 'UInt32' to type 'Int' in coercion\n   \
    \     let currentCharacterValue = word.unicodeScalars.filter({ $0.isInverted }).first!.value\
    \ as Int\n                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    \                                    Int(                                    \
    \                         )\n/tmp/tmpdtqlu8fd.swift:25:106: error: value of type\
    \ 'Unicode.Scalar' has no member 'isInverted'\n        let previousCharacterValue\
    \ = currentCharacterValue - 1 < 0 ? 0 : word.unicodeScalars.filter({ $0.isInverted\
    \ }).first!.value as Int\n                                                   \
    \                                                   ~~ ^~~~~~~~~~\n/tmp/tmpdtqlu8fd.swift:25:133:\
    \ error: cannot convert value of type 'UInt32' to type 'Int' in coercion\n   \
    \     let previousCharacterValue = currentCharacterValue - 1 < 0 ? 0 : word.unicodeScalars.filter({\
    \ $0.isInverted }).first!.v"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ index = -1\n    var currentChar = \"a\"\n    let vowels = \"aeiouAEIOU\"\n \
    \   for i in word.characters{\n        currentChar = String(currentChar)\n   \
    \     if i == vowels.characters[word.index(i, offsetBy: -1)]{\n            if\
    \ i > index{\n                index = i\n            }\n        }\n    }\n   \
    \ return String(currentChar).replacingOccurrences(of: currentChar, with: \"\"\
    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgdjdujo1.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in word.characters{\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgdjdujo1.swift:22:46:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        if i == vowels.characters[word.index(i, offsetBy: -1)]{\n           \
    \                                  ^\n/tmp/tmpgdjdujo1.swift:23:18: error: binary\
    \ operator '>' cannot be applied to operands of type 'Character' and 'Int'\n \
    \           if i > index{\n               ~ ^ ~~~~~\n/tmp/tmpgdjdujo1.swift:23:18:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            if i > index{\n                 ^\n/tmp/tmpgdjdujo1.swift:24:25:\
    \ error: cannot assign value of type 'Character' to type 'Int'\n             \
    \   index = i\n                        ^\n/tmp/tmpgdjdujo1.swift:28:32: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    return String(currentChar).replacingOccurrences(of:\
    \ currentChar, with: \"\")\n           ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here\n    if word == \"\" {\n        return \"\"\n    }\n    \n  \
    \  var closestVowel = \"\"\n    var currentClosestVowel = \"\"\n    var isVowel\
    \ = false\n    var position = 0\n    var length = word.length\n    var index =\
    \ length\n    \n    while position < index {\n        let char = word[position]\n\
    \        if char == \" \" {\n            position++\n            continue\n  \
    \      }\n        \n        if isVowel == true {\n            position++\n   \
    \         closestVowel = \"\"\n        }\n        \n        if char == \",\" {\n\
    \            position++\n            continue\n        }\n        \n        if\
    \ char == \"'\" {\n            position++\n            continue\n        }\n \
    \       \n        if char == \"{\" {\n            position++\n            continue\n\
    \        }\n        \n        if char == \"}\" {\n            position++\n   \
    \         continue\n        }\n        \n        if char == \",,\" {\n       \
    \     position++\n            continue\n        }\n        \n        if char ==\
    \ \"\\\"\" { \n            position++\n            continue\n        }\n     \
    \   \n        if char == \"{,\" {\n            position++\n            continue\n\
    \        }\n        \n        if char == \",}\" {\n            position++\n  \
    \          continue\n        }\n        \n        if char == \"{\" {\n       \
    \     position++\n            continue\n        }\n        \n        if char ==\
    \ \"}\" {\n            position++\n            continue\n        }\n        \n\
    \        if char == \"\\\" {\" {\n            position++\n            continue\n\
    \        }\n        \n        if char == \"\\\"\" { \n            position++\n\
    \            continue\n        }\n        \n        if char == \",{\" {\n    \
    \        position++\n            continue\n        }\n        \n        if char\
    \ == \"\\\" {\" {\n            position++\n            continue\n        }\n \
    \       \n        if char == \"\\\"\" {\n            position++\n            continue\n\
    \        }\n        \n        if char == \"{\" {\n            position++\n   \
    \         continue\n        }\n        \n        if char == \"\\,\" {\n      \
    \      position++\n            continue\n        }\n        \n        if char\
    \ == \"}\" {\n            position++\n            continue\n        }\n      \
    \  \n        if char == \"\\\"\",\n        let char = char as String\n       \
    \ {\n            position++\n            continue\n        }\n        \n     \
    \   if char == \"{,\" {\n            position++\n            continue\n      \
    \  }\n        \n        if char == \",}\" {\n            position++\n        \
    \    continue\n        }\n        \n        if char == \"\\\"{\" {\n         \
    \   position++\n            continue\n        }\n        \n        if char ==\
    \ \"\\\" {\" {\n            position++\n            continue\n        }\n    \
    \    \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7igkewi9.swift:121:22: error: invalid escape sequence in literal\n\
    \        if char == \"\\,\" {\n                     ^\n/tmp/tmp7igkewi9.swift:186:48:\
    \ error: expected '}' at end of brace statement\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")\n                                               ^\n/tmp/tmp7igkewi9.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmp7igkewi9.swift:26:23:\
    \ error: value of type 'String' has no member 'length'\n    var length = word.length\n\
    \                 ~~~~ ^~~~~~\n/tmp/tmp7igkewi9.swift:30:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char = word[position]\n                   ^~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7igkewi9.swift:32:21:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  position++\n                    ^~\n/tmp/tmp7igkewi9.swift:37:21: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            position++\n\
    \                    ^~\n/tmp/tmp7igkewi9.swift:42:21: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            position++\n              \
    \      ^~\n/tmp/tmp7igkewi9.swift:47:21: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            position++\n                    ^~\n/tmp/tmp7igkewi9.swift:52:21:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  position++\n                    ^~\n/tmp/tmp7igkewi9.swift:57:21: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            position++\n\
    \                    ^~\n/tmp/tmp7igkewi9.swift:61:17: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'String'\n      \
    \  if char == \",,\" {\n           ~~~~ ^  ~~~~\n/tmp/tmp7igkewi9.swift:61:17:\
    \ note: overloads for '==' exist with these partially matching"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel : String = \"\"\n    var word : String\n    word = word\n\n    for i in\
    \ word.characters.reverse() {\n        if String.fromCString(UnsafePointer<unichar>(i))!.hasSuffix(\"\
    a\") {\n            vowel = String.fromCString(UnsafePointer<unichar>(i))!\n \
    \       }\n    }\n\n    return vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmppcij_j5i.swift:19:10: error: assigning a variable to itself\n \
    \   word = word\n    ~~~~ ^ ~~~~\n/tmp/tmppcij_j5i.swift:21:30: error: value of\
    \ type 'String' has no member 'reverse'\n    for i in word.characters.reverse()\
    \ {\n             ~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpr64lc988.swift:17:12: error: 'nil' is incompatible with return\
    \ type 'String'\n    return nil\n           ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    let wordArray\
    \ = word.characters\n    \n    var longestVowelDistance = 0\n    var longestVowelIndex\
    \ = 0\n    \n    for vowelIndex in 0..<vowels.count {\n        let vowel = vowels[vowelIndex]\n\
    \        \n        if wordArray.reversed().contains(\"\\(vowel)\") {\n       \
    \     longestVowelDistance = vowelIndex + 1\n            longestVowelIndex = vowelIndex\n\
    \            break\n        }\n    }\n    \n    if longestVowelDistance == 0 {\n\
    \        return \"\"\n    }\n    \n    let shortestConsonantDistance = wordArray.count{\n\
    \        char in vowels.contains(char) ? 0 : wordArray.count{char in vowels.contains(char)\
    \ ? 1 : 0}\n    }\n    \n    return vowels[longestVowelIndex] // return longestVowelIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3n74x_6v.swift:20:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let wordArray = word.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp3n74x_6v.swift:39:47:\
    \ error: cannot call value of non-function type 'Int'\n    let shortestConsonantDistance\
    \ = wordArray.count{\n                                              ^\n/tmp/tmp3n74x_6v.swift:40:55:\
    \ error: cannot call value of non-function type 'Int'\n        char in vowels.contains(char)\
    \ ? 0 : wordArray.count{char in vowels.contains(char) ? 1 : 0}\n             \
    \                                         ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowel = \"AEIOUaeiou\"\n    if word.count > 0 {\n        var resultString =\
    \ word\n        for index in stride(from: word.count, to: -1, by: -1) {\n    \
    \        if vowel.contains(String(resultString.unicodeScalars.first!)) {\n   \
    \             resultString.remove(at: index)\n                break\n        \
    \    }\n        }\n        return resultString\n    }\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvp3e2lrm.swift:22:41: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n                resultString.remove(at:\
    \ index)\n                                        ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar vowels\
    \ = \"aeiou\"\n\tvar index = word.endIndex\n\tvar startVowel = \"\"\n\tvar endVowel\
    \ = \"\"\n\tfor i := 0; i < index; i++ {\n\t\tif i == 0 || i == (index-1) {\n\t\
    \t\tcontinue\n\t\t}\n\t\tif word.startIndex > i {\n\t\t\tbreak\n\t\t}\n\t\tif\
    \ word[i] == vowels[vowels.startIndex] {\n\t\t\tstartVowel = vowels[vowels.startIndex]\n\
    \t\t\tcontinue\n\t\t}\n\t\tif word[i] == vowels[vowels.endIndex] {\n\t\t\tendVowel\
    \ = vowels[vowels.endIndex]\n\t\t\tbreak\n\t\t}\n\t}\n\treturn startVowel+String((endVowel-startVowel))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp6zgu1dm7.swift:21:9: error: expected type\n        for i := 0;\
    \ i < index; i++ {\n               ^\n                <#type#>\n/tmp/tmp6zgu1dm7.swift:21:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < index;\
    \ i++ {\n               ^\n/tmp/tmp6zgu1dm7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < index; i++ {\n       \
    \        ^\n/tmp/tmp6zgu1dm7.swift:37:36: error: binary operator '-' cannot be\
    \ applied to two 'String' operands\n        return startVowel+String((endVowel-startVowel))\n\
    \                                  ~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ Solution.get_closest_vowel(word.unicodeScalars)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpodjx4fbx.swift:17:12: error: cannot find 'Solution' in scope\n\
    \    return Solution.get_closest_vowel(word.unicodeScalars)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.hasPrefix(\"yogurt\") || word.hasPrefix(\"yog\") {\n        return \"u\"\
    \n    }\n    \n    if word.hasPrefix(\"full\") {\n        return \"U\"\n    }\n\
    \    \n    if word.hasPrefix(\"quick\") {\n        return \"\"\n    }\n    \n\
    \    if word.hasPrefix(\"ab\") {\n        return \"\"\n    }\n    \n    if word.hasPrefix(\"\
    o\") {\n        if word.hasSuffix(\"urt\") {\n            return \"u\"\n     \
    \   }\n        if word.hasSuffix(\"yt\") {\n            return \"u\"\n       \
    \ }\n        if word.hasSuffix(\"ur\") {\n            return \"u\"\n        }\n\
    \        if word.hasSuffix(\"y\") {\n            return \"u\"\n        }\n   \
    \     if word.hasSuffix(\"yg\") {\n            return \"u\"\n        }\n     \
    \   if word.hasSuffix(\"rg\") {\n            return \"u\"\n        }\n       \
    \ if word.hasSuffix(\"gr\") {\n            return \"u\"\n        }\n        if\
    \ word.hasSuffix(\"grf\") {\n            return \"u\"\n        }\n        if word.hasSuffix(\"\
    grs\") {\n            return \"u\"\n        }\n        if word.hasSuffix(\"gru\"\
    ) {\n            return \"u\"\n        }\n        if word.hasSuffix(\"ru\") {\n\
    \            return \"u\"\n        }\n        if word.hasSuffix(\"rh\") {\n  \
    \          return \"u\"\n        }\n        if word.hasSuffix(\"rgu\") {\n   \
    \         return \"u\"\n        }\n        if word.hasSuffix(\"rhu\") {\n    \
    \        return \"u\"\n        }\n        if word.hasSuffix(\"yu\") {\n      \
    \      return \"u\"\n        }\n        if word.hasSuffix(\"uy\") {\n        \
    \    return \"u\"\n        }\n        if word.hasSuffix(\"uur\") {\n         \
    \   return \"u\"\n        }\n        if word.hasSuffix(\"uyu\") {\n          \
    \  return \"u\"\n        }\n        if word.hasSuffix(\"yuu\") {\n           \
    \ return \"u\"\n        }\n        if word.hasSuffix(\"yui\") {\n            return\
    \ \"u\"\n        }\n        if word.hasSuffix(\"uyu\") {\n            return \"\
    u\"\n        }\n        if word.hasSuffix(\"uui\") {\n            return \"u\"\
    \n        }\n        if word.hasSuffix(\"ui\") {\n            return \"u\"\n \
    \       }\n        if word.hasSuffix(\"yui\") {\n            return \"u\"\n  \
    \      }\n        if word.hasSuffix(\"uii\") {\n            return \"u\"\n   \
    \     }\n        if word.hasSuffix(\"yi\") {\n            return \"u\"\n     \
    \   }\n        if word.hasSuffix(\"ii\") {\n            return \"u\"\n       \
    \ }\n        if word.hasSuffix(\"yi\") {\n            return \"u\"\n        }\n\
    \        if word.hasSuffix(\"iii\") {\n            return \"u\"\n        }\n \
    \       if word.hasSuffix(\"iii\") {\n            return \"u\"\n        }\n  \
    \      if word.hasSuffix(\"e\") {\n            return \"u\"\n        }\n     \
    \   if word.hasSuffix(\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpa8n4k1x7.swift:127:27: error: unterminated string literal\n   \
    \     if word.hasSuffix(\"\n                          ^\n/tmp/tmpa8n4k1x7.swift:155:48:\
    \ error: expected '}' at end of brace statement\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")\n                                               ^\n/tmp/tmpa8n4k1x7.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmpa8n4k1x7.swift:127:27:\
    \ error: missing argument for parameter #1 in call\n        if word.hasSuffix(\"\
    \n                          ^\n                          <#String#>\nSwift.String:3:17:\
    \ note: 'hasSuffix' declared here\n    public func hasSuffix(_ suffix: String)\
    \ -> Bool\n                ^\n/tmp/tmpa8n4k1x7.swift:131:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var count = 0\n    for index,\
    \ _ in  word.characters.reverse().enumerated() {\n        var letter = word.characters[index]\n\
    \        if letter == Character(kVowel) {\n            if count <= 0 {\n     \
    \           return \"\"\n            }\n            count += 1\n        } else\
    \ if letter == Character(kConsonant) {\n            if count == 1 {\n        \
    \        return \"\"\n            }\n            count = 0\n        }\n    }\n\
    \    if count == 0 {\n        return \"\"\n    }\n    if count > 2 {\n       \
    \ return \"\"\n    }\n    if count < 2 {\n        return word.characters[word.characters.count\
    \ - 2]\n    }\n    return word.characters[word.characters.count - 3]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpwdzj8htz.swift:21:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in  word.characters.reverse().enumerated() {\n             ^\n\
    /tmp/tmpwdzj8htz.swift:21:14: error: expected Sequence expression for for-each\
    \ loop\n    for index, _ in  word.characters.reverse().enumerated() {\n      \
    \       ^\n/tmp/tmpwdzj8htz.swift:42:31: error: cannot convert return expression\
    \ of type 'Character' to return type 'String'\n        return word.characters[word.characters.count\
    \ - 2]\n               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwdzj8htz.swift:44:27:\
    \ error: cannot convert return expression of type 'Character' to return type 'String'\n\
    \    return word.characters[word.characters.count - 3]\n           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ index = word.startIndex\n    let word = word.lowercased()\n    if word.isEmpty\
    \ {\n        return \"\"\n    }\n    while index != word.endIndex {\n        let\
    \ char = word[index]\n        let nextIndex = index + 1\n        if char.isUppercase\
    \ && nextIndex < word.endIndex && word[nextIndex].isUppercase {\n            index\
    \ = nextIndex\n        } else {\n            break\n        }\n    }\n    return\
    \ word.substringFromIndex(index + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmptjkkvfa4.swift:24:25: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        let nextIndex = index + 1\n       \
    \                 ^\n/tmp/tmptjkkvfa4.swift:31:36: error: cannot convert value\
    \ of type 'String.Index' to expected argument type 'Int'\n    return word.substringFromIndex(index\
    \ + 1)\n                                   ^\n/tmp/tmptjkkvfa4.swift:31:17: error:\
    \ value of type 'String' has no member 'substringFromIndex'\n    return word.substringFromIndex(index\
    \ + 1)\n           ~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\t\n\t\
    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmprxdq_uu0/tmprxdq_uu0.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f73cb4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f739abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f739ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f739aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprxdq_uu0                        0x000055cb70594307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6f73ea0460 __libc_start_main +
    245

    6    tmprxdq_uu0                        0x000055cb70593f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ letters = word.characters\n    var index = letters.count\n    while index >\
    \ 0 {\n        if letters[letters.count - index - 1] == (\"a\"...\"z\").last {\n\
    \            letters.remove(at: letters.count - index)\n            break\n  \
    \      }\n        index -= 1\n    }\n    return String(letters)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgozw5nzv.swift:17:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    var letters = word.characters\n                   \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpgozw5nzv.swift:20:54:\
    \ error: referencing property 'last' on 'ClosedRange' requires that 'Character'\
    \ conform to 'Strideable'\n        if letters[letters.count - index - 1] == (\"\
    a\"...\"z\").last {\n                                                     ^\n\
    Swift.ClosedRange:1:11: note: requirement from conditional conformance of 'ClosedRange<Character>'\
    \ to 'BidirectionalCollection'\nextension ClosedRange : Collection, BidirectionalCollection,\
    \ RandomAccessCollection where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n/tmp/tmpgozw5nzv.swift:21:46: error: cannot convert value of\
    \ type 'Int' to expected argument type 'String.Index'\n            letters.remove(at:\
    \ letters.count - index)\n                                             ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n\n    for index in 0..<word.characters.count {\n        let cs\
    \ = word.characters[index]\n        let start = cs.unicodeScalars.index(of: cs.unicodeScalars.last!)\n\
    \        let end = cs.unicodeScalars.index(of: cs.unicodeScalars.first!)\n   \
    \     if start < end {\n            for vowel in vowels {\n                if\
    \ vowel.start <= start && end <= vowel.end {\n                    if vowel.start\
    \ < index && index < vowel.end {\n                        result = vowel.letter\n\
    \                        break\n                    }\n                }\n   \
    \         }\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpba1sryv0.swift:19:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<word.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpba1sryv0.swift:20:18: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let cs =\
    \ word.characters[index]\n                 ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpba1sryv0.swift:20:23:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ cs = word.characters[index]\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpba1sryv0.swift:21:39: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        let start = cs.unicodeScalars.index(of:\
    \ cs.unicodeScalars.last!)\n                                      ^\n/tmp/tmpba1sryv0.swift:21:39:\
    \ note: use 'firstIndex(of:)' instead\n        let start = cs.unicodeScalars.index(of:\
    \ cs.unicodeScalars.last!)\n                                      ^~~~~\n    \
    \                                  firstIndex\n/tmp/tmpba1sryv0.swift:22:37: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let end =\
    \ cs.unicodeScalars.index(of: cs.unicodeScalars.first!)\n                    \
    \                ^\n/tmp/tmpba1sryv0.swift:22:37: note: use 'firstIndex(of:)'\
    \ instead\n        let end = cs.unicodeScalars.index(of: cs.unicodeScalars.first!)\n\
    \                                    ^~~~~\n                                 \
    \   firstIndex\n/tmp/tmpba1sryv0.swift:23:18: error: binary operator '<' cannot\
    \ be applied to two 'String.UnicodeScalarView.Index?' (aka 'Optional<String.Index>')\
    \ operands\n        if start < end {\n           ~~~~~ ^ ~~~\n/tmp/tmpba1"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ get_closest_vowel_in_string(word, false)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpylj1x4wd.swift:17:9: error: cannot find 'get_closest_vowel_in_string'\
    \ in scope\n        return get_closest_vowel_in_string(word, false)\n        \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    guard word.characters.count > 0 else {\n        return \"\"\n    }\n    \n\
    \    var vowels: [Character] = []\n    \n    for i in word.characters {\n    \
    \    guard !isVowel(i) else {\n            continue\n        }\n        \n   \
    \     let range: Range<Int> = word.startIndex.successor()..<word.endIndex\n  \
    \      for j in range {\n            if isConsonant(j) {\n                vowels.append(j)\n\
    \            }\n        }\n    }\n    \n    if vowels.isEmpty, word.characters.count\
    \ > 1 else {\n        return \"\"\n    }\n    \n    return vowels.first!\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5utcarg_.swift:37:50: error: unexpected 'else' immediately following\
    \ 'if' condition\n    if vowels.isEmpty, word.characters.count > 1 else {\n  \
    \                                               ^\n/tmp/tmp5utcarg_.swift:37:50:\
    \ note: remove 'else' to execute the braced block of statements when the condition\
    \ is true\n    if vowels.isEmpty, word.characters.count > 1 else {\n         \
    \                                        ^~~~~\n                             \
    \                    \n/tmp/tmp5utcarg_.swift:18:16: error: 'characters' is unavailable:\
    \ Please use String directly\n    guard word.characters.count > 0 else {\n   \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp5utcarg_.swift:24:19: error: 'characters' is unavailable: Please use String\
    \ directly\n    for i in word.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp5utcarg_.swift:25:16: error: cannot find\
    \ 'isVowel' in scope\n        guard !isVowel(i) else {\n               ^~~~~~~\n\
    /tmp/tmp5utcarg_.swift:29:49: error: value of type 'String.Index' has no member\
    \ 'successor'\n        let range: Range<Int> = word.startIndex.successor()..<word.endIndex\n\
    \                                ~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp5utcarg_.swift:29:68:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let range: Range<Int> = word.startIndex.successor()..<word.endIndex\n\
    \                                                                   ^\n/tmp/tmp5utcarg_.swift:31:16:\
    \ error: cannot find 'isConsonant' in scope\n            if isConsonant(j) {\n\
    \               ^~~~~~~~~~~\n/tmp/tmp5utcarg_.swift:32:31: error: cannot convert\
    \ value of type 'Range<Int>.Element' (aka 'Int') to expected argument type 'Character'\n\
    \                vowels.append(j)\n                              ^\n/tmp/tmp5utcarg_.swift:37:29:\
    \ error: 'characters' is unav"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels else {\n        return \"\"\n    }\n    let vowelIndex =\
    \ word.index(of: vowels.first!)\n    let vowelIndexEnd = word.index(of: vowels.last!)\n\
    \    guard vowelIndex != nil && vowelIndexEnd != nil else {\n        return \"\
    \"\n    }\n    let wordAsArray = word.characters\n    let firstConsonantIndex\
    \ = wordAsArray.index(of: \"a\".characters.first!)!\n    let secondConsonantIndex\
    \ = wordAsArray.index(of: \"b\".characters.first!)!\n    let thirdConsonantIndex\
    \ = wordAsArray.index(of: \"c\".characters.first!)!\n    let forthConsonantIndex\
    \ = wordAsArray.index(of: \"d\".characters.first!)!\n    let fifthConsonantIndex\
    \ = wordAsArray.index(of: \"e\".characters.first!)!\n    let sixthConsonantIndex\
    \ = wordAsArray.index(of: \"f\".characters.first!)!\n    let seventhConsonantIndex\
    \ = wordAsArray.index(of: \"g\".characters.first!)!\n    let eighthConsonantIndex\
    \ = wordAsArray.index(of: \"h\".characters.first!)!\n    let ninthConsonantIndex\
    \ = wordAsArray.index(of: \"i\".characters.first!)!\n    let tenthConsonantIndex\
    \ = wordAsArray.index(of: \"j\".characters.first!)!\n    let eleventhConsonantIndex\
    \ = wordAsArray.index(of: \"k\".characters.first!)!\n    let twelfthConsonantIndex\
    \ = wordAsArray.index(of: \"l\".characters.first!)!\n    let thirteenthConsonantIndex\
    \ = wordAsArray.index(of: \"m\".characters.first!)!\n    let fourteenthConsonantIndex\
    \ = wordAsArray.index(of: \"n\".characters.first!)!\n    let fifteenthConsonantIndex\
    \ = wordAsArray.index(of: \"o\".characters.first!)!\n    let sixteenthConsonantIndex\
    \ = wordAsArray.index(of: \"p\".characters.first!)!\n    let seventeenthConsonantIndex\
    \ = wordAsArray.index(of: \"q\".characters.first!)!\n    let eighteenthConsonantIndex\
    \ = wordAsArray.index(of: \"r\".characters.first!)!\n    let nineteenthConsonantIndex\
    \ = wordAsArray.index(of: \"s\".characters.first!)!\n    let twentiethConsonantIndex\
    \ = wordAsArray.index(of: \"t\".characters.first!)!\n    let twentyFirstCon\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp14y0pqxy.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels else {\n                       ^~~~~~\n/tmp/tmp14y0pqxy.swift:25:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    let wordAsArray\
    \ = word.characters\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp14y0pqxy.swift:26:43: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n    let firstConsonantIndex = wordAsArray.index(of:\
    \ \"a\".characters.first!)!\n                                          ^\n/tmp/tmp14y0pqxy.swift:26:43:\
    \ note: use 'firstIndex(of:)' instead\n    let firstConsonantIndex = wordAsArray.index(of:\
    \ \"a\".characters.first!)!\n                                          ^~~~~\n\
    \                                          firstIndex\n/tmp/tmp14y0pqxy.swift:26:57:\
    \ error: 'characters' is unavailable: Please use String directly\n    let firstConsonantIndex\
    \ = wordAsArray.index(of: \"a\".characters.first!)!\n                        \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp14y0pqxy.swift:27:44: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    let secondConsonantIndex = wordAsArray.index(of:\
    \ \"b\".characters.first!)!\n                                           ^\n/tmp/tmp14y0pqxy.swift:27:44:\
    \ note: use 'firstIndex(of:)' instead\n    let secondConsonantIndex = wordAsArray.index(of:\
    \ \"b\".characters.first!)!\n                                           ^~~~~\n\
    \                                           firstIndex\n/tmp/tmp14y0pqxy.swift:27:58:\
    \ error: 'characters' is unavailable: Please use String directly\n    let secondConsonantIndex\
    \ = wordAsArray.index(of: \"b\".characters.first!)!\n                        \
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: "
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Your code goes here\n    var vowels = \"aeiouAEIOU\"\n    var vowels_count =\
    \ 0\n    var res = \"\"\n    var s = word\n    for char in s {\n        vowels_count\
    \ += 1\n        if char == \"a\" {\n            if vowels_count > 1 {\n      \
    \          vowels_count -= 1\n            }\n        } else {\n            if\
    \ vowels_count > 2 {\n                vowels_count -= 2\n            }\n     \
    \   }\n        res += char\n        if vowels_count == 0 {\n            break\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpcbsvzzl6.swift:33:16: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        res += char\n               ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    let len = word.characters.count\n\
    \    if len <= 0 {\n        return \"\"\n    }\n    var vowelIndexes: [Int] =\
    \ []\n    let vowels: Set<Character> = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n \
    \   for i in 0..<len {\n        let c = word.characters.last!\n        if vowels.contains(c)\
    \ {\n            vowelIndexes.append(i)\n        }\n    }\n    if vowelIndexes.count\
    \ == 0 {\n        return \"\"\n    }\n    let vowelIndex = vowelIndexes.first!\n\
    \    return String(word.characters.dropFirst(vowelIndex))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpm_hbe14g.swift:20:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let len = word.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpm_hbe14g.swift:27:22:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ c = word.characters.last!\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpm_hbe14g.swift:36:24: error: 'characters'\
    \ is unavailable: Please use String directly\n    return String(word.characters.dropFirst(vowelIndex))\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmphnodppqg.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, true)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.hasPrefix(\"y\") {\n        return \"u\"\n    }\n    if word.hasPrefix(\"\
    a\") {\n        return \"a\"\n    }\n    if word.hasPrefix(\"u\") {\n        return\
    \ \"u\"\n    }\n    if word.hasPrefix(\"o\") {\n        return \"o\"\n    }\n\
    \    if word.hasPrefix(\"i\") {\n        return \"i\"\n    }\n    if word.hasPrefix(\"\
    a\") {\n        return \"a\"\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpujoxvaop/tmpujoxvaop.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d3ec78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d3e96fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d3e96f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d3e96e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujoxvaop                        0x000055cce329f447 <unavailable> + 5191

    5    libc.so.6                          0x00002b4d3ee64460 __libc_start_main +
    245

    6    tmpujoxvaop                        0x000055cce329ef99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660030475
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.hasPrefix(\"a\") { \n        if word.hasSuffix(\"e\") {\n            return\
    \ \"\"\n        }\n    }\n    if word.hasPrefix(\"e\") {\n        if word.hasSuffix(\"\
    i\") {\n            return \"\"\n        }\n    }\n    if word.hasPrefix(\"o\"\
    ) {\n        if word.hasSuffix(\"u\") {\n            return \"\"\n        }\n\
    \    }\n    if word.hasPrefix(\"u\") {\n        if word.hasSuffix(\"o\") {\n \
    \           return \"\"\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpv02mmj6o/tmpv02mmj6o.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb9c172c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb9be69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb9be69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb9be687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv02mmj6o                        0x00005642066fd3b7 <unavailable> + 5047

    5    libc.so.6                          0x00002acb9c35e460 __libc_start_main +
    245

    6    tmpv02mmj6o                        0x00005642066fcff9 <unavailable> + 4089

    '
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel = \"aeiouAEIOU\"\n    var index = word.count - 1\n    var preIndex = 0\n\
    \    var endIndex = 0\n    var result: String = \"\"\n    var preVal = String()\n\
    \    \n    for char : Character  in word  {\n        if vowel.contains(String(char))\
    \ {\n            if char != vowel.first {\n                if preIndex != index\
    \ {\n                    preVal = String(word.characters[preIndex])\n        \
    \        }\n                endIndex = 0\n                for index : Int in 0...word.count\
    \ {\n                    if index == preIndex {\n                        continue\n\
    \                    }\n                    endIndex = index\n               \
    \ }\n                if String(word.characters[endIndex]).lowercased() == String(char).lowercased()\
    \ {\n                    if endIndex - preIndex == 2 {\n                     \
    \   result += String(word.characters[preIndex])\n                    }\n     \
    \           }\n            }\n        }\n        preIndex = index\n        index\
    \ = index - 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp95ipea8n.swift:28:37: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n                \
    \    preVal = String(word.characters[preIndex])\n                            \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp95ipea8n.swift:28:42: error: 'characters' is\
    \ unavailable: Please use String directly\n                    preVal = String(word.characters[preIndex])\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp95ipea8n.swift:37:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if String(word.characters[endIndex]).lowercased() == String(char).lowercased()\
    \ {\n                          ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp95ipea8n.swift:37:32: error:\
    \ 'characters' is unavailable: Please use String directly\n                if\
    \ String(word.characters[endIndex]).lowercased() == String(char).lowercased()\
    \ {\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp95ipea8n.swift:39:42: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \               result += String(word.characters[preIndex])\n                \
    \                         ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp95ipea8n.swift:39:47: error:\
    \ 'characters' is unavailable: Please use String directly\n    "
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var consonants = Array(Array(word.unicodeScalars).filter{ $0.isControl !=\
    \ nil })\n    var vowels = Array(Array(word.unicodeScalars).filter{ $0.isVowel\
    \ != nil })\n    \n    consonants = consonants.sorted{ $0.value > $1.value }\n\
    \    vowels = vowels.sorted{ $0.value > $1.value }\n    \n    if consonants.last!.value\
    \ > vowels.first!.value {\n        var vowelIndex = vowels.first!.value - consonants.last!.value\n\
    \        return String(word.unicodeScalars[vowelIndex...])\n    } else {\n   \
    \     return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdvhxpvpb.swift:18:34: error: missing argument label 'from:' in\
    \ call\n    var consonants = Array(Array(word.unicodeScalars).filter{ $0.isControl\
    \ != nil })\n                                 ^\n                            \
    \     from: \n/tmp/tmpdvhxpvpb.swift:18:61: error: unable to infer type of a closure\
    \ parameter '$0' in the current context\n    var consonants = Array(Array(word.unicodeScalars).filter{\
    \ $0.isControl != nil })\n                                                   \
    \         ^\n/tmp/tmpdvhxpvpb.swift:19:30: error: missing argument label 'from:'\
    \ in call\n    var vowels = Array(Array(word.unicodeScalars).filter{ $0.isVowel\
    \ != nil })\n                             ^\n                             from:\
    \ \n/tmp/tmpdvhxpvpb.swift:19:57: error: unable to infer type of a closure parameter\
    \ '$0' in the current context\n    var vowels = Array(Array(word.unicodeScalars).filter{\
    \ $0.isVowel != nil })\n                                                     \
    \   ^\n/tmp/tmpdvhxpvpb.swift:26:42: error: no exact matches in call to subscript\
    \ \n        return String(word.unicodeScalars[vowelIndex...])\n              \
    \                           ^\n/tmp/tmpdvhxpvpb.swift:26:42: note: found candidate\
    \ with type '(String.UnicodeScalarView.Index) -> Unicode.Scalar' (aka '(String.Index)\
    \ -> Unicode.Scalar')\n        return String(word.unicodeScalars[vowelIndex...])\n\
    \                                         ^\n/tmp/tmpdvhxpvpb.swift:26:42: note:\
    \ found candidate with type '(Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence'\
    \ (aka '(Range<String.Index>) -> Substring.UnicodeScalarView')\n        return\
    \ String(word.unicodeScalars[vowelIndex...])\n                               \
    \          ^\n/tmp/tmpdvhxpvpb.swift:26:42: note: found candidate with type '(())\
    \ -> String.UnicodeScalarView.SubSequence' (aka '(()) -> Substring.UnicodeScalarView')\n\
    \        return String(word.unicodeScalars[vowelIndex...])\n                 \
    \                        ^\n/tmp/tmpdvhxpvpb.swift:26:42: note: found candidate\
    \ with type '((UnboundedRange_) -> ()) -> St"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  \n  //\
    \ Initialize variables\n  var vowelsCount = \"\"\n  var consonantsCount = \"\"\
    \n  \n  // Initialize vowels\n  var vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ]\n  \n  // Initialize consonants\n  var consonants = [\"b\", \"c\", \"d\", \"\
    f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"v\", \"w\", \"x\", \"z\"]\n  \n  // Get vowel count\n  for char\
    \ in word {\n    if vowels.contains(char) {\n      vowelsCount += char\n    }\n\
    \  }\n  \n  // Get consonant count\n  for char in word {\n    if consonants.contains(char)\
    \ {\n      consonantsCount += char\n    }\n  }\n  \n  // Get vowels\n  for char\
    \ in vowels {\n    if vowelsCount == consonantsCount {\n      return char\n  \
    \  }\n  }\n  \n  // Return empty string if there are no vowel exist\n  return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp0f6ts8gi.swift:30:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n    if vowels.contains(char) {\n       \
    \                ^\n/tmp/tmp0f6ts8gi.swift:31:22: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n      vowelsCount +=\
    \ char\n                     ^\n/tmp/tmp0f6ts8gi.swift:37:28: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n    if consonants.contains(char)\
    \ {\n                           ^\n/tmp/tmp0f6ts8gi.swift:38:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \ consonantsCount += char\n                         ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for i in word.unicodeScalars.reversed()\
    \ {\n        for j in vowels.reversed() {\n            if i == j {\n         \
    \       return String(i)\n            }\n        }\n    }\n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqhb5m0rc.swift:20:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Unicode.Scalar' and 'Character'\n            if i == j\
    \ {\n               ~ ^  ~\n/tmp/tmpqhb5m0rc.swift:20:18: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (Unicode.Scalar, Unicode.Scalar)\n            if i == j {\n                \
    \ ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar vowels\
    \ = \"aeiou\"\n\tvar upper = word.uppercaseString\n\tvar length = upper.characters.count\n\
    \tvar index = upper.characters.reverse().index(after: upper.startIndex, offsetBy:\
    \ length)\n\t\n\t// Check if the given word has vowel on the right side or left\
    \ side.\n\tif upper[upper.index(upper.startIndex, offsetBy: index)...upper.index(upper.index(upper.startIndex,\
    \ offsetBy: index))] == vowels.lowercased() {\n\t\treturn vowels.lowercased()\n\
    \t} else {\n\t\treturn \"\"\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdwaqtzm.swift:18:19: error: value of type 'String' has no member\
    \ 'uppercaseString'\n        var upper = word.uppercaseString\n              \
    \      ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ str = \"\"\n    if word.hasPrefix(\"a\") {\n        return \"\"\n    }\n   \
    \ if word.hasPrefix(\"e\") {\n        return \"\"\n    }\n    if word.hasPrefix(\"\
    i\") {\n        return \"\"\n    }\n    if word.hasPrefix(\"o\") {\n        return\
    \ \"\"\n    }\n    if word.hasPrefix(\"u\") {\n        return \"\"\n    }\n  \
    \  if word.hasPrefix(\"y\") {\n        return \"\"\n    }\n    if word.hasPrefix(\"\
    a\") {\n        return \"\"\n    }\n    if word.hasPrefix(\"e\") {\n        return\
    \ \"\"\n    }\n    if word.hasPrefix(\"i\") {\n        return \"\"\n    }\n  \
    \  if word.hasPrefix(\"o\") {\n        return \"\"\n    }\n    if word.hasPrefix(\"\
    u\") {\n        return \"\"\n    }\n    if word.hasPrefix(\"y\") {\n        return\
    \ \"\"\n    }\n\n    if word.hasSuffix(\"i\") {\n        let i = word.index(word.startIndex,\
    \ offsetBy: 1)\n        return word.substring(to: i).lowercased\n    } else if\
    \ word.hasSuffix(\"o\") {\n        let o = word.index(word.startIndex, offsetBy:\
    \ 2)\n        return word.substring(to: o).lowercased\n    } else if word.hasSuffix(\"\
    a\") {\n        let a = word.index(word.startIndex, offsetBy: 1)\n        return\
    \ word.substring(to: a).lowercased\n    } else if word.hasSuffix(\"e\") {\n  \
    \      let e = word.index(word.startIndex, offsetBy: 2)\n        return word.substring(to:\
    \ e).lowercased\n    } else if word.hasSuffix(\"u\") {\n        let u = word.index(word.startIndex,\
    \ offsetBy: 1)\n        return word.substring(to: u).lowercased\n    } else if\
    \ word.hasSuffix(\"y\") {\n        let y = word.index(word.startIndex, offsetBy:\
    \ 1)\n        return word.substring(to: y).lowercased\n    }\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpij_qwu63.swift:57:21: error: value of type 'String' has no member\
    \ 'substring'\n        return word.substring(to: i).lowercased\n             \
    \  ~~~~ ^~~~~~~~~\n/tmp/tmpij_qwu63.swift:60:21: error: value of type 'String'\
    \ has no member 'substring'\n        return word.substring(to: o).lowercased\n\
    \               ~~~~ ^~~~~~~~~\n/tmp/tmpij_qwu63.swift:63:21: error: value of\
    \ type 'String' has no member 'substring'\n        return word.substring(to: a).lowercased\n\
    \               ~~~~ ^~~~~~~~~\n/tmp/tmpij_qwu63.swift:66:21: error: value of\
    \ type 'String' has no member 'substring'\n        return word.substring(to: e).lowercased\n\
    \               ~~~~ ^~~~~~~~~\n/tmp/tmpij_qwu63.swift:69:21: error: value of\
    \ type 'String' has no member 'substring'\n        return word.substring(to: u).lowercased\n\
    \               ~~~~ ^~~~~~~~~\n/tmp/tmpij_qwu63.swift:72:21: error: value of\
    \ type 'String' has no member 'substring'\n        return word.substring(to: y).lowercased\n\
    \               ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar vowels\
    \ = \"aeiouAEIOU\"\n\t\n\tvar res : String = \"\"\n\t\n\tif word.isEmpty {\n\t\
    \treturn \"\"\n\t}\n\t\n\tlet lowWord = word.lowercased()\n\t\n\tfor i in 0..<lowWord.count\
    \ {\n\t\t\n\t\tlet lowSubword = lowWord[i ..< word.count - 1]\n\t\tlet lowSubwordLower\
    \ = lowSubword.lowercased()\n\t\t\n\t\tif vowels.contains(lowSubwordLower) {\n\
    \t\t\tif res == \"\" {\n\t\t\t\tres = lowSubwordLower\n\t\t\t} else {\n\t\t\t\t\
    res = \"\\(res) \\(lowSubwordLower)\"\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpxwe20gkr.swift:29:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \                let lowSubword = lowWord[i ..< word.count - 1]\n            \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpxwe20gkr.swift:17:6: warning: variable 'vowels' was never mutated; consider\
    \ changing to 'let' constant\n        var vowels = \"aeiouAEIOU\"\n        ~~~\
    \ ^\n        let\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ let vowels = vowels, vowels.contains(word[word.startIndex..<word.index(before:\
    \ word.index(before: word.endIndex))]) {\n        return word[word.index(before:\
    \ word.index(before: word.endIndex))..<word.endIndex]\n    }\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpl56ismde.swift:17:21: error: cannot find 'vowels' in scope\n  \
    \  if let vowels = vowels, vowels.contains(word[word.startIndex..<word.index(before:\
    \ word.index(before: word.endIndex))]) {\n                    ^~~~~~\n/tmp/tmpl56ismde.swift:18:20:\
    \ error: cannot convert return expression of type 'Substring' to return type 'String'\n\
    \        return word[word.index(before: word.index(before: word.endIndex))..<word.endIndex]\n\
    \               ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \               String(                                                      \
    \              )\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ i = 0\n    var minV = 0\n    for char in word {\n        if i == 0 {\n     \
    \       if char == \"a\" || char == \"A\" {\n                minV = char\n   \
    \             i = 0\n            } else if char == \"e\" || char == \"E\" {\n\
    \                minV = char\n                i = 2\n            } else if char\
    \ == \"i\" || char == \"I\" {\n                minV = char\n                i\
    \ = 2\n            } else if char == \"o\" || char == \"O\" {\n              \
    \  minV = char\n                i = 2\n            } else if char == \"u\" ||\
    \ char == \"U\" {\n                minV = char\n                i = 2\n      \
    \      } else if char == \"y\" || char == \"Y\" {\n                minV = char\n\
    \                i = 2\n            } else {\n                minV = \"\"\n  \
    \          }\n        } else if i == 2 {\n            if char == \"a\" || char\
    \ == \"A\" {\n                if char == minV {\n                    minV = \"\
    \"\n                }\n            } else if char == \"e\" || char == \"E\" {\n\
    \                if char == minV {\n                    minV = \"\"\n        \
    \        }\n            } else if char == \"i\" || char == \"I\" {\n         \
    \       if char == minV {\n                    minV = \"\"\n                }\n\
    \            } else if char == \"o\" || char == \"O\" {\n                if char\
    \ == minV {\n                    minV = \"\"\n                }\n            }\
    \ else if char == \"u\" || char == \"U\" {\n                if char == minV {\n\
    \                    minV = \"\"\n                }\n            } else if char\
    \ == \"y\" || char == \"Y\" {\n                if char == minV {\n           \
    \         minV = \"\"\n                }\n            }\n        } else {\n  \
    \          if char == minV {\n                minV = \"\"\n            }\n   \
    \     }\n        i++\n    }\n    return minV\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmgxs5dq_.swift:22:24: error: cannot assign value of type 'Character'\
    \ to type 'Int'\n                minV = char\n                       ^~~~\n/tmp/tmpmgxs5dq_.swift:25:24:\
    \ error: cannot assign value of type 'Character' to type 'Int'\n             \
    \   minV = char\n                       ^~~~\n/tmp/tmpmgxs5dq_.swift:28:24: error:\
    \ cannot assign value of type 'Character' to type 'Int'\n                minV\
    \ = char\n                       ^~~~\n/tmp/tmpmgxs5dq_.swift:31:24: error: cannot\
    \ assign value of type 'Character' to type 'Int'\n                minV = char\n\
    \                       ^~~~\n/tmp/tmpmgxs5dq_.swift:34:24: error: cannot assign\
    \ value of type 'Character' to type 'Int'\n                minV = char\n     \
    \                  ^~~~\n/tmp/tmpmgxs5dq_.swift:37:24: error: cannot assign value\
    \ of type 'Character' to type 'Int'\n                minV = char\n           \
    \            ^~~~\n/tmp/tmpmgxs5dq_.swift:40:24: error: cannot assign value of\
    \ type 'String' to type 'Int'\n                minV = \"\"\n                 \
    \      ^~\n/tmp/tmpmgxs5dq_.swift:44:25: error: binary operator '==' cannot be\
    \ applied to operands of type 'Character' and 'Int'\n                if char ==\
    \ minV {\n                   ~~~~ ^  ~~~~\n/tmp/tmpmgxs5dq_.swift:44:25: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (Int, Int)\n                if char == minV {\n                \
    \        ^\n/tmp/tmpmgxs5dq_.swift:45:28: error: cannot assign value of type 'String'\
    \ to type 'Int'\n                    minV = \"\"\n                           ^~\n\
    /tmp/tmpmgxs5dq_.swift:48:25: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'Int'\n                if char == minV {\n\
    \                   ~~~~ ^  ~~~~\n/tmp/tmpmgxs5dq_.swift:48:25: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (Int, Int)\n                if char == minV {\n                        ^\n/tmp/tmpmgxs5dq_.swift:49:28:\
    \ error: cannot assign value of type 'String' to type 'Int'\n                "
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ alphabet = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let vowelIndex = alphabet.index(where:\
    \ { $0.isEqual(to: word[word.index(before: word.index(before: word.index(before:\
    \ word.endIndex))) ?? word.endIndex]) })\n    let consonantIndex = alphabet.index(where:\
    \ { $0.isEqual(to: word[word.index(before: word.endIndex)]) })\n    if vowelIndex\
    \ == nil && consonantIndex == nil {\n        return \"\"\n    }\n    if vowelIndex\
    \ == nil {\n        return alphabet[consonantIndex! - word.endIndex]\n    }\n\
    \    if consonantIndex == nil {\n        return alphabet[vowelIndex! - word.endIndex]\n\
    \    }\n    let vowelOffset = vowelIndex! - word.endIndex\n    let consonantOffset\
    \ = consonantIndex! - word.endIndex\n    if vowelOffset > consonantOffset {\n\
    \        return alphabet[vowelOffset - word.endIndex]\n    } else {\n        return\
    \ alphabet[consonantOffset - word.endIndex]\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmccpzrti.swift:18:49: error: value of type 'String' has no member\
    \ 'isEqual'\n    let vowelIndex = alphabet.index(where: { $0.isEqual(to: word[word.index(before:\
    \ word.index(before: word.index(before: word.endIndex))) ?? word.endIndex]) })\n\
    \                                             ~~ ^~~~~~~\n/tmp/tmpmccpzrti.swift:19:53:\
    \ error: value of type 'String' has no member 'isEqual'\n    let consonantIndex\
    \ = alphabet.index(where: { $0.isEqual(to: word[word.index(before: word.endIndex)])\
    \ })\n                                                 ~~ ^~~~~~~\n/tmp/tmpmccpzrti.swift:24:48:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        return alphabet[consonantIndex! - word.endIndex]\n          \
    \                                     ^\n/tmp/tmpmccpzrti.swift:27:44: error:\
    \ cannot convert value of type 'String.Index' to expected argument type 'Int'\n\
    \        return alphabet[vowelIndex! - word.endIndex]\n                      \
    \                     ^\n/tmp/tmpmccpzrti.swift:32:24: error: cannot convert return\
    \ expression of type 'ArraySlice<String>' to return type 'String'\n        return\
    \ alphabet[vowelOffset - word.endIndex]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmccpzrti.swift:34:24: error: cannot convert return expression of type\
    \ 'ArraySlice<String>' to return type 'String'\n        return alphabet[consonantOffset\
    \ - word.endIndex]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ word.hasPrefix(\"a\") == word.hasSuffix(\"a\") else { return \"\" }\n    var\
    \ vowels = Set<Character>()\n    for i in word.unicodeScalars.reversed().flatMap\
    \ { $0 as? Character }  {\n        if vowels.contains(i) {\n            vowels.remove(i)\n\
    \        }\n        else {\n            vowels.insert(i)\n        }\n    }\n \
    \   guard vowels.count >= 2 else { return \"\" }\n    return vowels.first!\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkzmrldyl.swift:19:58: warning: cast from 'ReversedCollection<String.UnicodeScalarView>.Element'\
    \ (aka 'Unicode.Scalar') to unrelated type 'Character' always fails\n    for i\
    \ in word.unicodeScalars.reversed().flatMap { $0 as? Character }  {\n        \
    \                                              ~~ ^   ~~~~~~~~~\n/tmp/tmpkzmrldyl.swift:19:45:\
    \ warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where\
    \ closure returns an optional value\n    for i in word.unicodeScalars.reversed().flatMap\
    \ { $0 as? Character }  {\n                                            ^\n/tmp/tmpkzmrldyl.swift:19:45:\
    \ note: use 'compactMap(_:)' instead\n    for i in word.unicodeScalars.reversed().flatMap\
    \ { $0 as? Character }  {\n                                            ^~~~~~~\n\
    \                                            compactMap\n/tmp/tmpkzmrldyl.swift:19:53:\
    \ warning: trailing closure in this context is confusable with the body of the\
    \ statement; pass as a parenthesized argument to silence this warning\n    for\
    \ i in word.unicodeScalars.reversed().flatMap { $0 as? Character }  {\n      \
    \                                             ~^\n                           \
    \                        (                    )\n/tmp/tmpkzmrldyl.swift:28:24:\
    \ error: cannot convert return expression of type 'Character' to return type 'String'\n\
    \    return vowels.first!\n           ~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find_closest_vowel(word: word, candidates: candidates2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpajrcdvmx.swift:17:12: error: cannot find 'find_closest_vowel' in\
    \ scope\n    return find_closest_vowel(word: word, candidates: candidates2)\n\
    \           ^~~~~~~~~~~~~~~~~~\n/tmp/tmpajrcdvmx.swift:17:55: error: cannot find\
    \ 'candidates2' in scope\n    return find_closest_vowel(word: word, candidates:\
    \ candidates2)\n                                                      ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ let index = word.findIndex(of: \" \") {\n        return word.substring(to: index)\n\
    \    } else {\n        return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_u49cxez.swift:17:25: error: value of type 'String' has no member\
    \ 'findIndex'\n    if let index = word.findIndex(of: \" \") {\n              \
    \     ~~~~ ^~~~~~~~~\n/tmp/tmp_u49cxez.swift:18:21: error: value of type 'String'\
    \ has no member 'substring'\n        return word.substring(to: index)\n      \
    \         ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n   var\
    \ chars = [Character](word);\n   var index = 0;\n   \n   for index in 0..<chars.count\
    \ {\n      if chars[index] == Character(\"a\") || chars[index] == Character(\"\
    e\") || chars[index] == Character(\"i\") || chars[index] == Character(\"o\") ||\
    \ chars[index] == Character(\"u\") {\n         break;\n      }\n   }\n   return\
    \ String(chars[chars.count - 1 - index]);\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp0osowy82/tmp0osowy82.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28c23d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28c20ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28c20cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28c20cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0osowy82                        0x0000561f274967d7 <unavailable> + 6103

    5    libc.so.6                          0x00002b28c25c1460 __libc_start_main +
    245

    6    tmp0osowy82                        0x0000561f27496419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ word.hasSuffix(\"E\") else {\n        return \"\"\n    }\n    \n    let wordWithoutESuffix\
    \ = word.substringToIndex(word.startIndex.successor())\n    \n    return wordWithoutESuffix.hasPrefix(\"\
    a\") ? \"a\" : wordWithoutESuffix.hasPrefix(\"e\") ? \"e\" : wordWithoutESuffix.hasPrefix(\"\
    i\") ? \"i\" : wordWithoutESuffix.hasPrefix(\"o\") ? \"o\" : wordWithoutESuffix.hasPrefix(\"\
    u\") ? \"u\" : \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp50n251fp.swift:21:35: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    let wordWithoutESuffix = word.substringToIndex(word.startIndex.successor())\n\
    \                             ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp50n251fp.swift:21:68:\
    \ error: value of type 'String.Index' has no member 'successor'\n    let wordWithoutESuffix\
    \ = word.substringToIndex(word.startIndex.successor())\n                     \
    \                              ~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowelSet = Set<String>([\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"])\n    \n \
    \   var lastLetter = word.endIndex\n    var newWord = String()\n    for i in 1..<word.count\
    \ {\n        let currentLetter = String(word.characters[word.startIndex.advancedBy(i-1)])\n\
    \        let currentPosition = vowelSet.distance(from: vowelSet.first!, to: currentLetter)\n\
    \        \n        if currentPosition < lastLetter {\n            newWord += String(word.characters[word.startIndex.advancedBy(i-1)])\n\
    \            lastLetter = i\n        }\n    }\n    return newWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqsc77prb.swift:22:68: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n        let currentLetter = String(word.characters[word.startIndex.advancedBy(i-1)])\n\
    \                                                   ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpqsc77prb.swift:23:69: error: cannot convert value of type 'String' to\
    \ expected argument type 'Set<String>.Index'\n        let currentPosition = vowelSet.distance(from:\
    \ vowelSet.first!, to: currentLetter)\n                                      \
    \                              ^\n/tmp/tmpqsc77prb.swift:26:63: error: value of\
    \ type 'String.Index' has no member 'advancedBy'\n            newWord += String(word.characters[word.startIndex.advancedBy(i-1)])\n\
    \                                              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqsc77prb.swift:27:26:\
    \ error: cannot assign value of type 'Int' to type 'String.Index'\n          \
    \  lastLetter = i\n                         ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    for i in 0..<word.characters.count-1 {\n        var index\
    \ = 0\n        var consonantIndex = 0\n        if word.characters.count > 0 {\n\
    \            var hasVowel = false\n            let firstChar = String(word.characters.dropLast())\n\
    \            for (index, char) in word.characters.enumerated() {\n           \
    \     let char = String(char)\n                if char == firstChar[index] {\n\
    \                    hasVowel = true\n                }\n            }\n     \
    \   }\n        if hasVowel {\n            if !isVowel(String(word.characters.dropFirst().dropFirst()))\
    \ {\n                continue\n            } else {\n                consonantIndex\
    \ = 1\n            }\n        }\n        let index = word.index(word.startIndex,\
    \ offsetBy: consonantIndex)\n        let char = String(word.characters.dropFirst())[index]\n\
    \        if isVowel(char) {\n            continue\n        } else {\n        \
    \    result += char\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpz906ia70.swift:18:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<word.characters.count-1 {\n          \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpz906ia70.swift:21:17: error: 'characters' is unavailable: Please use String\
    \ directly\n        if word.characters.count > 0 {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpz906ia70.swift:23:41:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ let firstChar = String(word.characters.dropLast())\n                       \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz906ia70.swift:24:39: error: 'characters' is unavailable: Please\
    \ use String directly\n            for (index, char) in word.characters.enumerated()\
    \ {\n                                      ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpz906ia70.swift:26:37: error: no exact matches\
    \ in call to subscript \n                if char == firstChar[index] {\n     \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpz906ia70.swift:31:12:\
    \ error: cannot find 'hasVowel' in scope\n        if hasVowel {\n           ^~~~~~~~\n\
    /tmp/tmpz906ia70.swift:32:17: error: cannot find 'isVowel' in scope\n        \
    \    if !isVowel(String(word.chara"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ 1. Split word\n    let leftConsonants = word.characters.filter({$0 < 'z'} ||\
    \ {$0 >= 'A' && $0 <= 'Z'} || {$0 >= 'a' && $0 <= 'z'})\n    let rightConsonants\
    \ = word.characters.filter({$0 > 'z'} || {$0 >= 'A' && $0 <= 'Z'} || {$0 >= 'a'\
    \ && $0 <= 'z'})\n    \n    // 2. Get vowel\n    let vowels = Set(leftConsonants\
    \ + rightConsonants).subtracting([\"e\", \"i\", \"o\", \"u\"])\n    let minDistance\
    \ = word.characters.count - 1\n    let minVowel = \"\"\n    var minChar = \"\"\
    \n    \n    vowels.forEach { char in\n        // 3. Compare left and right consonants\n\
    \        if leftConsonants.contains(char) {\n            if let index = leftConsonants.index(of:\
    \ char) {\n                if index != word.characters.count - 1 {\n         \
    \           let distance = leftConsonants[index] - char\n                    if\
    \ distance < minDistance {\n                        minDistance = distance\n \
    \                       minVowel = char\n                        minChar = index\n\
    \                    }\n                }\n            }\n        }\n        \n\
    \        if rightConsonants.contains(char) {\n            if let index = rightConsonants.index(of:\
    \ char) {\n                if index != word.characters.count - 1 {\n         \
    \           let distance = rightConsonants[index] - char\n                   \
    \ if distance < minDistance {\n                        minDistance = distance\n\
    \                        minVowel = char\n                        minChar = index\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    return minVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpr7yc0k_8.swift:18:55: error: single-quoted string literal found,\
    \ use '\"'\n    let leftConsonants = word.characters.filter({$0 < 'z'} || {$0\
    \ >= 'A' && $0 <= 'Z'} || {$0 >= 'a' && $0 <= 'z'})\n                        \
    \                              ^~~\n                                         \
    \             \"z\"\n/tmp/tmpr7yc0k_8.swift:18:70: error: single-quoted string\
    \ literal found, use '\"'\n    let leftConsonants = word.characters.filter({$0\
    \ < 'z'} || {$0 >= 'A' && $0 <= 'Z'} || {$0 >= 'a' && $0 <= 'z'})\n          \
    \                                                           ^~~\n            \
    \                                                         \"A\"\n/tmp/tmpr7yc0k_8.swift:18:83:\
    \ error: single-quoted string literal found, use '\"'\n    let leftConsonants\
    \ = word.characters.filter({$0 < 'z'} || {$0 >= 'A' && $0 <= 'Z'} || {$0 >= 'a'\
    \ && $0 <= 'z'})\n                                                           \
    \                       ^~~\n                                                \
    \                                  \"Z\"\n/tmp/tmpr7yc0k_8.swift:18:98: error:\
    \ single-quoted string literal found, use '\"'\n    let leftConsonants = word.characters.filter({$0\
    \ < 'z'} || {$0 >= 'A' && $0 <= 'Z'} || {$0 >= 'a' && $0 <= 'z'})\n          \
    \                                                                            \
    \           ^~~\n                                                            \
    \                                     \"a\"\n/tmp/tmpr7yc0k_8.swift:18:111: error:\
    \ single-quoted string literal found, use '\"'\n    let leftConsonants = word.characters.filter({$0\
    \ < 'z'} || {$0 >= 'A' && $0 <= 'Z'} || {$0 >= 'a' && $0 <= 'z'})\n          \
    \                                                                            \
    \                        ^~~\n                                               \
    \                                                               \"z\"\n/tmp/tmpr7yc0k_8.swift:19:56:\
    \ error: single-quoted string literal found, use '\"'\n    let rightConsonants\
    \ = word.characters.filter({$0 > 'z'} || {$0 >= 'A' && $0 <= 'Z'} || {$0 >= 'a'\
    \ && $0 <= 'z'})\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n    guard word.characters.count\
    \ > 1 else {\n        return \"\"\n    }\n    guard let index = word.characters.index(where:\
    \ { word.characters.last == $0 }) else { return \"\" }\n    let index1 = word.characters.index(before:\
    \ index)\n    let index2 = word.characters.index(before: index1, offsetBy: 1)\n\
    \    if vowels.contains(word.substring(to: index2)) {\n        return word.substring(to:\
    \ index2)\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpoij5cln0.swift:17:18: error: no exact matches in call to initializer\
    \ \n    let vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n                \
    \ ^\nSwift.Set:2:23: note: incorrect labels for candidate (have: '(_:_:_:_:_:)',\
    \ expected: '(arrayLiteral:_:_:_:_:)')\n    @inlinable public init(arrayLiteral\
    \ elements: Element...)\n                      ^\nSwift.SetAlgebra:2:23: note:\
    \ incorrect labels for candidate (have: '(_:_:_:_:_:)', expected: '(arrayLiteral:_:_:_:_:)')\n\
    \    @inlinable public init(arrayLiteral: Self.Element...)\n                 \
    \     ^\n/tmp/tmpoij5cln0.swift:18:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard word.characters.count > 1 else {\n          \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpoij5cln0.swift:21:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard let\
    \ index = word.characters.index(where: { word.characters.last == $0 }) else {\
    \ return \"\" }\n                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpoij5cln0.swift:21:39: warning: 'index(where:)'\
    \ is deprecated: renamed to 'firstIndex(where:)'\n    guard let index = word.characters.index(where:\
    \ { word.characters.last == $0 }) else { return \"\" }\n                     \
    \                 ^\n/tmp/tmpoij5cln0.swift:21:39: note: use 'firstIndex(where:)'\
    \ instead\n    guard let index = word.characters.index(where: { word.characters.last\
    \ == $0 }) else { return \"\" }\n                                      ^~~~~\n\
    \                                      firstIndex\n/tmp/tmpoij5cln0.swift:21:59:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard let\
    \ index = word.characters.index(where: { word.characters.last == $0 }) else {\
    \ return \"\" }\n                                                          ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ c"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ let wordArr = word.characters{\n        let vowels = \"aeiouAEIOU\".characters.sorted()\n\
    \        if let idx = vowels.firstIndex(of: wordArr.last!){\n            vowels.indices.contains(idx)\
    \ ? vowels[(idx+1)%vowels.count] : \"\"\n        }\n    }\n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpn3kr83_n.swift:17:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    if let wordArr = word.characters{\n               \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpn3kr83_n.swift:18:35: error: 'characters' is unavailable: Please use String\
    \ directly\n        let vowels = \"aeiouAEIOU\".characters.sorted()\n        \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpn3kr83_n.swift:20:50: error: result values in '? :' expression\
    \ have mismatching types 'String.Element' (aka 'Character') and 'String'\n   \
    \         vowels.indices.contains(idx) ? vowels[(idx+1)%vowels.count] : \"\"\n\
    \                                           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpn3kr83_n.swift:17:8:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    if let wordArr = word.characters{\n       ^             ~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = CharacterSet(charactersIn: \"aeiouy\") else { return \"\" }\n \
    \   var index = word.count\n    var vowelIndex = word.count\n    var lastIndex\
    \ = word.count - 1\n    var lastVowelIndex = word.count - 1\n    \n    while index\
    \ < word.count {\n        let c = word[index]\n        \n        if vowels.isSuperset(of:\
    \ c) || vowels.isSuperset(of: c.lowercased()) {\n            vowelIndex += 1\n\
    \        }\n        \n        if lastVowelIndex >= 0 {\n            if vowelIndex\
    \ <= lastVowelIndex && vowelIndex > 0 {\n                vowelIndex -= 1\n   \
    \         }\n        }\n        \n        if vowelIndex > index {\n          \
    \  lastVowelIndex = vowelIndex\n        }\n        \n        index += 1\n    }\n\
    \    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n    \n    return\
    \ String(cString: &word[vowelIndex], encoding: String.Encoding.utf8)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpocnhw8r1.swift:17:24: error: cannot find 'CharacterSet' in scope\n\
    \    guard let vowels = CharacterSet(charactersIn: \"aeiouy\") else { return \"\
    \" }\n                       ^~~~~~~~~~~~\n/tmp/tmpocnhw8r1.swift:24:17: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        let c = word[index]\n                ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpocnhw8r1.swift:47:12:\
    \ error: no exact matches in call to initializer \n    return String(cString:\
    \ &word[vowelIndex], encoding: String.Encoding.utf8)\n           ^\n/tmp/tmpocnhw8r1.swift:47:12:\
    \ note: found candidate with type '(Character) -> String'\n    return String(cString:\
    \ &word[vowelIndex], encoding: String.Encoding.utf8)\n           ^\n/tmp/tmpocnhw8r1.swift:47:12:\
    \ note: found candidate with type '([CChar]) -> String' (aka '(Array<Int8>) ->\
    \ String')\n    return String(cString: &word[vowelIndex], encoding: String.Encoding.utf8)\n\
    \           ^\n/tmp/tmpocnhw8r1.swift:47:12: note: found candidate with type '(inout\
    \ CChar) -> String' (aka '(inout Int8) -> String')\n    return String(cString:\
    \ &word[vowelIndex], encoding: String.Encoding.utf8)\n           ^\n/tmp/tmpocnhw8r1.swift:47:12:\
    \ note: found candidate with type '([UInt8]) -> String'\n    return String(cString:\
    \ &word[vowelIndex], encoding: String.Encoding.utf8)\n           ^\n/tmp/tmpocnhw8r1.swift:47:12:\
    \ note: found candidate with type '(String) -> String'\n    return String(cString:\
    \ &word[vowelIndex], encoding: String.Encoding.utf8)\n           ^\n/tmp/tmpocnhw8r1.swift:47:12:\
    \ note: found candidate with type '(inout UInt8) -> String'\n    return String(cString:\
    \ &word[vowelIndex], encoding: String.Encoding.utf8)\n           ^\n/tmp/tmpocnhw8r1.swift:47:64:\
    \ error: type 'String' has no member 'Encoding'\n    return String(cString: &word[vowelIndex],\
    \ encoding: String.Encoding.utf8)\n                                          \
    \              ~~~~~~ ^~~~~~~~\n/tmp/"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ word = word\n    let vowels = \"AEIOUaeiou\".characters\n    var vowelIndex\
    \ = 0\n    if word.characters.count <= 3 {\n        return \"\"\n    }\n    for\
    \ vowelIndex in 0..<word.characters.count-1 {\n        let characterIndex = word.index(vowelIndex,\
    \ offsetBy: 1)\n        guard let c = characterIndex else { return \"\" }\n  \
    \      guard let v = vowels[c] else { return \"\" }\n        if c != word.characters.count-1\
    \ {\n            let characterIndex2 = word.index(vowelIndex+1, offsetBy: 1)\n\
    \            guard let c2 = characterIndex2 else { return \"\" }\n           \
    \ if c2 != word.characters.count-1 {\n                let character = word[characterIndex..<characterIndex2]\n\
    \                if character == \"a\" || character == \"e\" || character == \"\
    i\" || character == \"o\" || character == \"u\" {\n                    return\
    \ v\n                }\n            }\n        }\n    }\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvjpnia9.swift:18:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowels = \"AEIOUaeiou\".characters\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxvjpnia9.swift:20:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count <= 3 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxvjpnia9.swift:23:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    for vowelIndex\
    \ in 0..<word.characters.count-1 {\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxvjpnia9.swift:24:41:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        let characterIndex = word.index(vowelIndex, offsetBy: 1)\n          \
    \                              ^\n/tmp/tmpxvjpnia9.swift:28:56: error: cannot\
    \ convert value of type 'Int' to expected argument type 'String.Index'\n     \
    \       let characterIndex2 = word.index(vowelIndex+1, offsetBy: 1)\n        \
    \                                               ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    guard word != \"\" else {\n        return \"\"\n    }\n    \n    var vowelIndex\
    \ = 0\n    var closestVowel = \"\"\n    var vowels = [String]()\n    vowels.reserveCapacity(256)\n\
    \    \n    for i in 0..<word.characters.count {\n        let charIndex = word.index(i,\
    \ offsetBy: 1)\n        \n        // Find left side\n        if word.startIndex\
    \ < charIndex {\n            vowelIndex = 0\n        } else {\n            vowelIndex\
    \ = word.characters.count - 1 - charIndex\n        }\n        \n        if let\
    \ v = vowels[vowelIndex] {\n            closestVowel = v\n            break\n\
    \        }\n        \n        vowelIndex += 1\n        vowels.append(\"\")\n \
    \   }\n    \n    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmk4x3j2n.swift:27:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<word.characters.count {\n            \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpmk4x3j2n.swift:28:36: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n        let charIndex = word.index(i, offsetBy:\
    \ 1)\n                                   ^\n/tmp/tmpmk4x3j2n.swift:37:12: error:\
    \ initializer for conditional binding must have Optional type, not 'String'\n\
    \        if let v = vowels[vowelIndex] {\n           ^       ~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ get_closest_vowel(word: word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmptyksu45x.swift:17:47: error: cannot find 'vowels' in scope\n  \
    \      return get_closest_vowel(word: word, vowels: vowels)\n                \
    \                                     ^~~~~~\n/tmp/tmptyksu45x.swift:17:47: error:\
    \ extra argument 'vowels' in call\n        return get_closest_vowel(word: word,\
    \ vowels: vowels)\n                                ~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var rIndex = 0\n    var lIndex\
    \ = 0\n    \n    var rCount = 0\n    var lCount = 0\n    \n    for index in 0..<word.count\
    \ {\n        var index = word.startIndex + index\n        if word[index] == \"\
    a\" {\n            rIndex = index\n            rCount++\n            if rCount\
    \ > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"e\" {\n            rIndex = index\n            rCount++\n            if\
    \ rCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"i\" {\n            rIndex = index\n            rCount++\n            if\
    \ rCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"o\" {\n            rIndex = index\n            rCount++\n            if\
    \ rCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"u\" {\n            rIndex = index\n            rCount++\n            if\
    \ rCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"A\" {\n            lIndex = index\n            lCount++\n            if\
    \ lCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"E\" {\n            lIndex = index\n            lCount++\n            if\
    \ lCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"I\" {\n            lIndex = index\n            lCount++\n            if\
    \ lCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"O\" {\n            lIndex = index\n            lCount++\n            if\
    \ lCount > 2 {\n                break\n            }\n        }\n        if word[index]\
    \ == \"U\" {\n            lIndex = index\n            lCount++\n            if\
    \ lCount > 2 {\n                break\n            }\n        }\n    }\n    \n\
    \    if rIndex > lIndex {\n        return \"\"\n    }\n    var vowel = \"\"\n\
    \    if word[rIndex] != \" \" {\n        vowel = word[rIndex]\n    }\n    if word[lIndex]\
    \ != \" \" {\n        vowel = vowel + word[lIndex]\n    }\n    return vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4scpvji.swift:27:26: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        var index = word.startIndex + index\n\
    \                         ^\n/tmp/tmpx4scpvji.swift:30:19: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            rCount++\n       \
    \           ^~\n/tmp/tmpx4scpvji.swift:37:19: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            rCount++\n                  ^~\n\
    /tmp/tmpx4scpvji.swift:44:19: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            rCount++\n                  ^~\n/tmp/tmpx4scpvji.swift:51:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  rCount++\n                  ^~\n/tmp/tmpx4scpvji.swift:58:19: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            rCount++\n  \
    \                ^~\n/tmp/tmpx4scpvji.swift:65:19: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            lCount++\n                \
    \  ^~\n/tmp/tmpx4scpvji.swift:72:19: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lCount++\n                  ^~\n/tmp/tmpx4scpvji.swift:79:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  lCount++\n                  ^~\n/tmp/tmpx4scpvji.swift:86:19: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            lCount++\n  \
    \                ^~\n/tmp/tmpx4scpvji.swift:93:19: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            lCount++\n                \
    \  ^~\n/tmp/tmpx4scpvji.swift:104:8: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    if word[rIndex]\
    \ != \" \" {\n       ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpx4scpvji.swift:105:21: error: cannot assign value\
    \ of type 'Character' to type 'String'\n        vowel = word[rIndex]\n       \
    \         ~~~~^~~~~~~~\n/tmp/tmpx4scpvji.swi"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n   var\
    \ result: String = \"\"\n   let vowels = Set([\"A\", \"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"U\", \"Y\", \"y\", \"O\", \"o\", \"R\", \"r\", \"L\", \"l\", \"L\"\
    , \"s\", \"z\"])\n   for char in word {\n      if let index = word.index(char)\
    \ {\n         if vowels.contains(word[index - 1 : index + 1]) {\n            result\
    \ = word[index - 1 : index + 1]\n            break\n         }\n      }\n   }\n\
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpx1et2he8.swift:21:44: error: expected ',' separator\n         if\
    \ vowels.contains(word[index - 1 : index + 1]) {\n                           \
    \                ^\n                                          ,\n/tmp/tmpx1et2he8.swift:21:44:\
    \ error: expected expression in list of expressions\n         if vowels.contains(word[index\
    \ - 1 : index + 1]) {\n                                           ^\n/tmp/tmpx1et2he8.swift:22:37:\
    \ error: expected ',' separator\n            result = word[index - 1 : index +\
    \ 1]\n                                    ^\n                                \
    \   ,\n/tmp/tmpx1et2he8.swift:22:37: error: expected expression in list of expressions\n\
    \            result = word[index - 1 : index + 1]\n                          \
    \          ^\n/tmp/tmpx1et2he8.swift:20:33: error: missing argument label 'of:'\
    \ in call\n      if let index = word.index(char) {\n                         \
    \       ^\n                                of: \n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Solution only works with english letters\n    \n    let consonants = \"\
    bcdfghjklmnpqrstvwxyz\"\n    let vowels = \"aeiouy\"\n    \n    // get last index\
    \ of consonant\n    if let index = word.index(where:{$0.isUpper}) {\n        //\
    \ get last index of vowel\n        if let last_vowel_index = word.index(where:{$0.isUpper},\
    \ offset:index+1) {\n            let vowel = word[last_vowel_index]\n        \
    \    if vowels.contains(vowel) {\n                // find index of the closest\
    \ consonant\n                let i = word.index(of: vowel)\n                \n\
    \                // if last index of consonant is bigger than last index of vowel\n\
    \                let consonantIndex = word[word.index(i, offsetBy:index+1)]\n\
    \                if consonants.characters.contains(consonantIndex) {\n       \
    \             // get the index\n                    var index = consonants.characters.firstIndex(of:\
    \ consonantIndex)\n                    \n                    // if the last index\
    \ of consonant is bigger than the last index of vowel plus one\n             \
    \       let isVowelConsonant = word[word.index(i, offsetBy:index+1)+1] == vowel\n\
    \                    \n                    if isVowelConsonant {\n           \
    \             // find first index of vowel after consonantIndex\n            \
    \            index = word.index(i, offsetBy:index+2)\n                    }\n\
    \                    \n                    return word[index].lowercased()\n \
    \               }\n            }\n        }\n    }\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp9g311kaq.swift:24:41: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'isUpper'\n    if let index = word.index(where:{$0.isUpper})\
    \ {\n                                     ~~ ^~~~~~~\n/tmp/tmp9g311kaq.swift:26:78:\
    \ error: extra argument 'offset' in call\n        if let last_vowel_index = word.index(where:{$0.isUpper},\
    \ offset:index+1) {\n                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    /tmp/tmp9g311kaq.swift:26:56: error: value of type 'String.Element' (aka 'Character')\
    \ has no member 'isUpper'\n        if let last_vowel_index = word.index(where:{$0.isUpper},\
    \ offset:index+1) {\n                                                    ~~ ^~~~~~~\n\
    /tmp/tmp9g311kaq.swift:39:54: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n                    let isVowelConsonant =\
    \ word[word.index(i, offsetBy:index+1)+1] == vowel\n                         \
    \                            ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = [\n        \"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"\", \"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\"\n    ]\n    \n    var vowel = \"\"\n  \
    \  \n    let length = word.length\n    \n    for i in 0..<length {\n        \n\
    \        if word.hasPrefix(vowels[i]) {\n            \n            vowel = vowels[i]\n\
    \            break\n        }\n        \n        if vowel == \"\" {\n        \
    \    \n            vowel = vowels[i]\n        }\n    }\n    \n    return vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp0yq66rtz.swift:24:23: error: value of type 'String' has no member\
    \ 'length'\n    let length = word.length\n                 ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowel: Character = \"U\"\n    var result: String = \"\"\n    \n    guard\
    \ word.characters.count != 0 else {\n        return result\n    }\n    \n    for\
    \ index in word.characters.reversed() {\n        \n        if index < word.characters.count\
    \ - 1 {\n            let char1 = word.characters.index(before: index)\n      \
    \      let char2 = word.characters.index(after: index)\n            \n       \
    \     if let char3 = word.characters.index(before: char2, after: char1) {\n  \
    \              \n                if char3 == word.characters.count - 1 {\n   \
    \                 vowel = word.characters.last\n                }\n          \
    \      \n                if let char4 = word.characters.index(before: char3, after:\
    \ char3) {\n                    \n                    if char4 != char2 {\n  \
    \                      vowel = word.characters.last\n                    }\n \
    \               }\n            }\n        }\n    }\n    \n    if vowel == \"U\"\
    \ || vowel == \"u\" {\n        result = vowel\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp219fyu4l.swift:21:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard word.characters.count != 0 else {\n         \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp219fyu4l.swift:25:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    for index\
    \ in word.characters.reversed() {\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp219fyu4l.swift:27:18: error: binary operator\
    \ '<' cannot be applied to operands of type 'String.Element' (aka 'Character')\
    \ and 'Int'\n        if index < word.characters.count - 1 {\n           ~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp219fyu4l.swift:27:18: note: overloads for\
    \ '<' exist with these partially matching parameter lists: (Character, Character),\
    \ (Int, Int)\n        if index < word.characters.count - 1 {\n               \
    \  ^\n/tmp/tmp219fyu4l.swift:28:55: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String.Index'\n            let\
    \ char1 = word.characters.index(before: index)\n                             \
    \                         ^\n/tmp/tmp219fyu4l.swift:29:54: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'String.Index'\n\
    \            let char2 = word.characters.index(after: index)\n               \
    \                                      ^\n/tmp/tmp219fyu4l.swift:31:72: error:\
    \ extra argument 'after' in call\n            if let char3 = word.characters.index(before:\
    \ char2, after: char1) {\n                                                ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmp219fyu4l.swift:34:45: error: value of optional type 'String.Element?'\
    \ (aka 'Optional<Character>') must be unwrapped to a value of type 'String.Element'\
    \ (aka 'Character')\n                    vowel = word.characters.last\n      \
    \                                      ^\n/t"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\".characters\n    let range = word.endIndex..<word.startIndex\n\
    \    let search = word.substringFromIndex(range)\n    \n    var searchIndex =\
    \ word.startIndex\n    var foundIndex = word.startIndex\n    \n    for i in 0\
    \ ..< range.count {\n        if vowels.contains(word.characters[i]) {\n      \
    \      if searchIndex == range.count {\n                return \"\"\n        \
    \    }\n            if searchIndex == range.count-1 {\n                return\
    \ vowels[searchIndex]\n            }\n            \n            searchIndex++\n\
    \            foundIndex++\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpepen7fwx.swift:17:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowels = \"aeiouAEIOU\".characters\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpepen7fwx.swift:19:23: error: value of type 'String' has no member\
    \ 'substringFromIndex'\n    let search = word.substringFromIndex(range)\n    \
    \             ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpepen7fwx.swift:24:20: error: referencing\
    \ property 'count' on 'Range' requires that 'String.Index' conform to 'Strideable'\n\
    \    for i in 0 ..< range.count {\n                   ^\nSwift.Range:1:11: note:\
    \ requirement from conditional conformance of 'Range<String.Index>' to 'Collection'\n\
    extension Range : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ get_closest_vowelHelper(word, 1, 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp1npkyo4b.swift:17:9: error: cannot find 'get_closest_vowelHelper'\
    \ in scope\n        return get_closest_vowelHelper(word, 1, 1)\n             \
    \  ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ solution(word: word, flag: \"y\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgx68zo2e.swift:17:12: error: cannot find 'solution' in scope\n\
    \    return solution(word: word, flag: \"y\")\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set<Character>([\"a\",\"e\",\"i\",\"o\",\"u\"])\n    var rightSideIndex:\
    \ Int = word.endIndex\n    \n    for i in 0 ..< rightSideIndex {\n        \n \
    \       if vowels.contains(String(word.unicodeScalars.first + i)) == false {\n\
    \            break\n        }\n        \n        vowels.insert(\"u\")\n      \
    \  \n    }\n    \n    return String(word.unicodeScalars.first + rightSideIndex)\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\"\
    ) == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplc5hifw7.swift:18:36: error: cannot convert value of type 'String.Index'\
    \ to specified type 'Int'\n    var rightSideIndex: Int = word.endIndex\n     \
    \                         ~~~~~^~~~~~~~\n/tmp/tmplc5hifw7.swift:22:55: error:\
    \ cannot convert value of type 'Unicode.Scalar?' to expected argument type 'Int'\n\
    \        if vowels.contains(String(word.unicodeScalars.first + i)) == false {\n\
    \                                                      ^\n/tmp/tmplc5hifw7.swift:30:39:\
    \ error: cannot convert value of type 'Unicode.Scalar?' to expected argument type\
    \ 'Int'\n    return String(word.unicodeScalars.first + rightSideIndex) \n    \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  var vowels:\
    \ [String] = []\n  vowels.append(\"a\")\n  vowels.append(\"e\")\n  vowels.append(\"\
    i\")\n  vowels.append(\"o\")\n  vowels.append(\"u\")\n  \n  var lastIndex: Int\
    \ = 0\n  for index in word.characters.reverse().enumerated() {\n    if index ==\
    \ word.characters.reversed().startIndex {\n      break\n    }\n    var found =\
    \ false\n    for vowel in vowels {\n      if vowel.characters[vowel.characters.count\
    \ - index + 1] == word.characters.reversed()[index] {\n        found = true\n\
    \        break\n      }\n    }\n    if found == true {\n      if lastIndex < word.characters.count\
    \ {\n        if vowels.contains(word.characters.reversed()[lastIndex..<word.characters.reversed().startIndex])\
    \ {\n          lastIndex = index\n          break\n        }\n      }\n    }\n\
    \  }\n  if lastIndex == word.characters.count - 1 {\n    return \"\"\n  }\n  \n\
    \  let lastVowel = word.characters.reversed()[lastIndex..<word.characters.reversed().startIndex]\n\
    \  let nextVowel = word.characters.reversed()[word.characters.reversed().startIndex..<word.characters.reversed().startIndex\
    \ + 2]\n  let isNextVowel = nextVowel.characters.count > 0\n  \n  if !isNextVowel\
    \ {\n    return lastVowel\n  }\n  \n  guard lastVowel.characters.count != 0 else\
    \ { return \"\" }\n  \n  return lastVowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmprdqm_tma.swift:25:32: error: value of type 'String' has no member\
    \ 'reverse'\n  for index in word.characters.reverse().enumerated() {\n       \
    \        ~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmprdqm_tma.swift:45:24: error: 'characters'\
    \ is unavailable: Please use String directly\n  if lastIndex == word.characters.count\
    \ - 1 {\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprdqm_tma.swift:49:24: error: 'characters' is unavailable:\
    \ Please use String directly\n  let lastVowel = word.characters.reversed()[lastIndex..<word.characters.reversed().startIndex]\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmprdqm_tma.swift:49:63: error: 'characters' is unavailable:\
    \ Please use String directly\n  let lastVowel = word.characters.reversed()[lastIndex..<word.characters.reversed().startIndex]\n\
    \                                                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmprdqm_tma.swift:50:24: error: 'characters'\
    \ is unavailable: Please use String directly\n  let nextVowel = word.characters.reversed()[word.characters.reversed().startIndex..<word.characters.reversed().startIndex\
    \ + 2]\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprdqm_tma.swift:50:51: error: 'characters' is unavailable:\
    \ Please use String directly\n  let nextVowel = word.characters.reversed()[word.characters.reversed().startIndex..<word.characters.reversed().startIndex\
    \ + 2]\n                                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmprdqm_tma.swift:50:91: erro"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word.lowercased(), lettersInBetweenConsonants.sorted())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp25abd6se.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word.lowercased(), lettersInBetweenConsonants.sorted())\n\
    \           ^~~~~~~~~~~~~~~\n/tmp/tmp25abd6se.swift:17:47: error: cannot find\
    \ 'lettersInBetweenConsonants' in scope\n    return getClosestVowel(word.lowercased(),\
    \ lettersInBetweenConsonants.sorted())\n                                     \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiou\"\n    \n    let vowels_start = vowels.prefix(upTo:\
    \ word.count).enumerated().map { $0.element }\n    let vowels_end = vowels.suffix(from:\
    \ word.count).enumerated().map { $0.element }\n    \n    return vowels_start.map\
    \ { vowel in vowels_end.filter { $0 != vowel }.first }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3ewi8vdk.swift:20:49: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n    let vowels_start = vowels.prefix(upTo:\
    \ word.count).enumerated().map { $0.element }\n                              \
    \                  ^\n/tmp/tmp3ewi8vdk.swift:21:47: error: cannot convert value\
    \ of type 'Int' to expected argument type 'String.Index'\n    let vowels_end =\
    \ vowels.suffix(from: word.count).enumerated().map { $0.element }\n          \
    \                                    ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here\n    var vowel = String()\n    for i in 0 ..< word.count {\n\
    \        if isVowel(word[word.count - i - 1]) {\n            vowel = word[word.count\
    \ - i - 1]\n            break\n        }\n    }\n    return vowel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmput9z_tn1.swift:20:12: error: cannot find 'isVowel' in scope\n \
    \       if isVowel(word[word.count - i - 1]) {\n           ^~~~~~~\n/tmp/tmput9z_tn1.swift:21:25:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  vowel = word[word.count - i - 1]\n                    ~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    var i = 0\n    var currentChar = String(i)\n    var prevChar\
    \ = String(i-1)\n    var endOfString = false\n    if word == \"\" {\n        return\
    \ \"\"\n    }\n    if word[0] != letters[0] {\n        return \"Invalid String:\
    \ Not a letter from English!\"\n    }\n    \n    for char in word {\n        if\
    \ letters[letters.index(char)] == vowels[vowels.indexOf(char)] {\n           \
    \ result = char\n            endOfString = true\n            prevChar = currentChar\n\
    \            break\n        }\n        if char == currentChar{\n            currentChar\
    \ = char\n            prevChar = currentChar\n        }\n    }\n    if endOfString\
    \ == true {\n        for char in word {\n            if char == currentChar{\n\
    \                currentChar = char\n                prevChar = currentChar\n\
    \            }\n        }\n        \n        if currentChar != letters[letters.index(currentChar)]\
    \ {\n            result = currentChar\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3919ay7n.swift:25:19: error: cannot find 'letters' in scope\n \
    \   if word[0] != letters[0] {\n                  ^~~~~~~\n/tmp/tmp3919ay7n.swift:30:12:\
    \ error: cannot find 'letters' in scope\n        if letters[letters.index(char)]\
    \ == vowels[vowels.indexOf(char)] {\n           ^~~~~~~\n/tmp/tmp3919ay7n.swift:30:20:\
    \ error: cannot find 'letters' in scope\n        if letters[letters.index(char)]\
    \ == vowels[vowels.indexOf(char)] {\n                   ^~~~~~~\n/tmp/tmp3919ay7n.swift:30:44:\
    \ error: cannot find 'vowels' in scope\n        if letters[letters.index(char)]\
    \ == vowels[vowels.indexOf(char)] {\n                                        \
    \   ^~~~~~\n/tmp/tmp3919ay7n.swift:30:51: error: cannot find 'vowels' in scope\n\
    \        if letters[letters.index(char)] == vowels[vowels.indexOf(char)] {\n \
    \                                                 ^~~~~~\n/tmp/tmp3919ay7n.swift:31:22:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  result = char\n                     ^~~~\n/tmp/tmp3919ay7n.swift:36:17: error:\
    \ binary operator '==' cannot be applied to operands of type 'Character' and 'String'\n\
    \        if char == currentChar{\n           ~~~~ ^  ~~~~~~~~~~~\n/tmp/tmp3919ay7n.swift:36:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == currentChar{\n\
    \                ^\n/tmp/tmp3919ay7n.swift:37:27: error: cannot assign value of\
    \ type 'Character' to type 'String'\n            currentChar = char\n        \
    \                  ^~~~\n/tmp/tmp3919ay7n.swift:43:21: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'String'\n      \
    \      if char == currentChar{\n               ~~~~ ^  ~~~~~~~~~~~\n/tmp/tmp3919ay7n.swift:43:21:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if char == currentChar{\n\
    \                    ^\n/tmp/tmp3919ay7n.swift:44:31: error: cannot assign value\
    \ of type 'Character' to type 'String'\n                currentCha"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    guard let vowels = \"AEIOUaeiou\".split(separator: \"\") else {\n       \
    \ return \"\"\n    }\n    \n    var indexStart = 0\n    var indexEnd = word.characters.count\
    \ - 1\n    var consonants = word.characters.filter({ $0 >= \"A\" && $0 <= \"Z\"\
    \ })\n    \n    while indexEnd - indexStart > 1 {\n        \n        indexStart\
    \ += 1\n        indexEnd -= 1\n        let testString = word.substring(with: NSRange(location:\
    \ indexStart, length: indexEnd - indexStart))\n        if testString.characters.count\
    \ > vowels.count {\n            continue\n        }\n        \n        let index\
    \ = vowels.index(of: String(testString[testString.characters.count - 1]), in:\
    \ consonants)\n        \n        if index >= 0 {\n            return String(testString[index])\n\
    \        }\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp6w5ro98m.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let vowels = \"AEIOUaeiou\".split(separator: \"\") else {\n       \
    \   ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6w5ro98m.swift:23:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    var indexEnd\
    \ = word.characters.count - 1\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp6w5ro98m.swift:24:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    var consonants = word.characters.filter({\
    \ $0 >= \"A\" && $0 <= \"Z\" })\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp6w5ro98m.swift:30:47: error: cannot find\
    \ 'NSRange' in scope\n        let testString = word.substring(with: NSRange(location:\
    \ indexStart, length: indexEnd - indexStart))\n                              \
    \                ^~~~~~~\n/tmp/tmp6w5ro98m.swift:30:31: error: value of type 'String'\
    \ has no member 'substring'\n        let testString = word.substring(with: NSRange(location:\
    \ indexStart, length: indexEnd - indexStart))\n                         ~~~~ ^~~~~~~~~\n\
    /tmp/tmp6w5ro98m.swift:35:95: error: extra argument 'in' in call\n        let\
    \ index = vowels.index(of: String(testString[testString.characters.count - 1]),\
    \ in: consonants)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowel = vowels.first(where: { (vowel) -> Bool in\n        return word.range(of:\
    \ vowel, options: .backwards) == nil\n    }) else { return \"\" }\n    return\
    \ vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_f_1xfc6.swift:17:23: error: cannot find 'vowels' in scope\n  \
    \  guard let vowel = vowels.first(where: { (vowel) -> Bool in\n              \
    \        ^~~~~~\n/tmp/tmp_f_1xfc6.swift:18:21: error: value of type 'String' has\
    \ no member 'range'\n        return word.range(of: vowel, options: .backwards)\
    \ == nil\n               ~~~~ ^~~~~\n/tmp/tmp_f_1xfc6.swift:18:48: error: cannot\
    \ infer contextual base in reference to member 'backwards'\n        return word.range(of:\
    \ vowel, options: .backwards) == nil\n                                       \
    \       ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelFound:\
    \ Bool = false\n    var closestVowel: Character? = nil\n    for char in word.characters\
    \ {\n        if !vowelFound {\n            for v in vowels {\n               \
    \ if char == v {\n                    vowelFound = true\n                    closestVowel\
    \ = v\n                }\n            }\n        }\n        else {\n         \
    \   if char == closestVowel! {\n                continue\n            }\n    \
    \        closestVowel = nil\n            vowelFound = false\n            if char\
    \ == vowels[vowels.count - 1] {\n                vowelFound = true\n         \
    \       closestVowel = char\n            }\n        }\n        if vowelFound {\n\
    \            break\n        }\n    }\n    return closestVowel?.description\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4luv3wjj.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp4luv3wjj.swift:44:26:\
    \ error: value of optional type 'String?' must be unwrapped to a value of type\
    \ 'String'\n    return closestVowel?.description\n                         ^\n\
    /tmp/tmp4luv3wjj.swift:44:26: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return closestVowel?.description\n  \
    \                       ^\n                                     ?? <#default value#>\n\
    /tmp/tmp4luv3wjj.swift:44:26: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    return closestVowel?.description\n\
    \                       ~ ^\n                       !\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ get_closest_vowel2(word: word, vowel: vowel)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvvfzrblu.swift:17:9: error: cannot find 'get_closest_vowel2' in\
    \ scope\n        return get_closest_vowel2(word: word, vowel: vowel)\n       \
    \        ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvvfzrblu.swift:17:47: error: cannot find\
    \ 'vowel' in scope\n        return get_closest_vowel2(word: word, vowel: vowel)\n\
    \                                                     ^~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    if word.isEmpty {\n        return \"\"\n    }\n    \n    var vowels = \"\
    aeiouAEIOU\"\n    \n    let lowerWord = word.lowercased()\n    \n    let len =\
    \ lowerWord.count\n    \n    var count = 0\n    \n    for char in lowerWord.reverse()\
    \ {\n        if vowels.contains(char) {\n            count += 1\n        }\n \
    \   }\n    \n    guard count > 0 else { return \"\" }\n    \n    let lastIndex\
    \ = len - 1\n    \n    let lastChar = lowerWord[lastIndex]\n    \n    if vowels.contains(lastChar)\
    \ {\n        return lastChar\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgdurujts.swift:30:27: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in lowerWord.reverse() {\n                ~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpgdurujts.swift:40:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    let lastChar\
    \ = lowerWord[lastIndex]\n                   ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgdurujts.swift:43:16:\
    \ error: cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return lastChar\n               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result: String = String()\n    var vowels = \"AEIOUaeiou\"\n    for idx in stride(from:\
    \ word.count-1, through: 0, by: -1) {\n        if word.index(idx, offsetBy: 1)\
    \ >= word.count-1 {\n            break\n        }\n        var char: String =\
    \ String(word.substring(from: idx, offsetBy: 1))\n        var idx = vowels.firstIndex(of:\
    \ char)\n        if idx > -1 {\n            result += char\n            break\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmprsgtfpi6.swift:20:23: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        if word.index(idx, offsetBy:\
    \ 1) >= word.count-1 {\n                      ^\n/tmp/tmprsgtfpi6.swift:20:41:\
    \ error: referencing operator function '>=' on 'BinaryInteger' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n        if word.index(idx, offsetBy: 1) >= word.count-1\
    \ {\n                                        ^\nSwift.BinaryInteger:1:11: note:\
    \ where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n/tmp/tmprsgtfpi6.swift:23:40:\
    \ error: value of type 'String' has no member 'substring'\n        var char: String\
    \ = String(word.substring(from: idx, offsetBy: 1))\n                         \
    \         ~~~~ ^~~~~~~~~\n/tmp/tmprsgtfpi6.swift:24:41: error: cannot convert\
    \ value of type 'String' to expected argument type 'String.Element' (aka 'Character')\n\
    \        var idx = vowels.firstIndex(of: char)\n                             \
    \           ^\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ let word = word.lowercaseString.range(of: \"a\") {\n        return \"\"\n  \
    \  }\n    else if let word = word.lowercaseString.range(of: \"e\") {\n       \
    \ return \"\"\n    }\n    else if let word = word.lowercaseString.range(of: \"\
    i\") {\n        return \"\"\n    }\n    else if let word = word.lowercaseString.range(of:\
    \ \"o\") {\n        return \"\"\n    }\n    else if let word = word.lowercaseString.range(of:\
    \ \"u\") {\n        return \"\"\n    }\n    else if let word = word.lowercaseString.range(of:\
    \ \"y\") {\n        return \"\"\n    }\n    else if let word = word.lowercaseString.range(of:\
    \ \"s\") {\n        return \"\"\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2xf4niwj.swift:17:24: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    if let word = word.lowercaseString.range(of: \"a\") {\n\
    \                  ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp2xf4niwj.swift:20:29: error:\
    \ value of type 'String' has no member 'lowercaseString'\n    else if let word\
    \ = word.lowercaseString.range(of: \"e\") {\n                       ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp2xf4niwj.swift:23:29: error: value of type 'String' has no member 'lowercaseString'\n\
    \    else if let word = word.lowercaseString.range(of: \"i\") {\n            \
    \           ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp2xf4niwj.swift:26:29: error: value of\
    \ type 'String' has no member 'lowercaseString'\n    else if let word = word.lowercaseString.range(of:\
    \ \"o\") {\n                       ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp2xf4niwj.swift:29:29:\
    \ error: value of type 'String' has no member 'lowercaseString'\n    else if let\
    \ word = word.lowercaseString.range(of: \"u\") {\n                       ~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmp2xf4niwj.swift:32:29: error: value of type 'String'\
    \ has no member 'lowercaseString'\n    else if let word = word.lowercaseString.range(of:\
    \ \"y\") {\n                       ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp2xf4niwj.swift:35:29:\
    \ error: value of type 'String' has no member 'lowercaseString'\n    else if let\
    \ word = word.lowercaseString.range(of: \"s\") {\n                       ~~~~\
    \ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ candidate = word.endIndex\n    \n    var prevIndex = word.startIndex\n    while\
    \ prevIndex >= 0 {\n        if word[prevIndex] != vowel.first && word[prevIndex]\
    \ != vowel.second {\n            candidate = word.endIndex - 1\n        }\n  \
    \      prevIndex -= 1\n    }\n    return word.substringToIndex(candidate)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2atyk5bq.swift:20:21: error: referencing operator function '>='\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while prevIndex >= 0 {\n                    ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n\
    /tmp/tmp2atyk5bq.swift:21:31: error: cannot find 'vowel' in scope\n        if\
    \ word[prevIndex] != vowel.first && word[prevIndex] != vowel.second {\n      \
    \                        ^~~~~\n/tmp/tmp2atyk5bq.swift:21:65: error: cannot find\
    \ 'vowel' in scope\n        if word[prevIndex] != vowel.first && word[prevIndex]\
    \ != vowel.second {\n                                                        \
    \        ^~~~~\n/tmp/tmp2atyk5bq.swift:22:39: error: binary operator '-' cannot\
    \ be applied to operands of type 'String.Index' and 'Int'\n            candidate\
    \ = word.endIndex - 1\n                        ~~~~~~~~~~~~~ ^ ~\n/tmp/tmp2atyk5bq.swift:22:39:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            candidate = word.endIndex - 1\n                    \
    \                  ^\n/tmp/tmp2atyk5bq.swift:24:19: error: binary operator '-='\
    \ cannot be applied to operands of type 'String.Index' and 'Int'\n        prevIndex\
    \ -= 1\n        ~~~~~~~~~ ^  ~\n/tmp/tmp2atyk5bq.swift:26:17: error: value of\
    \ type 'String' has no member 'substringToIndex'\n    return word.substringToIndex(candidate)\n\
    \           ~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [ \"a\", \"a\", \"e\", \"e\", \"i\", \"i\", \"o\", \"o\", \"u\", \"\
    u\" ]\n    let vowelCount = word.characters.count\n    let lastVowel = vowels.last!\n\
    \    let vowelIndex = word.characters.index(lastVowel, to: word.endIndex)\n  \
    \  let vowelCountAfter = word.characters.index(vowelIndex!, to: word.endIndex)\n\
    \    vowels = vowels.suffix(from: vowelCountAfter!).prefix(from: vowelCount!)\n\
    \    \n    if vowelIndex == nil || vowelIndex! < 0 || vowelIndex! >= vowelCount{\n\
    \        return \"\"\n    }\n    if word.characters.count < 2 {\n        return\
    \ \"\"\n    }\n    if word.characters.index(lastVowel, to: word.endIndex) == word.characters.index(vowels[vowels.first!],\
    \ to: word.endIndex){\n        return vowels[vowels.first!]\n    }\n    if word.characters.index(lastVowel,\
    \ to: word.endIndex) == word.characters.index(vowels[vowels.last!], to: word.endIndex){\n\
    \        return vowels[vowels.last!]\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_3nupxcl.swift:18:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelCount = word.characters.count\n          \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_3nupxcl.swift:20:27: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n    let vowelIndex\
    \ = word.characters.index(lastVowel, to: word.endIndex)\n                    \
    \      ^\nSwift.Collection:3:17: note: where 'T' = 'String.Index'\n    public\
    \ func index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where T : BinaryInteger\n\
    \                ^\n/tmp/tmp_3nupxcl.swift:20:43: error: incorrect argument label\
    \ in call (have '_:to:', expected '_:offsetBy:')\n    let vowelIndex = word.characters.index(lastVowel,\
    \ to: word.endIndex)\n                                          ^           ~~\n\
    \                                                      offsetBy\n/tmp/tmp_3nupxcl.swift:20:44:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Index'\n\
    \    let vowelIndex = word.characters.index(lastVowel, to: word.endIndex)\n  \
    \                                         ^\n/tmp/tmp_3nupxcl.swift:21:48: error:\
    \ incorrect argument label in call (have '_:to:', expected '_:offsetBy:')\n  \
    \  let vowelCountAfter = word.characters.index(vowelIndex!, to: word.endIndex)\n\
    \                                               ^             ~~\n           \
    \                                                  offsetBy\n/tmp/tmp_3nupxcl.swift:21:32:\
    \ error: instance method 'index(_:offsetBy:)' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n    let vowelCountAfter = word.characters.index(vowelIndex!,\
    \ to: word.endIndex)\n                               ^\nSwift.Collection:3:17:\
    \ note: where 'T' = 'String.Index'\n    public func index<T>(_ i: Self.Index,\
    \ offsetBy n: T) -> Self.Index where T : BinaryInteger\n                ^\n/tmp/tmp_3nupxcl.swift:22:52:\
    \ error: cannot assign value of type 'ArraySlice"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find_closest_vowel(word.utf8)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplae7jqiv.swift:17:12: error: cannot find 'find_closest_vowel' in\
    \ scope\n    return find_closest_vowel(word.utf8)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\treturn get_closest_vowel_helper(word,\
    \ vowels)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp6s8lpr0x.swift:18:9: error: cannot find 'get_closest_vowel_helper'\
    \ in scope\n        return get_closest_vowel_helper(word, vowels)\n          \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.characters.count < 3 { return \"\" }\n    guard let upper = word.characters.last\
    \ else {\n        return \"\"\n    }\n    let vowels = \"aeiouAEIOU\".characters()\n\
    \    let from = vowels.last\n    let to = vowels.first\n    guard word.characters.count\
    \ >= 2 else { return \"\" }\n    if word.characters.count == 2 {\n        return\
    \ word[..from]\n    }\n    var index = 0\n    while index < word.characters.count\
    \ {\n        let range = word.startIndex..<word.endIndex\n        let result =\
    \ word[range]\n        var bestIndex = 0\n        var bestRange: String.Index?\
    \ = nil\n        var bestString = \"\"\n        for char in vowels {\n       \
    \     let range2 = result.startIndex..<result.endIndex\n            let result2\
    \ = result[range2]\n            if result2.contains(\"a\") {\n               \
    \ if bestIndex == 0 {\n                    bestString = result2\n            \
    \        bestIndex = 1\n                    bestRange = range2\n             \
    \   } else {\n                    if result2.contains(char) {\n              \
    \          bestIndex = bestIndex + 1\n                    } else {\n         \
    \               if bestIndex == 1 {\n                            bestString =\
    \ result2\n                            bestRange = range2\n                  \
    \      }\n                    }\n                }\n            } else if result2.contains(\"\
    e\") {\n                if bestIndex == 0 {\n                    bestString =\
    \ result2\n                    bestIndex = 1\n                    bestRange =\
    \ range2\n                } else {\n                    if result2.contains(char)\
    \ {\n                        bestIndex = bestIndex + 1\n                    }\
    \ else {\n                        if bestIndex == 1 {\n                      \
    \      bestString = result2\n                            bestRange = range2\n\
    \                        }\n                    }\n                }\n       \
    \     } else if result2.contains(\"i\") {\n                if bestIndex == 0 {\n\
    \                    bestString = result2\n                    bestIndex = 1\n\
    \                    bestRange = range2\n                } else {\n          \
    \          if result2.contains(char) {\n                        bestIndex = bestIndex\
    \ + 1\n                    } else {\n                        if bestIndex == 1\
    \ {\n                            bestString = result2\n                      \
    \      bestRange = range2\n                        }\n                    }\n\
    \                }\n            } else if result2.contains(\"o\") {\n        \
    \        if bestIndex == 0 {\n                    bestString = result2\n     \
    \               bestIndex = 1\n                    bestRange = range2\n      \
    \          } else {\n                    if result2.contains(char) {\n       \
    \                 bestIndex = bestIndex + 1\n                    } else {\n  \
    \                      if bestIndex == 1 {\n                            bestString\
    \ = result2\n                            bestRange = range2\n                \
    \        }\n                    }\n                }\n            } else if result2.contains(\"\
    u\") {\n                if bestIndex == 0 {\n                    bestString =\
    \ result2\n                    bestIndex = 1\n                    bestRange =\
    \ range2\n                } else {\n                    if result2.contains(char)\
    \ {\n                        bestIndex = bestIndex + 1\n                    }\
    \ else {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp0c2pgkxb.swift:134:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmp0c2pgkxb.swift:103:24: note: to match this\
    \ opening '{'\n                } else {\n                       ^\n/tmp/tmp0c2pgkxb.swift:134:48:\
    \ error: expected '}' at end of brace statement\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")\n                                               ^\n/tmp/tmp0c2pgkxb.swift:98:45:\
    \ note: to match this opening '{'\n            } else if result2.contains(\"u\"\
    ) {\n                                            ^\n/tmp/tmp0c2pgkxb.swift:134:48:\
    \ error: expected '}' at end of brace statement\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")\n                                               ^\n/tmp/tmp0c2pgkxb.swift:35:28:\
    \ note: to match this opening '{'\n        for char in vowels {\n            \
    \               ^\n/tmp/tmp0c2pgkxb.swift:134:48: error: expected '}' at end of\
    \ brace statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n     \
    \                                          ^\n/tmp/tmp0c2pgkxb.swift:29:41: note:\
    \ to match this opening '{'\n    while index < word.characters.count {\n     \
    \                                   ^\n/tmp/tmp0c2pgkxb.swift:134:48: error: expected\
    \ '}' at end of brace statement\nassert(get_closest_vowel(word: \"Above\") ==\
    \ \"o\")\n                                               ^\n/tmp/tmp0c2pgkxb.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmp0c2pgkxb.swift:17:13:\
    \ error: 'characters' is unavailable: Please use String directly\n    if word.characters.count\
    \ < 3 { return \"\" }\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0c2pgkxb.swift:18:28: error: 'characters' is unavailable:\
    \ Please use String directly\n    guard let upper = word.characters.last else\
    \ {\n                           ^~~~~~~~~~\nSwift.String:"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ getVowel(word, fromIndex: word.endIndex.reversed())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7_llw96w.swift:17:9: error: cannot find 'getVowel' in scope\n \
    \       return getVowel(word, fromIndex: word.endIndex.reversed())\n         \
    \      ^~~~~~~~\n/tmp/tmp7_llw96w.swift:17:49: error: value of type 'String.Index'\
    \ has no member 'reversed'\n        return getVowel(word, fromIndex: word.endIndex.reversed())\n\
    \                                         ~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // 1. Sort all the consonants in order.\n    let sortedConsonants = word.sorted()\n\
    \    \n    // 2. Sort all the vowels in order.\n    let sortedVowels = sortedConsonants.reduce([String]())\
    \ { $0 + [$1] }\n    \n    // 3. Remove all the consonants and vowels that are\
    \ not in the word and store them.\n    var sortedAllConsonants: [String] = []\n\
    \    var sortedAllVowels: [String] = []\n    sortedAllConsonants = sortedConsonants.filter\
    \ { !word.isContains($0) }\n    sortedAllVowels = sortedVowels.filter { !word.isContains($0)\
    \ }\n    \n    // 4. Find the nearest vowel which we already know is the end of\
    \ the word.\n    let indexAfterVowel = sortedAllConsonants.firstIndex(of: word[word.index(word.startIndex,\
    \ offsetBy: word.index(word.endIndex, offsetBy: 1)) - 1])\n    \n    // 5. Get\
    \ the nearest vowel which we already know is the beginning of the word.\n    let\
    \ indexBeforeVowel = sortedAllVowels.firstIndex(of: word[word.index(word.startIndex,\
    \ offsetBy: word.index(word.startIndex, offsetBy: 1))])\n    \n    // 6. Return\
    \ an empty string if the nearest vowel is not found.\n    if indexBeforeVowel\
    \ != -1 && indexBeforeVowel != indexAfterVowel {\n        return \"\"\n    } else\
    \ {\n        return sortedAllVowels[indexAfterVowel]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7osv24qg.swift:27:59: error: value of type 'String' has no member\
    \ 'isContains'\n    sortedAllConsonants = sortedConsonants.filter { !word.isContains($0)\
    \ }\n                                                     ~~~~ ^~~~~~~~~~\n/tmp/tmp7osv24qg.swift:27:25:\
    \ error: cannot assign value of type '[String.Element]' (aka 'Array<Character>')\
    \ to type '[String]'\n    sortedAllConsonants = sortedConsonants.filter { !word.isContains($0)\
    \ }\n                        ^\n/tmp/tmp7osv24qg.swift:27:25: note: arguments\
    \ to generic parameter 'Element' ('String.Element' (aka 'Character') and 'String')\
    \ are expected to be equal\n    sortedAllConsonants = sortedConsonants.filter\
    \ { !word.isContains($0) }\n                        ^\n/tmp/tmp7osv24qg.swift:28:51:\
    \ error: value of type 'String' has no member 'isContains'\n    sortedAllVowels\
    \ = sortedVowels.filter { !word.isContains($0) }\n                           \
    \                  ~~~~ ^~~~~~~~~~\n/tmp/tmp7osv24qg.swift:28:21: error: cannot\
    \ assign value of type '[Any]' to type '[String]'\n    sortedAllVowels = sortedVowels.filter\
    \ { !word.isContains($0) }\n                    ^\n/tmp/tmp7osv24qg.swift:28:21:\
    \ note: arguments to generic parameter 'Element' ('Any' and 'String') are expected\
    \ to be equal\n    sortedAllVowels = sortedVowels.filter { !word.isContains($0)\
    \ }\n                    ^\n/tmp/tmp7osv24qg.swift:31:66: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n    let indexAfterVowel\
    \ = sortedAllConsonants.firstIndex(of: word[word.index(word.startIndex, offsetBy:\
    \ word.index(word.endIndex, offsetBy: 1)) - 1])\n                            \
    \                                     ^\n/tmp/tmp7osv24qg.swift:31:67: error:\
    \ instance method 'index(_:offsetBy:)' requires that 'String.Index' conform to\
    \ 'BinaryInteger'\n    let indexAfterVowel = sortedAllConsonants.firstIndex(of:\
    \ word[word.index(word.startIndex, offsetBy: word.index(word.endIndex, offsetBy:\
    \ 1)) - 1])\n                                                                \
    \  ^\nSwift.Collection:3:17: note: where 'T' = 'String."
  stdout: ''
  timestamp: 1660030476
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let charArray = word.characters.split(separator: \"\\u{0964}\").map(String.init)\
    \ else {\n        return \"\"\n    }\n    let reverseArray = charArray.enumerated().reverse()\n\
    \    for (_, char) in reverseArray {\n        if char as! String == \"a\" || char\
    \ as! String == \"A\" {\n            return char\n        } else if char as! String\
    \ == \"e\" || char as! String == \"E\" {\n            return char\n        } else\
    \ if char as! String == \"i\" || char as! String == \"I\" {\n            return\
    \ char\n        } else if char as! String == \"o\" || char as! String == \"O\"\
    \ {\n            return char\n        } else if char as! String == \"u\" || char\
    \ as! String == \"U\" {\n            return char\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpinz9zkhu.swift:17:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let charArray = word.characters.split(separator:\
    \ \"\\u{0964}\").map(String.init) else {\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpinz9zkhu.swift:17:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String]'\n\
    \    guard let charArray = word.characters.split(separator: \"\\u{0964}\").map(String.init)\
    \ else {\n          ^               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpinz9zkhu.swift:20:47: error: value of type 'EnumeratedSequence<[String]>'\
    \ has no member 'reverse'\n    let reverseArray = charArray.enumerated().reverse()\n\
    \                       ~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpinz9zkhu.swift:21:5:\
    \ error: failed to produce diagnostic for expression; please submit a bug report\
    \ (https://swift.org/contributing/#reporting-bugs) and include the project\n \
    \   for (_, char) in reverseArray {\n    ^\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar index\
    \ = 0\n\tfor _ in word{\n\t\tindex = index + 1\n\t}\n\t\n\tvar vowel = String()\n\
    \tif let vowel = word.rangeOfString(\"aeiouy\") {\n\t\tlet index1 = word.distance(from:\
    \ word.startIndex, to: vowel.upperBound, in: word)\n\t\tlet index2 = word.distance(from:\
    \ vowel.upperBound, to: word.endIndex, in: word)\n\t\tlet word2 = word.substring(from:\
    \ index2, to: word.endIndex)\n\t\tlet vowel2 = word2.rangeOfString(\"aeiouy\"\
    )\n\t\tif index1 == index2 {\n\t\t\treturn vowel2.lowerBound\n\t\t} else if index1\
    \ < index2 {\n\t\t\treturn vowel2.lowerBound\n\t\t} else if index1 > index2 {\n\
    \t\t\treturn vowel2.upperBound\n\t\t} else {\n\t\t\treturn vowel2.upperBound\n\
    \t\t}\n\t}\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp2dcy_yt.swift:23:22: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if let vowel = word.rangeOfString(\"aeiouy\") {\n \
    \                      ~~~~ ^~~~~~~~~~~~~\n/tmp/tmpp2dcy_yt.swift:24:79: error:\
    \ extra argument 'in' in call\n                let index1 = word.distance(from:\
    \ word.startIndex, to: vowel.upperBound, in: word)\n                         \
    \                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpp2dcy_yt.swift:25:77:\
    \ error: extra argument 'in' in call\n                let index2 = word.distance(from:\
    \ vowel.upperBound, to: word.endIndex, in: word)\n                           \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpp2dcy_yt.swift:26:20:\
    \ error: value of type 'String' has no member 'substring'\n                let\
    \ word2 = word.substring(from: index2, to: word.endIndex)\n                  \
    \          ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var result = \"\"\n    var i\
    \ = 0\n    let upper = word.unicodeScalars.filter() {\n        guard $0.isUppercase\
    \ else { return false }\n        return true\n    }\n    var lastLetter = upper.count\
    \ - 1\n    var letterIndex = 0\n    while i < word.count {\n        let currentLetter\
    \ = upper[i]\n        let currentIndex = word.index(currentLetter, offsetBy: i,\
    \ limitedBy: word.endIndex)\n        letterIndex = currentIndex\n        if currentLetter\
    \ != \"A\" && currentLetter != \"a\" {\n            let lowerLetter = upper[lastLetter]\n\
    \            let lowerIndex = word.index(lowerLetter, offsetBy: lastLetter, limitedBy:\
    \ word.endIndex)\n            if currentIndex < lowerIndex {\n               \
    \ lastLetter = letterIndex\n                letterIndex = currentIndex\n     \
    \       }\n        }\n        i += 1\n    }\n    let vowel = upper[lastLetter]\n\
    \    let lowerLetter = upper[lastLetter]\n    if lowerLetter != \"a\" && vowel\
    \ != \"A\" && vowel != \"a\" {\n        return \"\"\n    }\n    if vowel != lowerLetter\
    \ {\n        return \"\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5mulcly5.swift:23:18: error: value of type 'Unicode.Scalar' has\
    \ no member 'isUppercase'\n        guard $0.isUppercase else { return false }\n\
    \              ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = CharacterSet.vowels\n\
    \    var vowelSet = Set<Character>()\n    for char in word {\n        vowels.insert(char)\n\
    \    }\n    var result = \"\"\n    \n    var index = 0\n    while index < word.count\
    \ {\n        if word[index] == vowels.first! {\n            vowelSet.insert(word[index])\n\
    \            index += 1\n        } else {\n            index = word.index(word[index\
    \ - 1], offsetBy: 1)\n        }\n        if index == word.count - 1 {\n      \
    \      if vowelSet.count == 0 {\n                return \"\"\n            } else\
    \ {\n                result = vowelSet.first!\n            }\n        } else {\n\
    \            vowelSet.insert(word[index])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvaixv3sr.swift:20:18: error: cannot find 'CharacterSet' in scope\n\
    \    var vowels = CharacterSet.vowels\n                 ^~~~~~~~~~~~\n/tmp/tmpvaixv3sr.swift:30:29:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            vowelSet.insert(word[index])\n    \
    \                        ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpvaixv3sr.swift:33:36: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \            index = word.index(word[index - 1], offsetBy: 1)\n              \
    \                     ^\n/tmp/tmpvaixv3sr.swift:33:26: error: cannot assign value\
    \ of type 'String.Index' to type 'Int'\n            index = word.index(word[index\
    \ - 1], offsetBy: 1)\n                    ~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvaixv3sr.swift:39:40: error: cannot assign value of type 'Character' to\
    \ type 'String'\n                result = vowelSet.first!\n                  \
    \       ~~~~~~~~~~~~~~^\n/tmp/tmpvaixv3sr.swift:42:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            vowelSet.insert(word[index])\n                            ^~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.hasPrefix(\"y\") || word.hasPrefix(\"Y\") || word.hasPrefix(\"u\") || word.hasPrefix(\"\
    U\") {\n        return \"\"\n    }\n    guard let letters = word.unicodeScalars\
    \ else {\n        return \"\"\n    }\n    let vowelPositions = getVowelPositions(fromRight:\
    \ letters)\n    let vowels = vowelPositions.filter { vowel in\n        word.unicodeScalars.indices.contains(vowel.position)\n\
    \    }\n    return vowels.isEmpty ? \"\" : vowels[vowels.count - 1].scalar.stringValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpc01qgbfa.swift:20:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String.UnicodeScalarView'\n    guard let letters\
    \ = word.unicodeScalars else {\n          ^             ~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpc01qgbfa.swift:23:26: error: cannot find 'getVowelPositions' in scope\n\
    \    let vowelPositions = getVowelPositions(fromRight: letters)\n            \
    \             ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for letter in\
    \ word.characters.reverse() {\n        if let index = vowels.firstIndex(of: letter)\
    \ {\n            vowels.remove(at: index)\n            if vowels.isEmpty {\n \
    \               return letter\n            }\n        }\n    }\n    return \"\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4lmwipp5.swift:18:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for letter in word.characters.reverse() {\n                 \
    \ ~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660030475
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var index = 0\n    var vowelIndex:\
    \ Int = 0\n    var vowel: String = String()\n    var consonantIndex: Int = 0\n\
    \    var consonant: String = String()\n    var result = String()\n    var currentIndex\
    \ = 0\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n    for char\
    \ in word {\n        currentIndex += 1\n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            vowel =\
    \ String(vowels[vowelIndex])\n        } else {\n            consonant = String(char)\n\
    \        }\n        if vowel == consonant {\n            if vowelIndex != 0 &&\
    \ vowelIndex < 4 {\n                vowelIndex += 1\n            } else if vowelIndex\
    \ == 0 {\n                vowelIndex = 1\n            } else {\n             \
    \   vowelIndex = 0\n            }\n            consonantIndex += 1\n        }\
    \ else if currentIndex == 0 {\n            if vowelIndex != 4 {\n            \
    \    vowelIndex += 1\n            } else {\n                vowelIndex = 0\n \
    \           }\n        } else {\n            if vowelIndex != 0 {\n          \
    \      vowelIndex += 1\n            } else if vowelIndex == 0 {\n            \
    \    vowelIndex = 1\n            } else {\n                vowelIndex = 0\n  \
    \          }\n            consonantIndex += 1\n        }\n        if vowelIndex\
    \ == 0 && consonantIndex == 0 {\n            result = vowel\n            break\n\
    \        }\n        if vowelIndex == 0 && consonantIndex == 1 {\n            result\
    \ = consonant\n            break\n        }\n        if vowelIndex == 0 && consonantIndex\
    \ == 2 {\n            result = vowel\n            break\n        }\n        if\
    \ vowelIndex == 0 && consonantIndex == 3 {\n            result = consonant\n \
    \           break\n        }\n        if vowelIndex == 0 && consonantIndex ==\
    \ 4 {\n            result = vowel\n            break\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpjt0lpto9/tmpjt0lpto9.swift:97: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6877ea2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6877b99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6877b99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6877b987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjt0lpto9                        0x00005606a2f917e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b687808e460 __libc_start_main +
    245

    6    tmpjt0lpto9                        0x00005606a2f91429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660030476
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvm1h47tu/tmpvm1h47tu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc1ffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc1cf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc1cf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc1cf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm1h47tu                        0x000055c5bb383307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7dc21e7460 __libc_start_main +
    245

    6    tmpvm1h47tu                        0x000055c5bb382f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    word\
    \ = word.lowercased()\n    vowels = \"aeiou\".lowercased()\n    var letterIndex\
    \ = 0\n    var vowelIndex = 0\n    var letter = String()\n    var vowel = String()\n\
    \    if word.characters.count < 2 {\n        return \"\"\n    }\n    for i in\
    \ 0 ..< word.characters.count {\n        if word.characters[i] >= 'a' && word.characters[i]\
    \ <= 'z' {\n            letter = String(word.characters[i:i+1])\n            if\
    \ letter in vowels {\n                vowelIndex = vowels.firstIndex(of: letter)!\n\
    \                vowel = String(vowels[vowelIndex])\n                if vowel\
    \ in vowels {\n                    if letter < vowel {\n                     \
    \   return \"\"\n                    } else {\n                        return\
    \ vowel\n                    }\n                }\n            }\n           \
    \ letterIndex = word.characters.index(of: letter)!\n        } else {\n       \
    \     letterIndex = word.characters.index(of: \" \")!\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkxf4q3f5.swift:27:34: error: single-quoted string literal found,\
    \ use '\"'\n        if word.characters[i] >= 'a' && word.characters[i] <= 'z'\
    \ {\n                                 ^~~\n                                 \"\
    a\"\n/tmp/tmpkxf4q3f5.swift:27:63: error: single-quoted string literal found,\
    \ use '\"'\n        if word.characters[i] >= 'a' && word.characters[i] <= 'z'\
    \ {\n                                                              ^~~\n     \
    \                                                         \"z\"\n/tmp/tmpkxf4q3f5.swift:29:23:\
    \ error: expected '{' after 'if' condition\n            if letter in vowels {\n\
    \                      ^\n/tmp/tmpkxf4q3f5.swift:32:26: error: expected '{' after\
    \ 'if' condition\n                if vowel in vowels {\n                     \
    \    ^\n/tmp/tmpkxf4q3f5.swift:17:5: error: cannot assign to value: 'word' is\
    \ a 'let' constant\n    word = word.lowercased()\n    ^~~~\n/tmp/tmpkxf4q3f5.swift:18:5:\
    \ error: cannot find 'vowels' in scope\n    vowels = \"aeiou\".lowercased()\n\
    \    ^~~~~~\n/tmp/tmpkxf4q3f5.swift:23:13: error: 'characters' is unavailable:\
    \ Please use String directly\n    if word.characters.count < 2 {\n           \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpkxf4q3f5.swift:26:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ 0 ..< word.characters.count {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpkxf4q3f5.swift:27:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if word.characters[i] >= 'a' && word.characters[i] <= 'z' {\n       \
    \    ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpkxf4q3f5.swift:27:17: error: 'characters' is unavailable:\
    \ Please use String di"
  stdout: ''
  timestamp: 1660030476
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpufwr47il/tmpufwr47il.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86c44bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86c41b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86c41b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86c41b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpufwr47il                        0x000056320ca69307 <unavailable> + 4871

    5    libc.so.6                          0x00002b86c46ab460 __libc_start_main +
    245

    6    tmpufwr47il                        0x000056320ca68f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660030474
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ leftIndex = 0\n    var rightIndex = word.count\n    var currentVowel: String\
    \ = \"\"\n    while leftIndex < rightIndex {\n        let currentChar = String(word.characters[leftIndex])\n\
    \        let currentCharLen = currentChar.characters.count\n        if currentCharLen\
    \ == 3 {\n            currentVowel = String(currentChar.characters.dropFirst())\n\
    \        } else if currentCharLen == 2 && currentChar.hasSuffix(with: currentChar)\
    \ {\n            currentVowel = \"\"\n        } else {\n            currentVowel\
    \ = \"\"\n        }\n        if currentVowel != \"\" {\n            if currentVowel.hasSuffix(\"\
    AEIOU\") {\n                return currentVowel\n            }\n        }\n  \
    \      if currentCharLen == 2 {\n            if currentChar.hasSuffix(\"a\") {\n\
    \                leftIndex++\n            }\n            if currentChar.hasSuffix(\"\
    e\") {\n                leftIndex++\n            }\n            if currentChar.hasSuffix(\"\
    i\") {\n                leftIndex++\n            }\n            if currentChar.hasSuffix(\"\
    o\") {\n                leftIndex++\n            }\n            if currentChar.hasSuffix(\"\
    u\") {\n                leftIndex++\n            }\n            if currentChar.hasSuffix(\"\
    y\") {\n                rightIndex--\n            }\n        }\n        leftIndex++\n\
    \    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpzf70nm3j.swift:21:34: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let currentChar\
    \ = String(word.characters[leftIndex])\n                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpzf70nm3j.swift:21:39:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = String(word.characters[leftIndex])\n                         \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzf70nm3j.swift:22:42: error: 'characters' is unavailable: Please\
    \ use String directly\n        let currentCharLen = currentChar.characters.count\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpzf70nm3j.swift:24:47: error: 'characters'\
    \ is unavailable: Please use String directly\n            currentVowel = String(currentChar.characters.dropFirst())\n\
    \                                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzf70nm3j.swift:25:63: error: extraneous\
    \ argument label 'with:' in call\n        } else if currentCharLen == 2 && currentChar.hasSuffix(with:\
    \ currentChar) {\n                                                           \
    \   ^~~~~~~\n                                                               \n\
    /tmp/tmpzf70nm3j.swift:37:26: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n                leftIndex++\n                         ^~\n/tmp/tmpzf70nm3j.swift:40:26:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      leftIndex++\n                         ^~\n/tmp/tmpzf70nm3j.swift:43:26:\
    \ error: c"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowel = \"a\"...\"z\"\n    var result = \"\"\n    var lastIndex = word.count\
    \ - 1\n    for i in 0...vowel.count {\n        let subword = word[lastIndex..<i]\n\
    \        if subword.contains(vowel) {\n            let lastChar = word[lastIndex]\n\
    \            let lastCharIndex = vowel.index(of: lastChar)!\n            let currentChar\
    \ = word[i]\n            let currentCharIndex = vowel.index(of: currentChar)!\n\
    \            let resultDistance = i - lastCharIndex\n            let resultChar\
    \ = vowel[resultDistance]\n            result = resultChar + (result[..<i]) +\
    \ (currentChar)\n            lastIndex = i\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpasfpp5f9.swift:20:18: error: referencing property 'count' on 'ClosedRange'\
    \ requires that 'String' conform to 'Strideable'\n    for i in 0...vowel.count\
    \ {\n                 ^\nSwift.ClosedRange:1:11: note: requirement from conditional\
    \ conformance of 'ClosedRange<String>' to 'Collection'\nextension ClosedRange\
    \ : Collection, BidirectionalCollection, RandomAccessCollection where Bound :\
    \ Strideable, Bound.Stride : SignedInteger {\n          ^\n/tmp/tmpasfpp5f9.swift:23:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            let lastChar = word[lastIndex]\n  \
    \                         ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpasfpp5f9.swift:24:49: error: cannot\
    \ convert value of type 'Character' to expected argument type 'ClosedRange<String>.Element'\
    \ (aka 'String')\n            let lastCharIndex = vowel.index(of: lastChar)!\n\
    \                                                ^\n/tmp/tmpasfpp5f9.swift:24:33:\
    \ error: referencing instance method 'index(of:)' on 'ClosedRange' requires that\
    \ 'String' conform to 'Strideable'\n            let lastCharIndex = vowel.index(of:\
    \ lastChar)!\n                                ^\nSwift.ClosedRange:1:11: note:\
    \ requirement from conditional conformance of 'ClosedRange<String>' to 'Collection'\n\
    extension ClosedRange : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n/tmp/tmpasfpp5f9.swift:26:36:\
    \ error: referencing instance method 'index(of:)' on 'ClosedRange' requires that\
    \ 'String' conform to 'Strideable'\n            let currentCharIndex = vowel.index(of:\
    \ currentChar)!\n                                   ^\nSwift.ClosedRange:1:11:\
    \ note: requirement from conditional conformance of 'ClosedRange<String>' to 'Collection'\n\
    extension ClosedRange : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Strid"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel = \"\"\n    for char in word.characters {\n        if char.unicodeScalars.count\
    \ >= 3 {\n            let consonants1 = \"BCDFGHJKLMNPQRSTVWXYZ\"\n          \
    \  let consonants2 = \"BCDFGHJKLMNPQRSTVWXYZ\"\n            let range = NSRange(location:\
    \ (char.location + 1), length: char.unicodeScalars.count)\n            if let\
    \ consonants1Index = consonants1.characterIndex(of: char.unicodeScalars.first!,\
    \ in: char.unicodeScalars, range: range) {\n                if consonants1Index\
    \ > char.unicodeScalars.first!.location {\n                    break\n       \
    \         }\n            }\n            let consonants2Index = consonants2.characterIndex(of:\
    \ char.unicodeScalars.last!, in: char.unicodeScalars, range: range)\n        \
    \    if consonants2Index < char.unicodeScalars.last!.location {\n            \
    \    break\n            }\n            vowel = char.unicodeScalars.last!\n   \
    \         break\n        }\n    }\n    return vowel.description\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfm98utej.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpfm98utej.swift:22:25:\
    \ error: cannot find 'NSRange' in scope\n            let range = NSRange(location:\
    \ (char.location + 1), length: char.unicodeScalars.count)\n                  \
    \      ^~~~~~~\n/tmp/tmpfm98utej.swift:22:49: error: value of type 'Character'\
    \ has no member 'location'\n            let range = NSRange(location: (char.location\
    \ + 1), length: char.unicodeScalars.count)\n                                 \
    \          ~~~~ ^~~~~~~~\n/tmp/tmpfm98utej.swift:23:51: error: value of type 'String'\
    \ has no member 'characterIndex'\n            if let consonants1Index = consonants1.characterIndex(of:\
    \ char.unicodeScalars.first!, in: char.unicodeScalars, range: range) {\n     \
    \                                 ~~~~~~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpfm98utej.swift:24:66:\
    \ error: value of type 'Unicode.Scalar' has no member 'location'\n           \
    \     if consonants1Index > char.unicodeScalars.first!.location {\n          \
    \                            ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpfm98utej.swift:28:48:\
    \ error: value of type 'String' has no member 'characterIndex'\n            let\
    \ consonants2Index = consonants2.characterIndex(of: char.unicodeScalars.last!,\
    \ in: char.unicodeScalars, range: range)\n                                   ~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~\n/tmp/tmpfm98utej.swift:29:61: error: value of type 'Unicode.Scalar'\
    \ has no member 'location'\n            if consonants2Index < char.unicodeScalars.last!.location\
    \ {\n                                  ~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpfm98utej.swift:32:45:\
    \ error: cannot assign value of type 'Unicode.Scalar' to type 'String'\n     \
    \       vowel = char.unicodeScalars.last!\n                    ~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    word\
    \ = word.lowercased()\n    guard word.isEmpty == false else {\n        return\
    \ \"\"\n    }\n    var vowels = set(\"aeiou\")\n    for var i = 0; i < word.count\
    \ - 1; i++ {\n        if vowels.contains(word[i]) {\n            if word.index(word,\
    \ startIndex: i, offsetBy: -1) == word.index(word, startIndex: i + 1, offsetBy:\
    \ -1) {\n                return word[i]\n            }\n        }\n    }\n   \
    \ return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpb8np_lbc.swift:22:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < word.count - 1; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb8np_lbc.swift:17:5: error: cannot assign to value: 'word' is a 'let'\
    \ constant\n    word = word.lowercased()\n    ^~~~\n/tmp/tmpb8np_lbc.swift:21:18:\
    \ error: cannot find 'set' in scope\n    var vowels = set(\"aeiou\")\n       \
    \          ^~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [ \"a\",\"e\",\"i\",\"o\",\"u\" ];\n    let vowelIndexes = word.characters.enumerate().filter({\
    \ vowels.contains($0.element) }).map{ $0.offset }\n    \n    guard vowelIndexes.count\
    \ > 0 else {\n        return \"\"\n    }\n    \n    return word.substring(vowelIndexes.max(),\
    \ word.characters.count).lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfuiqoxvx.swift:18:40: error: value of type 'String' has no member\
    \ 'enumerate'\n    let vowelIndexes = word.characters.enumerate().filter({ vowels.contains($0.element)\
    \ }).map{ $0.offset }\n                       ~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpfuiqoxvx.swift:24:17:\
    \ error: value of type 'String' has no member 'substring'\n    return word.substring(vowelIndexes.max(),\
    \ word.characters.count).lowercased()\n           ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ closestVowel(word, toRange: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_85m7ycw.swift:17:12: error: cannot find 'closestVowel' in scope\n\
    \    return closestVowel(word, toRange: 0)\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ let word = word {\n        var index1 = word.startIndex\n        var index2\
    \ = word.endIndex\n        \n        while index1 > 0 && index2 < word.endIndex\
    \ {\n            if word[index1] == \"a\" || word[index1] == \"e\" || word[index1]\
    \ == \"i\" || word[index1] == \"o\" || word[index1] == \"u\" || word[index1] ==\
    \ \"A\" || word[index1] == \"E\" || word[index1] == \"I\" || word[index1] == \"\
    O\" || word[index1] == \"U\" {\n                index1--\n            } else {\n\
    \                index2--\n            }\n        }\n        \n        return\
    \ word.substringFromIndex(index2)\n    } else {\n        return \"\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7j_tvnvu.swift:21:22: error: referencing operator function '>'\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \        while index1 > 0 && index2 < word.endIndex {\n                     ^\n\
    Swift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\nextension BinaryInteger\
    \ {\n          ^\n/tmp/tmp7j_tvnvu.swift:23:23: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n                index1--\n                 \
    \     ^~\n/tmp/tmp7j_tvnvu.swift:25:23: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n                index2--\n                      ^~\n/tmp/tmp7j_tvnvu.swift:29:21:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n        return\
    \ word.substringFromIndex(index2)\n               ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7j_tvnvu.swift:17:8:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    if let word = word {\n       ^          ~~~~\n"
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ get the vowel string\n    let vowels = \"AEIOUaeiou\"\n    \n    // get the\
    \ current word\n    let currentWord = word.characters.reversed()\n    \n    //\
    \ get the first and last consonants\n    let firstConsonant = currentWord.first!\n\
    \    let lastConsonant = currentWord.last!\n    \n    // get the length of the\
    \ current word\n    let currentWordLength = (currentWord as NSString).length\n\
    \    \n    // find the current vowel by comparing with the word from the right\
    \ side\n    let currentVowelIndex = vowels.characters.firstIndex(of: lastConsonant)!\n\
    \    \n    // find the closest vowel from the right side of the word\n    let\
    \ vowelIndex = (currentVowelIndex - 1) % vowels.characters.count\n    \n    //\
    \ get the vowel by comparing with the word from the left side\n    let currentVowelFromLeftSide\
    \ = vowels.characters[vowelIndex]\n    \n    // return an empty string if none\
    \ of the conditions are met\n    if currentWordLength < 1 || currentWordLength\
    \ > currentWord.characters.count || currentVowelIndex < 0 || currentVowelIndex\
    \ > currentWord.characters.count || vowelIndex < 0 || vowelIndex > currentWord.characters.count\
    \ {\n        return \"\"\n    }\n    \n    // return an empty string if the first\
    \ vowel from the right side of the word doesn't met the conditions\n    if vowels.characters.count\
    \ > currentVowelFromLeftSide.count {\n        return \"\"\n    }\n    \n    //\
    \ return the vowel that met the conditions\n    return vowels[vowelIndex]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqn8ztywk.swift:21:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let currentWord = word.characters.reversed()\n    \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqn8ztywk.swift:28:45: error: cannot find type 'NSString'\
    \ in scope\n    let currentWordLength = (currentWord as NSString).length\n   \
    \                                         ^~~~~~~~\n/tmp/tmpqn8ztywk.swift:28:55:\
    \ error: value of type 'ReversedCollection<String>' has no member 'length'\n \
    \   let currentWordLength = (currentWord as NSString).length\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpqn8ztywk.swift:31:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    let currentVowelIndex\
    \ = vowels.characters.firstIndex(of: lastConsonant)!\n                       \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpqn8ztywk.swift:34:23: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    let vowelIndex = (currentVowelIndex - 1)\
    \ % vowels.characters.count\n                      ^\n/tmp/tmpqn8ztywk.swift:40:65:\
    \ error: value of type 'ReversedCollection<String>' has no member 'characters'\n\
    \    if currentWordLength < 1 || currentWordLength > currentWord.characters.count\
    \ || currentVowelIndex < 0 || currentVowelIndex > currentWord.characters.count\
    \ || vowelIndex < 0 || vowelIndex > currentWord.characters.count {\n         \
    \                                           ~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqn8ztywk.swift:40:142:\
    \ error: value of type 'ReversedCollection<String>' has no member 'characters'\n\
    \    if currentWordLength < 1 || currentWordLength > currentWord.characters.count\
    \ || currentVowelIndex < 0 || currentVowelIndex > currentWord.characters.count\
    \ || vowelIndex < 0 || vowelIndex > currentWord.characters.count {\n         \
    \                              "
  stdout: ''
  timestamp: 1660030476
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set([\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\"\
    , \"U\"])\n    if let first = word.index(word.startIndex, offsetBy: 1),\n    \
    \    let last = word.index(word.endIndex, offsetBy: -1)\n    {\n        let leftIndex\
    \ = first\n        let rightIndex = last\n        let leftSubstring = word[leftIndex]\n\
    \        let rightSubstring = word[rightIndex]\n        \n        if let leftSubstringIndex\
    \ = leftSubstring?.unicodeScalars.firstIndex(of: leftSubstring),\n           \
    \ let rightSubstringIndex = rightSubstring?.unicodeScalars.firstIndex(of: rightSubstring)\
    \ {\n            \n            let leftSubstringLength = leftSubstringIndex ==\
    \ nil ? 0 : leftSubstring!.unicodeScalars.count - leftSubstringIndex!\n      \
    \      let rightSubstringLength = rightSubstringIndex == nil ? 0 : rightSubstring!.unicodeScalars.count\
    \ - rightSubstringIndex!\n            \n            if leftSubstringLength > rightSubstringLength\
    \ {\n                if let index = leftSubstring.unicodeScalars.index(leftSubstring.unicodeScalars.startIndex,\
    \ offsetBy: rightSubstringLength) {\n                    return vowels.contains(word[index])\n\
    \                    \n                } else if let index = rightSubstring.unicodeScalars.index(rightSubstring.unicodeScalars.endIndex,\
    \ offsetBy: leftSubstringLength) {\n                    return vowels.contains(word[index])\n\
    \                    \n                } else {\n                    return false\n\
    \                }\n                \n            } else if rightSubstringLength\
    \ > leftSubstringLength {\n                if let index = rightSubstring.unicodeScalars.index(rightSubstring.unicodeScalars.endIndex,\
    \ offsetBy: leftSubstringLength) {\n                    return vowels.contains(word[index])\n\
    \                    \n                } else if let index = leftSubstring.unicodeScalars.index(leftSubstring.unicodeScalars.startIndex,\
    \ offsetBy: rightSubstringLength) {\n                    return vowels.contains(word[index])\n\
    \                    \n                } else {\n                    return false\n\
    \                }\n            } else {\n                return false\n     \
    \       }\n            \n        }\n        \n    }\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpebjb9qj_.swift:26:50: error: cannot use optional chaining on non-optional\
    \ value of type 'Character'\n        if let leftSubstringIndex = leftSubstring?.unicodeScalars.firstIndex(of:\
    \ leftSubstring),\n                                    ~~~~~~~~~~~~~^\n      \
    \                                           \n/tmp/tmpebjb9qj_.swift:26:82: error:\
    \ cannot convert value of type 'Character' to expected argument type 'Unicode.Scalar'\n\
    \        if let leftSubstringIndex = leftSubstring?.unicodeScalars.firstIndex(of:\
    \ leftSubstring),\n                                                          \
    \                       ^\n/tmp/tmpebjb9qj_.swift:27:53: error: cannot use optional\
    \ chaining on non-optional value of type 'Character'\n            let rightSubstringIndex\
    \ = rightSubstring?.unicodeScalars.firstIndex(of: rightSubstring) {\n        \
    \                              ~~~~~~~~~~~~~~^\n                             \
    \                       \n/tmp/tmpebjb9qj_.swift:27:85: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Unicode.Scalar'\n     \
    \       let rightSubstringIndex = rightSubstring?.unicodeScalars.firstIndex(of:\
    \ rightSubstring) {\n                                                        \
    \                            ^\n/tmp/tmpebjb9qj_.swift:29:84: error: cannot force\
    \ unwrap value of non-optional type 'Character'\n            let leftSubstringLength\
    \ = leftSubstringIndex == nil ? 0 : leftSubstring!.unicodeScalars.count - leftSubstringIndex!\n\
    \                                                                      ~~~~~~~~~~~~~^\n\
    \                                                                            \
    \       \n/tmp/tmpebjb9qj_.swift:30:87: error: cannot force unwrap value of non-optional\
    \ type 'Character'\n            let rightSubstringLength = rightSubstringIndex\
    \ == nil ? 0 : rightSubstring!.unicodeScalars.count - rightSubstringIndex!\n \
    \                                                                       ~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \          \n/tmp/tmpebjb9qj_.sw"
  stdout: ''
  timestamp: 1660030476
