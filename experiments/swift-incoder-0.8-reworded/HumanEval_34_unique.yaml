name: HumanEval_34_unique
language: swift
prompt: "\n/// Return sorted unique elements in an array\n/// >>> unique(l: [5, 3,\
  \ 5, 2, 3, 3, 9, 0, 123])\n/// [0, 2, 3, 5, 9, 123]\nfunc unique(l: [Int]) -> [Int]\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\
  \ == [0, 2, 3, 5, 9, 123])"
completions: ["  var uniques: [Int] = []\n  for uniqueInt in l {\n    if !contains(uniques,\
    \ uniqueInt) {\n      uniques.append(uniqueInt)\n    }\n  }\n  return uniques",
  "    var res: [Int] = []\n    for el in l {\n        if res.contains(el) {\n   \
    \         continue\n        }\n        res.append(el)\n    }\n    return res",
  '  return Array(Set(l)).sorted()', "    var result = Set<Int>()\n    for x in l\
    \ {\n        if !result.contains(x) {\n            result.insert(x)\n        }\n\
    \    }\n    return result.sorted()", "    var indexSet = Set()\n    var result\
    \ = [Int]()\n    for x in l {\n        if !indexSet.contains(x) {\n          \
    \  indexSet.add(x)\n            result.append(x)\n        }\n    }\n    return\
    \ result", "    var result: [Int] = []\n    for val in l {\n        if !contains(&result,\
    \ val) { result = result + [val] }\n    }\n    return result", "    var result\
    \ = [Int]()\n    for a in l {\n        if !result.contains(a) {\n            result.append(a)\n\
    \        }\n    }\n    return result", "    var a = l\n    for x in a {\n    \
    \    if a.contains(x) {\n            a = a.filter {$0 != x}\n        } else {\n\
    \            a.append(x)\n        }\n    }\n    return a", "    var result = [Int]()\n\
    \    for e in l {\n        if !contains(&result, e) {\n            result.append(e)\n\
    \        }\n    }\n    return result", "    var uniques = [Int]()\n    for n in\
    \ l {\n        if uniques.contains(n) {\n            continue\n        }\n   \
    \     uniques.append(n)\n    }\n    return uniques", "  var result = [Int]()\n\
    \  for item in l {\n    if !contains(&result, item) {\n      append(&result, item)\n\
    \    }\n  }\n  return result", '    return l.filter { !contains(l, $0) }.sorted()',
  "    var result: [Int] = []\n    for number in l {\n        if !contains(result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  "    \n    var result: [Int] = []\n    \n    for number in l {\n        if !contains(&result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    \n    return\
    \ result", "    var i = 0\n    var unique = [Int]()\n    for el in l {\n     \
    \   while i < l.count && el == l[i] {\n            i += 1\n        }\n       \
    \ if i == 0 {\n            unique.append(el)\n        } else {\n            while\
    \ i < l.count && el == l[i] {\n                i += 1\n            }\n       \
    \     unique.append(el)\n        }\n    }\n    return unique", "    var uniqueArray\
    \ = [Int]()\n    for ele in l {\n        if uniqueArray.contains(ele) {\n    \
    \        continue\n        } else {\n            uniqueArray.append(ele)\n   \
    \     }\n    }\n    return uniqueArray", "    let set = NSSet(array: l)\n    return\
    \ Array(set.allObjects)", "    let s = Set(l)\n    return Array(s)", '    return
    Set(l).sorted().map { l[$0] }', "  var result = Set()\n  for el in l {\n    result.insert(el)\n\
    \  }\n  return result.sorted().array()", "    var i = 0\n    var out = [Int]()\n\
    \    for el in l {\n        if !contains(out, el) {\n            out.append(el)\n\
    \            i += 1\n        }\n    }\n    return out", "    var res = [Int]()\n\
    \    for i in l {\n        if !contains(&res, i) {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res", "    let set: Set<Int> = Set()\n    var\
    \ result: [Int] = []\n    for x in l {\n        if !set.contains(x) {\n      \
    \      result.append(x)\n            set.insert(x)\n        }\n    }\n    return\
    \ result", "    let set: Set<Int> = Set(l)\n    return Array(set)", "    var res\
    \ = [Int]()\n    for el in l {\n        if !contains(res, el) {\n            res.append(el)\n\
    \        }\n    }\n    return res", "    var seen = Set()\n    var result: [Int]\
    \ = []\n    for elt in l {\n        if !seen.contains(elt) {\n            seen.insert(elt)\n\
    \            result.append(elt)\n        }\n    }\n    return result", "    var\
    \ result: [Int] = []\n    \n    for element in l {\n        if !contains(result,\
    \ element) {\n            result.append(element)\n        }\n    }\n    \n   \
    \ return result", "    var result = [Int]()\n    var set = Set<Int>()\n    for\
    \ x in l {\n        if !set.isEmpty {\n            set.insert(x)\n           \
    \ continue\n        }\n        result.insert(x)\n    }\n    return result", '    return
    Array(Set(l))', '  return Array(Set(l))', '    return Array(Set(l))', "    var\
    \ set = Set<Int>()\n    return l.filter { set.insert($0).inserted }", "    var\
    \ result: [Int] = []\n    for value in l {\n        if result.contains(value)\
    \ {\n            continue\n        }\n        result.append(value)\n    }\n  \
    \  return result", "    var result: [Int] = []\n    for x in l {\n        if !contains(&result,\
    \ &x) {\n            result = append(result, x)\n        }\n    }\n    return\
    \ result", "    if l == nil {\n        return []\n    }\n    \n    let dict =\
    \ Dictionary<Int, Bool>()\n    var uniq = [Int]()\n    for v in l {\n        if\
    \ let key = dict.objectForKey(v) {\n            uniq.append(v)\n        } else\
    \ {\n            dict[v] = true\n        }\n    }\n    \n    return uniq", " \
    \   var result: [Int] = []\n    for x in l {\n        if !result.contains(x) {\n\
    \            result.append(x)\n        }\n    }\n    return result", "    let\
    \ resultSet = NSMutableSet(array: l)\n    return Array(resultSet.allObjects)",
  '    return uniquify(l)', "    let count = l.count\n    var unique = [Int]()\n \
    \   for idx in 0..<count {\n        if unique.contains(l[idx]) {\n           \
    \ continue\n        }\n        unique.append(l[idx])\n    }\n    return unique",
  "    var seen = [Int]()\n    for x in l {\n        if !seen.contains(x) {\n    \
    \        seen.append(x)\n        }\n    }\n    return seen", "    var unique =\
    \ [Int]()\n    for el in l {\n        if !contains(unique, el) {\n           \
    \ unique.append(el)\n        }\n    }\n    return unique", "    l.sort()\n   \
    \ var result = [Int]()\n    for i : Int in l.indices {\n        if !contains(&result,\
    \ i) {\n            result = append(result, i)\n        }\n    }\n    return result",
  "    var result = [Int]()\n    for x in l {\n        if !result.contains(x) {\n\
    \            result.append(x)\n        }\n    }\n    return result", "    var\
    \ seen: [Int] = [0]\n    var result = [Int]()\n    for e in l {\n        if seen[0]\
    \ != e {\n            seen = [e]\n            result = [e]\n        }\n    }\n\
    \    return result", "    var result = [Int]()\n    var seen = [Bool]()\n    for\
    \ val in l {\n        if seen[val] {\n            continue\n        } else {\n\
    \            seen[val] = true\n            result.append(val)\n        }\n   \
    \ }\n    return result", "    l.sort()\n    var u: [Int] = []\n    for x in l\
    \ {\n        if !contains(u, x) {\n            u.append(x)\n        }\n    }\n\
    \    return u", "    var seen = [Int]()\n    return filter(l, { i in\n       \
    \ if seen.contains(i) {\n            return false\n        }\n        seen.append(i)\n\
    \        return true\n    })", "    let result: [Int] = []\n    let set = Set<Int>()\n\
    \    l.forEach { n in\n        if set.contains(n) {\n            set.insert(n)\n\
    \        } else {\n            append(n, &result)\n        }\n    }\n    return\
    \ result", "    var result = [Int]()\n    var prev: Int = l[0]\n    for i in l\
    \ {\n        if i == prev {\n            continue\n        }\n        prev = i\n\
    \        result.append(i)\n    }\n    return result.sort()", '    return l.sort()',
  "    var seen:[Int] = Array(count: l.count, repeatedValue: -1)\n    var filtered:[Int]\
    \ = Array(count: l.count, repeatedValue: -1)\n    for x in l {\n        if seen[x]\
    \ != -1 {\n            filtered[seen[x]] = x\n        } else {\n            seen[x]\
    \ = l.count\n            filtered[l.count] = x\n        }\n    }\n    return filtered",
  "    var i = 0\n    var arr: [Int] = []\n    while i < l.count {\n        if arr\
    \ != nil && arr!.contains(l[i]) {\n            i += 1\n        } else {\n    \
    \        arr.append(l[i])\n        }\n    }\n    return arr", "    l.sort()\n\
    \    var result = l\n    for i = 1; i < l.count; i++ {\n        if l[i-1] != l[i]\
    \ {\n            result.removeAtIndex(i)\n        }\n    }\n    return result",
  "    var output = [Int]()\n    for num in l {\n        if output.contains(num) {\n\
    \            continue\n        } else {\n            output.append(num)\n    \
    \    }\n    }\n    return output", "    var result = [Int]()\n    for x in l {\n\
    \        if result.contains(x) {\n            continue\n        }\n        result.append(x)\n\
    \    }\n    return result", "    var uniqueValues: [Int] = []\n    for value in\
    \ l {\n        if !contains(uniqueValues, value) {\n            uniqueValues.append(value)\n\
    \        }\n    }\n    return uniqueValues", "    var result: [Int] = []\n   \
    \ for x in l {\n        if !contains(result, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for element\
    \ in l {\n        if result.contains(element) {\n            continue\n      \
    \  }\n        result.append(element)\n    }\n    return result", "  var result\
    \ = [Int]()\n  result = Array(Set(result))\n  return result", "    var seen: [Int]\
    \ = []\n    var result = [Int]()\n    for x in l {\n        if !contains(seen,\
    \ x) {\n            seen = append(seen, x)\n            result = append(result,\
    \ x)\n        }\n    }\n    return result", '  return l.sort()', "    var set\
    \ = Set<Int>()\n    return l.filter { set.insert($0).inserted }", "    var uniquified:\
    \ [Int] = []\n    var index: Int = 0\n    for el in l {\n        if !uniquified.contains(el)\
    \ {\n            uniquified.append(el)\n        }\n    }\n    return uniquified",
  "    var result: [Int] = []\n    for element in l {\n        guard !contains(result,\
    \ element) else {\n            continue\n        }\n        result.append(element)\n\
    \    }\n    return result", "    var result = [Int]()\n    for el in l {\n   \
    \     if !contains(result, el) {\n            result.append(el)\n        }\n \
    \   }\n    return result", "    var result = [Int]()\n    for i in l {\n     \
    \   if !contains(&result, i) {\n            result.append(i)\n        }\n    }\n\
    \    return result", '    return Set(l).sorted()', '    return Array(Set(l)).sorted()',
  "    let dict = Dictionary(uniquesOfUnsorted(l))\n    var array = [Int]()\n    for\
    \ (key, value) in dict {\n        array.append(value)\n    }\n    return array",
  "    var result: [Int] = []\n    var seen: [Int] = [0]\n    for x in l {\n     \
    \   if seen[seen[0]] == 0 {\n            seen[seen[0]] = x\n            result\
    \ += [seen[0]]\n        } else {\n            guard x != seen[seen[0]] else {\
    \ return result }\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var last: Int?\n    for element in l {\n        if !result.contains(element)\
    \ {\n            result.append(element)\n        }\n        last?.isEqualTo(element)?.ifPresent()\
    \ {\n            result.remove(last!)\n        }\n    }\n    return result", " \
    \   let seen = Set<Int>()\n    return l.filter{ seen.insert($0).inserted }", " \
    \   var result = [Int]()\n    for i in l {\n        if result.contains(i) {\n\
    \            continue\n        }\n        result.append(i)\n    }\n    return\
    \ result", '  return l.sorted().reversed()', "    let seen = Set<Int>()\n    var\
    \ result = [Int]()\n    for e in l {\n        if seen.contains(e) {\n        \
    \    continue\n        }\n        seen.insert(e)\n        result.append(e)\n \
    \   }\n    return result", "    var uniqueArray = [Int]()\n    \n    for obj in\
    \ l {\n        if !uniqueArray.contains(obj) {\n            uniqueArray.append(obj)\n\
    \        }\n    }\n    \n    return uniqueArray", "  var result = [Int]()\n  var\
    \ lastValue = l[0]\n  for element in l {\n    if element != lastValue {\n    \
    \  result.insert(element)\n    }\n  }\n  return result", '    return l.sort()',
  "    var set: [Int] = []\n    for el in l {\n        if !contains(set, el) {\n \
    \           set += [el]\n        }\n    }\n    return set", "    var seen = [Int]()\n\
    \    var unique = [Int]()\n    for value in l {\n        if !contains(seen, value)\
    \ {\n            append(seen, value)\n            append(unique, value)\n    \
    \    }\n    }\n    return unique", '    return sort(sort(l))', "    var result\
    \ = [Int]()\n    for value in l {\n        if !result.contains(value) {\n    \
    \        result.append(value)\n        }\n    }\n    return result", "    var\
    \ seen: [Int] = [0]\n    var result: [Int] = []\n    for v in l {\n        if\
    \ seen[v] == 1 {\n            continue\n        }\n        result.append(v)\n\
    \        seen[v] = 1\n    }\n    return result", '    return l.filter{ $0 != l.first
    }', "    var result: [Int] = []\n    for a in l {\n        if !contains(result,\
    \ a) {\n            result.append(a)\n        }\n    }\n    return result", " \
    \   var result: [Int] = []\n    for i in l {\n        if !contains(result, i)\
    \ {\n            result.append(i)\n        }\n    }\n    return result", "   \
    \ var result = [Int]()\n    for element in l {\n        if !result.contains(element)\
    \ {\n            result.append(element)\n        }\n    }\n    return result",
  "    var seen: [Int] = []\n    return l.filter { !seen.contains($0) }.sorted()",
  "    var uniq = Set<Int>()\n    for v in l {\n        if !uniq.contains(v) {\n \
    \           uniq.insert(v)\n        }\n    }\n    return uniq.sorted()", '    return
    Array(Set(l)).sorted()', "    let seen = Set<Int>()\n    return l.filter() { seen.insert($0).inserted\
    \ }", '    return Array(Set(l)).sorted()', "    var seen = [Int]()\n    var result\
    \ = Array(0..<l.count).map { _ in l[0] }\n    for idx in 0..<result.count {\n\
    \        if idx != 0 && result[idx] == result[idx-1] {\n            result.removeAtIndex(idx)\n\
    \        } else {\n            seen.remove(result[idx])\n            result[idx]\
    \ = l[idx]\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var seen = [Int]()\n    for x in l {\n        if !seen.contains(x) {\n  \
    \          result.append(x)\n            seen.append(x)\n        }\n    }\n  \
    \  return result", "    var seen = [Int]()\n    var result = [Int]()\n\n    for\
    \ x in l {\n        if !contains(seen, x) {\n            seen.append(x)\n    \
    \        result.append(x)\n        }\n    }\n\n    return result", "    var l1\
    \ = l\n    var l2 = []\n    for i in l1 {\n        if !inArray(l2, i) {\n    \
    \        l2.append(i)\n        }\n    }\n    return l2", "    var seen: [Int]\
    \ = []\n    return seen.filter({ seen.contains($0) }).sorted() + l.filter() {\n\
    \        if !seen.contains($0) {\n            seen.append($0)\n            return\
    \ true\n        } else {\n            return false\n        }\n    }", "    let\
    \ seen = Set()\n    var uniques = [Int]()\n    for x in l {\n        if !seen.contains(x)\
    \ {\n            uniques.append(x)\n            seen.add(x)\n        }\n    }\n\
    \    return uniques", "    var result = [Int]()\n    for e in l {\n        if\
    \ !contains(&result, e) {\n            result.append(e)\n        }\n    }\n  \
    \  return result", "    var seen = [Int]()\n    var result: [Int] = []\n    for\
    \ item in l {\n        if seen.contains(item) {\n            continue\n      \
    \  }\n        seen.append(item)\n        result.append(item)\n    }\n    return\
    \ result", "    var uniques: [Int] = []\n    for e in l {\n        if !contains(uniques,\
    \ e) {\n            uniques.append(e)\n        }\n    }\n    return uniques",
  "    let set = Set<Int>()\n    for element in l {\n        set.insert(element)\n\
    \    }\n    return Array(set)", "    var result = [Int]()\n    for v in l {\n\
    \        if !contains(result, v) {\n            result.append(v)\n        }\n\
    \    }\n    return result", "    var seen: [Int] = []\n    var result: [Int] =\
    \ []\n    for el in l {\n        if !contains(seen, el) {\n            seen.insert(el)\n\
    \            result.append(el)\n        }\n    }\n    return result", '    return
    Array(Set(l))', "    var result: [Int] = []\n    var seen: Set<Int> = []\n   \
    \ for x in l {\n        if !seen.contains(x) {\n            seen.add(x)\n    \
    \        result.append(x)\n        }\n    }\n    return result", "    var seen\
    \ = [Int]()\n    return l.filter({\n        if seen.contains($0) {\n         \
    \   return false\n        }\n        seen.append($0)\n        return true\n  \
    \  })", "    var u: Set<Int> = []\n    for x in l {\n        if u.contains(x)\
    \ {\n            continue\n        }\n        u.insert(x)\n    }\n    return u.sorted()",
  "    var uniqueSet = Set()\n    var result = [Int]()\n    for element in l {\n \
    \       if !uniqueSet.contains(element) {\n            uniqueSet.insert(element)\n\
    \            result.append(element)\n        }\n    }\n    return result", " \
    \   var result: [Int] = []\n    for x in l {\n        guard !contains(&result,\
    \ x) else {\n            continue\n        }\n        result.append(x)\n    }\n\
    \    return result", "    let uniques = Set<Int>()\n    var uniqueArray = [Int]()\n\
    \n    for a in l {\n        if !uniques.contains(a) {\n            uniques.add(a)\n\
    \            uniqueArray.append(a)\n        }\n    }\n\n    return uniqueArray",
  "    var seen = [Int]()\n    var result = [Int]()\n    for v in l {\n        if\
    \ !seen.contains(v) {\n            seen.insert(v)\n            result.append(v)\n\
    \        }\n    }\n    return result", "    var uniques = [Int]()\n    for x in\
    \ l {\n        if !uniques.contains(x) {\n            uniques.append(x)\n    \
    \    }\n    }\n    return uniques", "    var result = [Int]()\n    for element\
    \ in l {\n        if !contains(result, element) {\n            result.append(element)\n\
    \        }\n    }\n    return result", "    let l = Array(l)\n    var seen = Set<Int>()\n\
    \    var result = Array<Int>()\n\n    for v in l {\n        if !seen.contains(v)\
    \ {\n            seen.insert(v)\n            result.append(v)\n        }\n   \
    \ }\n    return result.sorted()", "    var result = [Int]()\n    for num in l\
    \ {\n        if !contains(&result, num) {\n            append(result, num)\n \
    \       }\n    }\n    return result", '    return Array(Set(l))', "    var indexSet\
    \ = [Int]()\n    for element in l {\n        if indexSet.contains(element) {\n\
    \            continue\n        } else {\n            indexSet.append(element)\n\
    \        }\n    }\n    return indexSet", "    var result: [Int] = []\n    for\
    \ x in l {\n        if !contains(result, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for i in\
    \ l {\n        if !contains(result, i) {\n            result.append(i)\n     \
    \   }\n    }\n    return result", "    var result = [Int]()\n    for value in\
    \ l {\n        if result.contains(value) {\n            continue\n        }\n\
    \        result.append(value)\n    }\n    return result", "    let resultSet =\
    \ NSMutableOrderedSet()\n    for value in l {\n        resultSet.insert(value)\n\
    \    }\n    let array: [Int] = [resultSet.array]\n    return array", "    var\
    \ seen = [Bool](count: l.count, repeatedValue: false)\n    var result = [Int](count:\
    \ l.count, repeatedValue: 0)\n    for var i = 0; i < l.count; i++ {\n        if\
    \ seen[i] == true {\n            continue\n        }\n        seen[i] = true\n\
    \        result[result.count-1] = l[i]\n    }\n    return result", "    var unique\
    \ = [Int]()\n    var i = -1\n    for e in l {\n        if !contains(e, &unique)\
    \ {\n            unique.append(e)\n        }\n    }\n    return unique", "   \
    \ var i = -1\n    var l = len(l)\n    var ls = []\n    for v in l {\n        i\
    \ += 1\n        if ls[i] == v {\n            continue\n        } else {\n    \
    \        ls[i] = v\n        }\n        ls.sort(&naturalSort(&i))\n    }\n    return\
    \ ls", "    let map: Dictionary<Int,Int> = Dictionary(unique: l)\n    return Array(map.values)",
  "    var result = [Int]()\n    for value in l {\n        if !contains(&result, value)\
    \ {\n            result.append(value)\n        }\n    }\n    return result", " \
    \   var result = [Int]()\n    l.forEach {\n        if !contains(result) {$0 =\
    \ $0}\n    }\n    return result", "    let set = Set<Int>()\n    for element in\
    \ l {\n        guard !set.isDisjoint(with: element) else {\n            return\
    \ nil\n        }\n        set.insert(element)\n    }\n    return set.sorted()",
  "    var unique: [Int] = []\n    for elt in l {\n        if !contains(unique, elt)\
    \ {\n            unique.append(elt)\n        }\n    }\n    return unique", " \
    \   let result = Array(Set(l))\n    return result as! [Int]", "    var uniques\
    \ = [Int]()\n    for v in l {\n        if !contains(uniques, v) {\n          \
    \  uniques.append(v)\n        }\n    }\n    return uniques", '  return sort(unique(sorting(l)))',
  "  var n = 0\n  var h = 1\n  var m = 0\n  for k in l {\n    if k == 0 || k == 1\
    \ {\n      continue\n    }\n    if n%2==0 {\n      if k > h {\n        h = k\n\
    \      }\n    } else {\n      if k < m {\n        m = k\n      }\n    }\n    n\
    \ = n+1\n  }\n  var k2 = h\n  var l2 = m\n  var m = n2\n  var n = l2\n  var h\
    \ = n2\n  var l = []\n  for k in l2 {\n    if k == 0 || k == 1 {\n      continue\n\
    \    }\n    if n%2==0 {\n      if k2 > h {\n        h = k2\n      }\n    } else\
    \ {\n      if k < m {\n        m = k\n      }\n    }\n    n = n+1\n    l.append(k)\n\
    \  }\n  return l", "    var result = Set()\n    for el in l {\n        if result.contains(el)\
    \ {\n            continue\n        }\n        result.insert(el)\n    }\n    return\
    \ Array(result)", '    return l.sort()', "    var set = Set<Int>()\n    for x\
    \ in l {\n        if !set.isEmpty() {\n            if x == set.removeFirst() {\n\
    \                continue\n            }\n        } else {\n            set.add(x)\n\
    \        }\n    }\n    return Array(set.sorted())", "    var seen = [Int]()\n\
    \    return l.filter { seen.contains($0) || seen.insert($0).inserted }", '  return
    l.sorted(by: >).reduce(into: [Int](), { $0[$1] = $0[$1] || $1 })', "    var uniques:\
    \ [Int] = []\n    var curr = -1\n    for i in l {\n        if i == curr {\n  \
    \          continue\n        } else {\n            curr = i\n            uniques.append(i)\n\
    \        }\n    }\n    return uniques", "    var result = [Int]()\n    for x in\
    \ l {\n        if !contains(result, x) {\n            result.append(x)\n     \
    \   }\n    }\n    return result", '    return l.sorted().filter{ !contains(l,
    $0) }', "    var result = [Int]()\n    var count = 0\n    for value in l {\n \
    \       if !contains(result, value) {\n            result[count] = value\n   \
    \         count += 1\n        }\n    }\n    return result", "    var set = Set<Int>()\n\
    \    return l.filter({ set.insert($0).inserted }).sorted(by: { $0 > $1 })", " \
    \   var result: [Int] = []\n    for i in l {\n        if !result.contains(i) {\n\
    \            result.append(i)\n        }\n    }\n    return result", "    var\
    \ res = Set()\n    var tmp: Int\n    for tmp in l {\n        if !res.contains(tmp)\
    \ {\n            res.insert(tmp)\n        }\n    }\n    var result: [Int] = []\n\
    \    var idx: Int = 0\n    while idx < res.count {\n        result.append(res.removeFirst())\n\
    \        idx += 1\n    }\n    return result", "  var i = 0\n  var ret: [Int] =\
    \ []\n  for val in l {\n    if let index = ret.index(of: val) {\n      ret.remove(at:\
    \ index)\n    } else {\n      ret.append(val)\n    }\n  }\n  return ret", '    return
    Array(Set(l))', "    var result: [Int] = []\n    for element in l {\n        if\
    \ !contains(result, element) {\n            result.append(element)\n        }\n\
    \    }\n    return result", "    let set = Set()\n    for element in l {\n   \
    \     if !set.contains(element) {\n            set.insert(element)\n        }\n\
    \    }\n    return Array(set)", "    var a = Array(l)\n    a.sort()\n    return\
    \ a", "    var seen = [Int]()\n    var result = [Int]()\n    for x in l {\n  \
    \      if !seen.contains(x) {\n            seen.append(x)\n            result.append(x)\n\
    \        }\n    }\n    return result", "    var uniq = HashSet()\n    for num\
    \ in l {\n        uniq.insert(num)\n    }\n    return Array(uniq)", "    var unique\
    \ = [Int]()\n    var i = 0\n    for x in l {\n        if !unique.contains(x) {\n\
    \            unique.append(x)\n        }\n    }\n    return unique", "    var\
    \ seen: [Int] = Array(count: l.count, repeatedValue: -1)\n    return l.filter\
    \ { element in\n        let index = seen.index(of: element)\n        if index\
    \ == -1 { seen.insert(element, at: 0) } else {\n            seen.removeAtIndex(index)\n\
    \        }\n        return seen.count > 1\n    }", "    l.sort()\n    var result\
    \ = [Int]()\n    for x in l {\n        if !contains(result, x) {\n           \
    \ result.append(x)\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    for i in l {\n        if result.contains(i) {\n            continue\n   \
    \     }\n        result.append(i)\n    }\n    return result", "    var result:\
    \ [Int] = []\n    var index = 0\n    for element in l {\n        if let index\
    \ = result.index(of: element) {\n            result.insert(element, at: index)\n\
    \        } else {\n            result.append(element)\n        }\n    }\n    return\
    \ result", "    var result: [Int] = []\n    var set: [Int] = []\n    for x in\
    \ l {\n        if !set.contains(x) {\n            set.append(x)\n            result.append(x)\n\
    \        }\n    }\n    return result", "    l.sort()\n    var seen = [Int]()\n\
    \    var r = Int()\n    for v in l {\n        if seen[v] == nil {\n          \
    \  seen[v] = true\n            r += 1\n        }\n    }\n    return Array(repeating:r,\
    \ count:l)", "    var seen = [Bool](count: l.count, repeatedValue: false)\n  \
    \  return l.filter { seen.contains($0) }", "    var uniq = Set<Int>()\n    for\
    \ x in l {\n        uniq.insert(x)\n    }\n    return uniq.sort()", "    var seen:\
    \ [Int]()\n    return uniqueFilter(l, isEqualTo: &seen)", "    let seen = Set()\n\
    \    var uniques = [Int]()\n    for x in l {\n        if !seen.contains(x) {\n\
    \            uniques.append(x)\n            seen.insert(x)\n        }\n    }\n\
    \    return uniques", "    let dict = NSDictionary()\n    let res = Array(dict.object(forKey:\
    \ l))! as [Int]\n    return res", "    if l == nil || l.isEmpty { return [] }\n\
    \    let l = l.sorted()\n    var r = [Int]()\n    var u = [Int]()\n    for i in\
    \ 0..<l.count {\n        if u.contains(l[i]) {\n            continue\n       \
    \ } else {\n            u ~= l[i]\n            r ~= l[i]\n        }\n    }\n \
    \   return r", '    return uniqueSort(l, cmp: IntCompare())', "    var i = 0\n\
    \    var result = [Int]()\n    while i < l.count {\n        if result.contains(l[i])\
    \ {\n            result.remove(l[i])\n        } else {\n            result.append(l[i])\n\
    \        }\n        i += 1\n    }\n    return result", "    var seen: [Int] =\
    \ []\n    var result: [Int] = []\n    for ele in l {\n        if !contains(seen,\
    \ ele) {\n            append(result, ele)\n            append(seen, ele)\n   \
    \     }\n    }\n    return result", "    var seen = [Int]()\n    var result =\
    \ [Int]()\n    for item in l {\n        if !seen.contains(item) {\n          \
    \  seen.append(item)\n            result.append(item)\n        }\n    }\n    return\
    \ result", "    var result: [Int] = []\n    var index = 0\n    for el in l {\n\
    \        if result.count < index {\n            result.append(el)\n        } else\
    \ {\n            while result.count > index {\n                if result[index]\
    \ == el {\n                    result.remove(at: index)\n                } else\
    \ {\n                    index += 1\n                }\n            }\n      \
    \  }\n    }\n    return result", "    var u = [Int]()\n    for x in l {\n    \
    \    if !u.contains(x) {\n            u.append(x)\n        }\n    }\n    return\
    \ u", "    var result = [Int]()\n    for num in l {\n        if !contains(result,\
    \ num) {\n            result.append(num)\n        }\n    }\n    return result",
  '    return Array(Set(l)).sorted()', "    var result = [Int]()\n    for x in l {\n\
    \        if result.contains(x) {\n            continue\n        }\n        result.append(x)\n\
    \    }\n    return result", '  return Array(Set(l))', "    var result = [Int]()\n\
    \    for element in l {\n        if !contains(result, element) {\n           \
    \ result.append(element)\n        }\n    }\n    return result", "    var result\
    \ = [Int]()\n    for v in l {\n        if result.contains(v) == false {\n    \
    \        result.append(v)\n        }\n    }\n    return result", "    var output\
    \ = [Int]()\n    for (index, value) in l.enumerated() {\n        if !output.contains(value)\
    \ {\n            output.append(value)\n        }\n    }\n    return output", " \
    \   var h: [Int] = []\n    for v in l {\n        if !contains(h, v) {\n      \
    \      append(h, v)\n        }\n    }\n    return h", "    var l = l as! [Int]\n\
    \    var u = [Int]()\n\n    for v in l {\n        if !u.contains(v) {\n      \
    \      u.append(v)\n        }\n    }\n\n    return u", "  var seen: [Int] = Array(repeating:\
    \ 0, count: l.count)\n  return l.filter { e in\n    if seen[e] == 0 {\n      seen[e]\
    \ = 1\n      return true\n    }\n    return false\n  }", "    var result = [Int]()\n\
    \    for elem in l {\n        if !contains(&result, elem) {\n            result.append(elem)\n\
    \        }\n    }\n    return result", "  var a = Array(l)\n  a.sortInPlace()\n\
    \  var result = Array(a)\n  for i = 2; i < a.count; i++ {\n    if a[i] != a[i-1]\
    \ {\n      result.removeAtIndex(i)\n    }\n  }\n  return result", "    var seen\
    \ = [Int]()\n    var out = ArraySlice(l)\n    for v in out {\n        if !contains(seen,\
    \ v) {\n            append(seen, v)\n        }\n    }\n    return out", '    return
    removeDuplicates(uniqueInPlace(l))', "    return l.sorted().reduce([]) { a, x\
    \ in\n        if let index = a.index(of: x) {\n            a.insert(index, at:\
    \ 0)\n        }\n        a\n    }", "    var result: [Int] = []\n    var last\
    \ = l[0]\n    for e in l {\n        if e != last {\n            last = e\n   \
    \         result.append(e)\n        }\n    }\n    return result", "    var uniqueArray\
    \ = [Int]()\n    for element in l {\n        if !uniqueArray.contains(element)\
    \ {\n            uniqueArray.append(element)\n        }\n    }\n    return uniqueArray",
  "    var result = [Int]()\n    for v in l {\n        if !contains(&result, v) {\n\
    \            result.append(v)\n        }\n    }\n    return result", "    var\
    \ result = [Int]()\n    for el in l {\n        if result.contains(el) {\n    \
    \        continue\n        }\n        result.append(el)\n    }\n    return Array(result)",
  '    return Array(Set(l)).sorted()', "    var seen: [Int] = []\n    var result:\
    \ [Int] = []\n    for x in l {\n        if !contains(seen, x) {\n            seen\
    \ = append(seen, x)\n            result = append(result, x)\n        }\n    }\n\
    \    return result", "    var result = [Int]()\n    for value in l {\n       \
    \ if !result.contains(value) {\n            result.append(value)\n        }\n\
    \    }\n    return result", "    var i = 0\n    var result = [Int]()\n\n    while\
    \ i < l.count {\n        if !contains(&result, l[i]) {\n            result.append(l[i])\n\
    \        }\n        i += 1\n    }\n\n    return result", "    var uniques = [Int]()\n\
    \    for v in l {\n        if !uniques.contains(v) {\n            uniques.append(v)\n\
    \        }\n    }\n    return uniques", "    var result = [Int]()\n    for value\
    \ in l {\n        if !contains(result, value) {\n            result.append(value)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for value\
    \ in l {\n        if !contains(&result, value) {\n            result.append(value)\n\
    \        }\n    }\n    return result", "    var a = Array(l)\n    if a.isEmpty\
    \ {\n        return a\n    }\n    return a.unique()", "    var result: [Int] =\
    \ []\n    for value in l {\n        if !contains(&result, value) {\n         \
    \   result.append(value)\n        }\n    }\n    return result"]
stop_tokens:
- "\n}"
