language: swift
name: HumanEval_120_maximum
results:
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k is out of bounds\"\
    )\n    var result = [Int]()\n    let m = arr.maxElement()\n    for i in 0 ..<\
    \ k {\n        if arr[i] > m {\n            m = arr[i]\n        }\n        result.append(m)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplb5_nlzm.swift:20:17: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let m = arr.maxElement()\n            ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"index out of range\"\
    )\n    var result = [Int]()\n    let maxNumber = max(arr)\n    for value in arr\
    \ {\n        if value == maxNumber {\n            result.append(value)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpq5wg5j4y.swift:20:28: error: missing argument for parameter #2\
    \ in call\n    let maxNumber = max(arr)\n                           ^\n      \
    \                     , <#[Int]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    fatalError(\"unimplemented\")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp1kj8td72/tmp1kj8td72.swift:18: Fatal error: unimplemented

    Current stack trace:

    0    libswiftCore.so                    0x00002aec6691bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec66612b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec66612988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec666117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1kj8td72                        0x000056080ca26278 <unavailable> + 8824

    5    tmp1kj8td72                        0x000056080ca25379 <unavailable> + 4985

    6    libc.so.6                          0x00002aec66b07460 __libc_start_main +
    245

    7    tmp1kj8td72                        0x000056080ca25059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var max = [Int](repeating: 0, count: k)\n   \
    \ for element in arr {\n        if element>max[0] {\n            max = [Int](repeating:\
    \ element, count: k)\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpfymbhxr9/tmpfymbhxr9.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6220f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae621decb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae621dec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae621deb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfymbhxr9                        0x0000555ebad9b5f9 <unavailable> + 5625

    5    libc.so.6                          0x00002ae6222e1460 __libc_start_main +
    245

    6    tmpfymbhxr9                        0x0000555ebad9b1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(0 <= k <= arr.count, \"k should\
    \ be in the range of [0, len(arr)]\")\n    var maxArr = [Int](repeating: 0, count:\
    \ k)\n    \n    for i in 0 ..< k {\n        var maxIndex = -1\n        \n    \
    \    for j in 0 ..< arr.count {\n            if arr[j] > maxArr[j] {\n       \
    \         maxArr[j] = arr[j]\n                maxIndex = j\n            }\n  \
    \      }\n        \n        maxArr[maxIndex] += 1\n    }\n    \n    return maxArr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0a1oglez.swift:18:20: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n    precondition(0 <= k <= arr.count,\
    \ \"k should be in the range of [0, len(arr)]\")\n                   ^    ~~\n\
    /tmp/tmp0a1oglez.swift:18:20: error: cannot convert value of type 'Bool' to expected\
    \ argument type 'Int'\n    precondition(0 <= k <= arr.count, \"k should be in\
    \ the range of [0, len(arr)]\")\n                   ^\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    guard k <= arr.count, k > 0 else { return [Int]()\
    \ }\n    var maxArr = [Int]()\n    maxArr = arr\n    for i in maxArr {\n     \
    \   guard i > arr[0] && arr[i] > arr[0] else {\n            return maxArr\n  \
    \      }\n    }\n    maxArr = maxArr[k..<arr.count]\n    return maxArr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_hzkdxr3.swift:26:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n    maxArr = maxArr[k..<arr.count]\n             ~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    let n = arr.count\n    if n < k {\n   \
    \     return [0]\n    }\n    var max = [Int]()\n    if k == 1 {\n        for i\
    \ in 0 ..< n {\n            if arr[i] > max[0] {\n                max[0] = arr[i]\n\
    \            }\n        }\n        return [max[0]]\n    }\n    \n    for i in\
    \ 0 ..< k {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n     \
    \   }\n    }\n    \n    for i in 0 ..< (k - 1) {\n        if arr[i] > max[1] {\n\
    \            max[1] = arr[i]\n        }\n    }\n    \n    for i in 1 ..< n {\n\
    \        if arr[i] > max[1] {\n            if arr[i] > max[0] {\n            \
    \    max[0] = arr[i]\n            }\n            if arr[i] > max[1] {\n      \
    \          max[1] = arr[i]\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2295e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2292da561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae2292da286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae2292da13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae2292d9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae2290d9e83 <unavailable> + 188035

    6    tmpxc9loory                        0x000055f76119c8ce <unavailable> + 10446

    7    tmpxc9loory                        0x000055f76119b5c9 <unavailable> + 5577

    8    libc.so.6                          0x00002ae2297cf460 __libc_start_main +
    245

    9    tmpxc9loory                        0x000055f76119b2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = arr\n    for _ in 1...k {\n    \
    \    guard result.count >= k else { return result }\n        var max = result[0]\n\
    \        var maxIndex = 0\n        for element in result {\n            if element\
    \ > max {\n                max = element\n                maxIndex = result.index(of:\
    \ element)\n            }\n        }\n        result.remove(at: maxIndex)\n  \
    \      result.remove(at: 0)\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9r0h8i04.swift:26:35: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n                maxIndex = result.index(of: element)\n        \
    \                          ^\n/tmp/tmp9r0h8i04.swift:26:35: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \       maxIndex = result.index(of: element)\n                               \
    \   ^\n                                                     ?? <#default value#>\n\
    /tmp/tmp9r0h8i04.swift:26:35: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n                maxIndex = result.index(of:\
    \ element)\n                                  ^\n                            \
    \                        !\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return ArrayUtils.sortRange(arr, k)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp39hkxnws.swift:18:12: error: cannot find 'ArrayUtils' in scope\n\
    \    return ArrayUtils.sortRange(arr, k)\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let maxNums = Array(arr[k..<arr.count])\n   \
    \ let sortedMaxs = maxNums.sorted(by: <)\n    let sortedArr = Array(sortedMaxs)\n\
    \    return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmphpzk283t/tmphpzk283t.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af971724c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af97141bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af97141b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af97141a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphpzk283t                        0x0000556bdcce1689 <unavailable> + 5769

    5    libc.so.6                          0x00002af971910460 __libc_start_main +
    245

    6    tmphpzk283t                        0x0000556bdcce1289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k < 0 || k > arr.count {\n        return []\n\
    \    }\n    var maximums = [Int]()\n    for index in 0..<k {\n        if index\
    \ >= arr.count {\n            break\n        }\n        let maximum = arr[index]\n\
    \        for index in 0..<index {\n            if arr[index] > maximum {\n   \
    \             maximum = arr[index]\n            }\n        }\n        maximums.append(maximum)\n\
    \    }\n    return maximums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpg4jc5tt2.swift:29:17: error: cannot assign to value: 'maximum'\
    \ is a 'let' constant\n                maximum = arr[index]\n                ^~~~~~~\n\
    /tmp/tmpg4jc5tt2.swift:26:9: note: change 'let' to 'var' to make it mutable\n\
    \        let maximum = arr[index]\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let n = arr.count\n    var max = -1000\n    var\
    \ ans = [Int]()\n    for x in arr {\n        if x >= 0 {\n            if max <\
    \ x {\n                max = x\n            }\n        }\n    }\n    if k > max\
    \ {\n        return ans\n    }\n    var i = 0\n    for x in arr {\n        if\
    \ x >= 0 {\n            ans.append(x)\n            i += k - max > x - i ? k -\
    \ max : x - i\n            max = x - i\n        }\n    }\n    return ans\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpjnstg3pk/tmpjnstg3pk.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29ec25ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29ebf51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29ebf51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29ebf507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjnstg3pk                        0x0000555985cf1639 <unavailable> + 5689

    5    libc.so.6                          0x00002b29ec446460 __libc_start_main +
    245

    6    tmpjnstg3pk                        0x0000555985cf1239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k < 0 || k > arr.count { return [] }\n   \
    \ let result = arr[0..<k].sort()\n    return arr[0..<arr.count].sort()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_6x2fc97.swift:19:29: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    let result = arr[0..<k].sort()\n     \
    \            ~~~        ^\n/tmp/tmp_6x2fc97.swift:20:31: error: cannot convert\
    \ return expression of type '()' to return type '[Int]'\n    return arr[0..<arr.count].sort()\n\
    \           ~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return mergeSort(arr, k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpajwbwvlr.swift:18:12: error: cannot find 'mergeSort' in scope\n\
    \    return mergeSort(arr, k)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    precondition(k <= arr.count, \"k must be\
    \ less than or equal to arr.count\")\n    var maxArray = [Int](repeating: 0, count:\
    \ k)\n    \n    if arr.count == 0 || k == 0 {\n        return maxArray\n    }\n\
    \    \n    for element in arr {\n        var i = 0\n        while i < maxArray.count\
    \ && element > maxArray[i] {\n            i += 1\n        }\n        maxArray[i]\
    \ = max(element, maxArray[i])\n    }\n    \n    return maxArray\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b04e4473c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04e416a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b04e416a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b04e416a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b04e4169bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b04e3f69e83 <unavailable> + 188035

    6    tmplwvlyqa7                        0x000055c42d6ea890 <unavailable> + 10384

    7    tmplwvlyqa7                        0x000055c42d6e96d9 <unavailable> + 5849

    8    libc.so.6                          0x00002b04e465f460 __libc_start_main +
    245

    9    tmplwvlyqa7                        0x000055c42d6e93b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var max = [Int](repeating: 0, count: k)\n   \
    \ var index = 0\n    for x in arr {\n        if x > max[index] {\n           \
    \ max[index] = x\n            index += 1\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpgkwdlyts/tmpgkwdlyts.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef76e00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef76af7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef76af7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef76af67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgkwdlyts                        0x00005607c98bb649 <unavailable> + 5705

    5    libc.so.6                          0x00002aef76fec460 __libc_start_main +
    245

    6    tmpgkwdlyts                        0x00005607c98bb249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let len = arr.count\n    if k <= 0 || len ==\
    \ 0 || k > len {\n        return []\n    }\n    \n    let result = Array(repeating:\
    \ 0, count: k) // create result with k elements\n    let maxValue = arr[0]\n \
    \   let startIndex = k - 1\n    for i in 0..<len {\n        if arr[i] > maxValue\
    \ {\n            maxValue = arr[i]\n            startIndex = i\n        }\n  \
    \  }\n    \n    result[k - 1] = maxValue\n    for i = k - 2..<len {\n        result[i]\
    \ = arr[startIndex - i]\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqz7t3jyu.swift:34:11: error: expected 'in' after for-each pattern\n\
    \    for i = k - 2..<len {\n          ^\n/tmp/tmpqz7t3jyu.swift:34:11: error:\
    \ expected Sequence expression for for-each loop\n    for i = k - 2..<len {\n\
    \          ^\n/tmp/tmpqz7t3jyu.swift:28:13: error: cannot assign to value: 'maxValue'\
    \ is a 'let' constant\n            maxValue = arr[i]\n            ^~~~~~~~\n/tmp/tmpqz7t3jyu.swift:24:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxValue = arr[0]\n\
    \    ^~~\n    var\n/tmp/tmpqz7t3jyu.swift:29:13: error: cannot assign to value:\
    \ 'startIndex' is a 'let' constant\n            startIndex = i\n            ^~~~~~~~~~\n\
    /tmp/tmpqz7t3jyu.swift:25:5: note: change 'let' to 'var' to make it mutable\n\
    \    let startIndex = k - 1\n    ^~~\n    var\n/tmp/tmpqz7t3jyu.swift:33:11: error:\
    \ cannot assign through subscript: 'result' is a 'let' constant\n    result[k\
    \ - 1] = maxValue\n    ~~~~~~^\n/tmp/tmpqz7t3jyu.swift:23:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let result = Array(repeating: 0, count: k)\
    \ // create result with k elements\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k >= arr.count {\n        return arr\n   \
    \ }\n    var result = arr\n    var resultCount = 0\n    for i in 0..<k {\n   \
    \     if resultCount < result.count {\n            if resultCount > 0 {\n    \
    \            if resultCount > result[0] {\n                    resultCount = resultCount\n\
    \                    result = result\n                }\n            } else {\n\
    \                resultCount = 1\n                result = arr\n            }\n\
    \        } else {\n            if resultCount > result[0] {\n                resultCount\
    \ = resultCount\n                result = result\n            }\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkkqf6yr8.swift:27:33: error: assigning a variable to itself\n \
    \                   resultCount = resultCount\n                    ~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~\n/tmp/tmpkkqf6yr8.swift:28:28: error: assigning a variable to\
    \ itself\n                    result = result\n                    ~~~~~~ ^ ~~~~~~\n\
    /tmp/tmpkkqf6yr8.swift:36:29: error: assigning a variable to itself\n        \
    \        resultCount = resultCount\n                ~~~~~~~~~~~ ^ ~~~~~~~~~~~\n\
    /tmp/tmpkkqf6yr8.swift:37:24: error: assigning a variable to itself\n        \
    \        result = result\n                ~~~~~~ ^ ~~~~~~\n/tmp/tmpkkqf6yr8.swift:23:9:\
    \ warning: immutable value 'i' was never used; consider replacing with '_' or\
    \ removing it\n    for i in 0..<k {\n        ^\n        _\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 || k == 1 {\n        return arr\n \
    \   }\n    var max = [Int](repeating: 0, count: k)\n    for i in 0 ..< k {\n \
    \       max[i] = 0\n    }\n    for num in arr {\n        if num > max[k-1] {\n\
    \            max[k-1] = num\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp2c1xw0kl/tmp2c1xw0kl.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aefb58bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aefb55b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aefb55b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aefb55b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2c1xw0kl                        0x00005595744c07d9 <unavailable> + 6105

    5    libc.so.6                          0x00002aefb5aa7460 __libc_start_main +
    245

    6    tmp2c1xw0kl                        0x00005595744c03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k can't be greater\
    \ than the size of array\")\n    \n    var max = [Int](repeating: -1000, count:\
    \ k)\n    for i in 0..<arr.count {\n        max[i] = max(arr[i], max[i ..< k.count])\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkxnjb_48.swift:22:18: error: cannot call value of non-function\
    \ type '[Int]'\n        max[i] = max(arr[i], max[i ..< k.count])\n           \
    \      ^\n/tmp/tmpkxnjb_48.swift:22:42: error: value of type 'Int' has no member\
    \ 'count'\n        max[i] = max(arr[i], max[i ..< k.count])\n                \
    \                       ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    // write your code here\n    var maxArr = [Int]()\n\
    \    for el in arr{\n        if el > maxArr[k]{\n            maxArr = maxArr[k:]\
    \ + [el]\n        }else{\n            for i in k...{\n                if el >\
    \ maxArr[i]{\n                    maxArr[i] = el\n                    break\n\
    \                }\n            }\n        }\n    }\n    return maxArr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8zgt_qep.swift:22:31: error: expected expression in list of expressions\n\
    \            maxArr = maxArr[k:] + [el]\n                              ^\n/tmp/tmp8zgt_qep.swift:29:14:\
    \ error: expected '{' to start the body of for-each loop\n            }\n    \
    \         ^\n/tmp/tmp8zgt_qep.swift:22:31: error: missing argument for parameter\
    \ #1 in call\n            maxArr = maxArr[k:] + [el]\n                       \
    \       ^\n                              <#Range<Int>#>\nSwift.Array:17:23: note:\
    \ 'subscript(_:)' declared here\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\n/tmp/tmp8zgt_qep.swift:25:32:\
    \ error: cannot find 'i' in scope\n                if el > maxArr[i]{\n      \
    \                         ^\n/tmp/tmp8zgt_qep.swift:26:28: error: cannot find\
    \ 'i' in scope\n                    maxArr[i] = el\n                         \
    \  ^\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n  return removeDuplicates(arr, k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpauumejzw.swift:18:10: error: cannot find 'removeDuplicates' in\
    \ scope\n  return removeDuplicates(arr, k)\n         ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k < 1 {\n        return []\n    }\n    if\
    \ k == 1 {\n        return arr\n    }\n    if arr[0] > arr[1] {\n        var result\
    \ = Array(k + 1)\n        for i in 0..<k {\n            result[i] = arr[i]\n \
    \       }\n        return result\n    }\n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4qai5lq3.swift:25:28: error: missing argument label 'arrayLiteral:'\
    \ in call\n        var result = Array(k + 1)\n                           ^\n \
    \                          arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 || k > arr.count {\n        return\
    \ arr\n    }\n    let result = [Int](count: k, repeatedValue: 0)\n    for element\
    \ in arr {\n        if result[element - 1] < element {\n            result[element\
    \ - 1] = element\n        }\n    }\n    return result.suffix(k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3gkcejvk.swift:21:18: error: no exact matches in call to initializer\
    \ \n    let result = [Int](count: k, repeatedValue: 0)\n                 ^\n/tmp/tmp3gkcejvk.swift:21:18:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    let result = [Int](count: k, repeatedValue: 0)\n                 ^\n\
    /tmp/tmp3gkcejvk.swift:21:18: note: candidate has partially matching parameter\
    \ list (repeating: Int, count: Int)\n    let result = [Int](count: k, repeatedValue:\
    \ 0)\n                 ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = Array(repeating: 0, count: k)\n\
    \    var max = -Int(Int.max)\n    \n    for el in arr {\n        guard max < el\
    \ && el != 0 else {\n            result[result.indexWhere(max == el)!] = max\n\
    \            max = el\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf4ppmpl4.swift:23:27: error: value of type '[Int]' has no member\
    \ 'indexWhere'\n            result[result.indexWhere(max == el)!] = max\n    \
    \               ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"invalid k\")\n\
    \    var max = arr[0]\n    for i := 0; i < k; i++ {\n        if arr[i] > max {\n\
    \            max = arr[i]\n        }\n    }\n    var result = make([]Int, k)\n\
    \    for i := 0; i < k; i++ {\n        result[i] = max\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpv0o7qj6p.swift:20:12: error: expected type\n    for i := 0; i <\
    \ k; i++ {\n           ^\n            <#type#>\n/tmp/tmpv0o7qj6p.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < k; i++ {\n\
    \           ^\n/tmp/tmpv0o7qj6p.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < k; i++ {\n           ^\n/tmp/tmpv0o7qj6p.swift:25:25:\
    \ error: expected ',' separator\n    var result = make([]Int, k)\n           \
    \             ^\n                        ,\n/tmp/tmpv0o7qj6p.swift:26:12: error:\
    \ expected type\n    for i := 0; i < k; i++ {\n           ^\n            <#type#>\n\
    /tmp/tmpv0o7qj6p.swift:26:12: error: expected 'in' after for-each pattern\n  \
    \  for i := 0; i < k; i++ {\n           ^\n/tmp/tmpv0o7qj6p.swift:26:12: error:\
    \ expected Sequence expression for for-each loop\n    for i := 0; i < k; i++ {\n\
    \           ^\n/tmp/tmpv0o7qj6p.swift:25:18: error: cannot find 'make' in scope\n\
    \    var result = make([]Int, k)\n                 ^~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"index out of range\"\
    )\n\n    let len = arr.count\n    var result = arr\n    if len > k {\n       \
    \ result =  arr[k..<len]\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbmt04lnh.swift:23:22: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        result =  arr[k..<len]\n                  ~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return merge(arr, k, arr.count, 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptnrl6dqo.swift:18:12: error: cannot find 'merge' in scope\n   \
    \ return merge(arr, k, arr.count, 0)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    fatalError(\"not implemented\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp3vqfuppb/tmp3vqfuppb.swift:18: Fatal error: not implemented

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a45dffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a45af6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a45af6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a45af57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3vqfuppb                        0x0000564f62a8d278 <unavailable> + 8824

    5    tmp3vqfuppb                        0x0000564f62a8c379 <unavailable> + 4985

    6    libc.so.6                          0x00002b6a45feb460 __libc_start_main +
    245

    7    tmp3vqfuppb                        0x0000564f62a8c059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k should be less\
    \ than arr.count\")\n    var result = [Int]()\n    if arr.count > 0 {\n      \
    \  result = Array(arr.prefix(arr.count-k)).sorted()\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpwbu35hbt/tmpwbu35hbt.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1823a95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b182378cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b182378c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b182378b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwbu35hbt                        0x000055f2b6be9749 <unavailable> + 5961

    5    libc.so.6                          0x00002b1823c81460 __libc_start_main +
    245

    6    tmpwbu35hbt                        0x000055f2b6be9349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n  return maximumSlice(arr, k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdhz4s93o.swift:18:10: error: cannot find 'maximumSlice' in scope\n\
    \  return maximumSlice(arr, k)\n         ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count, \"k is out of bounds\"\
    )\n    \n    return Array(arr).maxByCount(k)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzy4t61uc.swift:20:23: error: value of type '[Int]' has no member\
    \ 'maxByCount'\n    return Array(arr).maxByCount(k)\n           ~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k > arr.count {\n        return []\n    }\n\
    \    \n    // Calculate the maximum numbers of k\n    var maxCount: Int = -1\n\
    \    for i in 0..<k {\n        if arr[i] == maxCount {\n            maxCount++\n\
    \        } else {\n            maxCount = arr[i]\n        }\n    }\n    \n   \
    \ var maxElem = maxCount\n    var max = arr[0]\n    \n    var result = [Int]()\n\
    \    for i in 0..<arr.count {\n        if arr[i] > max {\n            max = arr[i]\n\
    \        }\n        if arr[i] == maxCount {\n            result.append(arr[i])\n\
    \        }\n        if arr[i] > maxElem {\n            maxElem = arr[i]\n    \
    \    }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7mirtnwd.swift:26:21: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            maxCount++\n                    ^~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var biggest = [Int]()\n    for x in arr {\n \
    \       if biggest.count == k {\n            break\n        }\n        if x <\
    \ biggest[0] {\n            biggest = [x]\n        } else {\n            if x\
    \ == biggest[0] {\n                biggest = [x]\n            } else {\n     \
    \           biggest[0] = x\n            }\n        }\n    }\n    return biggest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b34a2847c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34a253e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b34a253e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b34a253e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b34a253dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b34a233de83 <unavailable> + 188035

    6    tmpliurj0af                        0x000055e049161594 <unavailable> + 9620

    7    tmpliurj0af                        0x000055e0491605a9 <unavailable> + 5545

    8    libc.so.6                          0x00002b34a2a33460 __libc_start_main +
    245

    9    tmpliurj0af                        0x000055e049160289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(0 <= k && k <= arr.count, message:\
    \ \"k should in the range of [0, arr.count)\")\n    \n    let maxIndex = arr.count\
    \ - k\n    let result = Array(count: maxIndex, repeatedValue: Int.max)\n    for\
    \ i in 0..<k {\n        result[i] = arr[i + maxIndex]\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0_22nw2f.swift:18:17: error: extraneous argument label 'message:'\
    \ in call\n    precondition(0 <= k && k <= arr.count, message: \"k should in the\
    \ range of [0, arr.count)\")\n                ^                          ~~~~~~~~~\n\
    \                                           \n/tmp/tmp0_22nw2f.swift:21:18: error:\
    \ no exact matches in call to initializer \n    let result = Array(count: maxIndex,\
    \ repeatedValue: Int.max)\n                 ^\n/tmp/tmp0_22nw2f.swift:21:18: note:\
    \ candidate has partially matching parameter list (repeating: _, count: Int)\n\
    \    let result = Array(count: maxIndex, repeatedValue: Int.max)\n           \
    \      ^\n/tmp/tmp0_22nw2f.swift:21:18: note: candidate has partially matching\
    \ parameter list (repeating: _, count: Int)\n    let result = Array(count: maxIndex,\
    \ repeatedValue: Int.max)\n                 ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return numsort.mergeSort(arr, k, func(x, y Int)\
    \ -> Bool {\n        x <= y\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb73evm_8.swift:18:38: error: expected expression in list of expressions\n\
    \    return numsort.mergeSort(arr, k, func(x, y Int) -> Bool {\n             \
    \                        ^\n/tmp/tmpb73evm_8.swift:18:42: error: expected identifier\
    \ in function declaration\n    return numsort.mergeSort(arr, k, func(x, y Int)\
    \ -> Bool {\n                                         ^\n/tmp/tmpb73evm_8.swift:18:12:\
    \ error: cannot find 'numsort' in scope\n    return numsort.mergeSort(arr, k,\
    \ func(x, y Int) -> Bool {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count, \"Index out of range\"\
    )\n    precondition(arr.count > 0, \"Array must contain at least one element\"\
    )\n    var result : [Int] = [0]\n    var i : Int = 0\n    var maxIndex : Int =\
    \ 0\n    var maxVal : Int = arr[0]\n    \n    while i < arr.count {\n        if\
    \ arr[i] > maxVal {\n            maxIndex = i\n            maxVal = arr[i]\n \
    \       }\n        i += 1\n    }\n    \n    for (i = maxIndex; i >= 0; i -= 1)\
    \ {\n        result[result.count - i] = arr[i]\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpk6w_8puh.swift:33:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i = maxIndex; i >= 0; i -= 1) {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0, \"Invalid k\")\n    \n  \
    \  var result = make([]Int, k)\n    \n    for i := 0; i < k; i++ {\n        result[i]\
    \ = arr[0]\n        arr = arr[k+1:]\n    }\n    \n    return result.sort()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_zk_33g2.swift:20:25: error: expected ',' separator\n    var result\
    \ = make([]Int, k)\n                        ^\n                        ,\n/tmp/tmp_zk_33g2.swift:22:12:\
    \ error: expected type\n    for i := 0; i < k; i++ {\n           ^\n         \
    \   <#type#>\n/tmp/tmp_zk_33g2.swift:22:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < k; i++ {\n           ^\n/tmp/tmp_zk_33g2.swift:22:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < k;\
    \ i++ {\n           ^\n/tmp/tmp_zk_33g2.swift:24:22: error: expected ',' separator\n\
    \        arr = arr[k+1:]\n                     ^\n                     ,\n/tmp/tmp_zk_33g2.swift:24:22:\
    \ error: expected expression in list of expressions\n        arr = arr[k+1:]\n\
    \                     ^\n/tmp/tmp_zk_33g2.swift:20:18: error: cannot find 'make'\
    \ in scope\n    var result = make([]Int, k)\n                 ^~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return ArraySlice(arr.sorted().prefix(k)).array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnbqg7b_z.swift:18:47: error: value of type 'ArraySlice<Int>' has\
    \ no member 'array'\n    return ArraySlice(arr.sorted().prefix(k)).array\n   \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    guard k > 0 && k < arr.count else { return arr\
    \ }\n    \n    if k == 0 || arr.count == 0 {\n        return arr\n    }\n    \n\
    \    let n = arr.count\n    \n    // Sort arr in O(n log n) time.\n    let sortedArr\
    \ = Array(sorted(arr))\n    \n    // Find the kth largest number from sortedArr\
    \ in O(n) time.\n    var largest = sortedArr[k - 1]\n    for i in 1..<k {\n  \
    \      if arr[i] > largest {\n            largest = arr[i]\n        }\n    }\n\
    \    \n    // Return the largest k numbers in arr in O(k log k) time.\n    return\
    \ Array(Array(sortedArr[0..<k]).prefix(k).sorted().suffix(k))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp85n9rxls.swift:27:27: error: cannot find 'sorted' in scope\n  \
    \  let sortedArr = Array(sorted(arr))\n                          ^~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return mergeSort(arr, k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpajwbwvlr.swift:18:12: error: cannot find 'mergeSort' in scope\n\
    \    return mergeSort(arr, k)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return select(arr, k)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4sbvsqb6.swift:18:12: error: cannot find 'select' in scope\n  \
    \  return select(arr, k)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    fatalError(\"unimplemented\")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp1kj8td72/tmp1kj8td72.swift:18: Fatal error: unimplemented

    Current stack trace:

    0    libswiftCore.so                    0x00002aec6691bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec66612b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec66612988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec666117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1kj8td72                        0x000056080ca26278 <unavailable> + 8824

    5    tmp1kj8td72                        0x000056080ca25379 <unavailable> + 4985

    6    libc.so.6                          0x00002aec66b07460 __libc_start_main +
    245

    7    tmp1kj8td72                        0x000056080ca25059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    ret := make([]Int, k)\n    for idx := range ret\
    \ {\n        ret[idx] = arr[idx]\n    }\n    sort.Sort(ret)\n    return ret\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0qskmvbn.swift:18:8: error: consecutive statements on a line must\
    \ be separated by ';'\n    ret := make([]Int, k)\n       ^\n       ;\n/tmp/tmp0qskmvbn.swift:18:9:\
    \ error: expected expression\n    ret := make([]Int, k)\n        ^\n/tmp/tmp0qskmvbn.swift:19:14:\
    \ error: expected type\n    for idx := range ret {\n             ^\n         \
    \     <#type#>\n/tmp/tmp0qskmvbn.swift:19:14: error: expected 'in' after for-each\
    \ pattern\n    for idx := range ret {\n             ^\n/tmp/tmp0qskmvbn.swift:19:14:\
    \ error: expected Sequence expression for for-each loop\n    for idx := range\
    \ ret {\n             ^\n/tmp/tmp0qskmvbn.swift:18:5: error: cannot find 'ret'\
    \ in scope\n    ret := make([]Int, k)\n    ^~~\n/tmp/tmp0qskmvbn.swift:23:12:\
    \ error: cannot find 'ret' in scope\n    return ret\n           ^~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= len(arr), \"k must be in range\"\
    )\n    return arr[k..<k+k]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpr7ll8txw.swift:18:23: error: cannot find 'len' in scope\n    precondition(k\
    \ <= len(arr), \"k must be in range\")\n                      ^~~\n/tmp/tmpr7ll8txw.swift:19:15:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return arr[k..<k+k]\n           ~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return maximumByWithKey(arr, nil, k)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpoje8e1bf.swift:18:12: error: cannot find 'maximumByWithKey' in\
    \ scope\n    return maximumByWithKey(arr, nil, k)\n           ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpoje8e1bf.swift:18:34: error: 'nil' requires a contextual type\n    return\
    \ maximumByWithKey(arr, nil, k)\n                                 ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 1 {\n        return arr\n    }\n    let\
    \ len = arr.count\n    var max = [Int](repeating: 0, count: k+1)\n    for j in\
    \ 0..<len {\n        let minIndex = j\n        for i = j+1..<k {\n           \
    \ if arr[i] > max[j] {\n                max[j] = arr[i]\n                minIndex\
    \ = i\n            }\n        }\n        max[j] = arr[minIndex]\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpr_q_w4ww.swift:25:15: error: expected 'in' after for-each pattern\n\
    \        for i = j+1..<k {\n              ^\n/tmp/tmpr_q_w4ww.swift:25:15: error:\
    \ expected Sequence expression for for-each loop\n        for i = j+1..<k {\n\
    \              ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count)\n    precondition(arr.count\
    \ >= k, \"k should not exceed length of array\")\n    let res = arr[k..<arr.count]\n\
    \    return res.sorted {$0 > $1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmprq3uvxyv/tmprq3uvxyv.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b257113cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2570e33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2570e33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2570e327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprq3uvxyv                        0x000055d7a0b616a9 <unavailable> + 5801

    5    libc.so.6                          0x00002b2571328460 __libc_start_main +
    245

    6    tmprq3uvxyv                        0x000055d7a0b612a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(\n        k < arr.count,\n     \
    \   \"The length of arr must be smaller than or equal to k.\",\n        \"The\
    \ length of arr is \\(arr.count) and k is \\(k).\"\n    )\n    if k == 1 {\n \
    \       return arr\n    }\n    \n    var maxArr: [Int] = []\n    \n    for i in\
    \ 0..<k {\n        maxArr.append(arr[i])\n    }\n    maxArr = maxArr.sorted()\n\
    \    \n    return maxArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpg3bus7bq.swift:18:17: error: missing argument label 'file:' in\
    \ call\n    precondition(\n                ^\n/tmp/tmpg3bus7bq.swift:21:9: error:\
    \ cannot convert value of type 'String' to expected argument type 'StaticString'\n\
    \        \"The length of arr is \\(arr.count) and k is \\(k).\"\n        ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = Array(repeating: 0, count: k)\n\
    \    if arr.count > k { return arr }\n    for elem in arr {\n        result[result.count\
    \ - 1] = elem\n        if result.count > k {\n            result.remove(at: result.count\
    \ - 1)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp2cuiryb9/tmp2cuiryb9.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7daad6cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7daaa63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7daaa63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7daaa627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2cuiryb9                        0x000055d364c096a9 <unavailable> + 5801

    5    libc.so.6                          0x00002b7daaf58460 __libc_start_main +
    245

    6    tmp2cuiryb9                        0x000055d364c092a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return maximumSort(arr, k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpjyiefgyu.swift:18:12: error: cannot find 'maximumSort' in scope\n\
    \    return maximumSort(arr, k)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    let sorted = arr.sorted()\n    \n    if\
    \ k < sorted.count {\n        return sorted[k..<sorted.count]\n    }\n    \n \
    \   return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpaut2bw1r.swift:22:22: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n        return sorted[k..<sorted.count]\n\
    \               ~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let len = arr.count\n    if k >= len {\n    \
    \    return arr\n    }\n    var maxArr = [Int](repeating: 0, count: k + 1)\n \
    \   var maxIndex = k\n    for i in 0..<k {\n        if arr[i] > maxArr[maxIndex]\
    \ {\n            maxArr[maxIndex] = arr[i]\n            maxIndex = maxIndex -\
    \ 1\n        }\n    }\n    return maxArr[0..<maxIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6khue1ai.swift:30:18: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return maxArr[0..<maxIndex]\n\
    \                 ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n  \
    \                    ^\nSwift.Collection:2:23: note: 'subscript(_:)' produces\
    \ 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23: note:\
    \ 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k <= 0 || k > len(arr) {\n        return [Int]()\n\
    \    }\n    \n    \n    let result = [Int](repeating: -Int.max, count: k)\n  \
    \  \n    var maxIndex = -1\n    var maxVal = -Int.max\n    \n    for i in 0..<arr.count\
    \ {\n        if arr[i] > maxVal {\n            maxVal = arr[i]\n            maxIndex\
    \ = i\n        }\n        result[maxIndex] = max(arr[maxIndex], arr[i])\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplk29lz3_.swift:18:22: error: cannot find 'len' in scope\n    if\
    \ k <= 0 || k > len(arr) {\n                     ^~~\n/tmp/tmplk29lz3_.swift:33:15:\
    \ error: cannot assign through subscript: 'result' is a 'let' constant\n     \
    \   result[maxIndex] = max(arr[maxIndex], arr[i])\n        ~~~~~~^\n/tmp/tmplk29lz3_.swift:23:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = [Int](repeating:\
    \ -Int.max, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 {\n        return arr\n    }\n    if\
    \ k < 0 || k > len(arr) {\n        return []\n    }\n    var res: [Int] = []\n\
    \    if k > 0 && len(arr) > 0 {\n        for i = 0; i < k; i++ {\n           \
    \ var max: Int = 0\n            for j in 0..<len(arr) {\n                max =\
    \ max<arr[j] ? max : arr[j]\n            }\n            res.append(max)\n    \
    \    }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpc03bh7j7.swift:26:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for i = 0; i < k; i++ {\n        ^   ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpc03bh7j7.swift:21:21: error: cannot find 'len' in scope\n    if k < 0\
    \ || k > len(arr) {\n                    ^~~\n/tmp/tmpc03bh7j7.swift:25:17: error:\
    \ cannot find 'len' in scope\n    if k > 0 && len(arr) > 0 {\n               \
    \ ^~~\n/tmp/tmpc03bh7j7.swift:28:26: error: cannot find 'len' in scope\n     \
    \       for j in 0..<len(arr) {\n                         ^~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int](repeating: -1000, count: k)\n\
    \    if arr.isEmpty {\n        return result\n    }\n    for i in 0 ..< k {\n\
    \        result[i] = max(arr[i], result[i])\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpxsmhnnlb/tmpxsmhnnlb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b008f497c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b008f18eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b008f18e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b008f18d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsmhnnlb                        0x0000558f71e53799 <unavailable> + 6041

    5    libc.so.6                          0x00002b008f683460 __libc_start_main +
    245

    6    tmpxsmhnnlb                        0x0000558f71e53399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    // \u5148\u6309\u7167\u5927\u7684k\u6B21\u65B9\
    \u6392\u5E8F\uFF0C\u7136\u540E\u53D6\u524Dk\u4E2A\n    let arr = arr.sorted(by:\
    \ { $0 * $0 })\n    return arr[0..<k]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb0t6q2oa.swift:19:30: error: contextual closure type '(Int, Int)\
    \ throws -> Bool' expects 2 arguments, but 1 was used in closure body\n    let\
    \ arr = arr.sorted(by: { $0 * $0 })\n                             ^\n/tmp/tmpb0t6q2oa.swift:19:35:\
    \ error: cannot convert value of type 'Int' to closure result type 'Bool'\n  \
    \  let arr = arr.sorted(by: { $0 * $0 })\n                               ~~~^~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = Array(repeating: 0, count: k)\n\
    \    \n    for i in 0..<arr.count {\n        result[i] = max(arr[i], result[i])\n\
    \    }\n    \n    result.removeFirst()\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp4n_t36b3/tmp4n_t36b3.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1634113c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1633e0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1633e0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1633e097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4n_t36b3                        0x000055c528b107f9 <unavailable> + 6137

    5    libc.so.6                          0x00002b16342ff460 __libc_start_main +
    245

    6    tmp4n_t36b3                        0x000055c528b103f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = arr\n    let length = arr.count\n\
    \    \n    if k > length {\n        return arr\n    }\n    \n    for i in 0..k-1\
    \ {\n        result[i] = max(result[i], arr[i])\n    }\n    \n    return Array(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp95c3zbnz.swift:25:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 0..k-1 {\n              ^~\n             \
    \ ...\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= len(arr), \"The length of arr\
    \ should be less than or equal to k\")\n    var maximums = [Int](repeating: 0,\
    \ count: k)\n    for (_, element) in arr.enumerated() {\n        var temp = 0\n\
    \        for idx in 0..<k {\n            if idx == k-1 {\n                break\n\
    \            }\n            if element > maximums[idx] {\n                temp\
    \ = element\n                maximums[idx] = element\n            }\n        }\n\
    \        maximums[k-1] = temp\n    }\n    return maximums\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7iam26yi.swift:18:23: error: cannot find 'len' in scope\n    precondition(k\
    \ <= len(arr), \"The length of arr should be less than or equal to k\")\n    \
    \                  ^~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Array(arr).reverse().prefix(min(k, arr.count)).drop(min(k,\
    \ arr.count)).reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgusv154_.swift:18:33: error: value of tuple type '()' has no member\
    \ 'prefix'\n    return Array(arr).reverse().prefix(min(k, arr.count)).drop(min(k,\
    \ arr.count)).reverse()\n           ~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count, \"k should be less\
    \ than arr.count\")\n    var result = Array<Int>()\n    for index in 0..<k {\n\
    \        let max = arr[index]\n        for element in arr {\n            if element\
    \ > max {\n                max = element\n            }\n        }\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp02vru_qm.swift:24:17: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n                max = element\n                ^~~\n/tmp/tmp02vru_qm.swift:21:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let max = arr[index]\n\
    \        ^~~\n        var\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k > len(arr) { return [] }\n    \n    var\
    \ max = arr[0]\n    \n    for element in arr {\n        if element > max {\n \
    \           max = element\n        }\n    }\n    \n    var result = make(k)\n\
    \    \n    for element in arr {\n        if element > max {\n            max =\
    \ element\n        }\n    }\n    \n    for element in arr {\n        if element\
    \ == max {\n            result[k-1] = element\n            k--\n        }\n  \
    \  }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwj601xk9.swift:18:12: error: cannot find 'len' in scope\n    if\
    \ k > len(arr) { return [] }\n           ^~~\n/tmp/tmpwj601xk9.swift:28:18: error:\
    \ cannot find 'make' in scope\n    var result = make(k)\n                 ^~~~\n\
    /tmp/tmpwj601xk9.swift:39:14: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n            k--\n             ^~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Array(Set(arr).sorted(by: >))[k..<k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8y1xe93k.swift:18:41: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return Array(Set(arr).sorted(by:\
    \ >))[k..<k]\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var maximums = [Int]()\n    for element in arr\
    \ {\n        maximums = append(maximums, element)\n        if maximums.count >\
    \ k {\n            maximums.removeLast()\n        }\n    }\n    return maximums\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqd3k1jk7.swift:20:20: error: cannot find 'append' in scope\n  \
    \      maximums = append(maximums, element)\n                   ^~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return arr[0..<k].sorted().prefix(k)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpk26107i5.swift:18:32: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr[0..<k].sorted().prefix(k)\n\
    \           ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var max = arr[0]\n    for x in arr {\n      \
    \  if x > max {\n            max = x\n        }\n    }\n    \n    if k == 1 {\n\
    \        return arr\n    }\n    \n    if k >= len(arr) {\n        return arr\n\
    \    }\n    \n    max += k\n    \n    var result = [Int]()\n    var count = 0\n\
    \    for x in arr {\n        if x >= max {\n            result.append(x)\n   \
    \         count += 1\n        }\n    }\n    \n    if count > k {\n        return\
    \ arr\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3p_mglqs.swift:29:13: error: cannot find 'len' in scope\n    if\
    \ k >= len(arr) {\n            ^~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k is out of range\"\
    )\n    let result = Array(arr[0..<k])\n    for index in 1..<arr.count {\n    \
    \    if arr[index] > result[result.count - index] {\n            result.append(arr[index])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpg68_pwam.swift:22:20: error: cannot use mutating member on immutable\
    \ value: 'result' is a 'let' constant\n            result.append(arr[index])\n\
    \            ~~~~~~ ^\n/tmp/tmpg68_pwam.swift:19:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let result = Array(arr[0..<k])\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k is out of bounds\"\
    )\n    precondition(arr.count > 0, \"arr must contain at least one element\")\n\
    \    let result = Array<Int>(repeating: 0, count: k)\n    for x in arr {\n   \
    \     if x < result.last! {\n            result.remove(at: result.index(before:\
    \ result.index(before: result.endIndex, offsetBy: -1)))\n        }\n        result.append(x)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw0do462e.swift:23:20: error: no exact matches in call to instance\
    \ method 'remove'\n            result.remove(at: result.index(before: result.index(before:\
    \ result.endIndex, offsetBy: -1)))\n                   ^\n/tmp/tmpw0do462e.swift:23:20:\
    \ note: found candidate with type '(Int) -> Int'\n            result.remove(at:\
    \ result.index(before: result.index(before: result.endIndex, offsetBy: -1)))\n\
    \                   ^\n/tmp/tmpw0do462e.swift:23:59: error: no exact matches in\
    \ call to instance method 'index'\n            result.remove(at: result.index(before:\
    \ result.index(before: result.endIndex, offsetBy: -1)))\n                    \
    \                                      ^\n/tmp/tmpw0do462e.swift:23:59: note:\
    \ found candidate with type '(Int, Int) -> Int'\n            result.remove(at:\
    \ result.index(before: result.index(before: result.endIndex, offsetBy: -1)))\n\
    \                                                          ^\n/tmp/tmpw0do462e.swift:25:16:\
    \ error: cannot use mutating member on immutable value: 'result' is a 'let' constant\n\
    \        result.append(x)\n        ~~~~~~ ^\n/tmp/tmpw0do462e.swift:20:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let result = Array<Int>(repeating:\
    \ 0, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var maximums = [Int]()\n    var i = 0\n    for\
    \ value in arr {\n        if i > k {\n            break\n        }\n        i\
    \ += 1\n        maximums.append(value)\n    }\n    return maximums\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp14zl8n8o/tmp14zl8n8o.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11c166ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11c1361b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11c1361988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11c13607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp14zl8n8o                        0x000055a45d8f05e9 <unavailable> + 5609

    5    libc.so.6                          0x00002b11c1856460 __libc_start_main +
    245

    6    tmp14zl8n8o                        0x000055a45d8f01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 {\n        return arr\n    }\n    \n\
    \    if arr.count <= k {\n        return arr\n    }\n    \n    \n    var maxArr:\
    \ [Int] = []\n    var maxIndex: Int = -1\n    var index = 0\n    \n    for index\
    \ in stride(from: 0, to: arr.count, by: k) {\n        \n        if arr[index]\
    \ > maxArr[maxIndex] {\n            maxArr = arr\n            maxIndex = index\n\
    \        }\n    }\n    \n    return maxArr\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpbaxj1lh8/tmpbaxj1lh8.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9e230fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9e2006b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9e2006988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9e20057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbaxj1lh8                        0x000055aa5dc1a689 <unavailable> + 5769

    5    libc.so.6                          0x00002ab9e24fb460 __libc_start_main +
    245

    6    tmpbaxj1lh8                        0x000055aa5dc1a289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result : [Int] = []\n    if k < 0 || k >=\
    \ arr.count {\n        return result\n    }\n    \n    let max = 0\n    var i\
    \ = 0\n    while i < arr.count && k < arr.count {\n        let value = arr[i]\n\
    \        if value > max {\n            max = value\n        }\n        if i ==\
    \ k {\n            result = append(result, max)\n            i = i + 1\n     \
    \   } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfz0vjto4.swift:28:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = value\n            ^~~\n/tmp/tmpfz0vjto4.swift:23:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = 0\n    ^~~\n \
    \   var\n/tmp/tmpfz0vjto4.swift:31:22: error: cannot find 'append' in scope\n\
    \            result = append(result, max)\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var n = arr.count\n    var result = [Int]()\n\
    \    for i in 0..<k {\n        let j = n - i\n        result.append(arr[j])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b82e8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b82b86561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0b82b86286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0b82b8613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0b82b85bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0b82985e83 <unavailable> + 188035

    6    tmptr6qg3xe                        0x0000558aaed835f7 <unavailable> + 9719

    7    tmptr6qg3xe                        0x0000558aaed825d9 <unavailable> + 5593

    8    libc.so.6                          0x00002b0b8307b460 __libc_start_main +
    245

    9    tmptr6qg3xe                        0x0000558aaed822b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k > 0 { // If k is greater than 0, then do\
    \ normal binary search.\n        let low = 0\n        let high = arr.count - 1\n\
    \n        while low < high {\n            let mid = low + (high - low)>>1\n\n\
    \            if arr[mid] > arr[mid + 1] {\n                high = mid - 1\n  \
    \          } else {\n                low = mid + 1\n            }\n        }\n\
    \n        return arr[low...high] // Return slice of max k elements.\n    } else\
    \ {\n        return arr // If k is 0 or less, then just return the given array.\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp568ddtqq.swift:26:17: error: cannot assign to value: 'high' is\
    \ a 'let' constant\n                high = mid - 1\n                ^~~~\n/tmp/tmp568ddtqq.swift:20:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let high = arr.count\
    \ - 1\n        ^~~\n        var\n/tmp/tmp568ddtqq.swift:28:17: error: cannot assign\
    \ to value: 'low' is a 'let' constant\n                low = mid + 1\n       \
    \         ^~~\n/tmp/tmp568ddtqq.swift:19:9: note: change 'let' to 'var' to make\
    \ it mutable\n        let low = 0\n        ^~~\n        var\n/tmp/tmp568ddtqq.swift:32:19:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n        return arr[low...high] // Return slice of max k elements.\n\
    \               ~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let len = arr.count\n    if k > len {\n     \
    \   k = len\n    }\n    if k == 0 {\n        return arr\n    }\n    \n    var\
    \ max = [Int](repeatElement(0, count: k))\n    for i in 0..<k {\n        if arr[i]\
    \ > max[0] {\n            max[0] = arr[i]\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8pt3xt1y.swift:20:9: error: cannot assign to value: 'k' is a 'let'\
    \ constant\n        k = len\n        ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(arr.count <= 1000, \"Array length\
    \ out of range\")\n    precondition(k < arr.count, \"k out of range\")\n    \n\
    \    var maxIdxs = [Int](repeating: 0, count: k+1)\n    \n    for i in 0 ..< arr.count\
    \ {\n        if maxIdxs[i] < arr[i] {\n            maxIdxs[i+1] = i\n        }\n\
    \    }\n    \n    var maxIdx = 0\n    for i in 0 ..< k && maxIdxs[i] != 0 {\n\
    \        maxIdx = maxIdxs[i]\n    }\n    \n    var result = [Int](repeating: 0,\
    \ count: k+1)\n    for i in 0 ..< k {\n        result[i] = arr[maxIdxs[i]]\n \
    \   }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpat85i1me.swift:30:33: error: cannot find 'i' in scope\n    for\
    \ i in 0 ..< k && maxIdxs[i] != 0 {\n                                ^\n/tmp/tmpat85i1me.swift:30:16:\
    \ error: cannot convert value of type 'Range<Int>' to expected argument type 'Bool'\n\
    \    for i in 0 ..< k && maxIdxs[i] != 0 {\n               ^\n/tmp/tmpat85i1me.swift:30:22:\
    \ error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i in 0\
    \ ..< k && maxIdxs[i] != 0 {\n             ~~~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int]()\n    var maxValue = arr[0]\n\
    \n    for element in arr {\n        if element > maxValue {\n            maxValue\
    \ = element\n        }\n    }\n\n    if k == 0 {\n        return [maxValue]\n\
    \    }\n\n    for _ in 0..<k-1 {\n        for element in arr {\n            if\
    \ element >= maxValue {\n                result.append(element)\n            \
    \    maxValue = element\n            }\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpvlwrmb7h/tmpvlwrmb7h.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae749713c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae74940ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae74940a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7494097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvlwrmb7h                        0x000055c6248697c9 <unavailable> + 6089

    5    libc.so.6                          0x00002ae7498ff460 __libc_start_main +
    245

    6    tmpvlwrmb7h                        0x000055c6248693c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k < 1 {\n        return arr\n    }\n    var\
    \ max = arr[0]\n    var maxIdx : Int = 0\n    for i in 0..<k {\n        if max\
    \ < arr[i] {\n            max = arr[i]\n            maxIdx = i\n        }\n  \
    \  }\n    return Array(arr[0 ..< maxIdx])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpwye7sg33/tmpwye7sg33.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e2fb05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e2f7fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e2f7fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e2f7fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwye7sg33                        0x000055dc6f74e709 <unavailable> + 5897

    5    libc.so.6                          0x00002b4e2fcf1460 __libc_start_main +
    245

    6    tmpwye7sg33                        0x000055dc6f74e309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let result = Array(repeating: Int.max, count:\
    \ k+1)\n    for a in arr {\n        if result[k] < a {\n            result[k]\
    \ = a\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4d10egii.swift:21:19: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n            result[k] = a\n            ~~~~~~^\n/tmp/tmp4d10egii.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = Array(repeating:\
    \ Int.max, count: k+1)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(0 <= k && k <= arr.count, \"index\
    \ out of range\")\n    var max = [Int]()\n    for i in 0..<arr.count {\n     \
    \   if arr[i] > max[0] {\n            max = [arr[i]]\n        } else if arr[i]\
    \ == max[0] {\n            if arr[i] > max[1] {\n                max = [arr[i]]\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d4b896c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d4b58d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2d4b58d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2d4b58d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2d4b58cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2d4b38ce83 <unavailable> + 188035

    6    tmpvfpx92om                        0x000056132a2d171a <unavailable> + 10010

    7    tmpvfpx92om                        0x000056132a2d0609 <unavailable> + 5641

    8    libc.so.6                          0x00002b2d4ba82460 __libc_start_main +
    245

    9    tmpvfpx92om                        0x000056132a2d02e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= len(arr))\n    var maxArr =\
    \ [Int](repeating: 0, count: k)\n    var num = 0\n    var maxNum = -1\n    for\
    \ _ in 0..<k {\n        if maxNum < arr[0] { maxNum = arr[0] }\n        if arr[0]\
    \ > maxNum { maxNum = arr[0] }\n        if arr[1] > maxNum { maxNum = arr[1] }\n\
    \        if arr[2] > maxNum { maxNum = arr[2] }\n        if arr[3] > maxNum {\
    \ maxNum = arr[3] }\n        if arr[4] > maxNum { maxNum = arr[4] }\n        if\
    \ arr[5] > maxNum { maxNum = arr[5] }\n        if arr[6] > maxNum { maxNum = arr[6]\
    \ }\n        if arr[7] > maxNum { maxNum = arr[7] }\n        if arr[8] > maxNum\
    \ { maxNum = arr[8] }\n        if arr[9] > maxNum { maxNum = arr[9] }\n      \
    \  if arr[10] > maxNum { maxNum = arr[10] }\n        if arr[11] > maxNum { maxNum\
    \ = arr[11] }\n        if arr[12] > maxNum { maxNum = arr[12] }\n        if arr[13]\
    \ > maxNum { maxNum = arr[13] }\n        if arr[14] > maxNum { maxNum = arr[14]\
    \ }\n        if arr[15] > maxNum { maxNum = arr[15] }\n        if arr[16] > maxNum\
    \ { maxNum = arr[16] }\n        if arr[17] > maxNum { maxNum = arr[17] }\n   \
    \     if arr[18] > maxNum { maxNum = arr[18] }\n        if arr[19] > maxNum {\
    \ maxNum = arr[19] }\n        if arr[20] > maxNum { maxNum = arr[20] }\n     \
    \   if arr[21] > maxNum { maxNum = arr[21] }\n        if arr[22] > maxNum { maxNum\
    \ = arr[22] }\n        if arr[23] > maxNum { maxNum = arr[23] }\n        if arr[24]\
    \ > maxNum { maxNum = arr[24] }\n        if arr[25] > maxNum { maxNum = arr[25]\
    \ }\n        if arr[26] > maxNum { maxNum = arr[26] }\n        if arr[27] > maxNum\
    \ { maxNum = arr[27] }\n        if arr[28] > maxNum { maxNum = arr[28] }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpm6qri2la.swift:78:72: error: expected '}' at end of brace statement\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])\n    \
    \                                                                   ^\n/tmp/tmpm6qri2la.swift:17:43:\
    \ note: to match this opening '{'\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n\
    \                                          ^\n/tmp/tmpm6qri2la.swift:18:23: error:\
    \ cannot find 'len' in scope\n    precondition(k <= len(arr))\n              \
    \        ^~~\n/tmp/tmpm6qri2la.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    guard k <= arr.count else { return [Int]() }\n\
    \    \n    // Find max index\n    var maxIndex = k\n    for index in stride(from:\
    \ 0, to: arr.count, by: k) {\n        if arr[index] > arr[maxIndex] {\n      \
    \      maxIndex = index\n        }\n    }\n    \n    // Return k elements\n  \
    \  return ArraySlice(arr, maxIndex, maxIndex+k)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxmu9whr_.swift:29:22: error: missing argument label 'arrayLiteral:'\
    \ in call\n    return ArraySlice(arr, maxIndex, maxIndex+k)\n                \
    \     ^\n                      arrayLiteral: \n/tmp/tmpxmu9whr_.swift:29:12: error:\
    \ cannot convert return expression of type 'ArraySlice<Int>' to return type '[Int]'\n\
    \    return ArraySlice(arr, maxIndex, maxIndex+k)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n  if k == 1 {\n    return arr\n  }\n  if arr.count\
    \ < k {\n    return []\n  }\n  \n  result = [Int](count: k, repeatedValue: -1000).sorted()\n\
    \  var i = 0\n  for element in arr {\n    result[i] = max(element, result[i])\n\
    \    i += 1\n  }\n  \n  return result[k:k+k]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgmmwosco.swift:25:3: error: cannot find 'result' in scope\n  result\
    \ = [Int](count: k, repeatedValue: -1000).sorted()\n  ^~~~~~\n/tmp/tmpgmmwosco.swift:25:12:\
    \ error: no exact matches in call to initializer \n  result = [Int](count: k,\
    \ repeatedValue: -1000).sorted()\n           ^\n/tmp/tmpgmmwosco.swift:25:12:\
    \ note: found candidate with type '(Int, Int) -> [Int]'\n  result = [Int](count:\
    \ k, repeatedValue: -1000).sorted()\n           ^\n/tmp/tmpgmmwosco.swift:28:5:\
    \ error: cannot find 'result' in scope\n    result[i] = max(element, result[i])\n\
    \    ^~~~~~\n/tmp/tmpgmmwosco.swift:28:30: error: cannot find 'result' in scope\n\
    \    result[i] = max(element, result[i])\n                             ^~~~~~\n\
    /tmp/tmpgmmwosco.swift:32:10: error: cannot find 'result' in scope\n  return result[k:k+k]\n\
    \         ^~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0, \"k must be positive\")\n\
    \    if k > arr.count {\n        return arr\n    }\n    return maxArray(arr, k)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwczh_bme.swift:22:12: error: cannot find 'maxArray' in scope\n\
    \    return maxArray(arr, k)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    let result = Array(repeating: 0, count:\
    \ k)\n    \n    for i in 0..<k { result[i] = maximum(arr: arr[i..<arr.count],\
    \ k: (k - 1) - i) }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp37hpmzul.swift:21:28: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n    for i in 0..<k { result[i] = maximum(arr: arr[i..<arr.count],\
    \ k: (k - 1) - i) }\n                     ~~~~~~^\n/tmp/tmp37hpmzul.swift:19:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = Array(repeating:\
    \ 0, count: k)\n    ^~~\n    var\n/tmp/tmp37hpmzul.swift:21:34: error: cannot\
    \ assign value of type '[Int]' to subscript of type 'Int'\n    for i in 0..<k\
    \ { result[i] = maximum(arr: arr[i..<arr.count], k: (k - 1) - i) }\n         \
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37hpmzul.swift:21:50:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    for i in 0..<k { result[i] = maximum(arr: arr[i..<arr.count], k:\
    \ (k - 1) - i) }\n                                                 ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var maxIndex = Int64(-1)\n    var maxValue =\
    \ arr[0]\n    for i in arr {\n        if i > maxValue {\n            maxIndex\
    \ = Int64(i)\n            maxValue = i\n        } else if i == maxValue && maxIndex\
    \ < i {\n            maxIndex = Int64(i)\n        }\n    }\n    var arr2 = Array[Int](k)\n\
    \    defer { arr2.SetIndex(0, arr) }\n    return arr2.Slice(maxIndex+1, k)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqn2nn1pz.swift:28:16: error: generic parameter 'Element' could\
    \ not be inferred\n    var arr2 = Array[Int](k)\n               ^\n/tmp/tmpqn2nn1pz.swift:28:16:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var arr2\
    \ = Array[Int](k)\n               ^\n                    <Any>\n/tmp/tmpqn2nn1pz.swift:28:16:\
    \ error: instance member 'subscript' cannot be used on type 'Array<_>'\n    var\
    \ arr2 = Array[Int](k)\n               ^~~~~\n/tmp/tmpqn2nn1pz.swift:28:22: error:\
    \ cannot convert value of type 'Int.Type' to expected argument type 'Int'\n  \
    \  var arr2 = Array[Int](k)\n                     ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k is out of range\"\
    )\n    var result = [0]\n    for val in arr {\n        if val > result[0] {\n\
    \            result[0] = val\n        }\n        if k == 1 {\n            result[1]\
    \ = val\n        }\n    }\n    return Array(result[k-1..<result.count])\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f53aa9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f537a0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f537a0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f537a013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f5379fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzbzpsnt6                        0x0000559464693a25 <unavailable> + 10789

    6    tmpzbzpsnt6                        0x00005594646927c9 <unavailable> + 6089

    7    libc.so.6                          0x00002b8f53c95460 __libc_start_main +
    245

    8    tmpzbzpsnt6                        0x00005594646924a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k < 1 || k > len(arr) {\n        fatalError(\"\
    Invalid args\")\n    }\n    \n    var maxNum = arr[0]\n    var maxIndex = -1\n\
    \    for index in 1..<k {\n        if arr[index] > maxNum {\n            maxNum\
    \ = arr[index]\n            maxIndex = index\n        }\n    }\n    return arr[maxIndex..<k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0wijvdwo.swift:18:21: error: cannot find 'len' in scope\n    if\
    \ k < 1 || k > len(arr) {\n                    ^~~\n/tmp/tmp0wijvdwo.swift:30:15:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return arr[maxIndex..<k]\n           ~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0)\n    precondition(arr.count\
    \ > 0)\n    let arr = Array(arr)\n    let n = arr.count\n    if n < k {\n    \
    \    return arr\n    }\n    var max = [Int]()\n    for i in 0..<k {\n        if\
    \ arr[i] > max[0] {\n            max[0] = arr[i]\n        }\n    }\n    for i\
    \ in 1..<n {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n    \
    \    } else {\n            if arr[i] > max[1] {\n                max[1] = arr[i]\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b953404cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9533d43561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9533d43286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9533d4313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9533d42bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9533b42e83 <unavailable> + 188035

    6    tmphz9ewvdz                        0x000055864858a856 <unavailable> + 10326

    7    tmphz9ewvdz                        0x0000558648589639 <unavailable> + 5689

    8    libc.so.6                          0x00002b9534238460 __libc_start_main +
    245

    9    tmphz9ewvdz                        0x0000558648589319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k > arr.count {\n        return [Int]()\n\
    \    }\n    \n    let maxValue = arr[0]\n    var result = [Int](repeatElement(-1000,\
    \ count: k))\n    for index in 1..<arr.count {\n        if arr[index] > maxValue\
    \ {\n            \n            maxValue = arr[index]\n            result = result[0..<k]\n\
    \        }\n        result[maxValue - arr[index]] = arr[index]\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp16et47s8.swift:27:13: error: cannot assign to value: 'maxValue'\
    \ is a 'let' constant\n            maxValue = arr[index]\n            ^~~~~~~~\n\
    /tmp/tmp16et47s8.swift:22:5: note: change 'let' to 'var' to make it mutable\n\
    \    let maxValue = arr[0]\n    ^~~\n    var\n/tmp/tmp16et47s8.swift:28:28: error:\
    \ cannot assign value of type 'ArraySlice<Int>' to type '[Int]'\n            result\
    \ = result[0..<k]\n                     ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    // base case\n    guard k <= arr.count\
    \ else { return arr }\n    \n    var result = [Int](repeating: -Int, count: k)\n\
    \    var maxCount = 0\n    \n    // iteratively find max element and insert it\
    \ into result\n    for i in 0 ..< k {\n        if arr[i] > result[i] {\n     \
    \       result[i] = arr[i]\n            maxCount = i\n        }\n    }\n    \n\
    \    // iteratively find the rest of the max elements\n    for i in (maxCount+1)\
    \ ..< arr.count {\n        if arr[i] > result[i] {\n            result[i] = arr[i]\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9cflps2w.swift:22:36: error: cannot convert value of type 'Int.Type'\
    \ to expected argument type 'Int'\n    var result = [Int](repeating: -Int, count:\
    \ k)\n                                   ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var max = [Int](repeatElement(-1000, count: k))\n\
    \    for x in arr {\n        if x < 0 || x > max {\n            guard max[k] !=\
    \ -1000\n                else {\n                    print(\"The length of max\
    \ should be less than k, which can not meet the requirements.\")\n           \
    \         return\n            }\n            max[k] = x\n        }\n    }\n  \
    \  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_1ldzl4z.swift:20:25: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if x < 0 || x > max {\n           \
    \             ^\n/tmp/tmp_1ldzl4z.swift:24:21: error: non-void function should\
    \ return a value\n                    return\n                    ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"\")\n    var max\
    \ = 0\n    var max = arr[0]\n    for i in 1...k {\n        if arr[i] > max {\n\
    \            max = arr[i]\n        }\n    }\n    var maxs = [Int]()\n    for n\
    \ in arr {\n        if n >= max {\n            maxs.append(n)\n        }\n   \
    \ }\n    return maxs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpae0ikgdg.swift:20:9: error: invalid redeclaration of 'max'\n  \
    \  var max = arr[0]\n        ^\n/tmp/tmpae0ikgdg.swift:19:9: note: 'max' previously\
    \ declared here\n    var max = 0\n        ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"invalid k\")\n\
    \    let result = arr.sorted()\n    result.removeFirst(k)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplmr6ezq5.swift:20:12: error: cannot use mutating member on immutable\
    \ value: 'result' is a 'let' constant\n    result.removeFirst(k)\n    ~~~~~~ ^\n\
    /tmp/tmplmr6ezq5.swift:19:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = arr.sorted()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count, \"Array length must\
    \ be greater than or equal to k\")\n    let result = Array(0..<k)\n    let maxArray\
    \ = arr.sort { $0 < $1 }\n    for number in maxArray {\n        result[number\
    \ - 1] = number\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwmmjb6fo.swift:20:24: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    let maxArray = arr.sort { $0 < $1 }\n\
    \                   ~~~ ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    require(0 <= k && k <= arr.count, message: \"\
    k is out of bounds\")\n    let ret = Array(Set(arr))\n    ret.sort()\n    return\
    \ ret[k..<ret.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw1krhoai.swift:18:5: error: cannot find 'require' in scope\n  \
    \  require(0 <= k && k <= arr.count, message: \"k is out of bounds\")\n    ^~~~~~~\n\
    /tmp/tmpw1krhoai.swift:20:9: error: cannot use mutating member on immutable value:\
    \ 'ret' is a 'let' constant\n    ret.sort()\n    ~~~ ^\n/tmp/tmpw1krhoai.swift:19:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let ret = Array(Set(arr))\n\
    \    ^~~\n    var\n/tmp/tmpw1krhoai.swift:21:15: error: cannot convert return\
    \ expression of type 'ArraySlice<Int>' to return type '[Int]'\n    return ret[k..<ret.count]\n\
    \           ~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return mergeSort(arr, k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpajwbwvlr.swift:18:12: error: cannot find 'mergeSort' in scope\n\
    \    return mergeSort(arr, k)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k <= 0 || k > arr.count {\n        return\
    \ []\n    }\n    \n    var max = [Int]()\n    var maxIndex = 0\n    \n    for\
    \ index in 0..<k {\n        if arr[index] > arr[index+k] {\n            max =\
    \ [arr[index]] + max\n        } else {\n            max = [arr[index]] + max\n\
    \        }\n        if index == k-1 {\n            maxIndex = index\n        }\n\
    \    }\n    \n    return [max] + arr[k-1..<maxIndex+k]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp689ijhnf.swift:36:13: error: cannot convert value of type '[Int]'\
    \ to expected element type 'Int'\n    return [max] + arr[k-1..<maxIndex+k]\n \
    \           ^\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0, \"Error: k should be positive.\"\
    )\n    precondition(k <= arr.count, \"Error: k should be less than or equal to\
    \ the size of arr.\")\n    var result = Array<Int>()\n    for i in 0..<k {\n \
    \       result = result.maxWithOrdered(arr[i])\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkvm5ny3j.swift:22:25: error: value of type '[Int]' has no member\
    \ 'maxWithOrdered'\n        result = result.maxWithOrdered(arr[i])\n         \
    \        ~~~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    fatalError()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpowspsh82/tmpowspsh82.swift:18: Fatal error

    Current stack trace:

    0    libswiftCore.so                    0x00002b14099bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14096b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14096b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14096b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpowspsh82                        0x000055d5b4e0a1de <unavailable> + 8670

    5    tmpowspsh82                        0x000055d5b4e092e9 <unavailable> + 4841

    6    libc.so.6                          0x00002b1409ba6460 __libc_start_main +
    245

    7    tmpowspsh82                        0x000055d5b4e08fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    // \u5148\u6309\u7167\u5927\u5C0F\u6392\
    \u5E8F\uFF0C\u7136\u540E\u518D\u53D6\u524Dk\u4E2A\n    return sort(arr) { a in\n\
    \        return a.count < k ? a : a[k..<a.count]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpeyhpwk10.swift:20:12: error: cannot find 'sort' in scope\n    return\
    \ sort(arr) { a in\n           ^~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    fatalError(\"not implemented\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp3vqfuppb/tmp3vqfuppb.swift:18: Fatal error: not implemented

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a45dffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a45af6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a45af6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a45af57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3vqfuppb                        0x0000564f62a8d278 <unavailable> + 8824

    5    tmp3vqfuppb                        0x0000564f62a8c379 <unavailable> + 4985

    6    libc.so.6                          0x00002b6a45feb460 __libc_start_main +
    245

    7    tmp3vqfuppb                        0x0000564f62a8c059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k <= 0 || k > len(arr) {\n        return []\n\
    \    }\n    var largest = arr[0]\n    var i: Int\n    for i = 1; i < k; i++ {\n\
    \        if arr[i] > largest {\n            largest = arr[i]\n        }\n    }\n\
    \    var result = [Int]()\n    for i = 1; i < k; i++ {\n        result.append(largest)\n\
    \        largest = arr[i]\n    }\n    result.append(largest)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3ylngd98.swift:23:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 1; i < k; i++ {\n    ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmp3ylngd98.swift:29:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for i = 1; i <\
    \ k; i++ {\n    ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmp3ylngd98.swift:18:22: error: cannot\
    \ find 'len' in scope\n    if k <= 0 || k > len(arr) {\n                     ^~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    let n = arr.count\n    \n    if n < k {\n\
    \        return arr\n    }\n    \n    var maxArr = [Int]()\n    \n    for i in\
    \ 0..<k {\n        maxArr.append(arr[i])\n    }\n    \n    for i in 0..<n {\n\
    \        if arr[i] > maxArr[k-1] {\n            maxArr[k-1] = arr[i]\n       \
    \ }\n    }\n    \n    return maxArr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpdce8mfsq/tmpdce8mfsq.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9da7877c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9da756eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9da756e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9da756d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdce8mfsq                        0x000055985cc96709 <unavailable> + 5897

    5    libc.so.6                          0x00002b9da7a63460 __libc_start_main +
    245

    6    tmpdce8mfsq                        0x000055985cc96309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int]()\n    var m = k\n    if m\
    \ < 1 || k > m.1 {\n        result = []\n    } else {\n        for i in 0..<m\
    \ {\n            if i == 0 {\n                result.append(arr[i])\n        \
    \    } else {\n                let temp = arr[i]\n                for j in 0..<k\
    \ {\n                    if j > 0 {\n                        if temp < arr[j]\
    \ {\n                            temp = arr[j]\n                            result.append(j)\n\
    \                        }\n                    }\n                }\n       \
    \         result.append(temp)\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpashflb9e.swift:20:23: error: value of type 'Int' has no member\
    \ '1'\n    if m < 1 || k > m.1 {\n                    ~ ^\n/tmp/tmpashflb9e.swift:31:29:\
    \ error: cannot assign to value: 'temp' is a 'let' constant\n                \
    \            temp = arr[j]\n                            ^~~~\n/tmp/tmpashflb9e.swift:27:17:\
    \ note: change 'let' to 'var' to make it mutable\n                let temp = arr[i]\n\
    \                ^~~\n                var\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n\treturn removeDuplicates(arr, k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_nc5pten.swift:18:9: error: cannot find 'removeDuplicates' in scope\n\
    \        return removeDuplicates(arr, k)\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    guard k > 0 && k < arr.count else { return arr\
    \ }\n    \n    var max = arr[0]\n    for v in arr {\n        if v > max {\n  \
    \          max = v\n        }\n    }\n    var newArray: [Int] = []\n    \n   \
    \ for v in arr {\n        if v == max {\n            newArray.append(v)\n    \
    \    }\n    }\n    \n    return newArray.sortWith({ $0 < $1 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpsbqtc168.swift:34:21: error: value of type '[Int]' has no member\
    \ 'sortWith'\n    return newArray.sortWith({ $0 < $1 })\n           ~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k >= 0 && k <= arr.count {\n        var max\
    \ = [Int]()\n        max[0] = arr[0]\n        for i = 1; i < k {\n           \
    \ if arr[i] > max[0] {\n                max[0] = arr[i]\n            } else {\n\
    \                max[k-i+1] = arr[i]\n            }\n        }\n        return\
    \ max\n    } else {\n        return [Int](repeatElement(0, count: k-arr.count))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp77nu1d_p.swift:21:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for i = 1; i < k {\n        ^   ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0, \"k should positive\")\n\
    \    precondition(arr.count > 0, \"arr should has count\")\n\n    if k <= 0 ||\
    \ k > arr.count {\n        return arr\n    }\n    \n    switch k {\n    case 1,\
    \ 2:\n        return arr\n    case 3:\n        return merge(merge(arr[0..<k -\
    \ 1], arr[k..<arr.count]), arr[k..<k])\n    default:\n        switch k {\n   \
    \     case 4, 5:\n            return merge(arr[0..<k - 1], merge(arr[k..<k - 1],\
    \ arr[k - 2..<k - 1], arr[k - 3..<k - 1]))\n        case 6:\n            return\
    \ merge(arr[0..<k - 1], merge(arr[k..<k - 1], merge(arr[k - 2..<k - 1], arr[k\
    \ - 3..<k - 1], arr[k - 4..<k - 1])))\n        default:\n            var result\
    \ = [Int]()\n            var i = 0\n            var j = 0\n            var k =\
    \ 0\n            var maxNum: Int = 0\n            var maxIndex: Int = 0\n\n  \
    \          for (; i < arr.count; i = j) {\n                if arr[i] > maxNum\
    \ {\n                    maxNum = arr[i]\n                    maxIndex = i\n \
    \               }\n                if arr[j] > maxNum {\n                    maxNum\
    \ = arr[j]\n                    maxIndex = j\n                }\n            \
    \    if maxNum == arr[i] {\n                    result[k] = arr[i]\n         \
    \           k = k + 1\n                    j = j + 1\n                }\n    \
    \        }\n            \n            k = k + 1\n            \n            return\
    \ result\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgx07suyd.swift:44:13: error: C-style for statement has been removed\
    \ in Swift 3\n            for (; i < arr.count; i = j) {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgx07suyd.swift:29:16: error: cannot find 'merge' in scope\n        return\
    \ merge(merge(arr[0..<k - 1], arr[k..<arr.count]), arr[k..<k])\n             \
    \  ^~~~~\n/tmp/tmpgx07suyd.swift:29:22: error: cannot find 'merge' in scope\n\
    \        return merge(merge(arr[0..<k - 1], arr[k..<arr.count]), arr[k..<k])\n\
    \                     ^~~~~\n/tmp/tmpgx07suyd.swift:33:20: error: cannot find\
    \ 'merge' in scope\n            return merge(arr[0..<k - 1], merge(arr[k..<k -\
    \ 1], arr[k - 2..<k - 1], arr[k - 3..<k - 1]))\n                   ^~~~~\n/tmp/tmpgx07suyd.swift:33:42:\
    \ error: cannot find 'merge' in scope\n            return merge(arr[0..<k - 1],\
    \ merge(arr[k..<k - 1], arr[k - 2..<k - 1], arr[k - 3..<k - 1]))\n           \
    \                              ^~~~~\n/tmp/tmpgx07suyd.swift:35:20: error: cannot\
    \ find 'merge' in scope\n            return merge(arr[0..<k - 1], merge(arr[k..<k\
    \ - 1], merge(arr[k - 2..<k - 1], arr[k - 3..<k - 1], arr[k - 4..<k - 1])))\n\
    \                   ^~~~~\n/tmp/tmpgx07suyd.swift:35:42: error: cannot find 'merge'\
    \ in scope\n            return merge(arr[0..<k - 1], merge(arr[k..<k - 1], merge(arr[k\
    \ - 2..<k - 1], arr[k - 3..<k - 1], arr[k - 4..<k - 1])))\n                  \
    \                       ^~~~~\n/tmp/tmpgx07suyd.swift:35:64: error: cannot find\
    \ 'merge' in scope\n            return merge(arr[0..<k - 1], merge(arr[k..<k -\
    \ 1], merge(arr[k - 2..<k - 1], arr[k - 3..<k - 1], arr[k - 4..<k - 1])))\n  \
    \                                                             ^~~~~\n"
  stdout: ''
  timestamp: 1659978844
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k should be less\
    \ or equal than \\\n    length of arr\")\n    precondition(k >= 0, \"k should\
    \ be less or equal than 0\")\n    if k == 0 || arr == nil || arr.isEmpty {\n \
    \       return []\n    }\n    var max_set = setOf(IntMax)\n    for i in 0..<(arr.count-(k-1))\
    \ {\n        let value = arr[k-1-i]\n        if !max_set.contains(value) {\n \
    \           max_set.insert(value)\n        }\n    }\n    let max_num = max_set.max()\n\
    \    return Array(max_set.filter{$0 != max_num})\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2wv36jcy.swift:18:67: error: invalid escape sequence in literal\n\
    \    precondition(k <= arr.count, \"k should be less or equal than \\\n      \
    \                                                            ^\n/tmp/tmp2wv36jcy.swift:18:34:\
    \ error: unterminated string literal\n    precondition(k <= arr.count, \"k should\
    \ be less or equal than \\\n                                 ^\n/tmp/tmp2wv36jcy.swift:19:18:\
    \ error: unterminated string literal\n    length of arr\")\n                 ^\n\
    /tmp/tmp2wv36jcy.swift:24:19: error: cannot find 'setOf' in scope\n    var max_set\
    \ = setOf(IntMax)\n                  ^~~~~\n/tmp/tmp2wv36jcy.swift:24:25: error:\
    \ cannot find 'IntMax' in scope\n    var max_set = setOf(IntMax)\n           \
    \             ^~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    let len = arr.count\n    \n    if k ==\
    \ 0 || k > len {\n        return [Int]()\n    }\n    \n    var maxK = k\n    \n\
    \    var max = -1000\n    \n    for i in 0..<k {\n        if arr[i] > max {\n\
    \            max = arr[i]\n            maxK = i\n        }\n    }\n    \n    var\
    \ result = [Int]()\n    \n    for i in 0..<maxK {\n        result.append(arr[i])\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp7oz1txgz/tmp7oz1txgz.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10be5f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10be2e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10be2e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10be2e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7oz1txgz                        0x000055c13b8f26b9 <unavailable> + 5817

    5    libc.so.6                          0x00002b10be7dd460 __libc_start_main +
    245

    6    tmp7oz1txgz                        0x000055c13b8f22b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    // \u5229\u7528\u6392\u5E8F\n    var res = IntArray(k,\
    \ 0)\n    for index in 0..<k {\n        res[index] = max(arr[index], arr[k-1])\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6n72incg.swift:19:15: error: cannot find 'IntArray' in scope\n\
    \    var res = IntArray(k, 0)\n              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Array(Set(arr)).sorted(by: >)[k..<k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpc4q4kzuw.swift:18:41: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return Array(Set(arr)).sorted(by:\
    \ >)[k..<k]\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"Invalid arguments\"\
    )\n    let len = arr.count\n    var max_arr = Array(repeating: -Int.max, count:\
    \ k)\n    for i in 0..<k {\n        max_arr[i] = arr[i]\n    }\n    var i = 1\n\
    \    while i < len {\n        if max_arr[i] < arr[i] {\n            max_arr[i]\
    \ = arr[i]\n        }\n        i += 1\n    }\n    return max_arr\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp14i0baaw/tmp14i0baaw.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7a85fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7a82f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac7a82f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7a82f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp14i0baaw                        0x0000561492ad1749 <unavailable> + 5961

    5    libc.so.6                          0x00002ac7a87e8460 __libc_start_main +
    245

    6    tmp14i0baaw                        0x0000561492ad1349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(0 <= k && k <= arr.count, \"invalid\
    \ k\")\n    if arr.count < k {\n        return arr\n    }\n    var maximum = [Int](repeating:\
    \ 0, count: k)\n    for i in 0..<k {\n        maximum[i] = max(maximum[i], arr[i])\n\
    \    }\n    return maximum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpkzaerjk0/tmpkzaerjk0.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac315db7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac315aaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac315aae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac315aad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkzaerjk0                        0x000056467b9db7d9 <unavailable> + 6105

    5    libc.so.6                          0x00002ac315fa3460 __libc_start_main +
    245

    6    tmpkzaerjk0                        0x000056467b9db3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int]()\n    \n    if arr.count\
    \ < k {\n        return result\n    }\n    \n    let small = arr.sorted().prefix(k).maxElement()\n\
    \    \n    for i in small.indices {\n        result.append(arr[i])\n    }\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprnaek8kd.swift:24:40: error: reference to member 'maxElement' cannot\
    \ be resolved without a contextual type\n    let small = arr.sorted().prefix(k).maxElement()\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 || arr == nil || arr == [] {\n    \
    \    return arr\n    }\n\n    var result = [Int](repeating: 0, count: k)\n\n \
    \   for index in 0..<arr.count {\n        for element in arr {\n            if\
    \ element > result[index] {\n                result[index] = element\n       \
    \     }\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpeq9311hp/tmpeq9311hp.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d70f8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d70c82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1d70c82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1d70c817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeq9311hp                        0x00005630c65cd829 <unavailable> + 6185

    5    libc.so.6                          0x00002b1d71177460 __libc_start_main +
    245

    6    tmpeq9311hp                        0x00005630c65cd429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    assert(k <= arr.count)\n    return Array(arr[Range(1...k)])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/Array.swift:418: Fatal error: Array index is out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6cf6d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6cf3c7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac6cf3c7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac6cf3c713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac6cf3c6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ac6cf3b0196 <unavailable> + 1339798

    6    libswiftCore.so                    0x00002ac6cf601457 <unavailable> + 3769431

    7    libswiftCore.so                    0x00002ac6cf3b0570 Array.subscript.getter
    + 20

    8    tmpy8t6feg1                        0x000056528bbd75ae <unavailable> + 9646

    9    tmpy8t6feg1                        0x000056528bbd6619 <unavailable> + 5657

    10   libc.so.6                          0x00002ac6cf8bc460 __libc_start_main +
    245

    11   tmpy8t6feg1                        0x000056528bbd62f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k must be greater\
    \ than or equal to the length of the array\")\n    return arr.reduce([Int](),\
    \ { (prev, cur) -> [Int] in\n        return prev.sorted {$0 > $1}\n    })[k..<arr.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpaczc1tiw.swift:21:7: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    })[k..<arr.count]\n~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0 && k <= arr.count, \"The length\
    \ of arr should be in range of [1, 1000].\")\n    let result = Array(repeating:\
    \ 0, count: k)\n    \n    arr.enumerate().sorted(by: { (x, y) in y! > x! }).enumerated().forEach\
    \ { (i, index) in\n        if index == 0 {\n            result[i] = arr[i]\n \
    \       } else {\n            result[i] = maxElementInArray(arr[0..<i])\n    \
    \    }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpq065dpbu.swift:25:25: error: cannot find 'maxElementInArray' in\
    \ scope\n            result[i] = maxElementInArray(arr[0..<i])\n             \
    \           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    ans := make([]Int, k)\n    if k > len(arr) ||\
    \ k < 1 {\n        return ans\n    }\n    for _, val := range arr {\n        if\
    \ val > ans[k] {\n            ans[k] = val\n        }\n    }\n    return ans\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4i08c_4b.swift:18:8: error: consecutive statements on a line must\
    \ be separated by ';'\n    ans := make([]Int, k)\n       ^\n       ;\n/tmp/tmp4i08c_4b.swift:18:9:\
    \ error: expected expression\n    ans := make([]Int, k)\n        ^\n/tmp/tmp4i08c_4b.swift:22:10:\
    \ error: expected 'in' after for-each pattern\n    for _, val := range arr {\n\
    \         ^\n/tmp/tmp4i08c_4b.swift:22:10: error: expected Sequence expression\
    \ for for-each loop\n    for _, val := range arr {\n         ^\n/tmp/tmp4i08c_4b.swift:18:5:\
    \ error: cannot find 'ans' in scope\n    ans := make([]Int, k)\n    ^~~\n/tmp/tmp4i08c_4b.swift:19:12:\
    \ error: cannot find 'len' in scope\n    if k > len(arr) || k < 1 {\n        \
    \   ^~~\n/tmp/tmp4i08c_4b.swift:20:16: error: cannot find 'ans' in scope\n   \
    \     return ans\n               ^~~\n/tmp/tmp4i08c_4b.swift:27:12: error: cannot\
    \ find 'ans' in scope\n    return ans\n           ^~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k out of range\"\
    )\n    precondition(k <= arr.count, \"k out of range\")\n\n    if k <= 0 {\n \
    \       return []\n    }\n\n    var ans = [Int]()\n    var curMax = -Int64(arr.count)\n\
    \    for el in arr {\n        if el > curMax {\n            ans = append(ans,\
    \ curMax)\n            curMax = el\n        } else {\n            curMax = el\n\
    \        }\n    }\n    ans = append(ans, curMax)\n    return ans[0 : k-1]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpvnte99c5.swift:36:18: error: expected ',' separator\n    return\
    \ ans[0 : k-1]\n                 ^\n                ,\n/tmp/tmpvnte99c5.swift:36:18:\
    \ error: expected expression in list of expressions\n    return ans[0 : k-1]\n\
    \                 ^\n/tmp/tmpvnte99c5.swift:29:19: error: cannot find 'append'\
    \ in scope\n            ans = append(ans, curMax)\n                  ^~~~~~\n\
    /tmp/tmpvnte99c5.swift:30:22: error: cannot assign value of type 'Int' to type\
    \ 'Int64'\n            curMax = el\n                     ^~\n                \
    \     Int64( )\n/tmp/tmpvnte99c5.swift:32:22: error: cannot assign value of type\
    \ 'Int' to type 'Int64'\n            curMax = el\n                     ^~\n  \
    \                   Int64( )\n/tmp/tmpvnte99c5.swift:35:11: error: cannot find\
    \ 'append' in scope\n    ans = append(ans, curMax)\n          ^~~~~~\n/tmp/tmpvnte99c5.swift:36:15:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return ans[0 : k-1]\n           ~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    assert(k <= arr.count)\n    \n    // binary search\
    \ on max element in sub-array\n    let startIdx = (arr.count + k - 1) / 2 // midpoint\
    \ of array\n    let endIdx = startIdx + k - 1\n    let maxElem = arr[endIdx]\n\
    \    \n    // Binary search on the max element in the rest of array\n    let maxIdx\
    \ = (startIdx + k - 1) / 2\n    if arr[maxIdx] > maxElem {\n        maxIdx -=\
    \ 1\n    }\n    \n    guard maxIdx == startIdx || arr[maxIdx] > maxElem else {\
    \ return [maxElem] }\n    \n    let lower = [Int](repeating: -1000, count: k)\n\
    \    let upper = [Int](repeating: 1000, count: k)\n    \n    lower.indices.forEach\
    \ { lower.remove(at: $0) }\n    upper.indices.forEach { upper.remove(at: $0) }\n\
    \    \n    // insert the max element\n    upper.insert(arr[maxIdx], at: startIdx)\n\
    \    \n    let result = [Int](repeating: -1000, count: k)\n    \n    for i in\
    \ 0..<k {\n        result[i] = upper[i]\n    }\n    \n    return result.sorted(by:\
    \ { $0 < $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpsnk3z_p_.swift:28:16: error: left side of mutating operator isn't\
    \ mutable: 'maxIdx' is a 'let' constant\n        maxIdx -= 1\n        ~~~~~~ ^\n\
    /tmp/tmpsnk3z_p_.swift:26:5: note: change 'let' to 'var' to make it mutable\n\
    \    let maxIdx = (startIdx + k - 1) / 2\n    ^~~\n    var\n/tmp/tmpsnk3z_p_.swift:36:35:\
    \ error: cannot use mutating member on immutable value: 'lower' is a 'let' constant\n\
    \    lower.indices.forEach { lower.remove(at: $0) }\n                        \
    \    ~~~~~ ^\n/tmp/tmpsnk3z_p_.swift:33:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let lower = [Int](repeating: -1000, count: k)\n    ^~~\n   \
    \ var\n/tmp/tmpsnk3z_p_.swift:37:35: error: cannot use mutating member on immutable\
    \ value: 'upper' is a 'let' constant\n    upper.indices.forEach { upper.remove(at:\
    \ $0) }\n                            ~~~~~ ^\n/tmp/tmpsnk3z_p_.swift:34:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let upper = [Int](repeating: 1000,\
    \ count: k)\n    ^~~\n    var\n/tmp/tmpsnk3z_p_.swift:40:11: error: cannot use\
    \ mutating member on immutable value: 'upper' is a 'let' constant\n    upper.insert(arr[maxIdx],\
    \ at: startIdx)\n    ~~~~~ ^\n/tmp/tmpsnk3z_p_.swift:34:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let upper = [Int](repeating: 1000, count: k)\n\
    \    ^~~\n    var\n/tmp/tmpsnk3z_p_.swift:45:15: error: cannot assign through\
    \ subscript: 'result' is a 'let' constant\n        result[i] = upper[i]\n    \
    \    ~~~~~~^\n/tmp/tmpsnk3z_p_.swift:42:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let result = [Int](repeating: -1000, count: k)\n    ^~~\n  \
    \  var\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0, \"k should be positive\"\
    )\n    precondition(k < len(arr), \"k should be less than the length of array\"\
    )\n    \n    var result = make([]Int, k)\n    for i := 0; i < k; i++ {\n     \
    \   result[i] = arr[i]\n    }\n    for i := k; i < len(arr); i++ {\n        result[i]\
    \ = max(arr[i-k], result[i-k]) + arr[i]\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpytfbd6vb.swift:21:25: error: expected ',' separator\n    var result\
    \ = make([]Int, k)\n                        ^\n                        ,\n/tmp/tmpytfbd6vb.swift:22:12:\
    \ error: expected type\n    for i := 0; i < k; i++ {\n           ^\n         \
    \   <#type#>\n/tmp/tmpytfbd6vb.swift:22:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < k; i++ {\n           ^\n/tmp/tmpytfbd6vb.swift:22:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < k;\
    \ i++ {\n           ^\n/tmp/tmpytfbd6vb.swift:25:12: error: expected type\n  \
    \  for i := k; i < len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpytfbd6vb.swift:25:12:\
    \ error: expected 'in' after for-each pattern\n    for i := k; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpytfbd6vb.swift:25:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := k; i < len(arr); i++ {\n           ^\n/tmp/tmpytfbd6vb.swift:19:22:\
    \ error: cannot find 'len' in scope\n    precondition(k < len(arr), \"k should\
    \ be less than the length of array\")\n                     ^~~\n/tmp/tmpytfbd6vb.swift:21:18:\
    \ error: cannot find 'make' in scope\n    var result = make([]Int, k)\n      \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Array(arr).sorted(by: >).prefix(k)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpsrl_usyg.swift:18:37: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return Array(arr).sorted(by: >).prefix(k)\n\
    \                                    ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n \
    \   @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __c"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return sort(arr.slice())[:k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpt772bars.swift:18:30: error: expected expression in list of expressions\n\
    \    return sort(arr.slice())[:k]\n                             ^\n/tmp/tmpt772bars.swift:18:12:\
    \ error: cannot find 'sort' in scope\n    return sort(arr.slice())[:k]\n     \
    \      ^~~~\n/tmp/tmpt772bars.swift:18:21: error: value of type '[Int]' has no\
    \ member 'slice'\n    return sort(arr.slice())[:k]\n                ~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return mergeSort(mergeSort(arr, k))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw7ewx91b.swift:18:12: error: cannot find 'mergeSort' in scope\n\
    \    return mergeSort(mergeSort(arr, k))\n           ^~~~~~~~~\n/tmp/tmpw7ewx91b.swift:18:22:\
    \ error: cannot find 'mergeSort' in scope\n    return mergeSort(mergeSort(arr,\
    \ k))\n                     ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var res = arr.prefix(k)\n    let maxArray = Array(res)\n\
    \    maxArray.sortInPlace()\n    return maxArray\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpauti_eui.swift:20:14: error: value of type '[Int]' has no member\
    \ 'sortInPlace'\n    maxArray.sortInPlace()\n    ~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    fatalError(\"not implemented\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp3vqfuppb/tmp3vqfuppb.swift:18: Fatal error: not implemented

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a45dffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a45af6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a45af6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a45af57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3vqfuppb                        0x0000564f62a8d278 <unavailable> + 8824

    5    tmp3vqfuppb                        0x0000564f62a8c379 <unavailable> + 4985

    6    libc.so.6                          0x00002b6a45feb460 __libc_start_main +
    245

    7    tmp3vqfuppb                        0x0000564f62a8c059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let res = arr.sorted()[0..<k]\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfejoovw0.swift:19:12: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return res\n           ^~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0 && k < len(arr), \"k is out\
    \ of range\")\n    \n    // create max array\n    var maxArr = make([]Int, k)\n\
    \    \n    // initialize max array elements\n    for i := 0; i < k; i++ {\n  \
    \      maxArr[i] = 0\n    }\n    \n    // find max element\n    for i := 0; i\
    \ < len(arr); i++ {\n        j := i\n        for ; j < len(arr); j++ {\n     \
    \       if arr[j] > maxArr[j] {\n                j = j + 1\n            }\n  \
    \      }\n        maxArr[i] = arr[j]\n    }\n    \n    return maxArr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpthbu19op.swift:21:25: error: expected ',' separator\n    var maxArr\
    \ = make([]Int, k)\n                        ^\n                        ,\n/tmp/tmpthbu19op.swift:24:12:\
    \ error: expected type\n    for i := 0; i < k; i++ {\n           ^\n         \
    \   <#type#>\n/tmp/tmpthbu19op.swift:24:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < k; i++ {\n           ^\n/tmp/tmpthbu19op.swift:24:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < k;\
    \ i++ {\n           ^\n/tmp/tmpthbu19op.swift:29:12: error: expected type\n  \
    \  for i := 0; i < len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpthbu19op.swift:29:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpthbu19op.swift:29:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n/tmp/tmpthbu19op.swift:30:10:\
    \ error: consecutive statements on a line must be separated by ';'\n        j\
    \ := i\n         ^\n         ;\n/tmp/tmpthbu19op.swift:30:11: error: expected\
    \ expression\n        j := i\n          ^\n/tmp/tmpthbu19op.swift:31:9: error:\
    \ C-style for statement has been removed in Swift 3\n        for ; j < len(arr);\
    \ j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~\n/tmp/tmpthbu19op.swift:18:31: error:\
    \ cannot find 'len' in scope\n    precondition(k > 0 && k < len(arr), \"k is out\
    \ of range\")\n                              ^~~\n/tmp/tmpthbu19op.swift:21:18:\
    \ error: cannot find 'make' in scope\n    var maxArr = make([]Int, k)\n      \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count)\n    return arr[k..<arr.count].sorted\
    \ { $0 > $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpctxfmjig/tmpctxfmjig.swift:18: Precondition failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42ea872c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42ea569b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42ea569988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42ea5687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpctxfmjig                        0x00005621539d1460 <unavailable> + 9312

    5    tmpctxfmjig                        0x00005621539d0539 <unavailable> + 5433

    6    libc.so.6                          0x00002b42eaa5e460 __libc_start_main +
    245

    7    tmpctxfmjig                        0x00005621539d0219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Solution.maximum(arr, k)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpembfas6_.swift:18:12: error: cannot find 'Solution' in scope\n\
    \    return Solution.maximum(arr, k)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    var result = [Int]()\n    \n    for a in\
    \ arr {\n        if result.count < k {\n            result.append(a)\n       \
    \ }\n        else {\n            if a > result[result.count - k] {\n         \
    \       result.removeLast()\n                result.append(a)\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp5g3lj_zu/tmp5g3lj_zu.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0efaf2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0efac23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0efac23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0efac227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5g3lj_zu                        0x00005639d3dfb779 <unavailable> + 6009

    5    libc.so.6                          0x00002b0efb118460 __libc_start_main +
    245

    6    tmp5g3lj_zu                        0x00005639d3dfb379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count, \"k out of range\"\
    )\n    var result = Array<Int>(repeating: -1000, count: k)\n    for index in range(arr.count)\
    \ {\n        if result[index] > arr[index] {\n            result[index] = arr[index]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbweyaq17.swift:20:18: error: cannot find 'range' in scope\n   \
    \ for index in range(arr.count) {\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [0] * (k+1)\n    for i := 1; i <=\
    \ k; i++ {\n        result[i] = max(arr[i-1], arr[i])\n    }\n    for i := k+1;\
    \ i <= len(arr); i++ {\n        result[i] = max(arr[i-1], arr[i])\n    }\n   \
    \ return result[0:k+1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4kzpaab5.swift:19:12: error: expected type\n    for i := 1; i <=\
    \ k; i++ {\n           ^\n            <#type#>\n/tmp/tmp4kzpaab5.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i <= k; i++ {\n\
    \           ^\n/tmp/tmp4kzpaab5.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i <= k; i++ {\n           ^\n/tmp/tmp4kzpaab5.swift:22:12:\
    \ error: expected type\n    for i := k+1; i <= len(arr); i++ {\n           ^\n\
    \            <#type#>\n/tmp/tmp4kzpaab5.swift:22:12: error: expected 'in' after\
    \ for-each pattern\n    for i := k+1; i <= len(arr); i++ {\n           ^\n/tmp/tmp4kzpaab5.swift:22:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := k+1; i <=\
    \ len(arr); i++ {\n           ^\n/tmp/tmp4kzpaab5.swift:25:20: error: expected\
    \ ',' separator\n    return result[0:k+1]\n                   ^\n            \
    \       ,\n/tmp/tmp4kzpaab5.swift:25:20: error: expected expression in list of\
    \ expressions\n    return result[0:k+1]\n                   ^\n/tmp/tmp4kzpaab5.swift:18:22:\
    \ error: binary operator '*' cannot be applied to operands of type '[Int]' and\
    \ 'Int'\n    var result = [0] * (k+1)\n                 ~~~ ^ ~~~~~\n/tmp/tmp4kzpaab5.swift:18:22:\
    \ note: overloads for '*' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    var result = [0] * (k+1)\n                     ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return arr.reduce(into: [Int](), {$0[$0.startIndex..<$0.endIndex]}){$0\
    \ ~= $0[$0.startIndex..<$0.endIndex].max()}.sorted()[0..<k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptb388h9u.swift:18:72: error: extra trailing closure passed in call\n\
    \    return arr.reduce(into: [Int](), {$0[$0.startIndex..<$0.endIndex]}){$0 ~=\
    \ $0[$0.startIndex..<$0.endIndex].max()}.sorted()[0..<k]\n                   \
    \                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptb388h9u.swift:18:38: error: contextual closure type '(inout [Int], Int)\
    \ throws -> ()' expects 2 arguments, but 1 was used in closure body\n    return\
    \ arr.reduce(into: [Int](), {$0[$0.startIndex..<$0.endIndex]}){$0 ~= $0[$0.startIndex..<$0.endIndex].max()}.sorted()[0..<k]\n\
    \                                     ^\n/tmp/tmptb388h9u.swift:18:126: error:\
    \ cannot convert return expression of type 'ArraySlice<Int>' to return type '[Int]'\n\
    \    return arr.reduce(into: [Int](), {$0[$0.startIndex..<$0.endIndex]}){$0 ~=\
    \ $0[$0.startIndex..<$0.endIndex].max()}.sorted()[0..<k]\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    // base case\n    if k == 0 || len(arr) <= k\
    \ {\n        return [arr[0]]\n    }\n    // recursion\n    var maxs = [Int]()\n\
    \    var max = [Int]()\n    for x in arr {\n        if x <= 0 {\n            continue\n\
    \        }\n        if maxs.count >= k {\n            maxs = maxs.dropFirst()\n\
    \        }\n        if x < maxs[0] {\n            max[0] = x\n        } else if\
    \ x > maxs[1] {\n            max[1] = x\n        }\n        maxs.append(x)\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfefhx63b.swift:19:18: error: cannot find 'len' in scope\n    if\
    \ k == 0 || len(arr) <= k {\n                 ^~~\n/tmp/tmpfefhx63b.swift:30:25:\
    \ error: no 'dropFirst' candidates produce the expected contextual result type\
    \ '[Int]'\n            maxs = maxs.dropFirst()\n                        ^\nSwift.Sequence:4:40:\
    \ note: 'dropFirst' produces 'DropFirstSequence<[Int]>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public __consuming func dropFirst(_ k: Int\
    \ = 1) -> DropFirstSequence<Self>\n                                       ^\n\
    Swift.Collection:3:40: note: 'dropFirst' produces 'ArraySlice<Int>', not the expected\
    \ contextual result type '[Int]'\n    @inlinable public __consuming func dropFirst(_\
    \ k: Int = 1) -> Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0, \"k must be greater than\
    \ zero\")\n    precondition(k < arr.count, \"k must be less than or equal to array\
    \ length\")\n    let len = arr.count\n    var max = arr[0]\n    arr.sort(by: <)\n\
    \    for index in 1..k {\n        if arr[index] > max {\n            max = arr[index]\n\
    \        }\n    }\n    return Array(arr[k..<len]).sorted(by: <)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprlzetdy3.swift:22:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort(by: <)\n    ~~~ ^\n/tmp/tmprlzetdy3.swift:23:19:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for index\
    \ in 1..k {\n                  ^~\n                  ...\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(arr.count >= k, \"The length of\
    \ the array should be in the range of [1, 1000].\");\n    precondition(k <= arr.count,\
    \ \"k should be in the range of [0, len(arr)).\");\n\n    if k == 0 {\n      \
    \  return arr\n    }\n    \n    var maxArr = [Int](repeating: -1000, count: k);\n\
    \    \n    for i in 0..<k {\n        maxArr[i] = arr[i] > maxArr[i] ? arr[i] :\
    \ maxArr[i]\n    }\n    \n    for i in 0..<k {\n        if arr[i] > maxArr[k-1]\
    \ {\n            maxArr[k-1] = arr[i]\n        }\n    }\n    \n    return maxArr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp_hnwal95/tmp_hnwal95.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad70b1c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad70aebfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad70aebf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad70aebe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_hnwal95                        0x0000564967c8e749 <unavailable> + 5961

    5    libc.so.6                          0x00002ad70b3b4460 __libc_start_main +
    245

    6    tmp_hnwal95                        0x0000564967c8e349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Array(zip(Array(0..<k).sorted(), arr))\n\
    \        .filter{_._1 > _._2}.map{_._2}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw0g5zf88.swift:19:17: error: type placeholder not allowed here\n\
    \        .filter{_._1 > _._2}.map{_._2}\n                ^\n/tmp/tmpw0g5zf88.swift:19:24:\
    \ error: type placeholder not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n\
    \                       ^\n/tmp/tmpw0g5zf88.swift:19:17: error: type placeholder\
    \ not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n                ^\n\
    /tmp/tmpw0g5zf88.swift:19:24: error: type placeholder not allowed here\n     \
    \   .filter{_._1 > _._2}.map{_._2}\n                       ^\n/tmp/tmpw0g5zf88.swift:19:17:\
    \ error: type placeholder not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n\
    \                ^\n/tmp/tmpw0g5zf88.swift:19:24: error: type placeholder not\
    \ allowed here\n        .filter{_._1 > _._2}.map{_._2}\n                     \
    \  ^\n/tmp/tmpw0g5zf88.swift:19:17: error: type placeholder not allowed here\n\
    \        .filter{_._1 > _._2}.map{_._2}\n                ^\n/tmp/tmpw0g5zf88.swift:19:24:\
    \ error: type placeholder not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n\
    \                       ^\n/tmp/tmpw0g5zf88.swift:19:17: error: type placeholder\
    \ not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n                ^\n\
    /tmp/tmpw0g5zf88.swift:19:24: error: type placeholder not allowed here\n     \
    \   .filter{_._1 > _._2}.map{_._2}\n                       ^\n/tmp/tmpw0g5zf88.swift:19:17:\
    \ error: type placeholder not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n\
    \                ^\n/tmp/tmpw0g5zf88.swift:19:24: error: type placeholder not\
    \ allowed here\n        .filter{_._1 > _._2}.map{_._2}\n                     \
    \  ^\n/tmp/tmpw0g5zf88.swift:19:17: error: type placeholder not allowed here\n\
    \        .filter{_._1 > _._2}.map{_._2}\n                ^\n/tmp/tmpw0g5zf88.swift:19:24:\
    \ error: type placeholder not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n\
    \                       ^\n/tmp/tmpw0g5zf88.swift:19:17: error: type placeholder\
    \ not allowed here\n        .filter{_._1 > _._2}.map{_._2}\n                ^\n\
    /tmp/tmpw0g5zf88.swift:19:24: error: type placeholder not allowed here\n     \
    \   "
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    let count = (arr as NSArray).count\n  \
    \  \n    if count == 0 { return [] }\n    \n    let maxNum = arr.reduce(0, combine:\
    \ { (prev, cur) -> Int in\n        let curInt = (cur as NSNumber).integerValue\n\
    \        return max(prev, curInt)\n    })\n    \n    let maxArr = [Int](count:\
    \ count, repeatedValue: maxNum)\n    \n    var maxCount = 0\n    for i in 0..<count\
    \ {\n        let curInt = (arr[i] as NSNumber).integerValue\n        if curInt\
    \ == maxNum {\n            maxCount += 1\n            maxArr[i] = curInt\n   \
    \     }\n    }\n    \n    let leftOver = k - maxCount\n    if leftOver > 0 { maxArr.append(contentsOf:\
    \ [Int](count: leftOver, repeatedValue: 0)) }\n    \n    return maxArr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2h_mrb6k.swift:19:25: error: cannot find type 'NSArray' in scope\n\
    \    let count = (arr as NSArray).count\n                        ^~~~~~~\n/tmp/tmp2h_mrb6k.swift:24:30:\
    \ error: cannot find type 'NSNumber' in scope\n        let curInt = (cur as NSNumber).integerValue\n\
    \                             ^~~~~~~~\n/tmp/tmp2h_mrb6k.swift:23:28: error: extraneous\
    \ argument label 'combine:' in call\n    let maxNum = arr.reduce(0, combine: {\
    \ (prev, cur) -> Int in\n                           ^   ~~~~~~~~~\n          \
    \                     \n/tmp/tmp2h_mrb6k.swift:24:40: error: value of type 'Int'\
    \ has no member 'integerValue'\n        let curInt = (cur as NSNumber).integerValue\n\
    \                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~\n/tmp/tmp2h_mrb6k.swift:28:53:\
    \ error: extra argument 'repeatedValue' in call\n    let maxArr = [Int](count:\
    \ count, repeatedValue: maxNum)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmp2h_mrb6k.swift:40:49: error: no exact matches in call to initializer \n\
    \    if leftOver > 0 { maxArr.append(contentsOf: [Int](count: leftOver, repeatedValue:\
    \ 0)) }\n                                                ^\n/tmp/tmp2h_mrb6k.swift:40:49:\
    \ note: found candidate with type '(Int, Int) -> [Int]'\n    if leftOver > 0 {\
    \ maxArr.append(contentsOf: [Int](count: leftOver, repeatedValue: 0)) }\n    \
    \                                            ^\n/tmp/tmp2h_mrb6k.swift:32:33:\
    \ error: cannot find type 'NSNumber' in scope\n        let curInt = (arr[i] as\
    \ NSNumber).integerValue\n                                ^~~~~~~~\n/tmp/tmp2h_mrb6k.swift:32:43:\
    \ error: reference to member 'integerValue' cannot be resolved without a contextual\
    \ type\n        let curInt = (arr[i] as NSNumber).integerValue\n             \
    \                             ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Array(Set(arr).sorted(by: >))[k..<k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8y1xe93k.swift:18:41: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return Array(Set(arr).sorted(by:\
    \ >))[k..<k]\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978840
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k < 1 || k > len(arr) {\n        return nil\n\
    \    }\n\n    let result = [Int]()\n    var currentMax = arr[0]\n    for i in\
    \ 1..<k {\n        if currentMax < arr[i] {\n            currentMax = arr[i]\n\
    \        }\n        result.append(currentMax)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_ikm_fo3.swift:18:21: error: cannot find 'len' in scope\n    if\
    \ k < 1 || k > len(arr) {\n                    ^~~\n/tmp/tmp_ikm_fo3.swift:19:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n/tmp/tmp_ikm_fo3.swift:28:16: error: cannot use mutating member\
    \ on immutable value: 'result' is a 'let' constant\n        result.append(currentMax)\n\
    \        ~~~~~~ ^\n/tmp/tmp_ikm_fo3.swift:22:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let result = [Int]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int]()\n    for num in arr {\n\
    \        if k <= 0 || num > result[k-1] {\n            result.append(num)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a0b731c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a0b428561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9a0b428286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9a0b42813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9a0b427bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9a0b227e83 <unavailable> + 188035

    6    tmpcat3u7bs                        0x00005650bffbf519 <unavailable> + 9497

    7    tmpcat3u7bs                        0x00005650bffbe559 <unavailable> + 5465

    8    libc.so.6                          0x00002b9a0b91d460 __libc_start_main +
    245

    9    tmpcat3u7bs                        0x00005650bffbe239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k should at most\
    \ have same length as arr\")\n\n    // use sortInPlace() to keep the original\
    \ array intact\n    let sortedArr = arr.sortInPlace()\n    if arr.count > k {\n\
    \        return sortedArr[k..<arr.count]\n    }\n\n    return sortedArr\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpspzgrktc.swift:21:25: error: value of type '[Int]' has no member\
    \ 'sortInPlace'\n    let sortedArr = arr.sortInPlace()\n                    ~~~\
    \ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 || arr == nil || arr.count <= 0 {\n\
    \        return nil\n    }\n    if k <= arr.count {\n        return Array(arr[k..<arr.count])\n\
    \    }\n    \n    var result = Array(k + 1)\n    for index in 0..<k {\n      \
    \  var maxIndex = index\n        for element in  arr[index..<arr.count] {\n  \
    \          if element > result[maxIndex] {\n                maxIndex = index\n\
    \            }\n        }\n        result[index] = arr[maxIndex]\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4,\
    \ 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\n\
    assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1c8__tx_.swift:18:22: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if k == 0 || arr == nil || arr.count\
    \ <= 0 {\n                 ~~~ ^  ~~~\n/tmp/tmp1c8__tx_.swift:19:16: error: 'nil'\
    \ is incompatible with return type '[Int]'\n        return nil\n             \
    \  ^\n/tmp/tmp1c8__tx_.swift:25:24: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var result = Array(k + 1)\n                       ^\n         \
    \              arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count, \"k is out of bounds\"\
    )\n    var max = [Int](repeating: 0, count: k)\n    var largestIndex: Int = -1\n\
    \    for i in 0..<k {\n        if arr[i] > max[k-1] {\n            max[k] = arr[i]\n\
    \            largestIndex = i\n        }\n    }\n    for i in 0..<k {\n      \
    \  if arr[i] > max[k] {\n            max[k] = arr[i]\n        }\n    }\n    max[largestIndex]\
    \ = arr[largestIndex]\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp5kx729jp/tmp5kx729jp.swift:18: Precondition failed: k is out of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3b303fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3b2d36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3b2d36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3b2d357b0 _assertionFailure(_:_:file:line:flags:)
    + 365

    4    tmp5kx729jp                        0x000055e51841464a <unavailable> + 9802

    5    tmp5kx729jp                        0x000055e518413669 <unavailable> + 5737

    6    libc.so.6                          0x00002ab3b322b460 __libc_start_main +
    245

    7    tmp5kx729jp                        0x000055e518413349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int]()\n    for indexValue in arr.reverse()\
    \ {\n        result.insert(indexValue, indexValue)\n    }\n    result.removeLast()\n\
    \    result.sort{$0 > $1}\n    if result.count > k {\n        return arr[k..<result.count]\n\
    \    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnieejt9d.swift:19:27: error: for-in loop requires '()' to conform\
    \ to 'Sequence'\n    for indexValue in arr.reverse() {\n                     \
    \ ~~~~^~~~~~~~~\n/tmp/tmpnieejt9d.swift:19:27: error: cannot use mutating member\
    \ on immutable value: 'arr' is a 'let' constant\n    for indexValue in arr.reverse()\
    \ {\n                      ~~~ ^\n/tmp/tmpnieejt9d.swift:25:19: error: cannot\
    \ convert return expression of type 'ArraySlice<Int>' to return type '[Int]'\n\
    \        return arr[k..<result.count]\n               ~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    // \u786E\u4FDD\u6570\u7EC4\u5927\u5C0F\u4E3A\
    \u4E00\u5B9A\u8303\u56F4\u5185\uFF0C\u5C0F\u4E8E\u7B49\u4E8E1000\n    if arr.count\
    \ < 1 || arr.count > 1000 {\n        return arr\n    }\n\n    if k <= 0 || k >=\
    \ arr.count {\n        return arr\n    }\n\n    // \u6309\u7167\u4ECE\u5927\u5230\
    \u5C0F\u7684\u987A\u5E8F\u6392\u5E8F\n    guard let array = arr.reduce([Int]())\
    \ { $0.sorted(<)\n    guard let maxValue = max(array) else {\n        return array\n\
    \    }\n\n    var result = [Int]()\n    var pos = 0\n    \n    for element in\
    \ array {\n        guard pos <= k else {\n            result.append(element)\n\
    \            break\n        }\n        \n        if element == maxValue {\n  \
    \          result.append(element)\n            pos += 1\n        }\n    }\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3u8nv3hq.swift:28:43: error: expected 'else' after 'guard' condition\n\
    \    guard let array = arr.reduce([Int]()) { $0.sorted(<)\n                  \
    \                        ^\n                                          else \n\
    /tmp/tmp3u8nv3hq.swift:28:45: error: anonymous closure argument not contained\
    \ in a closure\n    guard let array = arr.reduce([Int]()) { $0.sorted(<)\n   \
    \                                         ^\n/tmp/tmp3u8nv3hq.swift:74:72: error:\
    \ expected '}' at end of brace statement\nassert(maximum(arr: [1, 2, 3, -23, 243,\
    \ -400, 0], k: 0) == [] as [Int])\n                                          \
    \                             ^\n/tmp/tmp3u8nv3hq.swift:17:43: note: to match\
    \ this opening '{'\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n            \
    \                              ^\n/tmp/tmp3u8nv3hq.swift:28:41: error: missing\
    \ argument for parameter #2 in call\n    guard let array = arr.reduce([Int]())\
    \ { $0.sorted(<)\n                                        ^\n                \
    \                        , <#([Int], Int) throws -> [Int]#>\nSwift.Sequence:2:28:\
    \ note: 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n/tmp/tmp3u8nv3hq.swift:29:30:\
    \ error: cannot find 'array' in scope\n    guard let maxValue = max(array) else\
    \ {\n                             ^~~~~\n/tmp/tmp3u8nv3hq.swift:29:35: error:\
    \ missing argument for parameter #2 in call\n    guard let maxValue = max(array)\
    \ else {\n                                  ^\n                              \
    \    , <#_#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable public func\
    \ max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n\
    /tmp/tmp3u8nv3hq.swift:30:16: error: cannot find 'array' in scope\n        return\
    \ array\n               ^~~~~\n/tmp/tmp3u8nv3hq.swift:36:20: error: cannot find\
    \ 'array' in scope\n    for element in array {\n                   ^~~~~\n/tmp/tmp3u8nv3hq.swift:52:6:\
    \ error: operator functi"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    precondition(0 <= k, \"The k element must\
    \ be in between 0 and \\(arr.count)\")\n    precondition(k <= arr.count, \"The\
    \ k element must be in between 0 and \\(arr.count)\")\n    \n    // Add k to arr\n\
    \    let arr = arr + [k]\n    \n    // Sort arr\n    arr.sort()\n    \n    //\
    \ Get maximum k elements from arr\n    return Array(arr[k..<arr.count])\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzor5u_j3.swift:26:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n/tmp/tmpzor5u_j3.swift:23:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let arr = arr + [k]\n  \
    \  ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n  if arr == [] {\n    return arr\n  }\n  \n  var\
    \ result = [Int]()\n  \n  for item in arr {\n    result.append(item)\n    if result.count\
    \ > k {\n      result.removeLast()\n    }\n  }\n  \n  return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp5w8g8hf8/tmp5w8g8hf8.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4194290c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4193f87b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4193f87988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4193f867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5w8g8hf8                        0x0000562eada09729 <unavailable> + 5929

    5    libc.so.6                          0x00002b419447c460 __libc_start_main +
    245

    6    tmp5w8g8hf8                        0x0000562eada09329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    // Write your code here\n    \n    return arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmphnwhkm4e/tmphnwhkm4e.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1dc042ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1dc0121b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1dc0121988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1dc01207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphnwhkm4e                        0x000056515fe183c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b1dc0616460 __libc_start_main +
    245

    6    tmphnwhkm4e                        0x000056515fe17fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    func max(num: Int, i: Int, n: Int) -> Int {\n\
    \        if num > n {\n            return num\n        }\n        return i\n \
    \   }\n    if k == 1 {\n        return arr\n    }\n    if k == len(arr) {\n  \
    \      return arr\n    }\n    let nums = arr[k - 1]\n    arr.removeLast()\n  \
    \  if k == 2 {\n        return max(nums, arr[0], arr[k - 1])\n    }\n    if arr[k-1]\
    \ > nums {\n        return arr\n    }\n    return arr[k - 1]\n        .map({ max(nums,\
    \ $0, k - 1) })\n        .reduce([Int]()) { $0 + [$1] + [$0] }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb29w8d8k.swift:27:13: error: cannot find 'len' in scope\n    if\
    \ k == len(arr) {\n            ^~~\n/tmp/tmpb29w8d8k.swift:31:9: error: cannot\
    \ use mutating member on immutable value: 'arr' is a 'let' constant\n    arr.removeLast()\n\
    \    ~~~ ^\n/tmp/tmpb29w8d8k.swift:33:19: error: missing argument labels 'num:i:n:'\
    \ in call\n        return max(nums, arr[0], arr[k - 1])\n                  ^\n\
    \                   num:  i:      n: \n/tmp/tmpb29w8d8k.swift:33:16: error: cannot\
    \ convert return expression of type 'Int' to return type '[Int]'\n        return\
    \ max(nums, arr[0], arr[k - 1])\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb29w8d8k.swift:39:10: error: value of type 'Int' has no member 'map'\n\
    \        .map({ max(nums, $0, k - 1) })\n         ^~~\n/tmp/tmpb29w8d8k.swift:39:19:\
    \ error: missing argument labels 'num:i:n:' in call\n        .map({ max(nums,\
    \ $0, k - 1) })\n                  ^\n                   num:  i:  n: \n"
  stdout: ''
  timestamp: 1659978846
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k should be less\
    \ than or equal to the length of the array\")\n    \n    let resultMax = arr.reduce(Int.min,\
    \ { x, y in\n        return if x >= y {x} else {y}\n    })\n    let resultMin\
    \ = arr.reduce(Int.max, { x, y in\n        return if x <= y {x} else {y}\n   \
    \ })\n    if resultMin > resultMax {\n        var temp = [Int]()\n        for\
    \ i in 1...k {\n            temp.append(arr[i])\n        }\n        return temp\n\
    \    } else {\n        var temp = [Int]()\n        for i in 1...k {\n        \
    \    temp.append(arr[i])\n        }\n        \n        for i in 0..k-1 {\n   \
    \         if arr[i] == resultMin {\n                temp.removeAtIndex(i)\n  \
    \          }\n        }\n        return temp\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppdr0dtbs.swift:21:15: error: consecutive statements on a line must\
    \ be separated by ';'\n        return if x >= y {x} else {y}\n              ^\n\
    \              ;\n/tmp/tmppdr0dtbs.swift:24:15: error: consecutive statements\
    \ on a line must be separated by ';'\n        return if x <= y {x} else {y}\n\
    \              ^\n              ;\n/tmp/tmppdr0dtbs.swift:21:9: error: cannot\
    \ convert return expression of type '()' to return type 'Int'\n        return\
    \ if x >= y {x} else {y}\n        ^~~~~~\n/tmp/tmppdr0dtbs.swift:24:9: error:\
    \ cannot convert return expression of type '()' to return type 'Int'\n       \
    \ return if x <= y {x} else {y}\n        ^~~~~~\n/tmp/tmppdr0dtbs.swift:38:19:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        for\
    \ i in 0..k-1 {\n                  ^~\n                  ...\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    // code here\n    let arr = arr\n    let count\
    \ = arr.count\n    var maximums = [Int]()\n    if k == 0 || count <= k {\n   \
    \     return arr\n    }\n    \n    var maximum = arr[0]\n    for i in 1..<k {\n\
    \        if arr[i] > maximum {\n            maximum = arr[i]\n        }\n    }\n\
    \    maximums.append(maximum)\n    \n    for _ in 1..<k-1 {\n        var i = 0\n\
    \        for j in 0..<count {\n            if arr[i] > maximums[j] {\n       \
    \         maximums[j] = arr[i]\n            }\n            i += 1\n        }\n\
    \    }\n    \n    return maximums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp07dhuyrl/tmp07dhuyrl.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea2f0a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea2ed9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea2ed9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea2ed9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp07dhuyrl                        0x00005637a88b8709 <unavailable> + 5897

    5    libc.so.6                          0x00002aea2f292460 __libc_start_main +
    245

    6    tmp07dhuyrl                        0x00005637a88b8309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    \n    let n = arr.count\n    \n    guard n >=\
    \ 1 && n <= 1000 else {\n        return arr\n    }\n    \n    var max = [Int]()\n\
    \    \n    if n == 1 {\n        return arr\n    }\n    \n    if k > n {\n    \
    \    k = n\n    }\n    \n    for i in 0..<k {\n        if arr[i] > max[0] {\n\
    \            max[0] = arr[i]\n        }\n    }\n    \n    for i in 1..<n {\n \
    \       if arr[i] > max[0] {\n            max[0] = arr[i]\n        }\n    }\n\
    \    \n    for i in 0..<k {\n        if arr[i] > max[1] {\n            max[1]\
    \ = arr[i]\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpcg5x3l8u.swift:32:9: error: cannot assign to value: 'k' is a 'let'\
    \ constant\n        k = n\n        ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k < arr.count, \"len(arr) must be\
    \ >= k\")\n    var result = Array<Int>(repeating: Int.max,\n                 \
    \           count: k+1)\n    \n    for i in 0..<k {\n        result[i] = max(arr[i],\
    \ result[i-k])\n    }\n    \n    result[k] = arr[k]\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmphya1luis/tmphya1luis.swift:18: Precondition failed: len(arr) must be
    >= k

    Current stack trace:

    0    libswiftCore.so                    0x00002b1036090c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1035d87b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1035d87988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1035d867b0 _assertionFailure(_:_:file:line:flags:)
    + 365

    4    tmphya1luis                        0x000055c4996116c1 <unavailable> + 9921

    5    tmphya1luis                        0x000055c4996106f9 <unavailable> + 5881

    6    libc.so.6                          0x00002b103627c460 __libc_start_main +
    245

    7    tmphya1luis                        0x000055c4996103d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k > arr.count {\n        return nil\n    }\n\
    \    \n    var max: [Int] = []\n    var i = 0\n    var curMax: Int = arr[i]\n\
    \    for index in 1...k {\n        if arr[i] > curMax {\n            i = index\n\
    \            curMax = arr[i]\n        }\n    }\n    \n    max = [curMax] + max\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpp35l4a7g.swift:19:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count)\n    var max = -math.infinity\n\
    \    var result = [Int]()\n    for el in arr {\n        if el > max {\n      \
    \      max = el\n        } else {\n            append(result, max)\n         \
    \   if arr.count > 1 {\n                max += arr.last!\n            } else {\n\
    \                max = arr[0]\n            }\n        }\n    }\n    append(result,\
    \ max)\n    return result.sorted(by: { $0 > $1 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9i6doa44.swift:19:16: error: cannot find 'math' in scope\n    var\
    \ max = -math.infinity\n               ^~~~\n/tmp/tmp9i6doa44.swift:25:13: error:\
    \ cannot find 'append' in scope\n            append(result, max)\n           \
    \ ^~~~~~\n/tmp/tmp9i6doa44.swift:33:5: error: cannot find 'append' in scope\n\
    \    append(result, max)\n    ^~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let result = Array(repeating: 0, count: k)\n\
    \    for elem in arr {\n        result[result.index(of: elem)!] = elem\n    }\n\
    \    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4h9uu5ey.swift:20:15: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n        result[result.index(of: elem)!] = elem\n      \
    \  ~~~~~~^\n/tmp/tmp4h9uu5ey.swift:18:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let result = Array(repeating: 0, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return sortSliceByKey(arr, &k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxnl4crn1.swift:18:12: error: cannot find 'sortSliceByKey' in scope\n\
    \    return sortSliceByKey(arr, &k)\n           ^~~~~~~~~~~~~~\n/tmp/tmpxnl4crn1.swift:18:32:\
    \ error: cannot pass immutable value as inout argument: 'k' is a 'let' constant\n\
    \    return sortSliceByKey(arr, &k)\n                               ^~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return sort(arr, 0, arr.count-1, k)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppvsbhqot.swift:18:12: error: cannot find 'sort' in scope\n    return\
    \ sort(arr, 0, arr.count-1, k)\n           ^~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n\tif k == 0 || arr.isEmpty() { return arr }\n\t\n\
    \tarr.sortInPlace()\n\t\n\treturn arr[k..<arr.count]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpal1luovi.swift:18:19: error: cannot call value of non-function\
    \ type 'Bool'\n        if k == 0 || arr.isEmpty() { return arr }\n           \
    \              ^      ~~\n                                \n/tmp/tmpal1luovi.swift:20:6:\
    \ error: value of type '[Int]' has no member 'sortInPlace'\n        arr.sortInPlace()\n\
    \        ~~~ ^~~~~~~~~~~\n/tmp/tmpal1luovi.swift:22:12: error: cannot convert\
    \ return expression of type 'ArraySlice<Int>' to return type '[Int]'\n       \
    \ return arr[k..<arr.count]\n               ~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if arr.isEmpty {\n        return []\n    }\n\
    \    var max: [Int] = [0]\n    var i = 0\n    while i < arr.count {\n        if\
    \ arr[i] > max[0] {\n            max[0] = arr[i]\n        } else if arr[i] >=\
    \ max[0] {\n            max[1] = max[0]\n            max[0] = arr[i]\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return max[0 ..< k].sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b631497fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6314676561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6314676286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b631467613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6314675bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b63144757ec <unavailable> + 186348

    6    tmpp0trqaak                        0x000055f0b7266745 <unavailable> + 10053

    7    tmpp0trqaak                        0x000055f0b72656a9 <unavailable> + 5801

    8    libc.so.6                          0x00002b6314b6b460 __libc_start_main +
    245

    9    tmpp0trqaak                        0x000055f0b7265389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return sort(arr, nil, k, true, func(x, y Int)\
    \ -> Bool { return x <= y })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpryphgsk4.swift:18:36: error: expected expression in list of expressions\n\
    \    return sort(arr, nil, k, true, func(x, y Int) -> Bool { return x <= y })\n\
    \                                   ^\n/tmp/tmpryphgsk4.swift:18:40: error: expected\
    \ identifier in function declaration\n    return sort(arr, nil, k, true, func(x,\
    \ y Int) -> Bool { return x <= y })\n                                       ^\n\
    /tmp/tmpryphgsk4.swift:18:12: error: cannot find 'sort' in scope\n    return sort(arr,\
    \ nil, k, true, func(x, y Int) -> Bool { return x <= y })\n           ^~~~\n/tmp/tmpryphgsk4.swift:18:22:\
    \ error: 'nil' requires a contextual type\n    return sort(arr, nil, k, true,\
    \ func(x, y Int) -> Bool { return x <= y })\n                     ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(arr.count >= k, \"Array length must\
    \ be larger than or equal to k\")\n    var max = [Int](repeating: -Int.max, count:\
    \ k)\n    for num in arr {\n        if num > max[k-1] {\n            max[k-1]\
    \ = num\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpkq2nfv02/tmpkq2nfv02.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b13b228fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13b1f86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13b1f86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13b1f857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkq2nfv02                        0x00005570fc340729 <unavailable> + 5929

    5    libc.so.6                          0x00002b13b247b460 __libc_start_main +
    245

    6    tmpkq2nfv02                        0x00005570fc340329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"Invalid argument:\
    \ k\")\n    precondition(k <= 1000, \"Invalid argument: k\")\n    if k == 1 {\n\
    \        return arr\n    }\n    \n    var maxIndex = 0\n    var maxValue = -1000\n\
    \n    for i in 0 ..< arr.count {\n        if arr[i] > maxValue {\n           \
    \ maxValue = arr[i]\n            maxIndex = i\n        }\n    }\n\n    var res\
    \ = make([]Int, k)\n    res[maxIndex] = maxValue\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpusguu1tw.swift:34:22: error: expected ',' separator\n    var res\
    \ = make([]Int, k)\n                     ^\n                     ,\n/tmp/tmpusguu1tw.swift:34:15:\
    \ error: cannot find 'make' in scope\n    var res = make([]Int, k)\n         \
    \     ^~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    let result = Array(repeating: -1, count: k)\n\
    \    var maxSoFar = 0\n    var maximumIndex = -1\n\n    for i in 0..<arr.count\
    \ {\n        if result[i] < 0 && arr[i] > maxSoFar {\n            maxSoFar = arr[i]\n\
    \            maximumIndex = i\n        } else if arr[i] > maxSoFar {\n       \
    \     result[i] = arr[i]\n        }\n    }\n\n    return result[..<maximumIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpi87906en.swift:27:19: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n            result[i] = arr[i]\n            ~~~~~~^\n/tmp/tmpi87906en.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = Array(repeating:\
    \ -1, count: k)\n    ^~~\n    var\n/tmp/tmpi87906en.swift:31:18: error: cannot\
    \ convert return expression of type 'ArraySlice<Int>' to return type '[Int]'\n\
    \    return result[..<maximumIndex]\n           ~~~~~~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k must be less\
    \ than or equal to arr's count\")\n    \n    var maxs = [Int](repeating: -1000,\
    \ count: k)\n    var maxIndex = 0\n    \n    for i in 0..<arr.count {\n      \
    \  if arr[i] > maxs[maxIndex] {\n            maxs[maxIndex] = arr[i]\n       \
    \     maxIndex += 1\n        }\n    }\n    \n    return maxs\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp3nv_cdoc/tmp3nv_cdoc.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac85a052c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac859d49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac859d49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac859d487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3nv_cdoc                        0x0000562376292749 <unavailable> + 5961

    5    libc.so.6                          0x00002ac85a23e460 __libc_start_main +
    245

    6    tmp3nv_cdoc                        0x0000562376292349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if arr.isEmpty {\n        return []\n    }\n\
    \    \n    // \u4F7F\u7528Heapq to find the max\n    var maxHeap = [Int](repeating:\
    \ 0, count: k)\n    for i in 0..<k {\n        maxHeap[i] = arr[i]\n    }\n   \
    \ \n    var index = 1\n    \n    var max = arr[0]\n    \n    for element in arr\
    \ {\n        guard max < element else {\n            return\n        }\n     \
    \   \n        if index == k {\n            break\n        }\n        \n      \
    \  maxHeap[index] = element\n        index = index + 1\n        max = element\n\
    \    }\n    \n    // \u5BF9Heapq\u4E2D\u7684\u6570\u636E\u8FDB\u884C\u6392\u5E8F\
    \n    for i in 0..<k {\n        if maxHeap[i] > maxHeap[k - 1] {\n           \
    \ swap(&maxHeap[k - 1], &maxHeap[i])\n        }\n    }\n    \n    return maxHeap\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxn5j1njh.swift:34:13: error: non-void function should return a\
    \ value\n            return\n            ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int](repeating: 0, count: k)\n\
    \    var largest = 0\n    for n in arr {\n        if n > largest {\n         \
    \   largest = n\n        }\n    }\n    for n in arr {\n        if n > largest\
    \ && result.count < k {\n            result[result.count] = n\n            result.count\
    \ += 1\n        }\n    }\n    result.reduce(0, +)\n    if result.count < k {\n\
    \        result = result[k..<result.count]\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1osl_64n.swift:28:26: error: left side of mutating operator isn't\
    \ mutable: 'count' is a get-only property\n            result.count += 1\n   \
    \         ~~~~~~~~~~~~ ^\n/tmp/tmp1osl_64n.swift:31:12: warning: result of call\
    \ to 'reduce' is unused\n    result.reduce(0, +)\n           ^     ~~~~~~\n/tmp/tmp1osl_64n.swift:33:24:\
    \ error: cannot assign value of type 'ArraySlice<Int>' to type '[Int]'\n     \
    \   result = result[k..<result.count]\n                 ~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(0 <= k && k <= arr.count, \"index\
    \ out of range\")\n    if k == 0 { return arr }\n    if k == 1 {\n        return\
    \ max(arr, compare: >)\n    }\n    var largest = arr[0]\n    var idx = 1\n   \
    \ for current in arr {\n        if current > largest {\n            largest =\
    \ current\n        }\n        if current > largest && k >= idx {\n           \
    \ largest = current\n        }\n        if k == idx {\n            break\n   \
    \     }\n        idx += 1\n    }\n    if k == idx {\n        return arr\n    }\n\
    \    return arr[k...idx] + largest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdsybzh12.swift:21:19: error: extraneous argument label 'compare:'\
    \ in call\n        return max(arr, compare: >)\n                  ^     ~~~~~~~~~\n\
    \                        \n/tmp/tmpdsybzh12.swift:40:27: error: cannot convert\
    \ value of type 'Int' to expected argument type '[Int]'\n    return arr[k...idx]\
    \ + largest\n                          ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n  return ArraySlice(arr).sorted().prefix(k)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkwgvegpy.swift:18:35: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n  return ArraySlice(arr).sorted().prefix(k)\n\
    \                                  ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n \
    \   @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming fun"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"Parameter k should\
    \ satisfy 0 <= k <= arr.count\")\n    \n    let max_so_far = arr[0]\n    let max_remaining\
    \ = arr.dropFirst()\n    \n    var result = [Int]()\n    \n    for i in max_remaining.reversed()\
    \ {\n        if i > max_so_far {\n            result.append(max_so_far)\n    \
    \    } else {\n            result.append(i)\n        }\n    }\n    \n    result.append(max_so_far)\n\
    \    \n    return Array(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpf2h6y2gp/tmpf2h6y2gp.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeeebc34c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeeeb92bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeeeb92b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeeeb92a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf2h6y2gp                        0x000055c278199959 <unavailable> + 6489

    5    libc.so.6                          0x00002aeeebe20460 __libc_start_main +
    245

    6    tmpf2h6y2gp                        0x000055c278199559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 || len(arr) <= k {\n        return\
    \ arr\n    }\n    \n    // O(n) time and O(n) space\n    let maxIndex = k - 1\n\
    \    var maxVal = -math.pow(Int.max, Int64(maxIndex))\n    var result : [Int]\
    \ = []\n    \n    for idx in 0..<k {\n        let element = arr[idx]\n       \
    \ if element > maxVal {\n            maxVal = element\n            maxIndex =\
    \ idx\n        }\n    }\n    \n    for idx in 0..<k {\n        let element = arr[idx]\n\
    \        if element == maxVal {\n            result.append(element)\n        }\n\
    \    }\n    \n    return Array(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprkzq2aib.swift:18:18: error: cannot find 'len' in scope\n    if\
    \ k == 0 || len(arr) <= k {\n                 ^~~\n/tmp/tmprkzq2aib.swift:24:19:\
    \ error: cannot find 'math' in scope\n    var maxVal = -math.pow(Int.max, Int64(maxIndex))\n\
    \                  ^~~~\n/tmp/tmprkzq2aib.swift:31:13: error: cannot assign to\
    \ value: 'maxIndex' is a 'let' constant\n            maxIndex = idx\n        \
    \    ^~~~~~~~\n/tmp/tmprkzq2aib.swift:23:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let maxIndex = k - 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var maxVal = arr[0]\n    var maxIdx = 0\n   \
    \ for idx : Int in 1..<arr.count {\n        if arr[idx] > maxVal {\n         \
    \   maxVal = arr[idx]\n            maxIdx = idx\n        }\n    }\n    return\
    \ maxIdx ..< maxIdx + k - 1 // inclusive\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplgpax60c.swift:26:19: error: cannot convert return expression of\
    \ type 'Range<Int>' to return type '[Int]'\n    return maxIdx ..< maxIdx + k -\
    \ 1 // inclusive\n           ~~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k < 0 {\n        print(\"k is out of range\"\
    )\n    }\n    \n    if arr.isEmpty() {\n        return nil\n    }\n    \n    if\
    \ k > arr.count {\n        print(\"k is out of range\")\n    }\n    \n    \n \
    \   var max = -math.MinInt\n    var result : [Int] = []\n    for element in arr\
    \ {\n        if element > max {\n            max = element\n        }\n    }\n\
    \    \n    for element in arr {\n        if element == max {\n            result.append(element)\n\
    \        }\n    }\n    \n    \n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkabwf73z.swift:22:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpkabwf73z.swift:23:16: error: 'nil' is incompatible with return type\
    \ '[Int]'\n        return nil\n               ^\n/tmp/tmpkabwf73z.swift:31:16:\
    \ error: cannot find 'math' in scope\n    var max = -math.MinInt\n           \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = [Int]()\n    var curMax = arr[0]\n\
    \    for i in arr {\n        if i > curMax {\n            curMax = i\n       \
    \ }\n    }\n    if k <= curMax {\n        return result\n    }\n    var maxIdx\
    \ = 0\n    var maxValue = curMax\n    for i : Int in 0..<k {\n        for j :\
    \ Int in 0..<result.count {\n            if result[j] > maxValue {\n         \
    \       maxValue = result[j]\n                maxIdx = j\n            }\n    \
    \    }\n        result[maxIdx] = arr[i]\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp5hs2gdve/tmp5hs2gdve.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad06d640c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad06d337b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad06d337988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad06d3367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5hs2gdve                        0x000055ffec961819 <unavailable> + 6169

    5    libc.so.6                          0x00002ad06d82c460 __libc_start_main +
    245

    6    tmp5hs2gdve                        0x000055ffec961419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k should be less\
    \ than or equal to the length of arr\")\n    precondition(arr.count >= 1, \"arr\
    \ should have at least one element\")\n\n    if k == 1 {\n        return arr\n\
    \    }\n\n    let result = [Int](repeating: 0, count: k - 1)\n    for index in\
    \ 0..<result.count {\n        let max = arr[index] as Int\n        for i in index+1..<arr.count\
    \ {\n            if arr[i] > max {\n                max = arr[i]\n           \
    \     result[index] = max\n            }\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmxeez896.swift:30:17: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n                max = arr[i]\n                ^~~\n/tmp/tmpmxeez896.swift:27:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let max = arr[index]\
    \ as Int\n        ^~~\n        var\n/tmp/tmpmxeez896.swift:31:23: error: cannot\
    \ assign through subscript: 'result' is a 'let' constant\n                result[index]\
    \ = max\n                ~~~~~~^\n/tmp/tmpmxeez896.swift:25:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let result = [Int](repeating: 0, count: k -\
    \ 1)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 || k == 1 {\n        return arr\n \
    \   }\n    if k == len(arr) {\n        return arr\n    }\n    var res = [Int]()\n\
    \    var index = 0\n    var max = [Int]()\n    var maxIndex = -1\n    var maxIndex2\
    \ = -1\n    var index2 = 0\n    var max2 = 0\n    for element in arr {\n     \
    \   if index2 == k {\n            if element>max2 {\n                max2 = element\n\
    \                maxIndex2 = index2\n            }\n            index += 1\n \
    \           max[maxIndex2] = element\n            maxIndex2 += 1\n           \
    \ max2 = 0\n            index2 = 0\n        } else {\n            if element >\
    \ max[index2] {\n                max[index2] = element\n                index2\
    \ += 1\n            }\n        }\n    }\n    if maxIndex2 != k {\n        if max2\
    \ > max[maxIndex2] {\n            index = maxIndex2 + 1\n        }\n    }\n  \
    \  for element in arr {\n        if index == k {\n            if element > max2\
    \ {\n                max2 = element\n                maxIndex2 = index\n     \
    \       }\n            index += 1\n            max[maxIndex2] = element\n    \
    \        maxIndex2 += 1\n            max2 = 0\n            index2 = 0\n      \
    \  } else {\n            if element > max[index2] {\n                max[index2]\
    \ = element\n                index2 += 1\n            }\n        }\n    }\n  \
    \  if maxIndex2 != k {\n        if max2 > max[maxIndex2] {\n            index\
    \ = maxIndex2 + 1\n        }\n    }\n    res.append(max[maxIndex2])\n    \n  \
    \  if maxIndex != k {\n        if maxIndex == k {\n            index = maxIndex\
    \ + 1\n        }\n        if maxIndex == k {\n            index = maxIndex - 1\n\
    \        }\n        for element in arr {\n            if index == k {\n      \
    \          if element > max2 {\n                    max2 = element\n         \
    \           maxIndex2 = index\n                }\n                index += 1\n\
    \                max[maxIndex2] = element\n                maxIndex2 += 1\n  \
    \              max2 = 0\n                index2 = 0\n            } else {\n  \
    \              if element > max[index2] {\n                    max[index2] = element\n\
    \                    index2 += 1\n                }\n            }\n        }\n\
    \        if maxIndex2 != k {\n            if max2 > max[maxIndex2] {\n       \
    \         index = maxIndex2 + 1\n            }\n        }\n        res.append(max[maxIndex2])\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpvo8z8okc.swift:21:13: error: cannot find 'len' in scope\n    if\
    \ k == len(arr) {\n            ^~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(\n        k <= arr.count, \n   \
    \     \"The input k \\(k)  must not exceed the length of the array \\(arr.count)\"\
    )\n\n    var max = -1 * Int(MIN_BOUND)\n    for x in arr {\n        if x < max\
    \ {\n            continue\n        }\n        max = x\n    }\n    \n    var result\
    \ = [Int](repeating: -Int, count: k)\n    for x in arr {\n        if x > max {\n\
    \            continue\n        }\n        result[x - max] = x\n    }\n\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4,\
    \ 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\n\
    assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpcpgx51vn.swift:22:24: error: cannot find 'MIN_BOUND' in scope\n\
    \    var max = -1 * Int(MIN_BOUND)\n                       ^~~~~~~~~\n/tmp/tmpcpgx51vn.swift:30:36:\
    \ error: cannot convert value of type 'Int.Type' to expected argument type 'Int'\n\
    \    var result = [Int](repeating: -Int, count: k)\n                         \
    \          ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k <= arr.count, \"k is out of bounds\"\
    )\n    \n    var maxElement: [Int] = []\n    \n    for index in 0 ..< k {\n  \
    \      let element = max(arr[index], arr[index+1])\n        maxElement.append(element)\n\
    \    }\n    \n    return maxElement\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aaca78cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaca75c2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aaca75c2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aaca75c213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aaca75c1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aaca73c1e83 <unavailable> + 188035

    6    tmp2_iqyemw                        0x0000561ae7fa8779 <unavailable> + 10105

    7    tmp2_iqyemw                        0x0000561ae7fa7699 <unavailable> + 5785

    8    libc.so.6                          0x00002aaca7ab7460 __libc_start_main +
    245

    9    tmp2_iqyemw                        0x0000561ae7fa7379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k <= 0 || k > min(arr.count, k) {\n      \
    \  return []\n    }\n    \n    guard arr.count >= k else {\n        return arr\n\
    \    }\n    \n    var maxArr = make(ArraySlice, k, k)\n    \n    for i in 0 ..<\
    \ k {\n        maxArr[i] = arr[i]\n    }\n    \n    maxArr.sortInPlace()\n   \
    \ \n    return maxArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpvckh537y.swift:26:18: error: cannot find 'make' in scope\n    var\
    \ maxArr = make(ArraySlice, k, k)\n                 ^~~~\n/tmp/tmpvckh537y.swift:26:23:\
    \ error: generic parameter 'Element' could not be inferred\n    var maxArr = make(ArraySlice,\
    \ k, k)\n                      ^\n/tmp/tmpvckh537y.swift:26:23: note: explicitly\
    \ specify the generic arguments to fix this issue\n    var maxArr = make(ArraySlice,\
    \ k, k)\n                      ^\n                                <Any>\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    guard 0 <= k <= arr.count else { return [] }\n\
    \    \n    var maximums = [Int](repeating: -1, count: k)\n    \n    for i in 0..<arr.count\
    \ {\n        let current = arr[i]\n        \n        if maximums[current] == -1\
    \ {\n            maximums[current] = i\n        } else {\n            if maximums[current]\
    \ != i {\n                maximums[current] = i\n            }\n        }\n  \
    \  }\n    \n    var result: [Int] = []\n    \n    for i in 0..<k {\n        result.append(maximums[arr[i]])\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9ahbrxbv.swift:18:13: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n    guard 0 <= k <= arr.count else\
    \ { return [] }\n            ^    ~~\n/tmp/tmp9ahbrxbv.swift:18:13: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Int'\n    guard 0 <=\
    \ k <= arr.count else { return [] }\n            ^\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return Array(heap.PrefixMax(arr, k))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkd5a7eti.swift:18:18: error: cannot find 'heap' in scope\n    return\
    \ Array(heap.PrefixMax(arr, k))\n                 ^~~~\n"
  stdout: ''
  timestamp: 1659978841
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    guard k > 0 && k <= arr.count else { return []\
    \ }\n    \n    var result = Array(repeating: arr[0], count: k)\n    \n    for\
    \ i in 1...arr.count {\n        if arr[i] > result[result.count - k] {\n     \
    \       result[result.count - k] = arr[i]\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4,\
    \ 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\n\
    assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b080774cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0807443561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0807443286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b080744313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0807442bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0807242e83 <unavailable> + 188035

    6    tmpwg117019                        0x0000564f7c2ac668 <unavailable> + 9832

    7    tmpwg117019                        0x0000564f7c2ab5e9 <unavailable> + 5609

    8    libc.so.6                          0x00002b0807938460 __libc_start_main +
    245

    9    tmpwg117019                        0x0000564f7c2ab2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return removeDuplicates(arr, k, true)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpabv04487.swift:18:12: error: cannot find 'removeDuplicates' in\
    \ scope\n    return removeDuplicates(arr, k, true)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(0 <= k <= arr.count)\n    if k ==\
    \ 0 {\n        return arr\n    }\n    if k == 1 {\n        return max(arr)\n \
    \   }\n    var maxs = [Int]()\n    var i = k - 1\n    for index in 0..<arr.count\
    \ {\n        if arr[index] > arr[i] {\n            i += 1\n        }\n       \
    \ if i == k {\n            maxs.append(arr[i])\n            i -= 1\n        }\
    \ else {\n            maxs.append(arr[i])\n        }\n    }\n    return maxs\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpsknq3apu.swift:18:20: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n    precondition(0 <= k <= arr.count)\n\
    \                   ^    ~~\n/tmp/tmpsknq3apu.swift:18:20: error: cannot convert\
    \ value of type 'Bool' to expected argument type 'Int'\n    precondition(0 <=\
    \ k <= arr.count)\n                   ^\n/tmp/tmpsknq3apu.swift:23:23: error:\
    \ missing argument for parameter #2 in call\n        return max(arr)\n       \
    \               ^\n                      , <#[Int]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n/tmp/tmpsknq3apu.swift:23:16: error: global\
    \ function 'max' requires that '[Int]' conform to 'Comparable'\n        return\
    \ max(arr)\n               ^\nSwift.max:1:24: note: where 'T' = '[Int]'\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k == 0 || arr == nil || arr.isEmpty {\n  \
    \      return arr\n    }\n    \n    let arr = arr.sorted()\n    var maxArr = [Int](repeating:\
    \ 0, count: k)\n    \n    for element in arr {\n        maxArr[0] = max(maxArr[0],\
    \ element)\n        if maxArr.count >= k {\n            break\n        }\n   \
    \ }\n    \n    return maxArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp8d3eeo6_/tmp8d3eeo6_.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b1794ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b17641b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b17641988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b176407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8d3eeo6_                        0x000056268094f7e9 <unavailable> + 6121

    5    libc.so.6                          0x00002b2b17b36460 __libc_start_main +
    245

    6    tmp8d3eeo6_                        0x000056268094f3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659978842
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var max = -1000\n    var ans = [Int]()\n    for\
    \ x in arr {\n        if x > max {\n            max = x\n        }\n        if\
    \ x > -k && k <= arr.count {\n            ans.append(x)\n        }\n    }\n  \
    \  return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmptgi05pz8/tmptgi05pz8.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b573b7ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b573b4f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b573b4f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b573b4f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptgi05pz8                        0x000055b07f459639 <unavailable> + 5689

    5    libc.so.6                          0x00002b573b9eb460 __libc_start_main +
    245

    6    tmptgi05pz8                        0x000055b07f459239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k <= 0 || len(arr) <= k {\n        return\
    \ []\n    }\n    \n    var maxs = make([]Int, k)\n    \n    for i := 0; i < k;\
    \ i++ {\n        maxs[i] = max(arr[0], arr[i])\n    }\n    \n    for i := 1; i\
    \ < len(arr); i++ {\n        maxs[i] = max(maxs[i], arr[i])\n    }\n    \n   \
    \ return maxs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb2ol8fpr.swift:22:23: error: expected ',' separator\n    var maxs\
    \ = make([]Int, k)\n                      ^\n                      ,\n/tmp/tmpb2ol8fpr.swift:24:12:\
    \ error: expected type\n    for i := 0; i < k; i++ {\n           ^\n         \
    \   <#type#>\n/tmp/tmpb2ol8fpr.swift:24:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < k; i++ {\n           ^\n/tmp/tmpb2ol8fpr.swift:24:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < k;\
    \ i++ {\n           ^\n/tmp/tmpb2ol8fpr.swift:28:12: error: expected type\n  \
    \  for i := 1; i < len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpb2ol8fpr.swift:28:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpb2ol8fpr.swift:28:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(arr); i++ {\n           ^\n/tmp/tmpb2ol8fpr.swift:18:18:\
    \ error: cannot find 'len' in scope\n    if k <= 0 || len(arr) <= k {\n      \
    \           ^~~\n/tmp/tmpb2ol8fpr.swift:22:16: error: cannot find 'make' in scope\n\
    \    var maxs = make([]Int, k)\n               ^~~~\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    return removeDuplicates(append(maximum1(arr),\
    \ maximum2(arr, k)), k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpm2nf7sgx.swift:18:12: error: cannot find 'removeDuplicates' in\
    \ scope\n    return removeDuplicates(append(maximum1(arr), maximum2(arr, k)),\
    \ k)\n           ^~~~~~~~~~~~~~~~\n/tmp/tmpm2nf7sgx.swift:18:29: error: cannot\
    \ find 'append' in scope\n    return removeDuplicates(append(maximum1(arr), maximum2(arr,\
    \ k)), k)\n                            ^~~~~~\n/tmp/tmpm2nf7sgx.swift:18:36: error:\
    \ cannot find 'maximum1' in scope\n    return removeDuplicates(append(maximum1(arr),\
    \ maximum2(arr, k)), k)\n                                   ^~~~~~~~\n/tmp/tmpm2nf7sgx.swift:18:51:\
    \ error: cannot find 'maximum2' in scope\n    return removeDuplicates(append(maximum1(arr),\
    \ maximum2(arr, k)), k)\n                                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k > len(arr) { return [] }\n    \n    let\
    \ max = arr[0]\n    for i in 1...k { max = max(max, arr[i]) }\n    \n    let result\
    \ = [max]\n    if k <= arr.count { result.insert(arr.last, at: k - 1) }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4,\
    \ 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\n\
    assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpk8njr6j1.swift:18:12: error: cannot find 'len' in scope\n    if\
    \ k > len(arr) { return [] }\n           ^~~\n/tmp/tmpk8njr6j1.swift:21:22: error:\
    \ cannot assign to value: 'max' is a 'let' constant\n    for i in 1...k { max\
    \ = max(max, arr[i]) }\n                     ^~~\n/tmp/tmpk8njr6j1.swift:20:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = arr[0]\n    ^~~\n\
    \    var\n/tmp/tmpk8njr6j1.swift:21:28: error: cannot call value of non-function\
    \ type 'Int'\n    for i in 1...k { max = max(max, arr[i]) }\n                \
    \           ^\n/tmp/tmpk8njr6j1.swift:24:32: error: no exact matches in call to\
    \ instance method 'insert'\n    if k <= arr.count { result.insert(arr.last, at:\
    \ k - 1) }\n                               ^\n/tmp/tmpk8njr6j1.swift:24:32: note:\
    \ found candidate with type '(__owned Int, Int) -> ()'\n    if k <= arr.count\
    \ { result.insert(arr.last, at: k - 1) }\n                               ^\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    guard 0 <= k <= arr.count else { return [] }\n\
    \    var result = [Int](repeating: 0, count: k+1)\n    for i in 0..<arr.count\
    \ {\n        if result[k] > arr[i] { result[k+1] = arr[i] }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4,\
    \ 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\n\
    assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf4wuimxo.swift:18:13: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n    guard 0 <= k <= arr.count else\
    \ { return [] }\n            ^    ~~\n/tmp/tmpf4wuimxo.swift:18:13: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Int'\n    guard 0 <=\
    \ k <= arr.count else { return [] }\n            ^\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    precondition(k > 0, \"k must be positive integer\"\
    )\n    var max = [Int]()\n    var i = 1\n    var maxIndex = 0\n    while i <=\
    \ k {\n        if arr[i] > max {\n            max = arr[i]\n            maxIndex\
    \ = i\n        }\n        i += 1\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkd0khj26.swift:23:21: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if arr[i] > max {\n               \
    \     ^\n/tmp/tmpkd0khj26.swift:24:22: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            max = arr[i]\n                  ~~~^~~\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k <= 0 || len(arr) < k {\n        return []\n\
    \    }\n    \n    var result = [Int]()\n    for ele in arr {\n        let idx\
    \ = result.index(of: ele)\n        if idx != nil {\n            result.remove(at:\
    \ idx!)\n        }\n        \n        if result.count == k {\n            return\
    \ result\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5hmggrru.swift:18:18: error: cannot find 'len' in scope\n    if\
    \ k <= 0 || len(arr) < k {\n                 ^~~\n/tmp/tmp5hmggrru.swift:24:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ idx = result.index(of: ele)\n                         ^\n/tmp/tmp5hmggrru.swift:24:26:\
    \ note: use 'firstIndex(of:)' instead\n        let idx = result.index(of: ele)\n\
    \                         ^~~~~\n                         firstIndex\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    if k > len(arr) || k == 0 || len(arr) == 0 {\n\
    \        return []\n    }\n    \n    var maxHeap: [Int] = []\n    \n    var heap\
    \ = arr\n    for _ in 1...k {\n        maxHeap = append(maxHeap, heap[0])\n  \
    \      heap = heap[1..<len(heap)]\n    }\n    maxHeap = append(maxHeap, heap[0])\n\
    \    \n    return maxHeap\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphwrec9k4.swift:18:12: error: cannot find 'len' in scope\n    if\
    \ k > len(arr) || k == 0 || len(arr) == 0 {\n           ^~~\n/tmp/tmphwrec9k4.swift:18:34:\
    \ error: cannot find 'len' in scope\n    if k > len(arr) || k == 0 || len(arr)\
    \ == 0 {\n                                 ^~~\n/tmp/tmphwrec9k4.swift:26:19:\
    \ error: cannot find 'append' in scope\n        maxHeap = append(maxHeap, heap[0])\n\
    \                  ^~~~~~\n/tmp/tmphwrec9k4.swift:27:25: error: cannot find 'len'\
    \ in scope\n        heap = heap[1..<len(heap)]\n                        ^~~\n\
    /tmp/tmphwrec9k4.swift:27:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        heap = heap[1..<len(heap)]\n               ~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmphwrec9k4.swift:29:15: error: cannot find 'append' in scope\n    maxHeap\
    \ = append(maxHeap, heap[0])\n              ^~~~~~\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n  return sort(arr).prefix(k)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpj8wipgjg.swift:18:10: error: cannot find 'sort' in scope\n  return\
    \ sort(arr).prefix(k)\n         ^~~~\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted array \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
    \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
    \ [Int], k: Int) -> [Int] {\n    var result = Array<Int>()\n    var max = -1000\n\
    \    \n    for i in 0..<k {\n        if arr[i] > max {\n            max = arr[i]\n\
    \        }\n    }\n    \n    for n in arr {\n        if n > max {\n          \
    \  max = n\n        }\n    }\n    \n    result.appendContentsOf(arr[0 ..< Int(ceil(Double(k)*(Double(max)-Double(arr[0]))))])\n\
    \    \n    return result.sorted(by: { $0 > $1 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6z6fvb31.swift:33:43: error: cannot find 'ceil' in scope\n    result.appendContentsOf(arr[0\
    \ ..< Int(ceil(Double(k)*(Double(max)-Double(arr[0]))))])\n                  \
    \                        ^~~~\n/tmp/tmp6z6fvb31.swift:33:12: error: value of type\
    \ '[Int]' has no member 'appendContentsOf'\n    result.appendContentsOf(arr[0\
    \ ..< Int(ceil(Double(k)*(Double(max)-Double(arr[0]))))])\n    ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978842
