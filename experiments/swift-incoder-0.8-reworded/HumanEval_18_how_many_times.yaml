name: HumanEval_18_how_many_times
language: swift
prompt: "\n/// Find how many times a given substring can be found in the original\
  \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
  \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
  \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string:\
  \ String, substring: String) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(how_many_times(string: \"\", substring:\
  \ \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") ==\
  \ 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
  \ \"john doe\", substring: \"john\") == 1)"
completions: ["\tif string == \"\" {\n\t\treturn 0\n\t}\n\n\tvar result Int = 0\n\t\
    var startIndex = string.index(substring, startIndex: 0)\n\tvar lastIndex = string.index(substring,\
    \ startIndex: string.index(string, startIndex))\n\tif startIndex == lastIndex\
    \ {\n\t\tresult++\n\t}\n\n\twhile startIndex != lastIndex {\n\t\tstartIndex =\
    \ string.index(substring, startIndex: startIndex+1)\n\t\tlastIndex = string.index(substring,\
    \ startIndex: string.index(string, startIndex))\n\t\tif startIndex == lastIndex\
    \ {\n\t\t\tresult++\n\t\t}\n\t}\n\n\treturn result", "    // Return 1 if substring\
    \ is not found\n    if string.find(substring) == nil {\n        return 0;\n  \
    \  }\n    // Loop through string and count overlaping characters\n    var counter\
    \ = 0;\n    for idxChar in string.characters {\n        if idxChar == substring.characters.first\
    \ {\n            counter = counter + 1;\n        }\n        if idxChar == substring.characters.last\
    \ {\n            counter = counter + 1;\n        }\n    }\n    return counter;",
  "    if string.hasPrefix(substring) {\n        return string.count(substring)\n\
    \    }\n    if string.hasSuffix(substring) {\n        return string.count(substring)\
    \ + 1\n    }\n    if string.hasPrefix(\"(?i)\\(substring)\") {\n        return\
    \ string.count(substring)\n    }\n    if string.hasSuffix(\"(?i)\\(substring)\"\
    ) {\n        return string.count(substring) + 1\n    }\n    if substring.isEmpty\
    \ {\n        return 0\n    }\n    return string.countSubstrings(substring) + 1",
  "    var result = 0\n    var start_index = string.startIndex\n    while start_index\
    \ != string.endIndex {\n        let index = string.index(start_index, offsetBy:\
    \ substring.characters.count)\n        if start_index != index {\n           \
    \ start_index = index\n            continue\n        }\n        if index == string.endIndex\
    \ {\n            start_index = index\n        }\n        result = result + 1\n\
    \        if start_index == string.endIndex {\n            break\n        }\n \
    \       start_index = index\n    }\n    return result", "    if string.count <\
    \ substring.count {\n        return 0\n    }\n    \n    if string.characters.count\
    \ < substring.characters.count {\n        return 0\n    }\n    \n    let start\
    \ = min(string.startIndex, substring.startIndex)\n    let end = max(string.endIndex,\
    \ substring.endIndex)\n    \n    var count = 0\n    for idx in 0..<(end - start)\
    \ {\n        if string.substring(from: start + idx).isEqual(substring) {\n   \
    \         count += 1\n        }\n    }\n    return count", "\tif substring ==\
    \ \"\" {\n\t\treturn 0\n\t}\n\n\tvar startIndex = string.startIndex.advancedBy(0,\
    \ offset)\n\tvar endIndex = string.endIndex.advancedBy(len(substring), offset)\n\
    \n\tvar count = 0\n\tvar index = startIndex.advancedBy(0, offset)\n\tfor ; index\
    \ < endIndex; index = index.advancedBy(1, offset) {\n\t\tif string[index] != substring[0]\
    \ {\n\t\t\tbreak\n\t\t}\n\n\t\tcount++\n\t}\n\n\treturn count", "    if string.rangeOfString(substring)\
    \ != nil {\n        return string.rangeOfString(substring).length\n    }\n   \
    \ return 0", '    return count_occurrences(string, substring: substring)', " \
    \   var count = 0\n    for index in 0..<string.characters.count {\n        if\
    \ string.rangeOfString(substring) == nil || string.rangeOfString(substring!) !=\
    \ nil && string.rangeOfString(substring!, options: .CaseInsensitive).location\
    \ == index.location {\n            count += 1\n        }\n    }\n    return count",
  "\tlet range = (string as NSString).range(of: substring)\n\t\n\tvar count = 0\n\t\
    \n\twhile range.location != NSNotFound {\n\t\tcount += 1\n\t\t\n\t\tlet location\
    \ = string.index(range.lowerBound, offsetBy: 1)\n\t\tlet searchRange = NSRange(location:\
    \ location, length: substring.length)\n\t\t\n\t\trange = (string as NSString).range(of:\
    \ substring, options: [], range: searchRange)\n\t}\n\t\n\treturn count", "   \
    \ var count = 0\n    let start = string.startIndex(of: substring)\n    if start\
    \ == nil { return 0 }\n\n    for _ in 0..<string.distance(from: string.startIndex,\
    \ to: start) {\n        let end = string.index(start, offsetBy: substring.count,\
    \ limitedBy: string.endIndex)\n        guard end != nil else { continue }\n  \
    \      let range = start..<end!\n        count += range.count\n        start =\
    \ end!\n    }\n    return count", "    let start = string.startIndex.advanced(by:\
    \ substring.startIndex.distanceTo(string.startIndex))\n    let end = string.endIndex.advanced(by:\
    \ substring.startIndex.distanceTo(string.startIndex))\n    if string.hasPrefix(substring)\
    \ {\n        if string.endIndex.distanceTo(start) >= substring.endIndex.distanceTo(string.startIndex)\
    \ {\n            return substring.distanceTo(start) - string.startIndex.distanceTo(substring.startIndex)\n\
    \        } else {\n            return 0\n        }\n    } else if string.endIndex.distanceTo(start)\
    \ >= substring.startIndex.distanceTo(string.startIndex) {\n        return string.endIndex.distanceTo(start)\
    \ - substring.startIndex.distanceTo(string.startIndex)\n    } else {\n       \
    \ return 0\n    }", "    if string.isEmpty {\n        return 0\n    }\n    guard\
    \ let index = string.index(of: substring) else {\n        return 0\n    }\n  \
    \  var count = 0\n    for i in 0 ..< string.count {\n        if i != index {\n\
    \            let char = string[i]\n            if string.index(after: i) != index.advanced(by:\
    \ 1) {\n                count += 1\n            }\n            if string.index(before:\
    \ i) != index.advanced(by: -1) {\n                count += 1\n            }\n\
    \        }\n    }\n    return count", "    let substrings = substring.characters.map({\
    \ String($0) })\n    var count = 0\n    for index in string.characters.indices\
    \ {\n        for substring_index in substrings.indices {\n            if string.characters.elementAt(index)\
    \ == substrings.elementAt(substring_index) {\n                count = count +\
    \ 1\n                break\n            }\n        }\n    }\n    return count",
  "    \n    var count = 0\n    \n    if string != \"\" {\n        let splitString\
    \ = string.lowercased().components(separatedBy: substring)\n        let stringArray\
    \ = splitString.flatMap { $0 }\n        for subString in stringArray {\n     \
    \       count += 1\n        }\n    }\n    return count", "    if let foundIndex\
    \ = string.firstIndex(of: substring) {\n        let originalLength = string.distance(from:\
    \ string.startIndex, to: foundIndex)\n        return originalLength / substring.length\n\
    \    } else {\n        return 0\n    }", "    let index = string.lowercased().index(substring.lowercased(),\
    \ options: .caseInsensitive)\n    return index == nil ? 0 : index!", '    return
    count(string: &string, substring: &substring)', "    if string.contains(substring)\
    \ {\n        return string.count{ $0 == substring }\n    } else {\n        return\
    \ -1\n    }", "    if string == \"\" {\n        return 0\n    }\n\n    var counter\
    \ = 0\n    var idx = 0\n    while idx < string.characters.count {\n        if\
    \ substring[idx] != string[idx] {\n            break\n        }\n\n        counter\
    \ += 1\n        idx += 1\n    }\n\n    return counter", "    let characters =\
    \ (string as NSString).characters.map() { $0 }\n    var count = 0\n    var start\
    \ = characters.index(of: substring)\n    while start != NSNotFound  {\n      \
    \  count += substring.length\n        start = characters.index(of: substring,\
    \ in: start + 1..<characters.count)\n    }\n    return count", "    var i = 0\n\
    \    var count = 0\n    \n    for i in 0..<string.count {\n        let index =\
    \ string.index(string.startIndex, offsetBy: i)\n        let foundIndex = string.index(index,\
    \ offsetBy: substring.count)\n        \n        if foundIndex != nil {\n     \
    \       count = 1 + min(count, foundIndex!.distance(from: string.startIndex))\n\
    \        }\n    }\n    \n    return count", "    if string.count < substring.count\
    \ {\n        return -1\n    }\n\n    var times = 0\n    var start = string.startIndex\n\
    \    var end = string.endIndex\n\n    while start < end {\n        if string.substring(start,\
    \ end) == substring {\n            times += 1\n            start = start + string.count\n\
    \            end = string.endIndex\n        }\n        else {\n            start\
    \ = string.startIndex\n            end = string.endIndex\n        }\n    }\n\n\
    \    return times", "\treturn count_occurrence(string: String, substring: substring,\
    \ count: 0) + 1", '    return count(string, substring) + 1', "    guard let substringIndex\
    \ = string.firstIndex(of: substring) else { return 0 }\n\n    // If the string\
    \ is empty, return 0.\n    if substringIndex == string.endIndex { return 0 }\n\
    \n    // If the substring is found at the beginning of the string, return 1.\n\
    \    if substringIndex == 0 { return 1 }\n\n    // If the substring is found at\
    \ the end of the string, return 0.\n    if substringIndex == string.index(before:\
    \ string.endIndex) { return 0 }\n\n    // If the substring is found somewhere\
    \ in the middle, return the number of times the substring can be found on the\
    \ string\n    // before it and the substring itself after the string.\n    return\
    \ 1 + how_many_times(string: string.substring(from: substringIndex), substring:\
    \ substring)", "    var count = 0\n    guard string.contains(substring) else {\
    \ return 0 }\n    if let index = string.range(of: substring, options: .caseInsensitive)\
    \ {\n        var start = index\n        while start < string.endIndex,\n     \
    \          let rangeEnd = string.range(of: substring, options: .caseInsensitive,\
    \ range: start..<index),\n               rangeEnd.upperBound > rangeEnd.lowerBound\n\
    \        {\n            start = rangeEnd\n            count += 1\n        }\n\
    \    }\n    return count", "    if string.hasSuffix(substring) {\n        return\
    \ string.countSuffix(substring)\n    } else {\n        return string.countSubstring(substring)\n\
    \    }", "    var count = 0\n    for index in 0..<string.count {\n        guard\
    \ let index = string.distance(from: string.startIndex, to: index) == 0 else {\n\
    \            continue // No match at all\n        }\n        if string[index]\
    \ == substring {\n            count += 1\n        } else {\n            if string[index]\
    \ == substring[substring.length - 1], string.index(before: index) == nil {\n \
    \               count += 2\n            }\n        }\n    }\n    return count",
  "\tif string == \"\" || substring == \"\" {\n\t\treturn 0\n\t}\n\n\tlet lower =\
    \ string.startIndex.map({ $0 == string.startIndex.lowerBound })\n\tlet upper =\
    \ string.index(string.startIndex, offsetBy: substring.count)\n\n\tlet lowerUpper\
    \ = (lower, upper) |> Seq.zip\n\n\tvar lowerUpperCount = 0\n\n\tfor (lo, hi) <-\
    \ lowerUpper {\n\t\tif lo == false && hi == false {\n\t\t\tbreak\n\t\t}\n\n\t\t\
    if lo == false {\n\t\t\tlowerUpperCount += 1\n\t\t}\n\n\t\tif hi == false {\n\t\
    \t\tlowerUpperCount += 1\n\t\t}\n\n\t\tif lo == true {\n\t\t\tlowerUpperCount\
    \ += hi.count + 1\n\t\t}\n\n\t\tif hi == true {\n\t\t\tlowerUpperCount += lo.count\
    \ + 1\n\t\t}\n\t}\n\n\treturn lowerUpperCount", "    var index = 0\n    while\
    \ index < string.characters.count && index < substring.characters.count {\n  \
    \      if string.characters.contains(substring.characters.suffix(from: index))\
    \ {\n            index += 1\n        }\n        if string.characters.contains(substring.characters.prefix(from:\
    \ index)) {\n            index += 1\n        }\n        index += 1\n    }\n  \
    \  return index", "    if string == \"\" || substring == \"\" {\n        return\
    \ 0\n    }\n\n    let start = string.startIndex.advanced(by: substring.startIndex)\n\
    \    let end = string.endIndex.advanced(by: substring.startIndex).advanced(by:\
    \ substring.count)\n    return string.distance(from: start, to: end) + 1", '    return
    count_occurrences(string, substring)', "    let index = string.characters.index(of:\
    \ substring)\n    return index == nil ? 0 : index! + 1", "\tlet searchRange =\
    \ string.startIndex..<string.endIndex.advanced(by: -string.count)\n\treturn (string.unicodeScalars.filter\
    \ { unicodeScalar.compare(substring!, to: $0) != .orderedSame }\n\t\t\t.map({\
    \ unicodeScalar.decomposedString.count(for: string.unicodeScalars.filter({ unicodeScalar.compare(substring!,\
    \ to: $0) != .orderedSame }) }) ?? 0 }).sum", "    // Handle case where there\
    \ is no substring\n    if substring == \"\" {\n        return 0\n    }\n    var\
    \ count = 0\n    for character in string.characters.reversed() {\n        if character\
    \ == substring.characters.first {\n            count += 1\n        } else {\n\
    \            break\n        }\n    }\n    return count", "    guard string.hasSuffix(substring)\
    \ else { return 0 }\n    var counter = 0\n    var startIndex = string.startIndex\n\
    \    while startIndex < string.endIndex {\n        let start = startIndex\n  \
    \      let end = startIndex + substring.length\n        if let range = string.range(of:\
    \ substring, range: start..<end) {\n            counter += 1\n            startIndex\
    \ = range.upperBound\n        } else {\n            break\n        }\n    }\n\
    \    return counter", "    guard string.rangeOfString(substring) != nil else {\
    \ return 0 }\n    guard string.lowercaseString.rangeOfString(substring) != nil\
    \ else { return 0 }\n    let lowercaseString = string.lowercaseString\n    let\
    \ substringRange = string.rangeOfString(substring)\n    let substringLength =\
    \ substringRange.endIndex - substringRange.startIndex\n    let string = lowercaseString.substringWithRange(substringRange)\n\
    \    let count = lowercaseString.countSubstrings(in: string)\n    return count\
    \ + (substringLength / 2.0)", "    if string == \"\" || substring == \"\" {\n\
    \        return 0\n    }\n    var count = 0\n    var startIndex = string.startIndex\n\
    \    var endIndex = string.endIndex\n    while startIndex < endIndex {\n     \
    \   let index = startIndex.distanceTo(substring, matchingPolicy: .BackwardsSearch)\n\
    \        guard index < string.count else {\n            return count\n       \
    \ }\n        if index == 0 {\n            count += 1\n        }\n        if string.substring(index,\
    \ length: substring.length).starts(with: substring) {\n            count += 1\n\
    \        }\n        startIndex = string.index(startIndex, offsetBy: substring.length)\n\
    \        endIndex = string.index(startIndex, offsetBy: substring.length, limitedBy:\
    \ string.endIndex) ?? string.endIndex\n    }\n    return count", "    if string\
    \ == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    var count\
    \ = 0\n    \n    if substring.hasPrefix(string) {\n        count = 1 + how_many_times(substring[string.startIndex],\
    \ string)\n    }\n    \n    if substring.hasSuffix(string) {\n        count =\
    \ 1 + how_many_times(string, substring[string.endIndex..<string.endIndex.advancedBy(-1)])\n\
    \    }\n    \n    return count", "    return string.filter({ $0.contains(substring)\
    \ }).count {\n        substring, $0.contains(substring) == true\n    }", '    return
    string.utf16CountContaining(substring.utf16s)', "    guard let stringRange = Range(string.startIndex..<string.endIndex,\
    \ in: string),\n        let substringRange = Range(substring.startIndex..<substring.endIndex,\
    \ in: substring),\n        let foundRange = string.range(of: substring) else {\n\
    \        return 0\n    }\n    return foundRange.lowerBound == stringRange.lowerBound\
    \ ? stringRange.upperBound - foundRange.upperBound + 1", "    if substring.hasPrefix(string)\
    \ {\n        let lowerCaseSubstring = substring\n            .characters.map({\
    \ String($0) })\n            .map(String.init)\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { String($0) }\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { $0.lowercased() }\n       \
    \     .map(String.init)\n            .map(String.init)\n            .map { $0.uppercased()\
    \ }\n            .map(String.init)\n            .map(String.init)\n          \
    \  .map { $0.capitalized() }\n            .map(String.init)\n            .map\
    \ { $0.localizedStandardCompare(string) == ComparisonResult.orderedSame }\n  \
    \          .compactMap({ $0 })\n            .count\n        return lowerCaseSubstring\n\
    \    }\n    else {\n        let upperCaseSubstring = string\n            .characters.map({\
    \ String($0) })\n            .map(String.init)\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { String($0) }\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { $0.uppercased() }\n       \
    \     .map(String.init)\n            .map(String.init)\n            .map { $0.capitalized()\
    \ }\n            .map(String.init)\n            .map { $0.localizedStandardCompare(string)\
    \ == ComparisonResult.orderedSame }\n            .compactMap({ $0 })\n       \
    \     .count\n        return upperCaseSubstring\n    }", "\treturn count_overlapping_chars(string,\
    \ substring)", '    return string.characters.filter({ string.distance(from: $0,
    to: substring.starts(with: substring)) != 0 }).count', "\treturn countOccurrences(string,\
    \ substring)", "\tif string == \"\" {\n\t\treturn 0\n\t}\n\tlet start = string.startIndex(of:\
    \ substring)\n\tlet end = string.index(start, offsetBy: substring.length)\n\t\
    if end != nil {\n\t\treturn Int(end - start) + 1\n\t}\n\treturn 0", "    if string\
    \ == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if substring[0] == string[0] {\n        return how_many_times(string[1..<string.characters.count],\
    \ substring[1:])\n    } else {\n        let substringCharacters = substring.characters\n\
    \        var count = 0\n        for (i, _) in string.enumerated() {\n        \
    \    if substringCharacters.contains(string[i]) {\n                count += 1\n\
    \                if count > 1 {\n                    return count\n          \
    \      }\n            }\n        }\n        return count\n    }", "    let index\
    \ = string.distance(from: substring)\n    return (index + substring.length - 1).quotientAndRemainder()",
  "    if string.hasSuffix(substring) && string.hasPrefix(substring) {\n        let\
    \ range = string.startIndex..<string.endIndex.advanced(by: string.distance(from:\
    \ string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n    \
    \    return string.distance(from: string.startIndex, to: string.endIndex.advancedBy(range.count))\n\
    \    }\n    if string.hasSuffix(substring) {\n        let range = string.startIndex..<string.endIndex.advanced(by:\
    \ string.distance(from: string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n\
    \        return range.count\n    }\n    if string.hasPrefix(substring) {\n   \
    \     let range = string.startIndex.advanced(by: substring.count)..<string.endIndex\n\
    \        return string.distance(from: string.startIndex, to: string.endIndex.advancedBy(range.count))\n\
    \    }\n    return 0", "\tif substring == \"\" {\n\t\treturn 0\n\t}\n\n\tlet characters\
    \ = string.characters.split(separator: substring)\n\treturn characters.count +\
    \ 1", "    let start = string.rangeOfString(substring, options: .CaseInsensitiveSearch)!\n\
    \    let end = string.rangeOfString(substring, options: .CaseInsensitiveSearch,\
    \ range: start..<string.endIndex)\n    return end.location - start.location +\
    \ 1", "\tif string.find(substring) == String::npos {\n\t\treturn 0\n\t} else {\n\
    \t\tlet index = string.find(substring)\n\t\tlet count = substring.length\n\t\t\
    let firstMatch = index\n\t\tlet lastMatch = index\n\t\tif count > 1 {\n\t\t\t\
    lastMatch = string.distance(from: string.startIndex, to: index) + index\n\t\t\
    }\n\t\treturn lastMatch - firstMatch + 1\n\t}", '    return string.count { $0
    == substring }', '    return string.split(substring).count ?? 0', "    if string.countOfString(substring)\
    \ == 0 {\n        return 0\n    }\n\n    if string.rangeOfString(substring) !=\
    \ nil {\n        return 2\n    }\n\n    if string.rangeOfString(substring, options:\
    \ NSStringCompareOptions.CaseInsensitiveSearch) != nil {\n        return 2\n \
    \   }\n\n    return 1", "\treturn count_overlapping_cases(string, substring, true,\
    \ true)", "    return string.lowercase().characters.reduce(0) { memo, letter in\n\
    \        if let index = string.lowercase().characters.indexOf(letter) {\n    \
    \        memo += 1\n        }\n        return memo\n    }", "    \n    let mut\
    \ count = 1\n    var index = string.startIndex\n    while index != string.endIndex\
    \ {\n        index = string.index(in: substring, range: nil, locale: nil)\n  \
    \      if index != string.endIndex {\n            count += 1\n        }\n    }\n\
    \    return count", "    let count = (string.lowercased().count).times {\n   \
    \     string.lowercased().prefix(1).contains(substring).suffix(1).lowercased()\n\
    \    }\n    return count", "    let substring = substring.lowercased()\n    let\
    \ start = string.startIndex.lowercased().distance(from: string.startIndex.lowercased(),\
    \ to: substring)\n    let stop = string.endIndex.lowercased().distance(from: string.startIndex.lowercased(),\
    \ to: substring)\n    return (string.distance(from: string, to: start) + string.distance(from:\
    \ start, to: stop) - string.distance(from: start, to: string.endIndex.lowercased()))",
  "    if string.count == 0 || substring.count == 0 {\n        return 0\n    }\n\n\
    \    guard let start = string.range(of: substring) else { return 0 }\n    guard\
    \ let end = string.range(of: substring, options: .backwards) else { return 0 }\n\
    \n    return Int((end.location - start.location) + 1)", '    return count_substrings(string,
    substring, 0)', "    let range = (string as NSString).range(of: substring)\n \
    \   let count = range?.upperBound\n    if let count = count {\n        return\
    \ count\n    }\n    return 0", '    return count_times(string: &string, substring:
    &substring)', "\tif string.starts(with: substring) == false && string.contains(substring)\
    \ == false {\n\t\treturn 0\n\t}\n\treturn string.range(of: substring, options:\
    \ .caseInsensitive, range: nil, locale: nil)?.lowerBound ?? string.count(of: substring)",
  '    return strings.Count(substring, options: .AnchoredSearch)', "    let startIndex\
    \ = string.startIndex.distance(string: substring)\n    let endIndex = string.endIndex.distance(string:\
    \ substring)\n    if startIndex == 0 || endIndex == 0 {\n        return 0\n  \
    \  }\n    return string.distance(from: string.startIndex, to: endIndex) - startIndex",
  "    let index = string.index(of: substring)\n    return index != nil ? index.flatMap\
    \ { string.index(after: $0 + 1) ?? string.endIndex }\n        .compactMap { $0\
    \ }\n        .count\n        : 0", "    // TODO: Make this work in all cases\n\
    \    return how_many_times_with_overlapping_cases(string, substring, false)",
  "\tlet start = string.startIndex.advanced(by: find(string, substring))\n\tlet end\
    \ = find(string, substring).advanced(by: substring.length)\n\treturn max(0, end\
    \ - start)", "    if string == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var startIndex = 0\n    var endIndex = string.characters.count\n  \
    \  for subStringIndex in 0..<string.characters.count {\n        let subStringLength\
    \ = substring.length\n        for i in\n            0..<subStringLength {\n  \
    \              if string.characters.count - startIndex >= subStringLength {\n\
    \                    break\n                }\n                let index = string.index(string.startIndex,\
    \ offsetBy: startIndex + i)\n                let substringIndex = string.index(index,\
    \ offsetBy: subStringIndex)\n                if substringIndex < startIndex ||\
    \ substringIndex >= endIndex {\n                    continue\n               \
    \ }\n                count += 1\n                startIndex = substringIndex\n\
    \                endIndex = string.characters.count\n            }\n        }\n\
    \    return count", "    \n    var count = 0\n    \n    for index in 0..<string.characters.count\
    \ {\n        \n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n            count += 1\n        } else if string.substring(from: index).lowercased()\
    \ > substring.lowercased() {\n            count += 1\n        } else {\n     \
    \       count -= 1\n        }\n        \n    }\n    \n    return count", "   \
    \ var occurrences = 0\n    if string == \"\" {\n        return occurrences\n \
    \   }\n\n    if substring == \"\" {\n        return occurrences\n    }\n\n   \
    \ for i in  string.characters.indices {\n        if string.characters.elements[i].description\
    \ == substring {\n            occurrences += 1\n            if string.characters.elements[i+1].description\
    \ == substring {\n                occurrences += 1\n                if string.characters.elements[i+2].description\
    \ == substring {\n                    occurrences += 1\n                }\n  \
    \          }\n        }\n    }\n    return occurrences", "    if substring ==\
    \ \"\" {\n        return 0\n    }\n    \n    var count = 0\n    for index in 0..<string.characters.count\
    \ {\n        let isSame = string.characters.index(string.startIndex, offsetBy:\
    \ index) == string.characters.index(string.startIndex, offsetBy: index + substring.length)\n\
    \        let isStartIndex = string.characters.index(string.startIndex, offsetBy:\
    \ index) == string.characters.index(string.startIndex, offsetBy: 0)\n        let\
    \ isEndIndex = string.characters.index(string.startIndex, offsetBy: index + substring.length)\
    \ == string.characters.index(string.startIndex, offsetBy: string.characters.count\
    \ - substring.length)\n        if !isSame && !isStartIndex && !isEndIndex {\n\
    \            count += 1\n        }\n    }\n    return count", "    guard let index\
    \ = string.firstIndex(of: substring) else { return 0 }\n    let stringIndex =\
    \ string.distance(from: string.startIndex, to: index)\n    guard let stringRange\
    \ = Range(string.startIndex, stringIndex + substring.length),\n        let stringRangeCount\
    \ = string.distance(from: string.startIndex, to: index + substring.length)\n \
    \       else { return 0 }\n    return stringRangeCount / stringRange.count", " \
    \   let index1 = string.index(of: substring)\n    let index2 = string.index(of:\
    \ substring, in: index1!, offsetBy: 1)\n    let index3 = string.index(of: substring,\
    \ in: index2!, offsetBy: 1)\n    let index4 = string.index(of: substring, in:\
    \ index3!, offsetBy: 1)\n    let index5 = string.index(of: substring, in: index4!,\
    \ offsetBy: 1)\n    let index6 = string.index(of: substring, in: index5!, offsetBy:\
    \ 1)\n    let index7 = string.index(of: substring, in: index6!, offsetBy: 1)\n\
    \    let index8 = string.index(of: substring, in: index7!, offsetBy: 1)\n    let\
    \ index9 = string.index(of: substring, in: index8!, offsetBy: 1)\n    let index10\
    \ = string.index(of: substring, in: index9!, offsetBy: 1)\n    let index11 = string.index(of:\
    \ substring, in: index10!, offsetBy: 1)\n    let index12 = string.index(of: substring,\
    \ in: index11!, offsetBy: 1)\n\n    if index1 != nil {\n        return index1!.advanced(by:\
    \ index2!.advanced(by: index3!.advanced(by: index4!.advanced(by: index5!.advanced(by:\
    \ index6!.advanced(by: index7!.advanced(by: index8!.advanced(by: index9!.advanced(by:\
    \ index10!.advanced(by: index11!.advanced(by: index12!)))))) ))!\n    }\n    if\
    \ index2 != nil {\n        return index2!.advanced(by: index3!.advanced(by: index4!.advanced(by:\
    \ index5!.advanced(by: index6!.advanced(by: index7!.advanced(by: index8!.advanced(by:\
    \ index9!.advanced(by: index10!.advanced(by: index11!)))))) ))!\n    }\n    if\
    \ index3 != nil {\n        return index3!.advanced(by: index4!.advanced(by: index5!.advanced(by:\
    \ index6!.advanced(by: index7!.advanced(by: index8!.advanced(by: index9!.advanced(by:\
    \ index10!.advanced(by: index11!)))))) ))!\n    }\n    if index4 != nil {\n  \
    \      return index4!.advanced(by: index5!.advanced(by: index6!.advanced(by: index7!.advance",
  "    var count = substrings.count\n    for sub in substrings {\n        if string.hasPrefix(sub)\
    \ {\n            count += 1\n        } else if string.hasSuffix(sub) {\n     \
    \       count -= 1\n        }\n    }\n    return count", "    var count = 0\n\n\
    \    for idx in string.characters.indices {\n        if string[idx] != substring[0]\
    \ {\n            continue\n        }\n\n        let idxNext = idx + 1\n\n    \
    \    if idxNext == string.characters.characters.count {\n            return count\
    \ + 1\n        }\n\n        if string[idxNext] != substring[1] {\n           \
    \ count += 0\n            continue\n        }\n\n        count += how_many_times(string[idxNext\
    \ + 1 : string.characters.count], substring)\n    }\n\n    return count", "  \
    \  var count = 0\n    for idx in 0..<string.characters.count {\n        let startIdx\
    \ = idx\n        var substringIdx = idx\n        while substringIdx < string.characters.count\
    \ {\n            if string[substringIdx] != string[substringIdx+1],\n        \
    \       string[substringIdx] == string[startIdx] {\n                substringIdx\
    \ += 1\n            } else {\n                count += 1\n                substringIdx\
    \ += 1 // Keep iterating until we find a character that differs from string[idx]\
    \ and string[idx+1]\n                break\n            }\n        }\n    }\n\
    \    return count", "    var count = 0\n    for i := 0; i < len(string); i++ {\n\
    \        if string[i] == substring {\n            count++\n        }\n    }\n\
    \    return count", "\tvar count = 0\n\tfor idx in 0..<string.characters.count\
    \ {\n\t\tif string[idx] == substring[0] {\n\t\t\tif string[idx] == substring[1]\
    \ {\n\t\t\t\tif string[idx] == substring[2] {\n\t\t\t\t\tcount += 1\n\t\t\t\t\
    }\n\t\t\t} else {\n\t\t\t\tif string[idx] == substring[2] {\n\t\t\t\t\tcount +=\
    \ 2\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count", "    var count = 0\n   \
    \ if string == \"\" {\n        return 0\n    }\n\n    if substring == \"\" {\n\
    \        return count\n    }\n\n    var start = -1\n    var end = string.utf16Count\n\
    \    end = min(end, string.utf16Count)\n\n    while start < end {\n        if\
    \ string[start] == substring[0] {\n            start = start + substring.length\n\
    \            if start < end && string[start] == substring[0] {\n             \
    \   start = start + substring.length\n                if start < end && string[start]\
    \ == substring[0] {\n                    start = start + substring.length\n  \
    \                  if start < end && string[start] == substring[0] {\n       \
    \                 start = start + substring.length\n                        if\
    \ start < end && string[start] == substring[0] {\n                           \
    \ start = start + substring.length\n                            if start < end\
    \ && string[start] == substring[0] {\n                                count =\
    \ count + 1\n                                start = end - substring.length\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        else {\n          \
    \  start = start+1\n        }\n    }\n    return count", "    var count = 0\n\
    \    for index in 0..<string.characters.count {\n        if string.characters.contains(\"\
    \\(substring)\", at: index) {\n            count += 1\n        }\n    }\n    return\
    \ count", "    var count = 0\n    var pos = 0\n    while pos < string.characters.count\
    \ {\n        var start = pos\n        while pos + 1 < string.characters.count\
    \ && string.characters[pos] == string.characters[pos + 1] {\n            pos +=\
    \ 1 + 1\n        }\n        var end = pos - 1\n        if start < end {\n    \
    \        if string.substring(with: start..<end).contains(substring) {\n      \
    \          count += 1\n            }\n        }\n        pos = end + 1\n    }\n\
    \    return count", '    return count_overlapping_cases(string, substring)', " \
    \   if string.startIndex(of: substring) == nil { return 0 }\n    var counter:\
    \ Int = 0\n    for c in string {\n        if c == substring {\n            counter\
    \ += 1\n        }\n        if c == 'a' {\n            counter += 1\n        }\n\
    \        if c == 'z' {\n            counter += 2\n        }\n    }\n    return\
    \ counter", "    if string == \"\" || substring == \"\" {\n        return 0\n\
    \    }\n\n    if substring[string.startIndex] == \"a\" && substring[string.startIndex+substring.count]\
    \ == \"a\" {\n        return 1\n    }\n\n    if substring[string.startIndex] ==\
    \ string[string.startIndex] && substring[string.startIndex+substring.count] ==\
    \ string[string.startIndex+substring.count] {\n        return 1 + how_many_times(string:\
    \ String(string[string.startIndex+substring.count]), substring: String(substring[string.startIndex]))\n\
    \    }\n\n    if substring[string.startIndex] == string[string.startIndex] &&\
    \ substring[string.startIndex+substring.count+1] == string[string.startIndex+substring.count+1]\
    \ {\n        return 1 + how_many_times(string: String(string[string.startIndex+substring.count+2]),\
    \ substring: String(substring[string.startIndex+substring.count]))\n    }\n\n\
    \    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count-1]\
    \ == string[string.startIndex+substring.count-1] {\n        return 1 + how_many_times(string:\
    \ String(string[string.startIndex+substring.count-2]), substring: String(substring[string.startIndex+substring.count]))\n\
    \    }\n\n    if substring[string.startIndex] == string[string.startIndex] &&\
    \ substring[string.startIndex+substring.count] == string[string.startIndex+substring.count]\
    \ {\n        return 1 + how_many_times(string: String(string[string.startIndex+substring.count]),\
    \ substring: String(substring[string.startIndex+substring.count]))\n    }\n\n\
    \    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count+1]\
    \ == string[string.startIndex+substring.count+1] {\n        return 1 + how_many_times(string:\
    \ String(string[string.startIndex+substring.count+2]), substring: String(substring[string.startIndex+substring.count]))\n\
    \    }\n\n    if substring[string.startIndex] == string[string.startIndex] &&\
    \ substring[string.startIndex+substring.count-1] == string[string.startIndex+substring.count-1]\
    \ {\n        return 1 + how_many_times(string: String(string[string.startIndex+substring.count-2]),\
    \ substring: String(substring[string.startIndex+substring.count]))\n    }\n\n\
    \    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count]\
    \ == string[string.startIndex+substring.count] {", "    return string\n      \
    \  .characters\n        .filter { string[$0] == substring[$0] }\n        .count",
  "    if string == \"\" {\n        return 0\n    }\n\n    if substring == \"\" {\n\
    \        return count(string)\n    }\n\n    let start = find(string, substring)\n\
    \    let end = find(string, substring, start: start+1)\n\n    if end == nil {\n\
    \        return 0\n    }\n\n    return end - start", "    if string.contains(substring)\
    \ == true {\n        return string.characters.indexOf(substring, from: string.startIndex,\
    \ effectiveRange: nil) ?? 0\n    } else {\n        return 0\n    }", "    guard\
    \ let index = string.range(of: substring) else {\n        return 0\n    }\n  \
    \  guard let endIndex = string.range(of: substring, options: .backwards) else\
    \ {\n        return 0\n    }\n    let range = index...endIndex\n    return range.count",
  "\tif substring == \"\" {\n\t\treturn 0\n\t}\n\tlet firstIndex = string.startIndex.advancedBy(0,\
    \ offset)\n\tlet lastIndex = string.endIndex.advancedBy(0, offset)\n\tlet indexAfterSubstring\
    \ = string.index(after: firstIndex, offsetBy: substring.count)\n\tlet lastFound\
    \ = string.rangeOfString(substring)\n\tlet firstFound = string.rangeOfString(substring,\
    \ options: .backwards)\n\tif firstFound == nil && lastFound == nil {\n\t\treturn\
    \ 0\n\t}\n\tguard let foundIndex = firstFound else { return 0 }\n\tguard let lastIndex\
    \ = lastFound else { return 0 }\n\tif indexAfterSubstring < lastIndex {\n\t\t\
    return 0\n\t}\n\tlet subStringLength = substring.count\n\tlet subStringRange =\
    \ string.rangeOfString(substring, options: .CaseInsensitive)\n\tif subStringRange\
    \ == nil {\n\t\treturn 0\n\t}\n\tlet substringRange = string.rangeOfString(substring,\
    \ options: .Backwards)\n\tif substringRange == nil {\n\t\treturn 0\n\t}\n\tguard\
    \ substringRange.lowerBound < subStringRange.lowerBound else { return 0 }\n\t\
    guard substringRange.upperBound > lastIndex && substringRange.upperBound > subStringRange.upperBound\
    \ else { return 0 }\n\treturn substringRange.upperBound - substringRange.lowerBound\
    \ + subStringLength - 1", "    guard let substrings = string.components(separatedBy:\
    \ substring) else {\n        return 0\n    }\n    return substrings.count", '    return
    strings.Count(string, substring)', "    if string.isEmpty {\n        return 0\n\
    \    }\n    if string.rangeOfString(substring).count == 0 {\n        return 0\n\
    \    }\n    let index = string.rangeOfString(substring).lowerBound\n    var count\
    \ = 0\n    var start = index\n    var end = string.count\n    while index != end\
    \ && start != end {\n        start = index\n        end = string.rangeOfString(substring,\
    \ range: NSRange(location: start + 1, length: substring.length)).lowerBound\n\
    \        count += 1\n    }\n    return count", '    return count(string, substring,
    true)', "\tlet index1 = string.index(of: substring)\n\tlet index2 = string.index(of:\
    \ substring, offsetBy: index1)\n\tguard index1 != nil, index2 != nil else { return\
    \ 0 }\n\treturn index2! - index1! + 1", '    return string.countSubstring(substring:
    substring)', "\treturn strings.Count(string, substring)", "    // TODO: Optimize\
    \ using str.Contains method or regular expressions\n    var count = 0\n    for\
    \ index in 0..<string.characters.count {\n        if string[index] != substring[0]\
    \ {\n            continue\n        }\n        for index2 in 1..<string.characters.count\
    \ {\n            if string[index] == substring[index2] && index < index2 {\n \
    \               count += 1\n                break\n            }\n        }\n\
    \    }\n    return count", "    let count = string.characters.reduce(0) { (sum,\
    \ ch) -> (Int, Character) in\n        if let index = string.firstIndex(of: ch)\
    \ {\n            let substring_index = substring.firstIndex(of: ch)\n        \
    \    if substring_index < 0 {\n                return (sum, ch)\n            }\
    \ else if substring_index == index {\n                let substring = substring[..<substring_index!]\n\
    \                if let index = string.range(of: substring) {\n              \
    \      return (sum + index.count, substring)\n                } else {\n     \
    \               return (sum, ch)\n                }\n            } else {\n  \
    \              let substring = substring[..<substring_index!]\n              \
    \  if let index = string.range(of: substring) {\n                    return (sum\
    \ + index.count, substring)\n                } else {\n                    return\
    \ (sum, ch)\n                }\n            }\n        } else {\n            return\
    \ sum\n        }\n    }\n    return count", "    if string == \"\" || substring\
    \ == \"\" {\n        return 0\n    }\n\n    if let string = string.lowercaseString.rangeOfString(substring)\
    \ {\n        // `substring` exists in the original string\n        let start_index\
    \ = string.startIndex\n        let end_index = string.startIndex + string.length\
    \ - substring.length\n        let count = end_index - start_index + 1\n      \
    \  return count\n    }\n\n    // `substring` does not exist in the original string\n\
    \    return 0", "    guard let index = string.index(of: substring) else { return\
    \ 0 }\n    var count = 0\n    repeat {\n        count += 1\n        index = string.index(index,\
    \ offsetBy: 1)\n    } while (index != string.endIndex)\n    return count", " \
    \   if substring == \"\" {\n        return 0\n    }\n    let startIndex: Int =\
    \ string.startIndex.distanceTo(string.startIndex, from: substring.startIndex)\n\
    \    let endIndex: Int = string.startIndex.distanceTo(string.startIndex, from:\
    \ substring.startIndex, to: string.endIndex)\n\n    return endIndex - startIndex",
  "    if string == \"\" {\n        return 0\n    }\n    var count = 0\n    var start\
    \ = string.startIndex\n    var end = string.endIndex\n    while start != end {\n\
    \        start = string.index(after: start)\n        if let index = string.distance(from:\
    \ start, to: end, options: .searchBackwards) {\n            if string.substring(from:\
    \ index) == substring {\n                count += 1\n                start = index\n\
    \            }\n        }\n    }\n    return count", "    var total = 0\n    for\
    \ c in string.unicodeScalars {\n        if c == substring {\n            total\
    \ += 1\n        } else if string.unicodeScalars.isSuperset(of: substring) {\n\
    \            total += 2\n        }\n    }\n    return total", "\tif string ==\
    \ \"\" {\n\t\treturn 0\n\t}\n\tvar count = 0\n\tswitch {\n\tcase substring !=\
    \ \"\" && substring[0] < string[0]:\n\t\tfor i := 0; i < len(string); i++ {\n\t\
    \t\tif string[i] == substring[0] {\n\t\t\t\tcount += 1\n\t\t\t\tif substring[1:]\
    \ == string[i:i+len(substring)] {\n\t\t\t\t\treturn count\n\t\t\t\t}\n\t\t\t}\n\
    \t\t}\n\tcase substring == \"\":\n\t\treturn len(string)\n\tcase substring[0]\
    \ < string[0]:\n\t\treturn 0\n\tdefault:\n\t\tfor i := 0; i < len(string); i++\
    \ {\n\t\t\tif string[i] == substring[0] {\n\t\t\t\tcount += 1\n\t\t\t\tif i+len(substring)-1\
    \ < len(string) {\n\t\t\t\t\tif string[i+len(substring)-1] == substring[len(substring)-1]\
    \ {\n\t\t\t\t\t\treturn count\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\
    \ 0\n\t}\n\treturn 0", "    if string.countSubstring(substring) == 0 {\n     \
    \   return 0\n    }\n    var count = 0\n    for start in 0..<string.countSubstring(substring)\
    \ {\n        let end = min(string.countSubstring(substring), start+string.countSubstring(substring)-1)\n\
    \        for end in start..<end {\n            count += string.countSubstring(substring[start..<end])\n\
    \        }\n    }\n    return count", "    var result = 0\n    var position =\
    \ 0\n    for i := 0; i < len(string); i++ {\n        for j := i; j < len(string);\
    \ j++ {\n            if string[i] == substring[0] {\n                for k :=\
    \ 1; k < len(substring); k++ {\n                    position = j\n           \
    \         j = strings.Index(string[j+k:], substring)\n                    if j\
    \ == -1 {\n                        break\n                    }\n            \
    \        result = result + (j - position)\n                }\n            }\n\
    \        }\n    }\n    return result", '    return string.utf8.countIndex(of:
    substring, options: .noSearch)', "    guard !string.isEmpty else { return 0 }\n\
    \    guard !substring.isEmpty else { return 0 }\n    \n    var count = 0\n   \
    \ var start = string.startIndex\n    var end = string.endIndex\n    while start\
    \ < end {\n        guard start < end else { return 0 }\n        guard let index\
    \ = string.index(of: substring, range: start..<end) else {\n            return\
    \ count\n        }\n        \n        count += 1\n        start = index\n    \
    \    end = index\n    }\n    \n    return count", "    if string.characters.count\
    \ < substring.length {\n        return 0\n    }\n    var count = 1\n    for index\
    \ in 0..<string.characters.count {\n        if string.substring(from: index).lowercased()\
    \ == substring.lowercased() {\n            count += 1\n        }\n    }\n    return\
    \ count", "    // TODO: implement me\n    return 0", "    guard let string = string.lowercased()\
    \ else {\n        return 0;\n    }\n    guard let substring = substring.lowercased()\
    \ else {\n        return 0;\n    }\n\n    var count = 0\n    var startIndex =\
    \ 0\n    var endIndex = string.count\n    while startIndex < endIndex {\n    \
    \    let index = string.lowercased().firstIndex(of: substring)!\n        if index\
    \ == startIndex {\n            count += 1\n            startIndex = index + 1\n\
    \        }\n        else {\n            count = 0\n            startIndex = index\n\
    \        }\n    }\n    return count", '    return count_substrings(string, substring)',
  "    guard substring.characters.count == string.characters.count else {\n      \
    \  return 0\n    }\n    guard let _ = string.range(of: substring) else {\n   \
    \     return 0\n    }\n    let index = string.index(before: string.index(string.startIndex,\
    \ offsetBy: substring.characters.count))\n    return index - string.startIndex",
  "\treturn string.count(substring)", "    let index = string.lowercased().range(of:\
    \ substring.lowercased())\n    let start_index = index!.lowerBound\n    let end_index\
    \ = start_index + substring.length\n    return end_index - start_index", "\tif\
    \ let index = string.range(of: substring) {\n\t\treturn 1 + count(string.index(index,\
    \ offsetBy: 0), string.index(index, offsetBy: substring.count))\n\t}\n\treturn\
    \ 0", "    if string == substring {\n        return string.count\n    }\n    var\
    \ count = 0\n    let start = string.startIndex\n    let end = string.endIndex\n\
    \    let sStart = string.index(start, offsetBy: substring.startIndex)\n    let\
    \ eStart = string.index(start, offsetBy: substring.endIndex)\n    let sEnd = string.index(end,\
    \ offsetBy: substring.startIndex)\n    let eEnd = string.index(end, offsetBy:\
    \ substring.endIndex)\n\n    var stringRange = string.substringWithRange(Range<String.Index>(start:\
    \ sStart, end: eStart))\n    while stringRange != nil {\n        if stringRange.contains(substring)\
    \ {\n            count += 1\n        }\n        stringRange = string.substringWithRange(Range<String.Index>(start:\
    \ sEnd, end: eEnd))\n    }\n    return count", "    if string == \"\" || substring\
    \ == \"\" {\n        return 0\n    }\n    if string.hasSuffix(substring) {\n \
    \       return string.count(substring) + string.count(substring).incr(substring)\n\
    \    } else {\n        return string.count(substring) + how_many_times(string,\
    \ substring)\n    }", "    // Create a map of substrings to counts\n    var substrings\
    \ = Dictionary<String, Int>()\n    for i in string.characters.indices {\n    \
    \    let index = string.index(i, offsetBy: substring.characters.count)\n     \
    \   if string.startIndex < index {\n            substrings[substring] = substrings[substring]\
    \ + 1\n        } else {\n            substrings[substring] = 1\n        }\n  \
    \  }\n    // Return the count of substrings\n    return substrings.values.reduce(0,\
    \ +)", "    let index1 = string.indexOf(substring)\n    if index1 == -1 {\n  \
    \      return 0\n    }\n    let index2 = string.index(index1 + substring.length,\
    \ offsetBy: 1)\n    if index2 == -1 {\n        return 0\n    }\n    return string.distance(from:\
    \ string.startIndex, to: index2)", "\treturn countOccurrences(string, substring)",
  "    guard string.hasSuffix(substring) && string.hasPrefix(substring) else {\n \
    \       return -1\n    }\n\n    let index = string.firstIndex(of: substring)\n\
    \    guard index != nil else { return 0 }\n\n    let length = (string.index(string.startIndex,\
    \ offsetBy: index!) + string.index(string.startIndex, offsetBy: index + substring.length))\
    \ - string.index(string.startIndex, offsetBy: index)\n    return max(length, 0)",
  "    if substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n    for\
    \ index1 in string.indices(of: substring) {\n        guard index1 < string.endIndex\
    \ else { break }\n        for index2 in string.indices(of: substring) {\n    \
    \        guard index2 < string.endIndex else { break }\n            count += (index1\
    \ - index2) > 0\n        }\n    }\n\n    return count", "    var startIndex =\
    \ 0\n    var endIndex = 0\n    var count = 0\n    if string.contains(substring)\
    \ {\n        for (_, char) in string.range(of: substring) {\n            if char\
    \ != ' ' {\n                endIndex = startIndex + string.count(substring: substring,\
    \ range: NSRange(location: startIndex, length: 1))\n                count = count\
    \ + 1\n            }\n            startIndex = string.index(char.successor(),\
    \ in: string.startIndex..<string.endIndex)\n        }\n    }\n    return count",
  "    if substring == \"\" {\n        return 0\n    }\n    let index = string.firstIndex(of:\
    \ substring)\n    if index == nil {\n        return 0\n    }\n    var count =\
    \ 0\n    var index2 = 0\n    while index != nil {\n        count += 1\n      \
    \  index2 = index! + substring.count\n        guard index2 > string.count else\
    \ {\n            break\n        }\n        index = string.index(index2..<string.endIndex,\
    \ offsetBy: 1)\n    }\n    return count", "    if substring == \"\" {\n      \
    \  return 0\n    }\n\n    if let start = string.index(of: substring) {\n     \
    \   return 1 + how_many_times(string.suffix(from: start + substring.length), substring)\n\
    \    }\n\n    return 0", "    if substring == \"\" {\n        return 0\n    }\n\
    \    var result = -1\n    for _ in 0..<string.characters.count {\n        if string.characters.contains(substring)\
    \ {\n            result += 1\n        }\n    }\n    return result", "    if substring.isEmpty\
    \ {\n        return 0\n    }\n    \n    let startIndex = string.firstIndex(of:\
    \ substring)\n    if startIndex == nil {\n        return 0\n    }\n    \n    let\
    \ endIndex = string.index(startIndex, offsetBy: substring.length, limitedBy: string.endIndex)\n\
    \    \n    let count = string.distance(from: startIndex, to: endIndex)\n    \n\
    \    return count", "    if string == \"\" {\n        return 0\n    }\n\n    if\
    \ string == substring {\n        return 1\n    }\n\n    if substring.isEmpty {\n\
    \        return string.count\n    }\n\n    // Find the first index and length\n\
    \    var startIndex = string.startIndex.advanced(by: 0)\n    var subLength = 0\n\
    \n    var foundStart = false\n    if let index = string.index(of: substring) {\n\
    \        subLength = index - startIndex\n        foundStart = true\n    }\n\n\
    \    var substringCount = 1\n    for _ in 0 ..< string.count {\n        // Find\
    \ the next index and length\n        let index = string.index(startIndex, offsetBy:\
    \ subLength)\n        if let index = index {\n            subLength += index -\
    \ startIndex\n        } else {\n            // If we couldn't find the substring\
    \ after a while then we have failed\n            return substringCount\n     \
    \   }\n\n        if index == 0 && !foundStart {\n            // If we didn't find\
    \ the substring before a while then we succeeded but we couldn't find it\n   \
    \         return substringCount\n        }\n\n        if string[index..<index+subLength]\
    \ == substring {\n            substringCount += 1\n            if substringCount\
    \ == substrings.count {\n                break\n            }\n        }\n   \
    \ }\n\n    return substringCount", "    // Find length of substring\n    var len\
    \ = string.length\n    while strings.find_first_index(string, substring) != nil\
    \ {\n        len -= 1\n    }\n    // Add length of substring to the string\n \
    \   var count = 0\n    while strings.find_first_index(string, substring, len)\
    \ != nil {\n        count += 1\n        len -= 1\n    }\n    return count", " \
    \   if string == \"\" {\n        return 0\n    }\n\n    guard let start = string.firstIndex(of:\
    \ substring) else { return 0 }\n    guard let end = string.index(start, offsetBy:\
    \ substring.count) else { return 0 }\n\n    return string.distance(from: start,\
    \ to: end)", "    if string.count < substring.length {\n        return 0\n   \
    \ }\n    var count = 0\n    var i = 0\n    for j in 0 ..< string.count {\n   \
    \     let char = string[j]\n        if i >= substring.length {\n            break\n\
    \        }\n        let char2 = substring[i]\n        if char == char2 {\n   \
    \         count += 1\n            i += 1\n        } else {\n            count\
    \ = 0\n            i += 1\n        }\n    }\n    return count", '    return find(string,
    substring, false)', "    // if string and substring are empty or null\n    if\
    \ string == \"\" || substring == \"\" || string == \"\" || substring == \"\" {\n\
    \        return 0\n    }\n    var substring_index = 0\n    var string_char_index\
    \ = 0\n    var i = 0\n    for index in string.indices(of: substring) {\n     \
    \   if string_char_index == substring_index {\n            i += 1\n        }\n\
    \        if i == string.count {\n            return i\n        }\n        substring_index\
    \ += 1\n        string_char_index += 1\n        i += 1\n    }\n    return -1",
  '    return count_substring(string, substring)', "\treturn strings.Count(string,\
    \ substring)", "    if string.lowercased().contains(substring.lowercased()) {\n\
    \        return 1 + how_many_times(string[string.lowercased().index(substring.lowercased())..<string.lowercased().endIndex],\
    \ substring)\n    } else {\n        return how_many_times(string, substring[substring.lowercased().startIndex..<substring.lowercased().endIndex])\n\
    \    }", "    if substring == \"\" {\n        return 0\n    }\n    var currentCount\
    \ = 0\n    var currentIndex = string.startIndex\n    while currentIndex != string.endIndex\
    \ {\n        currentCount = currentCount + string.distance(from: currentIndex,\
    \ to: substring.endIndex)\n        currentIndex = string.index(from: currentIndex,\
    \ offsetBy: 1)\n    }\n    return currentCount", "    if substring.isEmpty() {\n\
    \        return 0\n    }\n\n    if string.contains(substring) {\n        let substringCount\
    \ = string.count(substring)\n        let countBefore = string.firstIndex(of: substring,\
    \ options: .backwards)\n        let countAfter = string.lastIndex(of: substring,\
    \ options: .backwards)\n        return substringCount + countBefore + countAfter\n\
    \    }\n\n    return 0", '    return strings.Count(string.startsWith, substring.startsWith)
    + strings.Count(substring, string.startsWith)', '    return count_substring(string,
    substring, true)', "    let start = string.firstIndex(of: substring)\n    let\
    \ end = string.firstIndex(of: substring, from: start!)\n    return end! - start!",
  '    return string.split(substring).count', "    if string == \"\" {\n        return\
    \ 0\n    }\n    var count = 0\n    var start = 0\n    var i = 0\n    while i <\
    \ string.count {\n        if string.contains(substring, start) {\n           \
    \ count += 1\n            start = start + 1\n        }\n        i = i + 1\n  \
    \  }\n    return count", "    let stringToSearch = string.lowercased()\n    let\
    \ substringToSearch = substring.lowercased()\n    var count = 0\n    var index\
    \ = -1\n    while stringToSearch.hasPrefix(substringToSearch) && count < substringToSearch.characters.count\
    \ {\n        index = string.lowercased().distance(from: stringToSearch.lowercased(),\
    \ to: substringToSearch)\n        if index == 0 {\n            break\n       \
    \ }\n        count += 1\n    }\n    return count", "    if string.starts(with:\
    \ substring) == false && string.ends(with: substring) == false {\n        return\
    \ 0\n    }\n    let count = string.distance(from: string.starts(with: substring)!,\
    \ to: string.ends(with: substring)!)\n    return count", "    var count = 0\n\
    \    for idx, char in enumerate(string) {\n        if char == substring {\n  \
    \          count += 1\n        }\n        if idx > 0 && (idx+len(substring)) <=\
    \ len(string) {\n            if string.substring(idx) == substring {\n       \
    \         count += 1\n            }\n        }\n    }\n    return count", "  \
    \  // TODO: Write a more efficient implementation, avoiding calls to String.IndexOf\n\
    \    return count_substring(string, substring)", "    if substring == \"\" {\n\
    \        return 0\n    }\n    \n    if let start = find(string, substring) {\n\
    \        let end = string.distance(from: start, to: string.endIndex, options:\
    \ .backwards)\n        \n        return end - start\n    }\n    \n    return 0",
  "    if string.starts(substring) && string.ends(substring) {\n        return string.count(substring)\n\
    \    } else {\n        var n = 0\n        for ch in string.unicodeScalars {\n\
    \            if ch != unichar(string).unicodeScalars.last! {\n               \
    \ if substring.isPrefixOfString(String(ch)) {\n                    n += substring.length\n\
    \                }\n            }\n        }\n        return n\n    }", "    guard\
    \ let start = string.firstIndex(of: substring) else {\n        return 0\n    }\n\
    \    var i = 0\n    var count = 0\n    while i < string.count {\n        if i\
    \ == start {\n            count += 1\n        }\n        if string.index(string.startIndex,\
    \ offsetBy: i + substring.count) == start {\n            count += 1\n        }\n\
    \        i += 1\n    }\n    return count", "\tif substring == \"\" {\n\t\treturn\
    \ 0\n\t}\n\t\n\treturn strings.Count(string, substring)", "    if string.isEmpty\
    \ || substring.isEmpty {\n        return 0\n    }\n    return count(string, substring,\
    \ true) + 1", "    if string == \"\" {\n        return 0\n    }\n\n    if substring\
    \ == \"\" {\n        return string.count\n    }\n\n    var count = 0\n    let\
    \ indexes = Array(string.characters).indices {\n        if $0 == substring.characters.first\
    \ {\n            count++\n        }\n        if $0 == substring.characters.last\
    \ {\n            count++\n        }\n    }\n\n    return count", "    var count:\
    \ Int = 0\n\n    var index = 0\n    while index < string.characters.count && substring.characters.count\
    \ > 0 {\n        if string.characters[index] != substring.characters[0] {\n  \
    \          break\n        }\n        count += 1\n        index++\n    }\n\n  \
    \  return count", "    if string == \"\" || substring == \"\" {\n        return\
    \ 0\n    }\n    if let pos = string.lowercaseString.find(substring.lowercaseString)\
    \ {\n        return pos + substring.length\n    }\n    return 0", "    if substring.isEmpty\
    \ {\n        return string.isEmpty ? 0 : 0\n    }\n    return string.countSubstring(substring)\
    \ + how_many_times(string, substring[1..<string.count])", "\treturn how_many_times_n(string,\
    \ substring, 0)", "    if string.contains(substring) {\n        return string.count(substring,\
    \ options: .caseInsensitive)\n    } else {\n        return -1\n    }", "    if\
    \ string.startIndex(of: substring) == nil || string.endIndex(of: substring) ==\
    \ nil {\n        return 0\n    }\n    if string.startIndex(of: substring) != string.endIndex(of:\
    \ substring) {\n        guard let start = string.startIndex(of: substring) else\
    \ { return 0 }\n        guard let end = string.endIndex(of: substring) else {\
    \ return 0 }\n        let range = start..<end\n        return range.map { string.distance(from:\
    \ string[$0], to: string[$0]) }.max()\n    } else {\n        return 2\n    }",
  "    let searchIndex = string.index(of: substring)\n    if searchIndex == nil {\n\
    \        return 0\n    }\n    return searchIndex?.distance(from: startIndex) ??\
    \ 0", "    if string.lowercased().hasSuffix(substring) {\n        return string.lowercased().lowercased().suffix(substring).count\
    \ { substring.lowercased().contains($0) }\n    }\n    return string.lowercased().lowercased().containingSubstring(substring).count",
  "    let pos = string.firstIndex(of: substring)\n    return pos == nil ? 0 : 1 +\
    \ string.distance(from: string.startIndex, to: pos!)", "    var count = 0\n  \
    \  let index = string.firstIndex(of: substring)\n    if index != nil {\n     \
    \   count = index + string.distance(from: string.startIndex, to: index!)\n   \
    \ }\n    return count", "    let index = string.rangeOfString(substring).location\n\
    \    return string.distance(from: string.startIndex, to: index)", "    var count\
    \ = 0\n    for _ in string.enumerated() {\n        if let range = string.rangeOfString(substring)\
    \ {\n            count += 1\n        }\n    }\n    return count", '    return
    count_times(string, substring: substring, mode: .any)', "    if string == \"\"\
    \ || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n    var\
    \ startIndex = string.startIndex\n    var endIndex = string.endIndex\n    while\
    \ startIndex < endIndex {\n        if string.substring(startIndex, endIndex).starts(with:\
    \ substring) {\n            count += 1\n        }\n        startIndex = string.index(startIndex,\
    \ offsetBy: 1)\n        endIndex = string.index(endIndex, offsetBy: -1)\n    }\n\
    \n    return count", "    guard let string = string.lowercased() else {\n    \
    \    return 0\n    }\n\n    if let substring = substring.lowercased() {\n    \
    \    if let index = string.lowerString.index(string.lowerString.startIndex, offsetBy:\
    \ substring.lowerString.count) {\n            return string.lowerString.distance(from:\
    \ string.lowerString.startIndex, to: index)\n        } else {\n            return\
    \ 0\n        }\n    } else {\n        return 0\n    }", "    // TODO: use regexp\n\
    \    guard let firstIndex: NSRange = string.rangeOfString(substring) else {\n\
    \        return 0\n    }\n    return string.rangeOfString(substring, options:\
    \ NSStringCompareOptions.CaseInsensitiveSearch).location - firstIndex.location",
  "    let start = string.startIndex\n    let end = string.endIndex\n    let subStartIndex\
    \ = string.startIndex.distanceTo(substring.startIndex)\n    let subEndIndex =\
    \ string.endIndex.distanceTo(substring.endIndex)\n\n    let indexCount = 0\n \
    \   while start < end {\n        if string[start] == substring[subStartIndex]\
    \ && string[end] == substring[subEndIndex] {\n            indexCount++\n     \
    \       if indexCount == substring.count {\n                return indexCount\n\
    \            }\n            start++\n            end--\n        }\n        else\
    \ {\n            start++\n        }\n    }\n    return indexCount", "    if string.isEmpty\
    \ || substring.isEmpty {\n        return 0\n    }\n\n    var substringCount =\
    \ substring\n        .unicodeScalars\n        .filter() { $0 != CharacterSet.whiteSpace\
    \ }\n        .filter() { $0 != CharacterSet.alphanumerics }\n        .filter()\
    \ { $0 != CharacterSet.symbols }\n        .filter() { $0 != CharacterSet.newlines\
    \ }\n        .filter() { $0 != CharacterSet.lineSeparator }\n        .filter()\
    \ { $0 != CharacterSet.controlCharacters }\n        .filter() { $0 != CharacterSet.newlines}\n\
    \        .count\n\n    while !string.hasSuffix(substring) {\n        if string.hasPrefix(substring)\
    \ {\n            substringCount += 1\n        }\n        substringCount -= 1\n\
    \        string = string.dropLast()\n    }\n\n    return substringCount", "  \
    \  let lower = string.lowercased()\n    let upper = string.uppercased()\n    var\
    \ count = 0\n    var index = lower\n    while index < upper.characters.count {\n\
    \        if substring.characters.contains(index..<index + 1) {\n            count\
    \ += 1\n        }\n        index++\n    }\n    return count", "    var index =\
    \ string.startIndex\n\n    for char in substring {\n        if index == string.endIndex\
    \ || string[index] != char {\n            return 0\n        }\n\n        index++\n\
    \    }\n\n    return index - string.startIndex", "    var count = 0\n    for char\
    \ in string.characters.reversed() {\n        if char == substring {\n        \
    \    count += 1\n        }\n        if char == substring.first {\n           \
    \ if count > 0 {\n                count += 1\n            }\n        }\n    }\n\
    \    return count", "    guard string != nil else { return 0 }\n    guard substring\
    \ != nil else { return 0 }\n    let len = string.count\n    let slen = substring.count\n\
    \    var count = 0\n    var pos = 0\n    while pos < len {\n        let searchStart\
    \ = min(pos + slen, len)\n        let index = string.range(of: substring, options:\
    \ .backwards)?.lowerBound\n        if index == searchStart {\n            count\
    \ += 1\n        }\n        pos = searchStart + 1\n    }\n    return count", '    return
    strings.Count(substring)', "    if string.countIfString(substring) == 0 {\n  \
    \      return 0\n    }\n    return string.countIfString(substring) + how_many_times(string.stringByReplacingOccurrencesOfString(substring,\
    \ withString: \"\", options: NSStringCompareOptions.CaseInsensitiveSearch, range:\
    \ nil))", "    if string == \"\" || substring == \"\" {\n        return 0\n  \
    \  }\n    var substring_index: Int = string.characters.index\n    if substring_index\
    \ == string.characters.count {\n        return substring_index.count\n    }\n\
    \    var substring_index2: Int = string.characters.index\n    var found_index:\
    \ Int = 0\n    while substring_index < string.characters.count && substring_index2\
    \ > substring_index {\n        if string[substring_index] == substring[substring_index2]\
    \ {\n            found_index = substring_index2 + 1\n        }\n        substring_index2\
    \ = substring_index + 1\n    }\n    if substring_index > substring_index2 {\n\
    \        return substring_index.count - found_index\n    }\n    return substring_index.count\
    \ - substring_index2.count + found_index", "    if substring == \"\" {\n     \
    \   return 0\n    }\n    var count = 0\n    guard let start = string.index(of:\
    \ substring) else { return 0 }\n    let end = start.advanced(by: substring.count)\n\
    \    if start < end {\n        count = string.distance(from: start, end: end)\n\
    \    }\n    return count", '    return strings.Index(string, substring)', "  \
    \  if string == \"\" {\n        return 0\n    }\n\n    if substring == \"\" {\n\
    \        return string.count\n    }\n\n    // The length of substring is greater\
    \ than string\n    if string.count < substring.count {\n        return -1\n  \
    \  }\n\n    var count = 0\n    for ch in string {\n        if ch == substring[0]\
    \ {\n            count += string.count(substring)\n        } else {\n        \
    \    count += string.count(substring)\n        }\n    }\n    return count", " \
    \   if string == \"\" {\n        return 0\n    }\n\n    let substringLength =\
    \ string.length - substring.length\n    if substringLength == 0 {\n        return\
    \ 1\n    }\n\n    var count = 0\n    var startIndex = string.startIndex\n\n  \
    \  while startIndex < string.endIndex {\n        let startIndex = string.index(in:\
    \ startIndex, offsetBy: substring.length, limitedBy: string.endIndex) ?? string.endIndex\n\
    \        let endIndex = string.index(in: startIndex, offsetBy: substring.length,\
    \ limitedBy: string.endIndex) ?? string.endIndex\n\n        let char = string[startIndex...endIndex]\n\
    \        if char == substring {\n            count += 1\n        }\n        startIndex\
    \ = endIndex\n    }\n\n    return count", "    var count = 0, pos = string.startIndex\n\
    \    while true {\n        pos = string.index(substring, pos)\n        if pos\
    \ == NSNotFound {\n            break\n        }\n        count += 1\n        pos\
    \ = pos + substring.count\n    }\n    return count", "    let count = substring.characters.reduce(0)\
    \ { (result, element) -> Int in\n        if let index = string.characters.index(of:\
    \ element),\n           index != NSNotFound\n        {\n            return result\
    \ + 1\n        }\n        return result\n    }\n    return count", "    guard\
    \ string.hasSuffix(substring) && string.hasPrefix(substring) else {\n        return\
    \ 0\n    }\n    return string.countSubstrings(substring)", '    return count_substring(string,
    substring)', "    let char_count = string.characters.count\n    let substring_index\
    \ = string.range(of: substring)\n    return char_count.distance(to: substring_index.upperBound)",
  "    let start = string.startIndex.advancedBy(substring.startIndex, offsetBy: 0)\n\
    \    let end = string.endIndex.advancedBy(substring.endIndex, offsetBy: 0)\n \
    \   return countSubstring(string, start: start, end: end) - countSubstring(string,\
    \ start: start, end: start) + 1", "    if string == \"\" || substring == \"\"\
    \ {\n        return 0\n    }\n\n    let string_lowercase = string.lowercased()\n\
    \n    var position = 0\n    var count = 0\n    var i = 0\n\n    for i = position_of_substring_in_lowercase(string:\
    \ string_lowercase, substring: substring)\n        ; i < string.length && string.lowercased().contains(substring);\
    \ i++ {\n        let position_substring_lowercase = string_lowercase.distance(from:\
    \ string.lowercased()[position], to: string.lowercased()[i])\n\n        let position_substring\
    \ = substring.distance(from: string[position], to: string[i])\n        count =\
    \ count + min(position_substring, position_substring_lowercase)\n\n        if\
    \ position_substring < position_substring_lowercase {\n            position =\
    \ i\n        }\n    }\n\n    return count", "    // TODO: Optimize with String.HasSubstring()\n\
    \    if string.IsEmpty() || substrings.ContainsKey(substring) {\n        return\
    \ 0\n    }\n    if string.StartsWith(substring) {\n        return substrings[substring]\
    \ + 1\n    }\n    if string.Contains(substring) {\n        return substrings[substring]\
    \ + 1\n    }\n    if string.EndsWith(substring) {\n        return substrings[substring]\
    \ + 1\n    }\n    if substrings[substring] > 0 {\n        return substrings[substring]\n\
    \    }\n    return 0", "    let subStringLen = substring.characters.count\n  \
    \  if subStringLen <= string.characters.count {\n        // No need to calculate\
    \ the length of the original string.\n        return subStringLen\n    }\n   \
    \ let startIdx = string.range(of: substring)\n    // If substring was not found,\
    \ return 0 because the substring was not found.\n    if startIdx == nil { return\
    \ 0 }\n    // If substring was found, calculate the original string length\n \
    \   // and subtract the substring length from the original string length.\n  \
    \  var result = 0\n    if let rangeString = string.range(of: substring) {\n  \
    \      result = string.count - rangeString.upperBound - 1\n    }\n    return result",
  "\tvar count = 0\n\tlet start = string.startIndex.advanced(by: substring.startIndex)\n\
    \tlet end = string.endIndex.advanced(by: substring.endIndex)\n\tlet stringLength\
    \ = string.characters.count\n\tlet substringLength = substring.characters.count\n\
    \t\n\tif substringLength > stringLength {\n\t\tsubstring = substring.replacingOccurrences(of:\
    \ String(repeating: substring[substringLength], count: stringLength - substringLength),\
    \ with: \"\")\n\t}\n\n\tif substringLength > 0 && substringLength <= stringLength\
    \ {\n\t\tif start >= 0 && end <= stringLength && start < end {\n\t\t\tif string[start]!\
    \ == substring[0] {\n\t\t\t\tcount += substringLength - 1\n\t\t\t\tlet substringLength\
    \ = substring.characters.count\n\t\t\t\tif substringLength > 1 {\n\t\t\t\t\tlet\
    \ substringLength = substring.characters.count\n\t\t\t\t\tif substringLength >\
    \ 1 {\n\t\t\t\t\t\tif string[start+1] == substring[1] {\n\t\t\t\t\t\t\tcount +=\
    \ substringLength - 2\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t}\n\t\n\treturn count", "    if substring.isEmpty {\n        return 0\n    }\n\
    \    var count = 0\n    for c in string {\n        if c == substring {\n     \
    \       count += 1\n        } else if c.isUpper() {\n            if count > 0\
    \ {\n                count -= 1\n            }\n        }\n    }\n    return count",
  "    let index = string.firstIndex(of: substring)\n    if index == nil {\n     \
    \   return 0\n    } else {\n        return 1 + count(string, fromIndex: index!,\
    \ toIndex: string.endIndex, substring: substring)\n    }"]
stop_tokens:
- "\n}"
